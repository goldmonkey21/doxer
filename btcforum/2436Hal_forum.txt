We used checks. For high value transactions, cashier's checks. I don't know how this transfers to a bitcoin environment. Oh, there wasn't as much mail order back then. Most shopping was local. The zerocoin part does more than defend against DOS, doesn't it? It also provides a degree of anyonymity, if I understand it. In the conventional multi-party anti-taint protocol, every participant knows the mapping from inputs to outputs. But in your improved protocol using libzerocoin, nobody sees the mapping. Now, this requires more than two participants, so considerable organization is needed to coordinate.Still, this an application of the zerocoin protocol which doesn't have an impact on the blockchain. OTOH, it has a small anonymity set, so the benefit is rather modest. I really like Adam's very creative idea earlier in this thread to have a pure-zerocoin system:https://bitcointalk.org/index.php?topic=175156.msg2420768#msg2420768The zerocoin paper proposed a hybrid bitcoin-zerocoin system. Bitcoins would be temporarily exchanged for zerocoins, and then exchanged back. Adam's idea was that zerocoins would be exchanged directly for zerocoins. Zerocoins could be mined directly, too. All this is a simple modification of the zerocoin protocol. In fact, it would be simpler in terms of code size, because you wouldn't have to support bitcoin transactions. No scripting language, no bitcoin validation rules. Just pure zerocoin spend transactions.This would also free us from the forced assumption of bitcoin-zerocoin parity. The heavy resource requirements of zerocoin might naturally break that parity. (Admittedly, zerocoin would first be implemented as an extension to an alt, so the value in terms of bitcoins would float. But the simplification is still a win.)There are various proposals to do P2P exchanges between altcoin chains. I don't know what the status is as far as Bitcoin support in the bitcoin-qt client. You'd have to have a new client to do the P2P protocol. But even if we had to rely on an exchange, it would be an interesting experiment.The last problem for a zerocoin implementation is the generation of an RSA modulus for which no one knows the factorization. This is hard, and deserves more analysis.  Lois Lane:How do you find someone who has spent a lifetime covering his tracks?For some, he was a guardian angel. For others, a ghost, who never quite fit in.What's the S stand for? I sent a PM a couple of days ago to frankAcct366, and accompanied it with a bitcoin tip. No reply yet.  I aquired most of my coins by mining. This has no anology with currency (unless you're counterfeiting  ) so I intend to treat bitcoins as precious metals and declare my profits as capital gains. Since I mined them more than a year earlier, they are long term capital gains. This is not as favorable as usual because it turns out that precious metals, even bullion, are considered "collectables" and taxed at a rate of 28%. Normal rate is 15%. If your overall tax rate is less than 28%, you can pay the lower rate. That is what I intend to do, based on my reading of the IRS documents.  I used to have one of these. In fact, I hacked a version of PGP to look for your private key on the ring, so you could sign or decrypt just by touching the ring to the reader. (Actually you had to kind of snap it in.) Since PGP already used the "key ring" terminology, I thought it was particularly apropos. Too bad they never caught on, although it would bring on the dreaded "stolen finger" attack. I actually had an account with MTB back in the day. They partnered with David Chaum, guru of techno-privacy. Chaum had a place with Cypherpunks roughly analogous to Satoshi's around here, except he didn't have the grace to disappear mysteriously, and he very definitely had feet of clay.Anyway, MTB offered accounts using Chaum's blinding technology, so the bank couldn't see whom you were paying, as long as it was another account holder. I don't think this would fly today, but that was before KYC etc. The experiment never really got off the ground, and it was terminated shortly after.The OP has a piece of blinded ecash suitable for transfer to another MTB account holder, at least if you had a time machine and could go back to the 90's. They were all powers of two, hence the 128 cents. Thank you so much for your kind and encouraging words. I'm sorry that I can't respond to each of you individually. But know that I am touched and encouraged by your words of support. I thought I'd write about the last four years, an eventful time for Bitcoin and me.For those who don't know me, I'm Hal Finney. I got my start in crypto working on an early version of PGP, working closely with Phil Zimmermann. When Phil decided to start PGP Corporation, I was one of the first hires. I would work on PGP until my retirement. At the same time, I got involved with the Cypherpunks. I ran the first cryptographically based anonymous remailer, among other activities.Fast forward to late 2008 and the announcement of Bitcoin. I've noticed that cryptographic graybeards (I was in my mid 50's) tend to get cynical. I was more idealistic; I have always loved crypto, the mystery and the paradox of it.When Satoshi announced Bitcoin on the cryptography mailing list, he got a skeptical reception at best. Cryptographers have seen too many grand schemes by clueless noobs. They tend to have a knee jerk reaction.I was more positive. I had long been interested in cryptographic payment schemes. Plus I was lucky enough to meet and extensively correspond with both Wei Dai and Nick Szabo, generally acknowledged to have created ideas that would be realized with Bitcoin. I had made an attempt to create my own proof of work based currency, called RPOW. So I found Bitcoin facinating.When Satoshi announced the first release of the software, I grabbed it right away. I think I was the first person besides Satoshi to run bitcoin. I mined block 70-something, and I was the recipient of the first bitcoin transaction, when Satoshi sent ten coins to me as a test. I carried on an email conversation with Satoshi over the next few days, mostly me reporting bugs and him fixing them.Today, Satoshi's true identity has become a mystery. But at the time, I thought I was dealing with a young man of Japanese ancestry who was very smart and sincere. I've had the good fortune to know many brilliant people over the course of my life, so I recognize the signs.After a few days, bitcoin was running pretty stably, so I left it running. Those were the days when difficulty was 1, and you could find blocks with a CPU, not even a GPU. I mined several blocks over the next days. But I turned it off because it made my computer run hot, and the fan noise bothered me. In retrospect, I wish I had kept it up longer, but on the other hand I was extraordinarily lucky to be there at the beginning. It's one of those glass half full half empty things.The next I heard of Bitcoin was late 2010, when I was surprised to find that it was not only still going, bitcoins actually had monetary value. I dusted off my old wallet, and was relieved to discover that my bitcoins were still there. As the price climbed up to real money, I transferred the coins into an offline wallet, where hopefully they'll be worth something to my heirs.Speaking of heirs, I got a surprise in 2009, when I was suddenly diagnosed with a fatal disease. I was in the best shape of my life at the start of that year, I'd lost a lot of weight and taken up distance running. I'd run several half marathons, and I was starting to train for a full marathon. I worked my way up to 20+ mile runs, and I thought I was all set. That's when everything went wrong.My body began to fail. I slurred my speech, lost strength in my hands, and my legs were slow to recover. In August, 2009, I was given the diagnosis of ALS, also called Lou Gehrig's disease, after the famous baseball player who got it.ALS is a disease that kills moter neurons, which carry signals from the brain to the muscles. It causes first weakness, then gradually increasing paralysis. It is usually fatal in 2 to 5 years. My symptoms were mild at first and I continued to work, but fatigue and voice problems forced me to retire in early 2011. Since then the disease has continued its inexorable progression.Today, I am essentially paralyzed. I am fed through a tube, and my breathing is assisted through another tube. I operate the computer using a commercial eyetracker system. It also has a speech synthesizer, so this is my voice now. I spend all day in my power wheelchair. I worked up an interface using an arduino so that I can adjust my wheelchair's position using my eyes.It has been an adjustment, but my life is not too bad. I can still read, listen to music, and watch TV and movies. I recently discovered that I can even write code. It's very slow, probably 50 times slower than I was before. But I still love programming and it gives me goals. Currently I'm working on something Mike Hearn suggested, using the security features of modern processors, designed to support "Trusted Computing", to harden Bitcoin wallets. It's almost ready to release. I just have to do the documentation.And of course the price gyrations of bitcoins are entertaining to me. I have skin in the game. But I came by my bitcoins through luck, with little credit to me. I lived through the crash of 2011. So I've seen it before. Easy come, easy go.That's my story. I'm pretty lucky overall. Even with the ALS, my life is very satisfying. But my life expectancy is limited. Those discussions about inheriting your bitcoins are of more than academic interest. My bitcoins are stored in our safe deposit box, and my son and daughter are tech savvy. I think they're safe enough. I'm comfortable with my legacy.[edited slightly] Indeed, I bricked my laptop when I was first experimenting with this technology several years ago. Fortunately it was under warrantee and they replaced it. All you have to do is make sure your BIOS is up to date and that won't be a problem.As far as XMHF (TrustVisor) I just bought a new system from bitcoinstore.com which should support it. This is a newer technology than Flicker which should remove some of the limitations. I'm worried though because Jon McCune, whose group is doing both of those projects, left CMU for Google. The projects seem a little rudderless now. Start of the security analysis bcflick is a Flicker PAL (Piece of Application Logic) designed to increase the security of the Satoshi Bitcoin client. Flicker uses security features on modern processors to create an isolated, cryptographically protected segment of memory which is immune to tampering by other code running on the same computer. These security features go by different names depending on the manufacturer. Intel calls it TXT, while AMD calls it SVM. I will refer to it here simply as the secure mode.The threat model which bcflick is designed to address is a thorough infection by sophisticated malware. It is assumed that the attacker can corrupt the operating system, install key loggers, read and write files and network traffic, and generally exert arbitrary control over the computer. Despite this powerful attacker, bcflick lets the user spend and receive bitcoins, and enforces a daily limit on the number of bitcoins spent. The attacker, as well as the user, is bound by that limit. This prevents the attacker from stealing the bitcoins all at once. He is forced to let them trickle out a little at a time, giving the user a chance to detect and mitigate the theft.Although this is a powerful attacker, we have to restrict its capability is one way. We assume that there is some way to boot into a "safe" mode, out of the control of the attacker. Typically this would be done by booting from an external medium, a CD or a USB drive. Technically, sophisticated malware can insinuate itself into even a boot from a clean medium, by inserting itself into the firmware of some peripheral device, or even the BIOS. However, these techniques are little used and hardware dependent. In practice, booting from a clean external device will produce a safe mode with high probability.bcflick uses the safe mode for three purposes. On initialization, the wallet is encrypted, and the decryption key is passed to bcflick, along with the daily spending limit. It is also used for error recovery, such as if the TPM timer gets reset, or if a Flicker crash gets things out of sync. By booting into safe mode, the user can reset the passphrase, and that will reinitialize bcflick. Last, if the user wants to spend more than the bcflick policy permits, he can boot into safe mode, unlock the wallet with the passphrase, and create arbitrary transactions, bypassing bcflick.The remainder of this document discusses the security design of bcflick. It is dived into four parts. I first list the security assumptions. The second part addresses security related to Flicker and the secure mode. The next part discusses Bitcoin related security. Finally, I conclude with further directions for research. Actually TPM's do have a secure clock. There's just no guarantee about when it will keep ticking. You can detect if it gets reset because there is a 20 byte nonce, which changes at every reset. I've found that my HP laptop preserves the timer in S3 sleep, I don't know for sure, but I shut it down for a few seconds and it seemed to be preserved, which was a surprise. And my HP desktop system is never shutdown, but it preserves the timer across reboots.If bcflick eetects a timer reset, it won't let you spend anything for 24 hours. But you can always boot into a safe mode and reset your passphrase. This will reininitialize bcflick and you can spend up to the daily limit, right away.  In this post, https://bitcointalk.org/index.php?topic=67508.0, Mike Hearn gives a good introduction to trusted computing technology and how it could help secure Bitcoin wallets. I've been working on these ideas, using the Flicker software that Mike linked to, and it's about ready for testing, if anyone is interested.Basically it's a patched version of bitcoin-qt/bitcoind (for Linux only) that enforces limits on your daily spending. You could get infected with malware and the most it could do would be to drain your wallet a little bit at a time. All this with a single machine, although only certain models of Intel and AMD processors support the secure mode.Mike gives a good summary of the principles of trusted computing. Suffice it to say that the technology allows you to create a piece of code that can run unmolested by the rest of the computer. The TPM chip is used to cryptographically protect its data. The data is sealed to the hash of the secure code, so that only that piece of code has access to its secrets.I'm using Jon McCune's Flicker technology. Flicker switches you into the secure mode for just an instant, and then switches you back out again. In this way, the secure mode doesn't have to coexist with the operating system, which would require hypervisor technology. Flicker is only about 3000 lines of code, small as these things go.I've made a Flicker module (they call it a PAL) called bcflick. And I've patched bitcoind to make calls into bcflick to generate new keys and to sign transactions. The Flicker module knows the wallet encryption key, while bitcoind (normally) doesn't. So the only way to sign transactions, for you or for malware, is to go through bcflick. Bcflick knows the time from the TPM and keeps track of the amount spent today, and will refuse to sign a transaction if the daily amount were to exceed the pre-set limit.Because Flicker is so minimal, it has limitations. The total size of the PAL has to be less than 1 Meg. And the size of the input to and output from the PAL is a couple hundred K. More importantly, the PAL can't do any device I/O, because that would interfere with OS management of devices. Basically, the PAL starts up, reads input buffer, does work, and writes its output buffer, all in the blink of an eye. Actually, that is a little exaggerated about the speed. Because the TPM is so slow, and because of the firmware overhead in switching into the secure mode, a Flicker call takes a substantial fraction of a second.These Flicker limitations restrict what we can do to strengthen a Bitcoin wallet. We can't ask the user to approve spends, because of no I/O. So the policy enforcement has to be self-contained. The daily spending limit seemed useful and not too complex. More complicated policies could be supported, such as adjusted daily limits based on the average of recent days. More ambitious would be to take into consideration infow of funds; this would require parsing the block chain, including dealing with reorgs.It's best to start with a new wallet. If you have some funds, transfer them elsewhere temporarily and delete wallet.dat. After you finish initialization, transfer your funds back to new, bcflick-protected addresses.In more detail, bcflick must be initialized when running cleanly, i.e. malware-free. This is unfortunately impossible. An approximation can be achieved by booting from a live CD or USB. Doing this will eliminate all but the most sophisticated threats.In this mode, start bitcoind with the -flickerlimit switch. This will allow you to set the daily spending limit that bcflick will enforce.  Then encrypt the new wallet with a long passphrase. This will pass the wallet encryption key to bcflick, along with the daily spending limit.If you don't want to transfer your funds away and you are certain that you are not currently infected with malware, there is a shortcut. Boot into a clean mode and start bitcoind with the -flickerlimit switch. Then change your passphrase. You can change it to something longer, or even have the old and new passphrases be the same. Executing a passphrase change (re)initializes bcflick with the wallet encryption key and spending limit. This procedure is also useful when things go wrong and bcflick stops working. Boot into a clean state, run bitcoind with -flickerlimit, and change the passphrase from itself to itself. Then you can boot into a regular mode, and bcflick will sign transactions, using the wallet encryption key to decrypt the signing keys. Bcflick will also create (encrypted) keys. This is so malware can't observe any decrypted keys. Any other operations requiring the wallet passphrase, such as spending in excess of the daily limit, should be done by booting into a clean mode and entering the passphrase. Under no circumstances should you enter your passphrase without booting into a clean mode. Otherwise, malware could learn it, and steal all your funds.Because the passphrase is not needed for daily use, you can use a longer and more complex one. That, coupled with the infrequent use, means you should probably write it down and store it in a secure place. I need to write more about the security model, both Flicker related and Bitcoin related. But in the mean time, here is a quick-start guide:Experimental integration of Flicker with BitcoinGet a computer that supports FlickerSet up the TPM:Get TPM/J from http://projects.csail.mit.edu/tc/tpmj/Enable the TPM in BIOSTake ownership of the TPM with sudo java edu.mit.csail.tpmj.tools.TPMTakeOwnership <ownerpwd>Create a counter with sudo java edu.mit.csail.tpmj.tools.TPMCreateCounter <ownerpwd> BITCGet the master branch of flicker working, git clone git://git.code.sf.net/p/flickertcb/codeGet the master branch of bitcoin working, git clone git://github.com/bitcoin/bitcoin.gitDownload the bitcoin block chainIf you have bitcoins, transfer them elsewhere and delete wallet.datGet the flicker branch, git clone http://github.com/halfinney/bitcoin/Get the mytxtck branch, git clone git://git.code.sf.net/u/hal/flickertcbMake a symbolic link called flicker in the bitcoin directory pointing to the flicker/examples/app directoryRun make in flicker/examples/{app,pal/libtommath,pal}Copy flicker/examples/pal/bcflick.bin to ~/.bitcoinRun make bitcoind in bitcoin/srcRun chmod 666 /sys/devices/system/cpu/cpu*/online /sys/kernel/flicker/* (you'll probably have to do this after every reboot)Boot into a secure mode (eg. boot from a live CD)Run bitcoind -flickerlimit=<limit> &  where limit is the maximum daily limit of bitcoins spentRun bitcoind encryptwallet <passphrase>Boot into a regular mode and flicker will limit the amount spent per day to the limit you have set, without requiring a passphraseNow you can transfer your funds back, to new addresses in your walletIf you want to spend more, boot into the secure mode and unlock the wallet with the passphrase I made an order from BitcoinStore, a high end HP laptop for my research into strengthening Bitcoin wallets with Trusted Computing. It was about $1000. Unfortunately the site crashed for several hours just after I sent my bitcoins in but before I could complete the order. I contacted customer service after the site came up, and they were very helpful. They entered my order manually, and I got an email that the order had been received. I didn't get any further response, however. I waited a week and emailed cs again. They were very apologetic and assured me they'd take care of it. To my surprise, the next morning I got a delivery and it was the laptop! It's working great.So the store has some growing pains but customer service will take care of you. My one disappointment was that the package came from MemoryDealers and not BitcoinStore. That would have been cool.  I was lucky enough to receive the first bitcoin transaction, and then I was careless enough to spend it accidentally. I probably still have the key sitting on a switched-off computer, so I could auction off the key. Usual caveats about making sure I delete it when I sell it... I felt bad about losing that donation address, particularly after elux very generously donated a whole bitcoin. I found a wallet on a backup that had the key, and so I was able to retrieve the funds. Again, thanks very much!  Actually the OP observed that the software always puts the change first. I was working on a separate project suggested by Mike Hearn, using the new secure "trusted computing" modes on modern cpus to enforce spending limits even when infested with malware. I'm using Jon McCune's flicker software from sourceforge. The secure mode signs transactions and enforces limits on spends, but to know the transaction amount it has to know which is the change output.So I was just looking at this code yesterday and scratching my head (figuratively). I'll post more on this project when it's further along.As far as my donation address, I created that years ago using Gavin's original vanitygen patch. I don't even know if I still have the key. It might be on a computer I don't use any more. I've substituted one of my offline savings wallet addresses. I shouldn't lose that.I'm not hurting for bitcoins; I started running the first day (and gave up after a few weeks because of the fan noise). Still, it's the thought that counts - thanks! bitcoin-qt tries to randomize the position of the change output, but I believe the code has a flaw:// Insert change txn at random position:vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));The problem is that size() is one in the common case of one payee, so GetRandInt will always return 0.The change ends up in the first output.I think it should be size()+1. Apologies for resurrecting this old thread, but I wanted to mention a new development. The people that brought you Flicker and TrustVisor, both mentioned by Mike, have a new project out. xmhf is a hypervisor framework built around Trusted Computing. Its main advantage is that it works on both Intel and AMD, but you still need a newer, relatively high-end machine. TrustVisor has been ported to xmhf, so now it works on both architectures whereas previously it was just AMD.I agree with the comments above that TC may not be quite right for bitcoin. For one thing these secure program compartments can't do any I/O directly. They have to rely on the insecure code to relay data, although crypto keeps the data secure. So if we wanted the user to approve a transaction, you'd have to send the data to a secure device for approval. In which case you might as well use multisig or even just keep all the keys there.You could try to implement a self-contained policy like rate limiting, although as discussed above you need a secure time source and state rollback protection. I'm worried that using the blockchain as a time standard might be vulnerable to timing games by the untrusted code, although there might be mitigations. A couple of other potential sources of secure time: the network time protocol, which is how a lot of computers keep their time in sync, has a crypto layer. Unfortunately it doesn't seem suitable for public use, although I found out the US NIST will supposedly supply you with an authenticated time if you go through a complicated application process, http://www.nist.gov/pml/div688/grp40/auth-ntp.cfm.Thinking way outside the box, you could open an SSL connection to a web page that's updated frequently, and use the Date: header from the http response. You'd hard code the CA root cert and all the relaying could be done by the untrusted code and still be secure. I've tried this with https://google.com and the time is pretty accurate. TrustVisor includes a version of openssl so this would seem to be feasible.But even if you got rate-limiting working, the untrusted code could substitute its addresses for the target addresses, or maybe just skim a percentage off each transaction, hoping to evade detection. A lot of things have to go right for the created transaction to match the user's intentions. Assuming a malware takeover and still trying to protect the user is aiming too high IMO. Maybe we can limit the damage though.
Hi, Mike. I am still alive alive but greatly limited.I looked at the first paper, which as you know is not about batch verification. It gives a speed up if you know R that we should already get with just r, with our pseudo Koblitz curve. But I discovered that I had missed an essential optimization in my Koblitz implementation, which is to split the G multiplication into two, with half size exponents. This should increase the speed-up from 20% to more like the 40% they claim. So thanks! (Not that I can do anything about it. Hopefully this hint will be sufficient.)On batch verification, I had thought of a much kludgier approach. Bear in mind that in the current signature (r,s), r is just the x-coordinate of R. So we need to supply the y-coordinate. (Actually, that's not important, but it saves a little space.) So presently the scriptSig pushes the key and the signature on the stack. My idea was to first push a magic number and the y-coordinate of R. Hopefully, legacy code would ignore these two deeper stack values, and just verify the signature traditionally. But new code could check for the magic number, reconstruct R, and do batch verification. This way transactions could be broadcast that were backwards compatible.Your idea is cleaner but I am concerned about transaction hash consistency between old and new nodes. Old nodes don't see R, so I think new nodes can't hash it. And it might have to be that way forever. On the plus side, this would let you go back and convert all existing transactions to the new format, giving benefit from batch verification immediately.I'll try to look at the second link tomorrow and see if such dramatic speedups are possible. I did try an experiment where I patched out signature verification entirely, just had it return true. I didn't get all the speedup I was hoping for on initial blockchain download. Be interesting to repeat that now that it takes so much longer.  I got an M-disk drive from Amazon using spendbitcoins.com.This is supposed to use a high power laser to etch the data into special rock-like DVDs .It should last a long time. The DVDs are readable by any conventional drive.http://www.amazon.com/LG-Electronics-WH12LS39K-Internal-Rewriter/dp/B00632U162/ref=pd_bxgy_e_text_b I recently found the 0.1 source code on one of my computers. I can send it if you want it, but I'm pretty severely disabled these days, so it may take me a while to respond. File this one under "you can't win."I fired up the new client after several days, the progress bar immediately went to 99%, and stayed there for the next ten minutes. I guess some people found the old behavior confusing, but of what use is this behavior? How much entropy does a live cd have after booting? Do you have to convert your btc to USD to write a call? Just noticed that we've reached "shave and a haircut" parity. The old secret knock is becoming true once again. Research dollar cost averaging. How about a limerick?There once was a girl from Des MoinesWhose breasts were as fine as her loins."I'll do tricks for dollars,Make all my guys holler,But I save my best stuff for Bitcoins!"(Probably should've posted anonymously...) Every day that goes by and Bitcoin hasn't collapsed due to legal or technical problems, that brings new information to the market. It increases the chance of Bitcoin's eventual success and justifies a higher price. This patch might work for the importhttp://forum.bitcoin.org/index.php?topic=9046.0Flipping a bit your way.  Any successful replacement of the Bitcoin block chain will forever undermine the credibility of any successor. How is an investor to know that it won't happen again?Rebooting now may benefit a few thousand early adopters. What happens when hundreds of millions use Bitcoin 2? They'll be just as jealous and envious of you as you are of others. Given the precedent you want to set, how will you argue against yet another reboot? I'm the author of this code. The main.cpp code sends a version message in response to receiving one, on inbound connections. Sorry I haven't responded, communicating is hard for me these days. This seems to be a very good and sound approach. I would not bother to use longer keys for the master key, chances are the user passphrase will be the weakest part. Also I would stay away from point compression for patent reasons.  Sent 1000 btc to a friend as a test transaction the first month. Luckily he sent it back.   I started using Bitcoin the first day. Satoshi sent me 10 btc within a day or two, so he must have spent at least one of his early blocks. Exactly what do you mean by money laundering? One way to deal with the key-addition attack would be to store a MAC (keyed crypto checksum) with the encrypted data (priv keys). The MAC key could be either an alternate hash of the encryption passphrase, or a hash of a separate MAC passphrase. The MAC passphrase would have to be entered whenever the client started, and the MAC key would be stored in memory while running. I agree, we should be very conservative about this part of Bitcoin. It is the foundation of value for the whole system. Q on the video:You received 1 btc, then before it was confirmed, made a payment of 0.1 btc. Was that payment real? When we cut to the future, the 1 btc tx had 2 confirmations, but the 0.1 had none. Both txns could have been confirmed in the same block. Do you know why that didn't happen?
One thing you might want to do is use the hash to determine the result of a gambling game. You could bet with someone on whether the next hash will be even or odd. The problem is if your opponent is a miner, he could influence a certain percentage of the block hashes, gaining an advantage. Got any Google Trends graphs that match this shape? The second to last dot on the blue line is the last actual data point, right? I notice that it was farther from the trend line than any other point. Is this a sign that the trend is breaking down? I was sent this report on genjix's talk, not sure if it's linked elsewhere:http://www.dyndy.net/2011/04/bitcoin-presented-to-the-old-world/ One of the influences on Bitcoin was Nick Szabo's idea of Bit Gold. I kind of wish it had been called Bitgold but that would have caused confusion with Nick's (somewhat different) idea.Maybe we should call block creation "panning".  You also deleted "deleted" in the title... I added a step to the wiki:# Recheck blockexplorer to make sure the address still shows the right amount, in case the block chain reorganizesChecking the address balance once, then waiting for more blocks, is not safe by itself as the transaction may go away.(Just realized my solution is still vulnerable: the transaction could pay you, go away, you wait n blocks, and a different transaction pays you, you recheck the balance and it looks good, but then the 2nd transaction goes away.) Trying to review the diff - looks like UpdateSpent() could return fReturn uninitialized if it's false. This is good because without it, someone can test whether 2 addresses are in the same wallet, by sending a payment to both of them. Then you can't spend one without the other. Steve, the way the client works now, all the wallet keys are read into memory at startup. Subsequent changes are made in memory and written to disk. This proposed patch decrypts keys as they are read into memory at startup, and encrypts new keys as they are written out to disk.Decrypting keys on use wouldn't be too hard. Add a popup to read the passphrase, perhaps cache it for a while as you suggest.Strangely, the hard part is encrypting new keys, because Bitcoin creates keys at odd times. The oddest time is when receiving a payment to the "current address" displayed at the top of the window. Bitcoin likes to keep things fresh so it generates a new address to display, and new key. But it can't encrypt the new key without the passphrase, and in general no user is around to respond to a popup at random times. From The Simpsons, "Homer at the Bat": Look at my sig, Bitcoin address with my name in it courtesy of Gavin's vanity patch. Does your ISP also block incoming port 8333? I have an even better idea. My transactions compete with those of others for free space in the blocks, so clearly I should forward only my own transactions and block everybody else's. Profit! Off to make a pull request... Back in the 90's on the cypherpunks mailing list, Wei Dai (of Crypto++ and b-money fame) invented a system of anonymous lending. Of course the classic problem with anonymous loans is that you don't know whose legs to break if they don't pay it back. Wei solved this problem, with some conditions.The participants in the protocol are borrowers, lenders, and bystanders (who don't want to lend or borrow right now, but might wish to do so on future runs of the protocol). The key is that all participants are fully identified, to the extent that they are vulnerable to that all-important leg-breaking. Nevertheless, the protocol conceals the role of each participant, and the amount they are borrowing or lending, if any.There needs to be a system of anonymous payments, and a simple trusted machine called the Pot. (In practice, the Pot would be simulated by the participants, using a cryptographic multi-party computation.)In a preliminary phase, participants would anonymously negotiate and agree on the amount each person would borrow or lend, such that the total amount borrowed equalled the total amount lent. The actual protocol then has four phases, two for borrowing/lending, and two for repayment.Phase 1 is private. Each participant anonymously puts money into the Pot, and gets in exchange a signed receipt for the amount. Lenders would put the most money in, bystanders less, and borrowers little or none. You'll see why in a moment.Phase 2 is public. The Pot now has a certain amount of money in it; this is divided equally and distributed publicly to all participants.The borrowing/lending is now done. People who put more money in the Pot than the per-person distribution in phase 2 are net lenders; people who put in less are net borrowers; and people who put in the same amount are the bystanders, with no net change. No one knows whether anyone else is a borrower or lender.When it is time to repay the loan, two more phases are run, the mirror images of the first two.Phase 3 is public. Each participant publicly and verifiably puts back into the Pot the exact amount taken out in phase 2 (or, that amount plus interest). This is leg-breaking time! No excuses, everybody's got to pay up.Phase 4 is private. Each participant anonymously presents his receipt from phase 1 to the Pot, and gets back that amount (or, that amount plus interest). This unwinds the earlier transactions and all the funds are back where they started.All that is visible publicly is that everyone splits up the pot evenly in phase 2, and then returns that same amount in phase 3. But behind the scenes, transfers of value are taking place. And failure to repay a loan means failure to carry out phase 3, which be publicly visible and will lead to serious consequences. Why did you put paytxfee=0.00 in your bitcoin.conf? Is it possible you had another value in the past? There's good discussion of this feature here:https://github.com/bitcoin/bitcoin/issues#issue/3https://gist.github.com/803170Issues: - Symmetric (aes) vs public key (rsa) encryption - Decrypt at startup vs decrypt on use - Create new keys automatically (as now) vs create only on user action - Encrypt all keys with same passphrase vs different passphrases for different key setsOne way to analyze these is via a threat model. What can the attacker do, that we will try to defend against? And what will we not defend against?We can distinguish three levels of attacker:1. Can read user files2. Can read/write user files but only read system files3. Can read/write everything, root privilegesSorry, getting tired, will write more later.". tcatm's bitcoin-js-remote script gives you a "mybitcoin at home" functionality. Run the Bitcoin client and his code on your home machine, open up port 8338 incoming, and you can access your wallet remotely using your mobile browser. It even creates and reads QR-codes for easy phone to phone payments. You don't have to trust any third party service. Really this is such a great concept, I don't know why it isn't better known. That's a very concise implementation. I did spot one bug:Code:+    vector<unsigned char> Encrypt(vector<unsigned char> vchPlaintext)+    {+      // max ciphertext len for a n bytes of plaintext is+      // n + AES_BLOCK_SIZE - 1 bytes+      int len = vchPlaintext.size();+      int c_len = len + AES_BLOCK_SIZE, f_len = 0;+      vector<unsigned char> vchCiphertext(c_len);The max ciphertext size is actually len + 2*AES_BLOCK_SIZE, so you should set c_len to that, and allocate that much space.Also a security flaw, you are using a constant IV everywhere, it looks like. You need to use a different IV for each encryption.One other point, Bitcoin uses a CPrivKey type for sensitive data like private keys. It zeroes memory when it's freed. bitcoin.xxx ftw
If I post a transaction with a fee that would be accepted by only one miner, I will have to wait much longer for my transaction to get into a block. If he controlled 1% of the mining power, I'd have to wait for 100 blocks on average. That may not be attractive to many users. This is not quite right, but the code is pretty spread out. Generally un/serialization is done by the operator<< and operator>> methods of CDataStream in serialize.h. We do CTransaction tx; vRecv >> tx; to read a transaction object; or vSend << a1; to send something of template class a1 (in PushMessage in net.h).The << and >> methods in CDataStream call Serialize() or Unserialize(), which do default the nVersion parameter to VERSION. But in these calls the default is not used, they pass the nVersion instance variable of CDataStream. And this instance variable is set to the min of the node and peer version, e.g. in the code I showed above. Looking at the getwork code, it should only call CreateNewBlock() every minute or so:Code:        if (pindexPrev != pindexBest ||            (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))        {[...]            nTransactionsUpdatedLast = nTransactionsUpdated;            pindexPrev = pindexBest;            nStart = GetTime();            // Create new block            pblock = CreateNewBlock(reservekey);This will call CreateNewBlock() either on a new block coming in, or on a new transaction if it's been 60 seconds since the last call. This shouldn't affect every getwork call, unless it's actually taking 60 seconds to do CreateNewBlock(), which would be remarkable. The js-remote script implements a ssl web server, fully self contained. You don't need apache. Just run SSLserver.py, open up port 8338 for incoming, and connect with your mobile browser to https://yourhost.com:8338. Then you can access your wallet from anywhere, check balance, make payments, etc. The person who originally had them would lose them. Warning, lots of bad information and wrong answers in this thread!Addresses are not created in batches of 100 (after initialization), they are created one at a time as they are used, so you always have a pool of 100 unused addresses.Wallets do hold transactions, all the ones you see in the client window.You would probably not want to share the same wallet between your home system and your phone, because of the risk of theft, any more than you would empty your bank account and carry all your money around with you as cash. Most people plan to hold a fraction of their assets in their phones. Adding a check for a sufficiently low probability event means that the overwhelming majority of the time, the CPU or memory glitched, and it is a false alarm.Adding checks for address hash collisions with existing addresses would not protect you against the creation of an address in the future whose hash collides with yours.If you ever did generate an address whose hash collided with an existing address, you could steal any bitcoins held by that address. So you might not want to throw this windfall away. I used to have trouble managing payments to a service that used a new address every time. Seems to conflict with the idea of an address book. Imagine if everyone's phone number changed every call. Not too convenient.Here's what I do now:1. Copy the payment address.2. Choose Send Coins in the client.3. Choose Address Book in the popup.4. Choose New Address.5. Enter a name for this payee, and paste in the Bitcoin address. Use the same name for all payments to this payee. For example, I use MBC for all transfers to my mybitcoin.com account.6. Click OK in the New Address window.7. Click OK in the Address Book window.8. The Pay To field now holds the payment address. Enter the amount and click Send.This way the transaction in your wallet will show who it's for. It does add some extra steps though. I wish sites would give customers the option to reuse a persistent address.  If we are seriously considering putting this in the client, are there concrete plans to use this? Is someone committed to investing in making and selling scratchoff cards? Or is this patch useful for some other case that doesn't require such specialized equipment? The great majority of companies pay dividends, and that is what gives the stock its value.New tech companies often don't pay dividends, but (believe it or not) their stock value comes from the expectation that they will pay dividends someday. The buy-low-sell-high game only works when the market is trading in a narrow range. But you can't expect it to stay that way forever. Specifically, what are you proposing? What nVersion value should they check, what should they check it against, and what should they do if the check fails/succeeds?Messages do not have version numbers. Nodes exchange their client versions on connection, but that value increments with every release. There's no way to know if packets from a more-recent client peer have changed to be incompatible with this version.Here is some of the code that handles the "version" message:Code:        // Change version        if (pfrom->nVersion >= 209)            pfrom->PushMessage("verack");        pfrom->vSend.SetVersion(min(pfrom->nVersion, VERSION));        if (pfrom->nVersion < 209)            pfrom->vRecv.SetVersion(min(pfrom->nVersion, VERSION));pfrom->nVersion is the peer version. This sends the "verack" message, checking if the peer is newer than version 209 for backwards compatibility. It sets the outgoing serialization version (vSend) to the older of the peer and this node, but only does it for incoming (vRecv) for peers older than 209. Otherwise the incoming deserialization version is left at this node; don't know why the difference.This design puts the responsibility on the newer node to send/receive backwards compatible messages. You laugh, but I predict that fractional reserve Bitcoin banks will exist. They'll make loans and pay interest, just as banks have done for centuries. At least is believable, unlike the ludicrous claim that they'd limit transactions to $100. That one was a transparent bluff. Kiba you're always looking for ways to earn btc, you should sell your user name. Bet you could get 100 btc for it. Nice job! Sent 25 btc as thanks to 17eSZivDJpuJp9TxezTXVxkgLbsr3XZM1i. A txn "in limbo" (in the transaction pool) will block double spends from being forwarded by peers, or accepted by (unhacked) miners. The pool is only in memory so gets wiped when the node is restarted, making network behavior somewhat nondeterministic. The wallet currently retransmits unconfirmed txns indefinitely, however the peers will not forward them unless/until the txns are cleared from peer memory due to a restart. There's other stuff in wallets, including preferences, address book entries for payees, and account information. bitkeys format won't be suitable for wallet backup if it loses all this. Here is the government press release on the Liberty Dollar case:http://charlotte.fbi.gov/dojpressrel/pressrel11/ce031811.htmI worry that Bitcoin can be seen as even more of a threat to the supremacy of the dollar, which by this reasoning would make it terrorism. An extreme claim, to be sure, but apparently the U.S. Is willing to go there.The government also advances this theory:Now this is really stretching the truth. Until the Civil War era, there was no U.S. currency as such, rather paper money was issued, perfectly legally, by private banks. There is no Constitutional prohibition of private currency. There is a law that prohibits private metallic coins, 18 USC 486, which is what they used against LD. It's ominous to see the U.S. expanding its claims like this, to the point where they would cover Bitcoin. The modification to repeatedly hash the 64 bit password is a good idea, and should prevent square root attacks. I would probably have used a simpler iterative formula, but that one seems safe enough. SHA512 is notorious for speed variations on different architectures, but compared to the time to type in the password, that should be ok. Where does the magic number 108333 come from?
I have looked into this, and you do need the public key to break it. (Also I was wrong about Pollard rho being suitable, but the other two are.) Bitcoin does not reveal the public key until the tx is spent; only a hash is revealed until then. However the spending tx is vulnerable while moving through the network on its way to a block. A miner or peer could hold the transaction, break the key in 2^32 work, and substitute their own spend.As far as the algorithmic details, here is baby step giant step. Public key Y, private key x, and generator G satisfy:Y = xGx is of the form s + k, where s is known salt and k is unknown 64 bits. Split k into left and right halves l, r:k = l*2^32 + rwith l and r 32 bits. Then we have, substituting for x in the first eqn:Y = (s + l*2^32 + r)GY + l(2^32(G_inv)) = (s + r)GWe precompute all 2^32 values of the RHS and store them in a hash table. Then we sequentially try the 2^32 values for l in the LHS and look for a match in the table. That gives us l and r, which gives us the private key x. One case to consider is when you have addresses A and B in your wallet but don't want them linked. Jollygreen's code will allow making sure you never spend from A and B together, I think, so that's good.But suppose someone uses the multipay patch to send to both A and B together, because they suspect that the addresses are linked. There are a few ways this could go wrong. Suppose he told you he was sending 10 to A, but also includes 1 to B in the transaction. I'm not sure what the client would do, but it might show you receiving 11. Then you'd be like, dude, you sent me 11 not 10. And he'd be like, you're busted.Another way it could go wrong is that you could spend them together, and again, you're busted. I think Jollygreen is protecting against this.Yet another failure mode would make it impossible to spend the funds, because it would break the rules. So sipa's patch needs to be part of this, allowing the outputs to be split. We know that Bitcoin's resistance to attack is based on the cost for the attacker to overwhelm the network, or at least to control a large fraction of its computing power. We assume this cost will continue to rise in the future so attacks will be infeasible even for well-funded attackers.But the computational power of the network is proportional to difficulty; and it appears that difficulty is proportional to bitcoin price. It follows that unless bitcoins become substantially more valuable than they are today, the Bitcoin network will never be substantially more resistant to attack than it is today.For Bitcoin to succeed and become secure, bitcoins must become vastly more expensive. The unit of spending in Bitcoin is the output of a transaction. That's the closest thing in the system to a "coin". It's not safe to have only 64 bits of the private key be unknown. This can be broken in 2^32 work using such algorithms as baby step giant step, Pollard rho, or the kangaroo. It's an artifact of the coin choice algorithm, not an inherent property of transactions. Sipa offered a patch in that thread, but I don't know what it does. Follow the rules!I've put up a wiki page listing the rules used by the client to process transactions and blocks. It's a bit linear and could benefit from some refactoring, but I didn't want to go too far in terms of pseudocode, because IMO it obscures the logic.https://en.bitcoin.it/wiki/Protocol_rules You're conflating two issues: using bitcoins to buy things on eBay; and using eBay to sell bitcoins for dollars. I would focus on use cases.1. Back up all the keys in a wallet, and later restore the wallet state if the wallet is deleted or corrupted.2. Merge two wallets by exporting all the keys in one, and importing to another.3. Export and remove selected keys from wallet, for moving to safe long-term storage in case the wallet is hacked; later, move the keys back to a wallet for spending.4. Export selected keys for transferring their funds to someone else; the recipient imports the keys and gains access to the funds.Any others?I wonder whether it makes sense to use bitkeys format for case 1 and 2. Wallets do have other things, which is part of your problem. I'd suggest that case 1 & 2 should use wallet formats.This would mean you don't have to worry about reserve keys. I'd treat the other key classes the same.Case 3 & 4 are very similar. They suggest you should have an export-and-delete function. Gavin suggested: 1. export key to disk file; 2. read disk file, make sure key is there; 3. delete key from wallet.Case 4 probably should delete the exported key. You can save a copy and re-import it if the recipient never uses it.For the case 4 import you really want to do: 1. import keys; 2. do a spend from these keys to one of yours; 3. delete imported keys. That assures that ownership transfers. You don't need this for case 3 import as it's your key.Finally, as far as the address and balance: I don't like putting them into CSV fields, because they are redundant and unnecessary. Your comment fields seem okay, but note that the balance may be out of date. How about a command that would take a bitkeys file, and display the address and current balance? Then you could leave the comments out. Here's how I would approach this idea. The concept would be to function in max-anonymity mode by default as now, but to also specify a certain address as being associated with an identity. Receiving coins to that address is trivial, just give out that address for payment. Add a feature to make identified payments from that address as you propose. Important, payments from that address should use that same address for change. Equally important, make sure that regular "anonymous" payments DO NOT use the identified address, otherwise your anonymity will be compromised. That way, anonymous and identified payments can coexist.You could also have more than one identified address, keeping each separate. Probably you'd want to use the address label to choose which to pay with. But the same principles would apply: change back to the same address, and never use it for regular payments.As far as getting started, I'd like to see a sticky walking through the steps to create a pull request. But yeah, you can check out from sourceforge using svn, get your changes working, and post the output of svn diff as a patch. There was quite a bounty for this at one timehttp://bitcointalk.org/index.php?topic=1812.0Can't you store the block chain somewhere else? The block file is 90MB. So you'd have to do 11,000 initial block downloads. I had the impression the roadmap called for a BitDNS-like decentralized mapping system, since Gavin asked to map "strings" to addresses. Maybe I misunderstood. Wow, do you mean your bitcoin client communicated a terabyte in a month??? That doesn't sound right.Average block size is about 3.5 kB, that makes about 15 MB/month. If you had 100 peers that could be maybe 2 GB/month. This can be done using the TPM chip and Intel's Trusted Execution Technology. http://www.intel.com/technology/security/ Newbie chodpaba has discovered a strong correlation between lagged btc price and difficulty: http://bitcointalk.org/index.php?topic=4339.0. It predicts that difficulty should stay level or decrease slightly for the next month. We'll see! Very nice analysis! Since the price has been at or near 1 for a month now, this would predict that difficulty should now level off for at least a month. Should be interesting to see! Well, I can always pay you to work on my block, just like I can pay you to work on my car. So it can certainly be arranged, outside the Bitcoin protocol.I'm not sure I've seen a convincing analysis of the optimal strategy for miners in the era of no block creation fees, even ignoring these kinds of side payments. Plug your hash rate into the Bitcoin Calculator to see how often you can expect to find a block. 400 kh/s will take over two years. That's if difficulty doesn't go up.http://www.alloscomp.com/bitcoin/calculator.php Here is a rather exhaustive analysis of the legality of private currencies in the U.S., by GWU law professor Lewis Solomon:http://www.smallisbeautiful.org/local_currencies/Book.pdfHe focusses on community "scrip" currencies like Ithaca Hours, and concludes that they are probably legal. One caveat is that the book is from 1995, and of course financial regulations have changed since then. Still community currencies operate in the open, unmolested by the Feds.
I don't believe the software does this now, but a miner could copy the transaction from your block, and include both that and the one with the txn fee in its new block. Then it could collect the fee even if it built on another block than yours.Maybe it would work to make the fee transaction depend on your 50 btc creation fee. That one can't be moved. The frequency of finding blocks is an example of the Poisson distribution. Here is a good, simple page about it:http://stattrek.com/Lesson2/Poisson.aspx(no, that doesn't say star trek)Here is a calculator: http://stattrek.com/Tables/Poisson.aspx. You plug in the number of blocks you should have gotten in an interval, and the number of blocks you actually did get (or think you might get). It will tell you the probably to get that many blocks, or more, or less. My pet peeve, related to endianness, is treating hashes as numbers and reversing them. A hash is a byte string with a well defined order and it makes no more sense to reverse it than to reverse text.I would also have used a more common elliptic curve for the crypto, and made some changes to speed it up. In another thread, they proposed bringing accounts into the UI, and doing them a little differently. Every transaction would be labelled with an account name. You could filter your wallet and only view txns for a certain account. And most importantly, you could pay from an account, and it would only use coins from that account.This would make accounts be like virtual wallets, so you could have anonymous accounts and identity based accounts, and the coins wouldn't get intermixed. This should satisfy at least some use cases for choosing coins to pay with.Maybe these should be called something different from accounts, as current accounts are kind of fictitious. Moving money between accounts is currently just bookkeeping, while with what I am talking about it would require an actual transaction. Maybe these should be called something like virtual wallets, or wallet partitions. Another feature we need IMO is the ability to reclaim payments that aren't going through, and/or to reissue payments with a higher transaction fee. (We also need basic support for transaction fees.) As the network gets busier this will become important. This might be nice but I don't see it as a prerequisite for 1.0.In the discussion on BitDNS, there was resistance to overloading the main chain as a title registry. Another chain a la BitDNS could be used to map general strings to btc addresses, as well as domain names.One issue is it pretty much has to be first come first served. Whoever grabs gavin@acm.org first, gets it. There wouldn't be any way to verify ownership of the address. I love that it works on my iPad - a lot of charting services don't.In the top right corner, the difficulty value is overwritten by the current Dte and time. Suppose you sell some bitcoins on mtgox and when you go to withdraw the proceeds, he says, no I think I'll keep them. Is your only recourse to eat the loss and take your business elsewhere? Can he really run his business "any way he wants"? That's where it is. Maybe you were looking at another Library folder? Start with your home directory and open Library from there. Is there anything we need to do for robustness against spam/flooding attacks? I thought [mike] had some ideas. Bitcoin's behind-the-scenes address handling makes things a little complicated. Say you received 2 payments of 50 to your empty wallet. Then you made 2 payments of 30. Now you will have 2 addresses worth 20, both addresses you've never seen before and which don't show up in the transaction list. These received the "change" from the 30 payments.These addresses don't reveal which 50 payment they came from. To see that you'd have to provide some new mechanisms. Maybe show the transaction history behind each address. Maybe show change addresses in the main window. Maybe bring in the account features and tag transactions with accounts.It's not as simple/useful as it seems. CreateNewBlock() has this code:Code:3368         uint64 nBlockSize = 1000;3369         int nBlockSigOps = 100;3370         while (!mapPriority.empty())3371         {3372             // Take highest priority transaction off priority queue3373             double dPriority = -(*mapPriority.begin()).first;3374             CTransaction& tx = *(*mapPriority.begin()).second;3375             mapPriority.erase(mapPriority.begin());3376 3377             // Size limits3378             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK);3379             if (nBlockSize + nTxSize >= MAX_BLOCK_SIZE_GEN)3380                 continue;3381             int nTxSigOps = tx.GetSigOpCount();3382             if (nBlockSigOps + nTxSigOps >= MAX_BLOCK_SIGOPS)3383                 continue;3384 3385             // Transaction fee required depends on block size3386             bool fAllowFree = (nBlockSize + nTxSize < 4000 || dPriority > COIN * 144 / 250);3387             int64 nMinFee = tx.GetMinFee(nBlockSize, fAllowFree);The last couple of lines here relate to one of the free-transaction rules: if the size counting the new tx is < 4000 then it is eligible to pay no tx fee.I wanted to point out the first line, which initializes nBlockSize to 1000. It means there is only 3000 bytes reserved for free transactions, not 4K as often stated.dPriority for a tx is calculated as sum over all input transactions of the input value times its depth, divided by tx size in bytes. This is compared above with 144/250, in units of bitcoins. 250 is about the size of a simple transaction, so to be eligible for no tx fees beyond the 3000 bytes area, the average depth of the inputs times the tx value must be > 144 btc (more for complex transactions with many inputs). If so, the GetMinFee() function allows up to 27K of space.A special case is transactions with input(s) not in blocks. These don't contribute to priority, as though depth==0. If all the inputs are not in blocks, then dPriority will be zero, and the tx can go into the block only if its predecessors have got into the block.If someone sends out a bunch of transactions quickly, such that each one depends on the one before, then all but possibly the first will have dPriority zero. With no tx fees, only about 12 can get into the 3K free area. If there are other transactions around, there will be room for fewer.I do see a pattern of blocks about 3.1K in size with about 12 transaction. Also there have been reports of chains of transactions, each dependent on the previous, getting into consecutive blocks, one per block. This might be because with each new block, (only) the next tx in the chain gets nonzero dPriority. I did some mining the first few weeks of Bitcoin and I got a block or two the first day. I could pay someone with the 50 btc from block 77, if that would have any collector value. Or transfer the private key to them, but I couldn't prove I deleted it. Actually there's respectable cryptographic research into making signing keys enormous, potentially GBs in size. The purpose is to make it hard for a virus to steal them. Then you might say, well, how do I sign with a multi-GB key? This is the trick, you can sign using a small subset of the key, but the subset changes for each signature, so the virus has to steal the whole key in order to sign arbitrary data.Not too applicable to Bitcoin, but the basic idea might be useful sometimes. I'd suggest people look at this PDF, make sure we're fixing the right problem. This is a graph of orphan transactions showing dependencies. Note that there's a chain of 100+ transactions all dependent on the one before. Probablythis is the Faucet.It goes without saying that a tx can't go in a block if it's predecessors are not in blocks. I wonder if a single faucet txn getting dropped could lead to a whole chain of them being blocked? How did it happen though? Should be impossible unless you did more than you said. The online QR encoder at http://zxing.org/w/decode.jspx works on the 6.66 Bitcoin note above, while it failed on the earlier ones. Helps to encode less data probably. Here's what it decodes to:   bitcoin:priv=4RPhNpsD95XcjXG4637DwTNgQLh2eqQ7r7hH5yeLA16F;amount=6.660000;On the other thread, Mike and Gavin suggested an important optimization: Include an optional block number where the address first appears. Otherwise the recipient has to scan the entire block chain to find transactions for that address, which can reportedly take a couple of minutes on a slow machine. Including the starting block number means you only have to scan from there, which will be very fast assuming it's a relatively new address. Actually if you look at Wei Dai's b-money or Nick Szabo's Bit Gold proposals, both from the 90's, you see a lot of the ideas of Bitcoin.b-money:b-money used proof of work in a different way for money creation, but transfers are just like Bitcoin.Bit Gold:Bit Gold comes closer to the creation concept of Bitcoin. The way the blocks chain together is much like Nick's challenge problems. Actually I was wrong, this is exactly what is happening here. You see that both inputs come from the same transaction. In these cases, the pay-yourself cycle was repeated, and you again end up with two addresses in the same wallet, funded by the same transaction, which must be used together. I don't think it's happening here, but I had something similar happen when I paid myself.Suppose you have a wallet funded only with one 15.87 btc transaction, and you pay yourself (ie one of your wallet addresses) 10. Then you will have two funded addresses in your wallet, the 10 you paid, and one with 5.87 for change. Now suppose you pay someone else 10. You'd think it would just use the 10 btc address as input. But it won't.The client will choose both the 10 and 5.87 addresses as input, and have two outputs, 10 btc to the address you are paying, and 5.87 back to you as change. The reason is the client's coin-choosing algorithm is transaction based. If you have transaction where both outputs go to you, as when you pay yourself, then if the client payscwith that transaction, it will always use both addresses.So this is a way you can get transactions like what you saw, with two inputs and two outputs, and values that match.
What about difficulty adjustments though? Difficulty will increase by a factor of 4 every 2016 blocks. Current difficulty is > 32000 or 2^15, plus the implied 32 bits for an actual value of 2^47, ie 47 bits of zeroes at the front of the hash. We add 2 more zeroes every 2016 blocks, so after 105 such adjustments, the target will be all zeroes!However, I peeked at the code, and even an all-zero target can be met with an all-zero hash. So theymos is right, Mr Lucky (who I think has an infinitely fast computer in his pocket) can go all the way, as fast as the net can broadcast blocks. Yes, I can read it now with the darker background. Frankly I find it illegible. I just upgraded to 0.3.20, and while it didn't find Mike's transaction automatically, I ran with the new -rescan switch and that picked it up. Only took 10 or 15 seconds on my Macbook Air. Gavin has a patch for creating an address with your name in it:http://bitcointalk.org/index.php?topic=1387.0Just call me 1HAL6HS2YzAi7Z9ZTuyZhgmf59DfMVbZrQ Sounds like that FAQ entry is obsolete and should be updated. Did you ever get this? Here's some minimal code that might work. Add to rpc.cpp after getwork:Code:Value broadcasttransactions(const Array& params, bool fHelp){    if (fHelp || params.size() < 1)        throw runtime_error(            "broadcasttransactions <hexencodedtransaction> ...\n"            "Broadcasts specified transaction(s) out onto the network.");    for(int param=0; param<params.size(); param++)    {        string strTx = params[param].get_str();        CDataStream vMsg(ParseHex(strTx));        CTransaction tx;        vMsg >> tx;        CInv inv(MSG_TX, tx.GetHash());        RelayMessage(inv, tx);    }    return Value::null;}Then add at the end of pCallTable (the next code block):Code:    make_pair("broadcasttransactions", &broadcasttransactions),Maybe add "broadcasttransactions" to that next table, pAllowInSafeMode, otherwise I guess you have to start the server with -disablesafemode.This is untested, I only spent about half an hour on it, so you don't have to pay if you use it. I was an early participant on Less Wrong as well as its progenitor Overcoming Bias. One principle of rationality is not to choose goals blindly, but to think about what you ultimately want to accomplish, and decide what projects make the most sense. That's why I asked, why Bitcoin?Much discussion on those sites is on cognitive bias, and IMO the most important bias is overconfidence. Study after study has shown that people vastly overestimate the accuracy of their predictions and estimates. The hard step is taking this to heart, and accepting that it applies to you, not just to people who disagree with you. Just to give you a taste of how far you are from rationality, there is actually a mathematical proof that two sufficiently rational people cannot disagree.According to these communities, one of the best ways to get unbiased estimates of future events is the prediction market. They have strong track records and good theory behind them. A Bitcoin based prediction market would be a great asset and contribution to the world. Now all we need is a proposal to overload the block chain to hold email, and the circle will be complete. Is it rational to try to achieve Bitcoin dominance? How confidant are you in forecasting the consequences if you succeed? sha256sum produces hex output, you need to convert to binary with xxd:sha256sum -b manual.txt | colrm 65 99 | xxd -r -p | sha256sum -bd1e802bfb7a086bb37e3e3f395e990e2663354ffaf948b9dde71020000000000 I'm kind of surprised that Mike's transactions didn't show up in my wallet. Instead it still counts that address as having a positive balance. Granted it is non-standard for payments from my wallet keys to originate elsewhere, but there are other ways it could happen, involving restoring from backup.Well I just looked at the code, and it does only watch for transactions that pay me. However it looks like the new release will rescan the block chain on startup; that will probably fix it. I wonder how costly it would be to watch for outgoing transactions all the time. Congratulations Mike! That was fast, you got the bitcoins only two blocks later. Not only that, you had to create a transaction with 5 inputs, corresponding to the 5 payments into the address. Do you mind telling how you did it?As far as use cases, you could email someone some bitcoins without knowing their address, or even if they hadn't tried Bitcoin yet. Some people want to print bitcoins on paper and put them in a safe for long term security. If you could pay bitcoins to a newly created key, and export the private key, it would be a backup that would be safe against wallet theft. Lots of people have asked for this. Sorry! I did screw up the encoding. Here is the 256-bit private key in big-endian hex:C85AFBACCF3E1EE40BDCD721A9AD1341344775D51840EFC0511E0182AE92F78EMy new attempt to base58 encode this is:EV71KQfoePBeWT79sV1VE7fWRgv1KNUxTNapH6ZbaRfBThat's custom code, maybe somebody could check it.To apologize, I've added 30 BTC to the address. We're now at block 109352.The reason I did it this way is that it would be a good format for passing around or backing up bitcoins.BTW the new version of Bitcoin has a -rescan switch to find all txns that are for wallet keys. Only takes a couple minutes. Checking the amount on an address would be very fast. Just scan the block chain to determine the balance for every address, and store as a hash table. Lookups would be in the nanoseconds, inconsequential compared to EC math.None of this would create network activity. The corresponding bitcoin address is 17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL. Here's the blockexplorer link: http://blockexplorer.com/address/17kzeh4N8g49GFvdDzSf8PjaPfyoD1MndL. When the balance goes to zero, someone's got it. This is a base58 encoded plain private key (256 bit value from a "key" entry in my wallet) worth 20 BTC. We're now at block 109180. Let's see how long it takes for someone to input the key and collect the bitcoins.2qy6pGXd5yCo9qy3vxnN7rALgsXXcdboReZ9NZx5aExyETA: this is wrong, the correct value is later in the thread Right now I'd estimate there are 300,000-400,000 funded addresses. Let's round up to a million, 2^20. When you generate a new address the chances are 2^20/2^160 or 1 in 2^140 that you will collide with a funded address. You need to generate 2^139 addresses for a 50-50 chance of success. With my estimate of about 2^17 tries/sec, that is 2^122 seconds. That is over 10^29 (1000000000000000000000000000000) years. Not a problem. If you have a home computer, https://github.com/tcatm/bitcoin-js-remote gives you mybitcoin-like functionality using your own wallet at home. Bitcoin addresses are 160-bit hashes of keys which have 256 bits of uniqueness. We could switch to a 256-bit hash pretty easily (or even not use a hash, just use the 256-bit x coordinate of the public key). The scriptPubkey could use OP_HASH256 instead of OP_HASH160 to reduce the risk of collisions. Addresses would be a few characters longer.
The bottleneck is an elliptic curve multiply, which takes about 2 ms, for 500/sec. However if you just want to generate addresses as fast as possible, you can repeatedly increment the private key while adding G to the public key. I have a patch to Gavin's vanity-address search that does this. It should speed it up by a factor of 300 or so. So that would be 150,000 addresses/sec maybe. No, it would not. Why are so many Russians dishonest? Is it because of all those years of communism, a system built on lies? Or does it go deeper in the Russian culture? Are Russian children even taught by their parents not to lie? Are they taught sayings like "honesty is the best policy", and stories like George Washington and the cherry tree? Don't forget the risk of theft. Backups won't help if your coins get spent. Best to split off some of your coins to long term savings, transfer them to a separate wallet, securely back up that wallet, and securely delete it. Unfortunately this isn't easy with the current client. I like ribuck's terminology:http://bitcointalk.org/index.php?topic=3311.msg46648#msg46648He suggests bitcents, then millicents and microcents. Microcents happen to be the smallest available subdivision of bitcoins, so this works nicely. I've done some benchmarking suggesting that the main CPU bottleneck on initial block download is verifying digital signatures on all transactions in all blocks. If I download from another client on the LAN, I get up to block 70,000 in about 5 minutes, but the rest takes like half an hour. http://articles.cnn.com/2009-05-18/tech/death.online_1_online-multiple-e-mail-addresses-account-information-and-passwords?_s=PM:TECH"Your husband, an avid gamer and techie, dies of a heart attack, leaving his vast online life -- one you don't know much about -- in limbo."His accounts, to which you don't know the passwords, go idle. His e-mails go unanswered, his online multiplayer games go on without him and bidders on his eBay items don't know why they can't get an answer from the seller."Web site domains that he has purchased, some of which are now worth hundreds of thousands of dollars,  will expire, and you may never know."Not to mention his bitcoins...Article goes on to mention sites like Legacy Locker, Assetlock, Deathswitch and Slightly Morbid, which will email your survivors with crucial info, passwords, etc. Article in the NY Times today about FreedomBox, Eben Moglen's project to get everybody running private servers on plug computers. Seems like a natural fit for Bitcoin. Not mining obviously, but could hold a wallet accessible from your mobile. Also another good target for Bitcoin donations. Probably should amortize the price of the graphics card over two or three years. That state of the art card may not be too competitive in a couple of years. This amortized cost may be even greater than the cost of electricity. Would there be interest in a network based on a GPU-resistant problem, instead of SHA-256? Then everyone could be a miner again.(I know what you're thinking: like what problem, exactly? Well I don't know GPU architecture, but I imagine such problems exist. Maybe some of the memory based problems in http://en.m.wikipedia.org/wiki/Proof-of-work_system) Actually I'd say this hints at a serious bug in the client. Look at the record of Ronald's address for receiving money from the mining pool:http://blockexplorer.com/address/1D3hzQnKeQuKoHZ7vZPu8bygiRRMvfhSowHe receives payments and then sends them on, returning again and again to a zero balance.Until the first tx of 2011-01-30, when he receives 3.37. From then on, he no longer reduces his balance to zero; he reduces it to 3.37. This transaction alone is not transferred.Clearly the wallet simply missed this transaction. Yet it picked up a transaction to the same address 8 hours earlier and one two hours later.So there are two possibilities that I see. One, Ronald was messing with his wallet at that time and somehow removed this address from the wallet for a brief time, then put it back. Not an easy thing to do, I don't think. (Maybe deleting the wallet for a while, then restoring it?)Possibility two is that the client somehow overlooked the transaction due to a bug. Obviously not something that happens very often. What could it be? Maybe something to do with block collisions and chain reorg?The block with the missed transaction was 105286. Any way to tell at this late date whether there was anything unusual about this block? I have argued that difficulty should be proportional to price. Difficulty will rise until mining becomes unprofitable. Since the price recently tripled, difficulty should do the same. Imagine if mybitcoin.com could optionally issue payments signed with a single public key, one known to be associated with that service. Then even non-members could accept such payments and trust that no double spending will occur. The Double Trouble game only waits for one confirmation. This should take ten minutes on average. Unfortunately, the time is highly variable, from a few seconds to more than an hour. Makes for a frustrating experience sometimes.Gambling games need to switch to a chip system like real casinos. You'd buy chips with a delay, then gamble with them with instant payouts, cashing out any time. Is it possible for me to win every lottery for the next ten years, just by luck?If so,what would happen?Would they stop having lotteries because they assume I cheated?Would I be worshipped as a god? I think that was Joe's suggestion: if a block shows up that turns one or more previously-broadcast transactions into double-spends, you don't count it. Maybe we could give it a negative difficulty penalty, so that the block chain with this block would have lower cumulative difficulty than without it; that way it would stay an orphan and not be added to the chain. Then if it was all a big mix-up and other nodes kept building on this one, eventually they would overcome the negative difficulty and it would be accepted, as Joe proposed with his 6-block rule.Obviously changing the voting rules like this would need careful analysis. This is off-topic because it is on-topic. It did finally go through, just slow I guess. Suppose the attacker is generating blocks occasionally. in each block he generates, he includes a transfer from address A to address B, both of which he controls.To cheat you, when he generates a block, he doesn't broadcast it. Instead, he runs down to your store and makes a payment to your address C with his address A. You wait a few seconds, don't hear anything, and transfer the goods. He broadcasts his block now, and his transaction will take precedence over yours. I did "Copy to Clipboard" of my Bitcoin address and then hit Pay, paid myself 20 btc. Is this supposed to work?It sort of worked and sort of didn't. The transaction displays as "Payment to yourself" with Debit -20.00 and Credit +20.00. But Status is stuck at "0/offline?". I'm online and I've never had a problem sending a transaction before.
I think this is a great idea Joe. There have been many, many, many requests for this functionality. The recent addition of the rescan feature will help. When you import the key, do a rescan to pick up the transaction that funds it. Then pay yourself. People want this for backups too.I don't think you need to remove the key from the sender's wallet, it will still notice when it's spent. OTOH might be a good idea to remove it, otherwise you might accidentally spend it before the recipient inputs it. I agree that Satoshi's "200 bytes for backward compatibility" is something of a mystery. The 200 is probably a clue. It is quite a bit bigger than a Bitcoin block header. Might be about the size of a block header plus a dummy transaction.There are still some ways to embed arbitrary data in Bitcoin transactions. AFAIK scriptSig data is not checked, and you could put anything at the front without invalidating any signatures. So a BitDNS hash could be stuck into the current Bitcoin block. The idea of a Merkle tree is you just store the root, and then when someone wants to convince you that something's in the tree, they produce the Merkle branch. The Merkle roots are in the block headers. Merkle branches are stored with transactions in wallets. So when you do a spend, in principle you can prove that your "in" transactions are legit, by providing the Merkle branches for all of them. However there are no data structures defined at this time for sending such information in the network.Now this is not a matter of removing spent transactions; rather, it's a mode of operation that would allow nodes to forget all transactions, spent and unspent, and just keep block headers. Did you create the bitcoin.conf file? Should be in the same directory as wallet.dat. Also make sure you spell rpcpassword correctly. The problem is this code in main.h:GetMinFee(), called from main.cpp:AcceptToMemoryPool()601           // To limit dust spam, require a 0.01 fee if any output is less than 0.01602           if (nMinFee < CENT)603               foreach(const CTxOut& txout, vout)604                   if (txout.nValue < CENT)605                       nMinFee = CENT;This will prevent clients from forwarding transactions with outputs < 0.01 btc. We can change this rule but not everyone upgrades so lower value transactions will propagate unreliably for months.I suggest we figure out how to fix this once and for all, put in the new rule but set it to trigger only as of some block number in the future, and meanwhile do something cool in the client so people will want to upgrade before the rule change. There was some discussion on the cryptography mailing list two years ago (much of it poor quality unfortunately IMO):http://www.mail-archive.com/cryptography@metzdowd.com/msg09959.htmlThe thread links are screwed up after the first two messages; skip to:http://www.mail-archive.com/cryptography@metzdowd.com/msg09966.htmland from there you can follow the Thread right-arrow at the top left.There was another flurry of messages when the client was released:http://www.mail-archive.com/cryptography@metzdowd.com/msg10142.html I would focus on two ideas:How are bitcoins created?Everyone on the network competes to be the first solve a computationally hard puzzle. The winner is rewarded with 50 new bitcoins. Puzzle difficulty is automatically adjusted so it takes about ten minutes to get a solution, creating a slow, manageable increase in the supply of bitcoins. The 50 bitcoin reward gets halved every four years, so the total number of bitcoins that will ever be created stays under 21 million.How are bitcoins transferred?Bitcoins are associated with cryptographic public keys controlled by the person who owns them. To transfer them to someone else (i.e. to make a payment) he broadcasts on the Bitcoin network a digital signature identifying the bitcoins he is transferring, along with the public key of the new owner. This information is stored in a distributed database maintained by the Bitcoin network that records the public keys that own every bitcoin. Bitcoin software validates the digital signature and updates the database to record the new owner of the bitcoins. He will then be able to transfer them to someone else in the future.Note that I am not trying to explain how these two ideas are connected, via the block chain. That's just too hard to get across quickly. Verifying an ECDSA signature takes about 3 ms. Let's say the typical transaction has 2 inputs. Each transaction is verified twice, once alone and once in a block. That's 12 ms per node, times 10000 nodes for 120 cpu-seconds, aka 2 cpu-minutes or 1/30 cpu-hour. I'm going to say a computer draws 300W @ $0.10/kWh for electricity, for $0.03 per cpu-hour. YMMV. That makes $0.001 for cpu costs, a tenth of a cent, which appears to dominate. Lots of good ideas here!I like Gavin's idea to display full precision in the UI and allow it on payments.I like ribuck's terminology: 100 bitcents in a bitcoin, 1000 millicents in a bitcent, 1000 microcents in a Millicent.I like [mike]'s suggestion to allow miners to store information relating to costs and policies, and to adapt network behavior from that information. I'd suggest using it specifically to normalize the "anti-spam" limits: the 0.01 minimums for large-transaction fees and for free transactions. Clearly Bitcoin needs a way to adjust these values, and Mike's proposal seems like a good candidate.I also wonder if the anti-spam rule shouldn't be changed, to trigger if the largest output is tiny, rather than for any output. In Gavin's example, outputs of 1.5 and 0.000001 change seem ok to me. I used to have a copy, but I think maybe I gave it away. I'll have to check my shelves. IMO one way to get a handle on a reasonable value for 1 bitcoin is via this formula:probability Bitcoin ultimately succeeds * value of 1 bitcoin if it succeedsBitcoin has the potential to become the dominant currency for large-scale electronic transactions worldwide. If this happens, bitcoins could be worth millions of dollars each.So what is the probability of such a grandiose outcome? One in a million? Maybe so.I see the recent increase in value as a rise in the consensus probability that Bitcoin will succeed. You're missing Oct-Dec I have enhanced the bc_key program to print interesting information about transactions found in the wallet file.https://github.com/halfinney/bc_keyRun it as:Code:./bc_key EVERYTHING ~/.bitcoin/wallet.dat(substitute your own wallet.dat location on mac and windows)This dumps everything in the wallet, including keys and address book, but let's just look at transactions:Code:./bc_key EVERYTHING ~/.bitcoin/wallet.dat | grep ^txI'll go ahead and violate my own privacy because I want to make a point. Here's my output:Code:tx 011104eddf3afd4e1133996e3e2a9c7f16ed1f9dfa922493612bab9b8be19f0e    1.50000000 12gHtU8z4HNymJUBetcyY2MU8CYYfszq5X 2011/01/22 spenttx 5fa35fa2e753c8997aaca3b1cb434f218884d95ae8803a0ee7ff8eee298ba00f    3.00000000 1BPE6sLdYn8zoRH2ovEWiqQH4NRbyAAHNK 2011/01/22 change spenttx cff5962c80af06506d6583710fdbde01b95e0bf4a37df27af82ee5038b241016    9.00000000 1NiihskVid2GTWEJjKDaft67aFkeCJTTaE 2011/02/06 changetx 31989da39c18a351fb393b05d7d66efd69cf1cc64958d67a5c49189e28402b1f    0.50000000 157a7eFdnTg89gPZ5wWPjX1TMVL3ffeDSh 2011/01/28 changetx a5a88c6af09b9bcd21a7ee0e0c25ce912a0ccabd90a5a6d8a5644c7b6c519321    6.00000000 payment                            2011/01/30 spenttx b6f4b9239544d864d5fbbfce5bc6d6333227e2b6db8aa0d35beba3bcf12b212d   12.00000000 1513Z4iDpW1K3qyknHUhwxhXy6H5aYd6q6 2011/01/30 spenttx 061ef85f7936b138675e5c6b01c67ddbb8710aa9c00dffdd1859e2e0b231ce47    3.00000000 payment                            2011/02/01 spenttx 835d37f77fc980efa21771e3fefbd79d9a20f2f69d3d0517d99f86aeecae464a  997.00000000 1F4YL3tYS1Y4dEvCUppwMjggi2imgJogVW 2011/01/20 change spenttx 3ed3602d07e3f16f90f4966c502e5fcccb7e13faacc0053e9558e91a93a9a24f    3.00000000 1J6ToHCuN6jeniL7wD2zJwxhRUv2V6TLXW 2011/01/30 change spenttx 78537330713ec5c92befd3e1a91c754198ee14877c02d8888c899280d0a49c58  994.00000000 1K8THF4Qkr5mMKjQRJe1xW33ZYoUrgtUHL 2011/01/20 changetx 82621223fccb83122edda411f941c729929507a21bed320d1a9af6caa12dc159 1000.00000000 1KeWUnmZZUNDSeWKf9pqZmMdtkeJ5jENnX 2011/01/02 spenttx 5fd3fed9bef47df2c95255b863bf989b027121bfcedd692d08888ba704130c7a    5.00000000 19MvB9acQ4wx4GtGxBwTamMkfHPVSBWY3Z 2011/01/22 change spenttx 9555b4b8e84e6e5b045847fe86d6bb82df67e4360a897b485dbd8a76e0b46b83   10.00000000 1NC55QPMZqtpRNiRvkBatNvZLrXT5XqnRR 2011/02/03 change spenttx 3a3b74721cc6af482bcc8b6722f80a87a9de103ee26a67975a2eee69328a3b92    6.00000000 1513Z4iDpW1K3qyknHUhwxhXy6H5aYd6q6 2011/01/20 spenttx 4c9bb949f106cfe6bed53415e7dcb86f5c93603434c65ca6423d5de1eabafa92    1.25000000 12gHtU8z4HNymJUBetcyY2MU8CYYfszq5X 2011/01/22 spenttx 03f87b3c1ed4231e64a781ce2f8c10c03e7a3f6439389c97af640e1e63eb29b0    0.25000000 1LKRbsyxiSi3zfHKyumEH8W7fSQapapnnw 2011/01/28 changetx a97511426aac9be884236578060293a1b6783d4c7467288bf89436bfc38feec9    3.00000000 payment                            2011/01/30 spenttx 230fec2b39bc56ef359a5c078505b8aac0d8221c5109dd0fa8f98ddd667ab8d3   18.87000000 12BxP2C6aj2KT5fsnNdiyVMKfhm9tu1MK4 2011/02/01tx 7b8cb378bc8f15e98a8f94c2c20a8e552b6dd785f3863c1baac314e8b8d56ada    6.00000000 1513Z4iDpW1K3qyknHUhwxhXy6H5aYd6q6 2011/01/30 spenttx ca43a17aa52c670e96c77a752552d502016355e2c7018ed4c930215e8366a9da    6.00000000 1513Z4iDpW1K3qyknHUhwxhXy6H5aYd6q6 2011/01/20 spentThe big number is the transaction ID, suitable for plugging into blockexplorer.com. Next is the bitcoin amount, your address that received the bitcoins, and the date of the transaction. Finally come the optional words change and spent. Change means this transaction produced change as a side effect of a payment you made to others, and the address shown is the change address, which is largely hidden in the client UI. Spent means that the bitcoin(s) associated with this transaction have been spent and are no longer available.There are basically three types of wallet transactions. First are payments from someone else to a wallet key. Next are payments to others which happen to exactly use up one or more available transactions, with nothing left over. These are shown as "payment" in the address field and are always marked as spent. Last are payments where there were bitcoins left over, which get returned to a new address. These are the ones which are shown as change.To see the transactions which are available for spending, filter out the spent ones with grep -v:Code:./bc_key EVERYTHING ~/.bitcoin/wallet.dat | grep ^tx | grep -v spent\$Code:tx cff5962c80af06506d6583710fdbde01b95e0bf4a37df27af82ee5038b241016    9.00000000 1NiihskVid2GTWEJjKDaft67aFkeCJTTaE 2011/02/06 changetx 31989da39c18a351fb393b05d7d66efd69cf1cc64958d67a5c49189e28402b1f    0.50000000 157a7eFdnTg89gPZ5wWPjX1TMVL3ffeDSh 2011/01/28 changetx 78537330713ec5c92befd3e1a91c754198ee14877c02d8888c899280d0a49c58  994.00000000 1K8THF4Qkr5mMKjQRJe1xW33ZYoUrgtUHL 2011/01/20 changetx 03f87b3c1ed4231e64a781ce2f8c10c03e7a3f6439389c97af640e1e63eb29b0    0.25000000 1LKRbsyxiSi3zfHKyumEH8W7fSQapapnnw 2011/01/28 changetx 230fec2b39bc56ef359a5c078505b8aac0d8221c5109dd0fa8f98ddd667ab8d3   18.87000000 12BxP2C6aj2KT5fsnNdiyVMKfhm9tu1MK4 2011/02/01These are really my "bitcoins". They are what I have available to spend. The sum of the bitcoin amounts should equal my wallet balance. Any spend I make will come from one or more of these transactions. Generally, the Bitcoin client will try to combine one or more small transactions to make a payment, otherwise it will use the smallest single transaction capable of funding the payment.Although my wallet doesn't show it too clearly, it's not unusual for a single Bitcoin address to be funded by multiple transactions. But for making payments, this is basically irrelevant. Individual transactions are picked to fund payments without regard to whether some of them happen to use the same address. People talk about moving keys/addresses, but also it is important to move the transactions. Bitcoin is a transaction based system. Your keys authorize (sign) payments, but the payments actually come from the transactions you have received and which are in your wallet. If you're splitting off some keys into another wallet, you need to move the transactions that fund those keys, or they won't be able to do anything. (Should move address book and account entries too.) I've put the code up at github. I'm a C programmer more than C++; it shows.https://github.com/halfinney/bitcoin/tree/secp256k1Here's a self contained test program that compares the speeds. Build with -lcrypto.Code:#include <stdio.h>#include <sys/time.h>#include <openssl/ec.h>#include <openssl/ecdsa.h>#include <openssl/evp.h>#define REPS 1000// Split a secp256k1 exponent k into two smaller ones k1 and k2 such that for any point Y,// k*Y = k1*Y + k2*Y', where Y' = lambda*Y is very faststatic intsplitk (BIGNUM *bnk1, BIGNUM *bnk2, const BIGNUM *bnk, const BIGNUM *bnn, BN_CTX *ctx){    BIGNUM *bnc1 = BN_new();    BIGNUM *bnc2 = BN_new();    BIGNUM *bnt1 = BN_new();    BIGNUM *bnt2 = BN_new();    BIGNUM *bnn2 = BN_new();    static unsigned char a1b2[] = {        0x30, 0x86, 0xd2, 0x21, 0xa7, 0xd4, 0x6b, 0xcd,        0xe8, 0x6c, 0x90, 0xe4, 0x92, 0x84, 0xeb, 0x15,    };    static unsigned char b1m[] = {        0xe4, 0x43, 0x7e, 0xd6, 0x01, 0x0e, 0x88, 0x28,        0x6f, 0x54, 0x7f, 0xa9, 0x0a, 0xbf, 0xe4, 0xc3,    };    static unsigned char a2[] = {        0x01, 0x14, 0xca, 0x50, 0xf7, 0xa8, 0xe2, 0xf3,        0xf6, 0x57, 0xc1, 0x10, 0x8d, 0x9d, 0x44, 0xcf,        0xd8,    };    BIGNUM *bna1b2 = BN_bin2bn(a1b2, sizeof(a1b2), NULL);    BIGNUM *bnb1m = BN_bin2bn(b1m, sizeof(b1m), NULL);    BIGNUM *bna2 = BN_bin2bn(a2, sizeof(a2), NULL);    BN_rshift1(bnn2, bnn);    BN_mul(bnc1, bnk, bna1b2, ctx);    BN_add(bnc1, bnc1, bnn2);    BN_div(bnc1, NULL, bnc1, bnn, ctx);    BN_mul(bnc2, bnk, bnb1m, ctx);    BN_add(bnc2, bnc2, bnn2);    BN_div(bnc2, NULL, bnc2, bnn, ctx);    BN_mul(bnt1, bnc1, bna1b2, ctx);    BN_mul(bnt2, bnc2, bna2, ctx);    BN_add(bnt1, bnt1, bnt2);    BN_sub(bnk1, bnk, bnt1);    BN_mul(bnt1, bnc1, bnb1m, ctx);    BN_mul(bnt2, bnc2, bna1b2, ctx);    BN_sub(bnk2, bnt1, bnt2);    BN_free(bnc1);    BN_free(bnc2);    BN_free(bnt1);    BN_free(bnt2);    BN_free(bnn2);    BN_free(bna1b2);    BN_free(bnb1m);    BN_free(bna2);    return 0;}static intsecp256k1Verify(const unsigned char hash[32], const unsigned char *dersig, size_t sigsize, const EC_KEY *pkey){    int rslt = 0;;    const EC_GROUP *group = EC_KEY_get0_group(pkey);    const EC_POINT *Y = EC_KEY_get0_public_key(pkey);    const EC_POINT *G = EC_GROUP_get0_generator(group);    EC_POINT *Glam = EC_POINT_new(group);    EC_POINT *Ylam = EC_POINT_new(group);    EC_POINT *R = EC_POINT_new(group);    const EC_POINT *Points[3];    const BIGNUM *bnexps[3];    BIGNUM *bnp = BN_new();    BIGNUM *bnn = BN_new();    BIGNUM *bnx = BN_new();    BIGNUM *bny = BN_new();    BIGNUM *bnk = BN_new();    BIGNUM *bnk1 = BN_new();    BIGNUM *bnk2 = BN_new();    BIGNUM *bnk1a = BN_new();    BIGNUM *bnk2a = BN_new();    BIGNUM *bnsinv = BN_new();    BIGNUM *bnh = BN_bin2bn(hash, 32, NULL);    static unsigned char beta[] = {        0x7a, 0xe9, 0x6a, 0x2b, 0x65, 0x7c, 0x07, 0x10,        0x6e, 0x64, 0x47, 0x9e, 0xac, 0x34, 0x34, 0xe9,        0x9c, 0xf0, 0x49, 0x75, 0x12, 0xf5, 0x89, 0x95,        0xc1, 0x39, 0x6c, 0x28, 0x71, 0x95, 0x01, 0xee,    };    BIGNUM *bnbeta = BN_bin2bn(beta, 32, NULL);    BN_CTX *ctx = BN_CTX_new();    ECDSA_SIG *sig = d2i_ECDSA_SIG(NULL, &dersig, sigsize);    if (sig == NULL)        goto done;    EC_GROUP_get_curve_GFp(group, bnp, NULL, NULL, ctx);    EC_GROUP_get_order(group, bnn, ctx);    if (BN_is_zero(sig->r) || BN_is_negative(sig->r) || BN_ucmp(sig->r, bnn) >= 0        || BN_is_zero(sig->s) || BN_is_negative(sig->s) || BN_ucmp(sig->s, bnn) >= 0)        goto done;    EC_POINT_get_affine_coordinates_GFp(group, G, bnx, bny, ctx);    BN_mod_mul(bnx, bnx, bnbeta, bnp, ctx);    EC_POINT_set_affine_coordinates_GFp(group, Glam, bnx, bny, ctx);    EC_POINT_get_affine_coordinates_GFp(group, Y, bnx, bny, ctx);    BN_mod_mul(bnx, bnx, bnbeta, bnp, ctx);    EC_POINT_set_affine_coordinates_GFp(group, Ylam, bnx, bny, ctx);    Points[0] = Glam;    Points[1] = Y;    Points[2] = Ylam;    BN_mod_inverse(bnsinv, sig->s, bnn, ctx);    BN_mod_mul(bnk, bnh, bnsinv, bnn, ctx);    splitk(bnk1, bnk2, bnk, bnn, ctx);    bnexps[0] = bnk2;    BN_mod_mul(bnk, sig->r, bnsinv, bnn, ctx);    splitk(bnk1a, bnk2a, bnk, bnn, ctx);    bnexps[1] = bnk1a;    bnexps[2] = bnk2a;    EC_POINTs_mul(group, R, bnk1, 3, Points, bnexps, ctx);    EC_POINT_get_affine_coordinates_GFp(group, R, bnx, NULL, ctx);    BN_mod(bnx, bnx, bnn, ctx);    rslt = (BN_cmp(bnx, sig->r) == 0);    ECDSA_SIG_free(sig);done:    EC_POINT_free(Glam);    EC_POINT_free(Ylam);    EC_POINT_free(R);    BN_free(bnp);    BN_free(bnn);    BN_free(bnx);    BN_free(bny);    BN_free(bnk);    BN_free(bnk1);    BN_free(bnk2);    BN_free(bnk1a);    BN_free(bnk2a);    BN_free(bnsinv);    BN_free(bnh);    BN_free(bnbeta);    BN_CTX_free(ctx);        return rslt;}main(){    EC_KEY *pkey;    EC_GROUP *group;    const EC_POINT *ecpub;    unsigned char sig[100];    unsigned siglen = sizeof(sig);    unsigned char hash[32];    struct timeval tv1, tv2;    double time1, time2;    int i;    int rslt;    ENGINE_load_builtin_engines();    CRYPTO_malloc_init();    group = EC_GROUP_new_by_curve_name(NID_secp256k1);    pkey=EC_KEY_new();    EC_KEY_set_group(pkey,group);    EC_KEY_generate_key(pkey);    ecpub = EC_KEY_get0_public_key(pkey);    ECDSA_sign(0, hash, 32, sig, &siglen, pkey);    rslt = ECDSA_verify(0, hash, 32, sig, siglen, pkey);    printf("rslt = %d\n", rslt);    rslt = secp256k1Verify(hash, sig, siglen, pkey);    printf("rslt = %d\n", rslt);    hash[0]++;    rslt = ECDSA_verify(0, hash, 32, sig, siglen, pkey);    printf("rslt = %d\n", rslt);    rslt = secp256k1Verify(hash, sig, siglen, pkey);    printf("rslt = %d\n", rslt);    hash[0]--;    gettimeofday(&tv1, NULL);    for(i=0; i<REPS; i++) {        rslt = ECDSA_verify(0, hash, 32, sig, siglen, pkey);    }    gettimeofday(&tv2, NULL);    printf("rslt = %d\n", rslt);    time1 = (tv2.tv_sec - tv1.tv_sec + (tv2.tv_usec - tv1.tv_usec)/1000000.) / REPS;    printf("time: %g\n", time1);    gettimeofday(&tv1, NULL);    for(i=0; i<REPS; i++) {        rslt = secp256k1Verify(hash, sig, siglen, pkey);    }    gettimeofday(&tv2, NULL);    printf("rslt = %d\n", rslt);    time2 = (tv2.tv_sec - tv1.tv_sec + (tv2.tv_usec - tv1.tv_usec)/1000000.) / REPS;    printf("time: %g\n", time2);    printf("%f%% speedup\n", (time1-time2)/time1);    exit(0);} I implemented an optimized ECDSA verify for the secp256k1 curve used by Bitcoin, based on pages 125-129 of the Guide to Elliptic Curve Cryptography, by Hankerson, Menezes and Vanstone. I own the book but I also found a PDF on a Russian site which is more convenient.secp256k1 uses the following prime for its x and y coordinates:p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fand the curve order is:n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141The first step is to compute values beta, lambda such that for any curve point Q = (x,y):lambda * Q = (beta*x mod p, y)This is the so-called efficiently computable endomorphism, and what it means is, you can multiply any curve point by this special value lambda very quickly, by doing a single mod-p multiply.The book tells (well, hints) how to compute lambda and beta, and here are the values I found:lambda = 0x5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72beta = 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501eeGiven that we can multiply by lambda quickly, here is the trick to compute k*Q. First use the shortcut to compute Q' = lambda*Q. Next, k must be decomposed into two parts k1 and k2, each about half the width of n, such that:k = k1 + k2*lambda mod nThenk*Q = (k1 + k2*lambda)*Q = k1*Q + k2*lambda*Q = k1*Q + k2*Q'That last expression can be evaluated efficiently via a double multiply algorithm, and since k1 and k2 are half length, we get the speedup.The missing piece is splitting k into k1 and k2. This uses the following 4 values:a1 = 0x3086d221a7d46bcde86c90e49284eb15b1 = -0xe4437ed6010e88286f547fa90abfe4c3a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8b2 = 0x3086d221a7d46bcde86c90e49284eb15(it's ok that a1 = b2)Use these as follows to split k:c1 = RoundToNearestInteger(b2*k/n)c2 = RoundToNearestInteger(-b1*k/n)k1 = k - c1*a1 - c2*a2k2 = -c1*b1 - c2*b2With all this, I measure about a 25% speedup on raw signature verifications. For Bitcoin, initial block load from a wifi-connected local node is reduced from:real   36m21.537suser   24m43.277ssys   0m27.950sto:real   32m59.777suser   18m21.145ssys   0m28.262sNot a big difference, and it would probably be even less significant when fetching over the net. In another thread, [mike] wrote:I'm trying to inplement the secp256k1 shortcut. Should have results shortly. Unfortunately I only expect about 20% speedup. We'll see.I'm also looking at batch signature verification:http://cseweb.ucsd.edu/~mihir/papers/batch.pdfhttp://www.math.snu.ac.kr/~jhcheon/publications/2007/BatchVer_PKC2007_CL.pdfThis can theoretically speed up verification by almost a factor of 4 (table 6 in 2nd paper) if you have a lot of signatures in a batch. It requires a slight change in the ECDSA signature format: (r, s) is replaced by (R, s), where R is the EC point of which r is the x coordinate. This change could be applied retroactively, as R is calculated and discarded every time the sig is verified.We do tend to have sigs in batches, namely blocks; sometimes several dozen or even hundreds, and this will grow. Batch verification returns true iff all sigs are valid. A good block should never have invalid signatures so it makes sense to batch the verify.I need to research some security aspects, namely: does R need to be checked to see if it's on the curve (ie y^2 = x^3 + 7)? And what is an appropriate security parameter for the probability the batch verify test could be fooled? The papers talk about 2^80 but that seems too conservative. So what does that mean for Bitcoin loans? Where would the money come from to pay interest? I really like this, sent a tip. Be nice to be able to see a larger window of time. FYI the cluster of transactions on the hour is the mining pool paying out. I'd like to see a separate forum for mining. Lately mining posts are filling the Development and Technical Discussion forum.
I'd like to bet on Bitcoin difficulty and dollar trading price, 6 and 12 months in the future. See this analysis by [mike] looking at similar transaction loads and what that would mean for mining servers:http://bitcointalk.org/index.php?topic=2454.msg34469#msg34469Mike astutely identifies the bottleneck as the CPU power to verify transaction signatures. I've been doing some profiling and over 90% of the CPU time of the (non-generating) client is spent in ECDSA_verify.There are plans for lightweight clients that would not download blocks, just headers. Then they would be sent details of transactions involving them. Only the big iron would keep the block chain. You could tear your banknotes into 5 pieces and hide them separately. As long as you can recover at least 3 pieces you should be able to exchange them for fresh bills. How many dots on that map? I lost count. I'd like to learn to play poker. Would this be a good place? I agree this can be a problem. Putting in a transaction fee won't help if the next block happens to take an hour to generate.I suggested a technical solution to reduce variability:http://bitcointalk.org/index.php?topic=2968.0We might also consider shortening the ten minute target interval. Making it five minutes would greatly reduce the chance of a long wait. How about counting the number of people in #bitcoin? That should include almost everyone who's running the client at that moment. I'd like to see stats on how this number is changing. This is how I understand transaction fees to work:- the client offers a fee by creating a tx with a "surplus", ie. the input amount is greater than the output amount- when a miner creates a block he can create a transaction paying himself up to 50 btc plus the sum of all the tx fees in the blockThe miner doesn't have to pay himself that much but the tx fees are lost anyway. Context is important. Does this mean the merchant API has/had a way of discovering account names? And this involved sending a dummy transaction of 0 to each account? Has this been fixed? I wouldn't be surprised if in 30-50 years they were able to genetically engineer some sea organism to extract gold from seawater and concentrate it in their shell, as they do with calcium and other elements now. I think Bruce is right, in the long run gold is doomed as a source of value. Now I'm paranoid. I just tried to login to mtgox from my iPad and got an invalid certificate error. The issuer is certificates.godaddy.com. Has anyone else gotten this? I suspect it is a misconfiguration of the mtgox server a la http://blog.boxedice.com/2009/05/11/godaddy-ssl-certificates-and-cannot-verify-identity-on-macsafari/. Suppose you receive a payment and then immediately spend it. Then there is a block reorganization and the payment to you goes away. It never comes back because it was a double spend. Can the client handle this? How would it appear in the transaction window? What do you mean by walking the block chain? Could you clarify what you would do when you receive a block containing a payment transaction to one of your addresses? Do you need to go back and look at old blocks? Or can you just assume it's valid because it's in a block, possibly waiting for some confirmations, in which case maybe you don't need to save old blocks at all. None of the pictures have been showing up at http://bitcoinme.com for a few weeks now. I PM'd Bruce about it a while back but no change. Ultimately it's good for the network for mining to be expensive. It makes it that much harder for a well financed attacker to dominate the network. I listen to the network (via http://bitcointalk.org/index.php?topic=2808.0), and while transactions generally come pretty randomly, there is occasionally a cluster of a dozen or so transactions, coming very quickly, within a second or two. It took me a while to realize that when these happen, it is always the top of the hour. I don't notice them every hour, but several times a day, always on the hour.Looking at blockexplorer, it looks like these are a series of small payments, a few cents or a few bitcoins, generally from high value transactions near 50 btc. And they each normally have a 0.01 btc transaction fee.An interesting pattern... Signatures are DER encoded in Bitcoin, and your signature above is in the same format. 30 is a sequence of values, in this case the two ECDSA components, called r and s. 46 is the length of the sequence. Then 02 means integer, 21 is the length, followed by 0x21 bytes which is the r value. Then there's another 02 and length for the s value. If the high bit of r or s is set, they get 00 prepended so it's clear they're positive. Bitcoin sigs have exactly the same format as you can see in any blockexplorer.com dump. Well my attempt to verify that sig in openssl failed, it didn't verify. That's no surprise since the two methods also disagreed about the validity of the bitcoin sig. I hoped I'd see something wrong in the data structures, but I didn't. Your pubkey is a valid EC point on the secp256k1 curve. The signature appears to be properly formatted.I'll see if I can think of anything else... Several people have mentioned they are working on mobile clients (at least Android, don't know about iOS). But I haven't seen much discussion of the design in terms of security and performance issues.In another thread, http://bitcointalk.org/index.php?topic=2957.msg41905#msg41905, [mike] made a provocative comment: "1) Are you trying to make an Android client? You don't want to verify transactions if so."Can mobile clients get away without verifying transactions? Maybe they could just rely on the block chain. Any transaction in a block that has enough confirmations is considered to be good. Checking blocks is both easy and quick, pretty much just hashing.The one problem I see would be a possible delay in knowing that payments to you are valid. It wouldn't matter for payments to merchants who can run regular clients, but payments from one mobile user to another might be slow to be validated.Another possible shortcut would be for mobile clients not to forward blocks, transactions, and addresses the way regular clients do. Network transmissions draw a lot of power. Mobile nodes could just leech. If they don't process transactions, they wouldn't even need to read those.iOS doesn't have true multitasking. I don't think a client could receive the block chain in the background. Android presumably doesn't have this problem, but the question would be impact on battery life to keep the client running all the time.
Here's what I would suggest. Create a new key pair in your code. Hash and sign something like 'abc'. Then see if you can verify the signature. If it works, publish the key and signature here. I can try to verify the sig with OpenSSL. I was successful at verifying a Bitcoin signature, so this might reveal differences in the two libraries. I was able to verify the signature using the openssl command line and a bunch of cutting and pasting of hex dumps. The data input to the hash isCode:01 00 00 00 03 30 f3 70  1f 9b c4 64 55 2f 70 49  |.....0.p...dU/pI|57 91 04 08 17 ce 77 7a  d5 ed e1 6e 52 9f cd 0c  |W.....wz...nR...|0e 94 91 56 94 00 00 00  00 19 76 a9 14 02 bf 4b  |...V......v....K|28 89 c6 ad a8 19 0c 25  2e 70 bd e1 a1 90 9f 96  |(......%.p......|17 88 ac ff ff ff ff 72  14 2b f7 68 6c e9 2c 6d  |.......r.+.hl.,m|e5 b7 33 65 bf b9 d5 9b  b6 0c 2c 80 98 2d 59 58  |..3e......,..-YX|c1 e6 a3 b0 8e a6 89 00  00 00 00 00 ff ff ff ff  |................|d2 81 28 bb b6 20 7c 1c  3d 0a 63 0c c6 19 dc 7e  |..(.. |.=.c....~|7b ea 56 ac 19 a1 da b1  27 c6 2c 78 fa 1b 63 2c  |{.V.....'.,x..c,|00 00 00 00 00 ff ff ff  ff 01 00 a6 f7 5f 02 00  |............._..|00 00 19 76 a9 14 9e 35  d9 3c 77 92 bd ca ad 56  |...v...5.<w....V|97 dd eb f0 43 53 d9 a5  e1 96 88 ac 00 00 00 00  |....CS..........|01 00 00 00                                       |....|and the hash ise8a875b4a6b23e507cdad56d1d74285f22fec05bfd6be2f737923c43fcc23987If you have this value, it is correct, and you can look elsewhere. The sum of the IN values has to be greater than or equal to the sum of the OUT values. If it is greater, the difference is a transaction fee, collectable by whoever generates the block that includes this transaction. Okay, I did that too, and the secret is that the scriptSig is entirely removed and replaced with the scriptPubKey from the source (old) transaction. I'm still a little confused about how this works in the source.VerifyScript() doesn't actually concatenate the two scripts. It runs scriptSig, and that leaves stuff on the stack, then it runs the old scriptPubKey with the stack left by scriptSig. The only connection is the stack. So when we run the scriptPubKey, which holds the OP_CHECKSIG, the "current script" is just that, the old scriptPubKey. This is the script which gets OP_CODESEPARATOR stripped and then put in place of the scriptSig, for hashing.What I don't understand is this line from the OP_CHECKSIG code:                    // Drop the signature, since there's no way for a signature to sign itself                    scriptCode.FindAndDelete(CScript(vchSig));This is apparently the basis for the advice to "remove the signature" for hashing. But it doesn't make sense, because there is no signature in scriptPubKey, which is where this opcode is found. This line doesn't seem to do anything, and advice to remove a nonexistent signature is misleading. What you are doing looks pretty good to me now that I understand it better. I tried hashing your data and got 90377525e05bd71ce8ba413a84fdaea299766732f165fab28a69d30c83337f9b, don't know if that matches yours. The only other thing I can think of would be to try reversing the hash on input to the ECDSA functions. Okay, I've confirmed that hashes OK using sha256sum and gets your value, 0f898c5494eaa468d12cf0630a0c0b238cc1149c1c53bbc592d16497094e95ff. So the question remains to verify the sig.You will have to add 01 00 00 00 to the end before you hash, for the hashtype.I'm not sure about your scriptsig shortening. You removed the sig ok, but there seems to be more stuff added at the end, after the pubkey. Wow, that's bizarre that the byte order of the hashes is reversed on the wire like that. Have you tried reproducing the published transaction hash by hashing the raw transaction? Does that work? What do you get, 0f89... as it is on the wire, or the reverse, ff95... as blockexplorer has it? And do you need to byte reverse the embedded hashes in the tx in order to get the right answer? I don't see how that hex dump corresponds to the transaction. You have outpoint hashes starting with 30 f3, 72 14, and d2 81, none of which are in the transaction. Ah, okay,  I didn't know that miners worked that way,  thanks.    Interesting analysis! Don't forget that in several years, if Bitcoin succeeds, there will be orders of magnitude more transactions. And some of these will be able to pay substantial fees. So there will be a strategy to start generating right away, beat the miners who are waiting, and collect these high value tx fees.Also, currently miners don't update the block they're working on with new transactions as they come in. I think that makes the hash search more efficient. So by the time a block is generated, there's already a substantial pool of new transactions to start working on. This too may change in the future though. I'd add speed, you shouldn't have to wait too long for a transaction to go through. Bitcoin gets a B-, it's fast enough for a lot of things but too slow for some.Scalability, could it be used for every transaction, everywhere in the world? In its current form I'd say no, but possibly with the addition of lightweight clients. So I'll say C, has potential but not there yet. Bitcoin aims to produce blocks every ten minutes. But the actual time between blocks is quite variable, being governed by the Poisson distribution. I listen to block formation, and this variability is apparent. It's not unusual for blocks to be formed just a few seconds apart, while sometimes an hour goes by without one.This variability is intrinsic to the hash solutions used by Bitcoin, and will not change even as the network grows. It may be a problem particularly for transactions that want a single confirmation. An application where a ten minute delay is acceptable might be in trouble if the delay becomes an hour.A way to reduce the variability while maintaining the average solution time is to split the hash problem up into several sub-problems. Instead of solving a hash puzzle with difficulty 16,000, solve 4 puzzles with difficulty 4,000. The total difficulty and average time to find a solution is the same, but the variability is much less. Splitting into even more sub-problems will further reduce variability.A downside to reducing variability is that we would have more block collisions, where more than one node solved the same block at about the same time. This would reduce the efficiency of the network, as nodes work on blocks doomed to be superseded, and blocks get reshuffled in and out of the longest chain. Also, it would give more advantage to the fastest node; in the extreme, if we eliminated all variability, it would win every time.So we wouldn't want to go too far with this. But splitting into a modest number of sub-problems could substantially reduce the odds of hour+ inter-block intervals, hopefully without causing too many problems. I was scared to upgrade since I had a fair amount of vintage bitcoins in there. But everything seemed ok. I'll play with it some more and see if I can get a key pool.I was wrong about the wkey, it would mostly add creation and expiration dates, maybe a future feature. I made some edits. It might be nice to explain what the various SIGHASH values are intended to be used for, and whether they will work at this time. I modified the bc_key program originally by dirtyfilthy, to dump out info on everything in the wallet.dat file.https://github.com/halfinney/bc_keyIt prints out keys (as addresses), transaction hashes, key pool addresses, address book names, etc.Run it as:./bc_key EVERYTHING ~/.bitcoin/wallet.dator wherever your wallet.dat might be. I like to pipe the output through sort.I've noticed two oddities in the couple of wallets I've looked at:There are no wkey entries, only keys. wkeys would hold extra stuff with Merkle branches and all that. Is this not yet (or no longer) supported, present in the code for the hypothetical "lightweight client"?I have a very old wallet, created by the first version of bitcoin. Recently I upgraded to a modern version. However, the wallet has no pool entries. I thought the upgrade would create 100 keypool entries? Here's where grondilu describes his scripts to sign arbitrary data with wallet keys using openssl. Very impressive.http://bitcointalk.org/index.php?topic=2694.msg39658#msg39658 See also the program referenced in post 15 of this thread:http://bitcointalk.org/index.php?topic=2507.0;allI think grondilu has some code samples showing how to sign with these openssl keys. I don't think it works that way. The banker can't get a shoe shine with the new money, because it does not belong to him. It belongs to the bank. And what the bank does with the new money is lend it out. Now, when you connect to the port, the client spews out a version message, which reveals its identity. With the shy patch, there's no response. It could be ssh, could be torrent, could be bitcoin, could be http, could be anything. The scanner would have to try to send crafted packets for each of dozens or hundreds of known protocols, to try to elicit a response.Of course while we're all on 8333, it's pretty obvious what's what. But presumably that will change eventually. Maybe we should fix this duplicate-transaction problem. We could embed the block number in the generation transaction so they would all be unique. Right now the txin has hash = all zeroes, n = UINT_MAX. We could change to n = block number and still identify it as coinbase by the zero hash.
Meant to add, seems to work ok with other clients, I've got 30+ connections. It did turn my dot red on the bitcoin world map, I guess that scanner relies on noisy nodes. I made a patch to make the client "shy". On incoming connections, it won't send a version message until it receives one. This can help make port scanning identification harder.Code:diff --git a/main.cpp b/main.cppindex b7dfd9f..cb4fad6 100644--- a/main.cpp+++ b/main.cpp@@ -2290,6 +2290,10 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)             return true;         } +        // Be shy and don't send version until we hear+        if (pfrom->fInbound)+            pfrom->PushVersion();+         pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);          AddTimeData(pfrom->addr.ip, nTime);diff --git a/net.h b/net.hindex f070816..12e415b 100644--- a/net.h+++ b/net.h@@ -571,14 +571,9 @@ public:         fGetAddr = false;         vfSubscribe.assign(256, false); -        // Push a version message-        /// when NTP implemented, change to just nTime = GetAdjustedTime()-        int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());-        CAddress addrYou = (fUseProxy ? CAddress("0.0.0.0") : addr);-        CAddress addrMe = (fUseProxy ? CAddress("0.0.0.0") : addrLocalHost);-        RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));-        PushMessage("version", VERSION, nLocalServices, nTime, addrYou, addrMe,-                    nLocalHostNonce, string(pszSubVer), nBestHeight);+        // Be shy and don't send version until we hear+        if (!fInbound)+            PushVersion();     }      ~CNode()@@ -735,6 +730,19 @@ public:   +    void PushVersion()+    {+        /// when NTP implemented, change to just nTime = GetAdjustedTime()+        int64 nTime = (fInbound ? GetAdjustedTime() : GetTime());+        CAddress addrYou = (fUseProxy ? CAddress("0.0.0.0") : addr);+        CAddress addrMe = (fUseProxy ? CAddress("0.0.0.0") : addrLocalHost);+        RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));+        PushMessage("version", VERSION, nLocalServices, nTime, addrYou, addrMe,+                nLocalHostNonce, string(pszSubVer), nBestHeight);+    }+++      void PushMessage(const char* pszCommand)     {I noticed that the variable nLocalHostNonce is being used to detect connecting to ourself. But I'm not sure it is working, because we will (re-)randomize nLocalHostNonce on incoming connection before we compare with incoming version message. So even if we are connecting to ourself, nLocalHostNonce won't match. The shy patch should fix this. Satoshi once suggested that people could hack their client to generate and discard a bunch of random addresses until you got one that started with your initials or even your name if it was short. Well, I guess it would have to skip the forbidden letters like 'l'.Signed, Ha. Oh I see, the terminal would just look back at the most recent payment to this address, which would usually be the "change" from the previous payment, and use that as the source transaction. Ye, that should work I think. I really like the style. The intro is funny and ironic, as though you have to explain this thing called money and why you might want some. The reader is in on the joke, and this invites him in and makes him receptive. I wouldn't change the informal tone.I can't judge the second part because I know Bitcoin too well. You need feedback from people who've never heard of it. The EMH says that market prices are approximately "correct" and you can't expect large gains. Yet many Bitcoiners expect large increases in the price of bitcoins. Is the EMH failing in the Bitcoin market, giving us a true free lunch? Or are Bitcoin investors deluding themselves by not recognizing the likelihood of loss? I think it will work to give change to the paying Bitcoin address. The client avoids this for privacy reasons - it tries to hide which output is payment and which is change. But it should work.Oh, wait, you want to feed the change back into the card, don't you? That's trickier, because Bitcoin payments must reference the hash of the source transaction. What you need to do is store on the card the original source transaction hash (that funded the address on the card). Then when you make a payment, the terminal uses this for the txin, and creates a tx that gives change back to your address. It computes the hash of this new transaction and writes it back to the card. This will then be used as the txin for the next payment.Does anyone know a smart card that supports ECDSA signatures? It's possible to do purely P2P poker using cryptography to shuffle the cards. The problem is that either all n players have to cooperate to decrypt a card, in which case if any player leaves the hand can't be completed; or t < n players suffice to decrypt a card, in which case any t players could collude to learn other players' cards. But it could work for a friendly game. A sign of getting old: Even though it's been almost ten years now, I still can't hear the phrase "Homeland Security" without feeling that I am reading a dystopian science fiction novel. Your name (in the paper) is Nakamoto? Are you any relation to Satoshi? This would be a centralized system anyway. It's basically equivalent to a bank issuing digital money in the form of PK signatures, but because it's quantum it's theoretically more secure. You'd still be trusting the bank/mint not to cheat or inflate. No, I didn't have anything to do with that story, I've been assuming the author was Eliezer Yudkowsky, founder of LW. I've been reading it too, very entertaining. Kiba, I'll bet you'd enjoy it. http://lesswrong.com/lw/1ab/dying_outside/That's my story. Travel is very difficult for me now. I read it off and on, and I've met several of the people involved. Yet another way to Change the World. Wei Dai is active there sometimes, one of the godfathers of Bitcoin. No, it seems I spent it in November, too bad. Of course the client doesn't let us pick which coins to pay with.  I didn't know it was the first transaction until today. This was actually a test payment Satoshi sent to me during debugging. I see in my email logs I offered to send it back but it seems I didn't.    It was an IP-address based payment. By the time an accusation of fraud could be credibly verified, likely there would have been plenty of time for the funds to be thoroughly laundered. Criminals would be well aware of the need to clean hot bitcoins quickly. That's interesting, I was just wondering about that the other day, what is the highest balance for a Bitcoin address? 90,000 bitcoins, that's amazing. Since we're all rich with bitcoins, or we will be once they're worth a million dollars like everyone expects, we ought to put some of this unearned wealth to good use. What better than to send our benefactor Satoshi to the Financial Cryptography conference.http://ifca.ai/fc11/FC is traditionally held at luxurious island resorts, and this year is no exception. Satoshi could meet the movers and shakers of the financial and cryptographic worlds while enjoying the beautiful beaches of St. Lucia. Unfortunately it is too late for him to speak, but given Bitcoin's enormous growth and potential, no doubt he would make many valuable connections. Indeed it may well turn out that Bitcoin becomes the single most successful example of Financial Cryptography.FC does tend to be expensive. We appear to have missed the cutoff for cheap rooms. We probably need to budget $300 a night or about $1500. Add ~$500 for registration, maybe $2000 for travel, and we're talking about $4K or so. If 40 people chipped in $100 we'd be golden.This is our chance to give something back to the creator of this fantastic new form of money, or currency, or payment system, or whatever. All we need is Satoshi's agreement and we can get started. I finally got around to building my own client from source (on Ubuntu) and the first thing I did was to add sound effects. I now hear a little pop whenever there's a transaction, and a chime when there's a new block.It was easy, here's the diff for main.cpp, just 3 lines:Code:diff --git a/main.cpp b/main.cppindex b7dfd9f..1196520 100644--- a/main.cpp+++ b/main.cpp@@ -4,6 +4,7 @@  #include "headers.h" #include "cryptopp/sha.h"+#include "wx/sound.h"   @@ -2575,6 +2576,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)      else if (strCommand == "tx")     {+wxSound::Play("snd_tx.wav");         vector<uint256> vWorkQueue;         CDataStream vMsg(vRecv);         CTransaction tx;@@ -2628,6 +2630,7 @@ bool ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)      else if (strCommand == "block")     {+wxSound::Play("snd_blk.wav");         CBlock block;         vRecv >> block;For snd_tx.wav I used http://www.series-of-articles.com/sfx/snd/pop.wav; for snd_blk.wav I used http://www.series-of-articles.com/sfx/snd/bell.wav.A quick hack, but entertaining and informative.
I find it distracting to see the # confirmations for each transaction. Do I really need to know that there are 20,132 confirmations to a transaction? And, oh look, it just went up to 20,133. Anything beyond a few dozen is overkill IMO. I propose that beyond a certain number, say 100, we just display it as confirmed.Even more useful would be to display the date by old transactions. That would help me remember what they were. The danger is if people are buying bitcoins in the expectation that the price will go up, and the resulting increased demand is what is driving the price up. That is the definition of a BUBBLE, and as we all know, bubbles burst. Did you build this yourself from source? The "old-school cypherpunk" is Perry Metzger, who is (still) the moderator of the Cryptography mailing list, where Satoshi first announced Bitcoin. Would it work, on a new machine with no wallet, to create the .bitcoin directory, with wallet.dat a symlink to an empty file on your 5MB volume? Then when you launch the client for the first time, would it create the wallet on the encrypted volume? Or would it just overwrite the symlink file with wallet data? It's pretty strange really that we all see a good chance that bitcoins will hit a dollar in the relatively near future. How many investments can be expected to triple in value in that time frame? Is gold going to be $3500 any time soon? Apple stock going to triple? Maybe Facebook, if you could get some. That seems like a pretty sure thing.We are really lucky to be in at the beginning of a possibly explosive new phenomenon. Considering the odds against most money-tripling investments, Bitcoin looks like a good place for a percentage of your portfolio. If the private keys in the wallet were encrypted, then the virus couldn't get them until you entered your password to make a payment. This might give you a chance to discover and eliminate the virus before it can do harm. Maybe try puttingreturn false;as the first line of Detect128BitSSE2(), see if that fixes it. If so, and you're really energetic, move the return down to just before, then just after the memcpy, to confirm that's where the problem is. How much for an ounce of unobtanium? Bitcoin uses elliptic curve cryptography for its keys and signatures, but the specific curve used is pretty unusual. It is called secp256k1, from a standard called SEC2, published by a group called SECG, http://www.secg.org/index.php?action=secg,docs_secg.Taking the name secp256k1 apart, sec comes from the standard, p means that the curve coordinates are a prime field, 256 means the prime is 256 bits long, k means it is a variant on a so-called Koblitz curve, and 1 means it is the first (and only) curve of that type in the standard. This is all fine and common, except for the Koblitz part. Koblitz curves are a special kind of elliptic curves that have some internal structure that can be used to speed up calculations. Standards bodies have tended to shy away from Koblitz curves out of fear that this internal structure could someday be exploited to yield a new attack. Indeed certain Koblitz curves, but not secp256k1, lose a couple dozen bits of security to a known attack.Most standards use what are called random curves when they are using prime fields. SEC2 also includes random curves, and the very next one after secp256k1 is called secp256r1. This curve, secp256r1, is widely standardized and used, including by the U.S. government, which calls it P-256.I don't know the rationale behind using secp256k1. It has the potential for speed - I've seen estimates from 33% to 50% speedup - but the techniques are quite esoteric as it is not a conventional Koblitz curve, and I doubt that the OpenSSL implementation exploits this. I'm not losing much sleep over the theoretical possibility of an attack on secp256k1, but it is likely to be less widely implemented. I looked at BouncyCastle, a widely used Java crypto library, and they had commented out the code for secp256k1. Whereas secp256r1 (P-256) might well be a default curve for the native crypto keys in future OS's.It wouldn't be a change to make lightly, but we might want to consider changing to this more widely used standard curve. We'd have to mark the new keys to distinguish them, and be prepared to handle both kinds of signatures.One question is whether we would ever reach a point where clients could eliminate support for the old curve? Maybe just miners could retain support, and the fact that a transaction got into a block with some confirmations would be good enough evidence that it was valid. Why would it ever stop mining for coins? Interestingly, the dollar sign originated with two vertical bars rather than one, according to several theories.http://en.wikipedia.org/wiki/Dollar_signhttp://en.wikipedia.org/wiki/CifrãoAlso, supposedly Unicode allows the character to be rendered either with one line or two, entirely depending on the taste of the font designer. Let me unpack this idea into parts.1. Sharing your compute power in a massively parallel effort that has some value.2. Doing this specifically with GPU.3. Getting paid for it.4. Getting paid specifically with bitcoins.#1 is widely done, eg Folding@Home to improve biological models. There are a ton of these. For #2, I imagine that some do use GPUs, as people are very competitive. #3 is hard. If you're getting paid, someone is paying, so we are mostly looking at commercial applications. But these tend to be sensitive or secret, not suitable for wide sharing. For example, an obvious application would be rendering graphics for a new movie. But the producers wouldn't want their scenes to be leaked.To solve these problems and then focus only on people who want to receive bitcoins would be doubly difficult. According to Gavin's https://github.com/gavinandresen/bitcointools/blob/master/NOTES.txt, serialization of any vector object gets preceded by a count of the number of elements in the vector, in the variable-length 1/3/5/9 byte format. I added this count field to the new wiki, e.g. to addr messages. Also, block messages contain a vector of their transactions, so that part is also preceded by a variable-length count. In addition to documenting the on-the-wire protocol, I think we should document the rules a peer should follow. Some rules are for behaving cooperatively, such as participating in the flood-based broadcasting. Others are for using the network safely, how and when to validate incoming blocks and other data. I think you have some of this in the original wiki page RHorning, but I'm not sure it has all propagated to the new wiki. The creation of the site was described here: http://bitcointalk.org/index.php?topic=854.0;all As long as OpenSSL outputs keys in this format, it will work. I doubt they'd change it due to compatibility. That's very generous, but I don't feel right taking the bounty for 5 minute's work. I'll send back the 50. Is that address in the top post yours?btc=1Hy9dexzNzjvQYkYy6zKRVZMU8k2j5vuPt Try doing tail -c 65 after the base64 -d. Your pubkey has ASN.1 cruft. According to https://en.bitcoin.it/wiki/Mining_Hardware_Comparison, the 5770 draws about 100W and generates 150 Mhash/s. According to http://www.alloscomp.com/bitcoin/calculator.php, this should generate a block every 5 days. 5 days is 120 hours, times 100W is 12 kWh. Around here it's $0.20 per kWh, so that's about $2.50 per block for electricity. A block of 50 bitcoins is worth about $15 now, less $2.50 is $12.50 profit. The $99 card will be paid off after 8 blocks, so that's about 40 days at current difficulty. After that it's pure profit.Most people assume difficulty will continue to rise, but I think it will level off soon, because except for unusual deals like this one, GPU mining is close to becoming unprofitable.
Paypal tells me that the way to get verified is to link my bank account. How would I use a VCC number to get verified? I already have a CC linked. I came up with an even more extravagant estimate of $10 million a couple years ago on the cryptography list:http://www.mail-archive.com/cryptography@metzdowd.com/msg10152.htmlI compared the stock of bitcoins to total worldwide wealth, rather than GWP, which is the amount produced in one year. What I meant about purchases taking longer would be in the range of several hundred to several thousand dollars. Today you can go into Best Buy and get a new TV for $1000, put it on your VISA and walk out. For a Bitcoin transaction in this range, the seller would probably want to wait for 2 or 3 confirmations to be safe against double spending, which would take 20-30 minutes. That's pretty inconvenient. Doesn't the client check with multiple connected peers to make sure it has the latest block? Maybe there could be a window that displays all connected peers and the latest info from each. Then you could check that they all agree about chain length, etc. Actually there is a very good reason for Bitcoin-backed banks to exist, issuing their own digital cash currency, redeemable for bitcoins. Bitcoin itself cannot scale to have every single financial transaction in the world be broadcast to everyone and included in the block chain. There needs to be a secondary level of payment systems which is lighter weight and more efficient. Likewise, the time needed for Bitcoin transactions to finalize will be impractical for medium to large value purchases.Bitcoin backed banks will solve these problems. They can work like banks did before nationalization of currency. Different banks can have different policies, some more aggressive, some more conservative. Some would be fractional reserve while others may be 100% Bitcoin backed. Interest rates may vary. Cash from some banks may trade at a discount to that from others.George Selgin has worked out the theory of competitive free banking in detail, and he argues that such a system would be stable, inflation resistant and self-regulating.I believe this will be the ultimate fate of Bitcoin, to be the "high-powered money" that serves as a reserve currency for banks that issue their own digital cash. Most Bitcoin transactions will occur between banks, to settle net transfers. Bitcoin transactions by private individuals will be as rare as... well, as Bitcoin based purchases are today. Thanks! I'm enjoying the countdown to 100,000. Looks like it might not happen until the 29th, but it'll be soon. Actually you can't go to prison for not paying your taxes (in the US at least). There are no longer debtors' prisons. You can go to prison for not filing accurate tax forms, but not for failing to pay. The IRS may take away your income and possessions, you may be forced out on the street, but you will not go to prison. Well there wasn't much interest in the bet, that's fine. Looks like Christmas was a little optimistic anyway. By my calculations, at current rates block 100,000 should show up in about 6 days, 2 1/2 hours, or about 10:30 PM UT on Dec 28. That's what EFF did for accepting donations. See http://www.eff.org/helpout, about 12-15 lines down the page. I see Bitcoin as ultimately becoming a reserve currency for banks, playing much the same role as gold did in the early days of banking. Banks could issue digital cash with greater anonymity and lighter weight, more efficient transactions. Instead of a file as input, use the hash of a domain name, and you have a quick-n-dirty system for claiming ownership permanently (the name belongs to the key making the payment). Then as suggested in the BitDNS thread, use any common DHT implementation to broadcast the signed DNS records. Would it be that hard for external miners to do the extra compare, and only return solutions that actually work? I hate to see too many special-case switches. I'd predict that difficulty will stop rising once it becomes impossible to mine at a profit. Based on ribuck's figures, we're pretty much there if you account for GPU prices, and maybe a factor of 4 away even for people who only count electricity (because they use their cards for gaming etc). So unless the price of bitcoins rises, I expect difficulty to start leveling off soon. I got sued back in the 90s over some messages sent via an anonymous remailer I ran. The EFF was an enormous help, found me a lawyer who worked pro bono. I really owe them. "To implement this simply requires adding one new field to each transaction, the 'name' (or hash) of the 'stock' being transferred."In the case of DNS this still leaves the problem of discovering where in the world are your DNS records hosted. I think you need one more piece of data, the IP addresses of your authoritative DNS name servers.I'm unclear on who gets to register new names in your scheme, how much they have to pay, and who receives thevpayment. Also, are name registrations permanent and forever? "1.c.   Codified verification that can rigorously check if a transaction is valid or not for that particular template."Would this be codified by an extended scripting language, or by hard-coded logic in the client? I think it has to be a scripting language, otherwise it will be too hard to get agreement to add new templates. We would need to create scripting extensions to allow a wide range of new applications. For BitDNS we would need the ability to look back in the block chain and check if a given name has been registered before."3.   Every transaction must still comply with the existing enforced network rules. Such as no, double spending."With the kinds of scripting extensions I anticipate, we could actually replace all these implicit, hard-coded Bitcoin rules with explicit scripted tests. The same kind of script that could test that a new BitDNS name had not been registered before, could be used to test that a Bitcoin transaction wasn't a double-spend.There might be some  template applications where the double-spending rules don't make sense. Some of the BitDNS proposals don't do true Bitcoin transactions at all, they piggyback extra data on top of a dummy Bitcoin transaction where you just pay yourself. It would be nice to remove this unnecessary part.In this view, the core logic of Bitcoin would check that blocks had the required difficulty, were properly formatted, and that their scripts all return true. Everything else would be done by application-specific layers. I wonder if it would work to put a (possibly salted?) hash of the name into the block rather than the name itself? Then it would not be obvious what name is being registered, but you could still lookup registrations by name. This would not be perfectly secure, short names could be found from hashes by brute force, but it would make front-running much harder. I thought of a possible problem with all these proposals: front-running by miners. This is where a miner sees an attempt to register a name, thinks it is a good name, and registers it for himself instead. Since domain registration fees are based on the value of average names, extra-good names wouldn't be covered by the fees and might be stolen in this way. Some existing registrars have been accused of a similar practice, registering names through agents after people query for name availability. Seems like everyone's tugging in a different direction. Here are some of the specific issues:1. Bitcoin main chain vs start a new chain, with DCCs ("DomainChain coins").2. Permanent name registration vs renewal necessary.3. Support for an unlimited family of applications vs just focus on DNS.4. DNS "gateway" servers setting minimum transaction fees vs burning a DCC to register a domain.5. Include in the block chain, in addition to domain name: just ownership public key, vs ownership public key plus authoritative DNS server IP addresses, vs arbitrary DNS records.6. Single TLD .web or .p2p, etc., vs "advisory" TLDs which may be ignored, versus all TLDs being allowed in names.Any other issues/design choices which can be factored out? As a relative newbie to the code, I do find your version easier to read. It's easier to find the implementations of functions since most are class members and are now in named .cpp files. It's also nice to have the full class implementation in one place rather than having to flip back and forth between .h and .cpp files.However that is for reading, and the needs of developers may be somewhat different. Obviously Satoshi knows the current layout intimately, and as the main developer it is up to him to see whether he could work with the new layout.One concern I'd have with losing the inlinable .h functions is whether it could slow down either initial block load/verify/indexing, or mining (a bit moot with gpu miners these days). 
Actually one of the criteria for SHA-3 is speed, which is not particularly important for Bitcoin. We might consider using a different approach.http://en.wikipedia.org/wiki/Provably_secure_cryptographic_hash_functionThese hash functions are slow but have a degree of provable security.There have also been various proposals for proof of work (POW) systems, including some that were designed to resist hardware optimization. Perhaps this could produce "fairer" generation where graphics cards and specialized hardware wouldn't have such an advantage. (However people with access to large networks of computers might dominate then.) I'd like to hear some specific criticisms of the code. To me it looks like an impressive job, although I'd wish for more comments. Now I've mostly studied the init, main, script and a bit of net modules. This is some powerful machinery. ... is an ATI Radeon HD 5970...Anyone else putting graphics cards on their Christmas lists for some serious mining?Actually the 5970 is a little pricey, newegg.com has it from $500 to $1200 dollars. But even lower end cards should be able to generate a few blocks a month hopefully.Somewhere I got the idea that the number of "stream processors" would be proportional to hashes/sec. Probably clock rate would be proportional too. So I've gone through and divided # stream processors by price to get a "bang for the buck" measure. The 5970 has 3200 stream processors so the $500 card would have 6.4 processors per dollar. Actually most of the Radeon cards are in the 5-7 ratio so for the most part you get what you pay for.The best ratio I found was for an HD5850 which has 1440 stream processors for as little as $200. That gives it a ratio of 7.2 and the price is closer to my budget. This has been reported at http://bitcointalk.org/index.php?topic=1628.msg24699#msg24699 to get as much as 300 Mhash/sec. At current difficulty the calculator predicts a block every two days.With bitcoins at about $0.20, a block of 50 is worth $10, so after 40 days the card would be paid for. That may be a little optimistic (especially if everyone gets 5850s for Christmas) but at least it would be fun to be generating blocks. I like the suggestion, hadn't heard it before. I'm trying to follow it now. I though it was funny that calling this an RFC is kind of a play on words. RFC means Request For Comments, and in this case you're requesting that comments be added to transactions. So it's a request for comments in both senses. OK so if there are going to be bitdnscoins (aka DCCs, DomainChain Coins) then they have to be useful for something. Otherwise every BitDNS miner is going to fill every block with his own domain name registrations, rather than replace one with someone else's registration in exchange for a transaction fee in a useless currency.The rules have to be that you have to spend a certain amount of bitdnscoins/DCCs in order to register your names and/or do other BitDNS transactions. That's the only way to make this alternative currency desirable and valuable.(Well we could do like Bitcoin and say there would only ever be 22 million DCCs ever created, so they'd get valuable from scarcity just like bitcoins. But that seems weak.) Satoshi, are you endorsing the idea that additional block chains would each create their own flavor of coins, which would trade with bitcoins on exchanges? These chain-specific coins would be used to reward miners on those chains, and to purchase some kinds of rights or privileges within the domain of that chain? I agree with ribuck that DNS servers don't necessarily need to get paid, to support Bitcoin domains. After all, what is the purpose of a DNS server? It is to lookup domains for its clients, which are users wanting to connect to computers using domain names. If BitDNS becomes popular, DNS servers will want to be able to lookup those domains too. All that is necessary is to track the block chain and maintain indexes and hash tables to record which domains are in effect and their basic DNS data. DNS servers don't have to be Bitcoin miners. The existing motivations for DNS servers to operate and provide lookup serves to their clients will be sufficient to make them track Bitcoin domains. A few more questions about http://privwiki.dreamhosters.com/wiki/Bitcoin_DNS_System_ProposalIt appears this can support several top level domains, such as .anon, .sex, .p2p, or whatever. Other proposals envisioned a single new TLD like .bitdns.Names can be changed when registered, but only from one TLD to another. You could change pics.sex to pics.p2p. I don't understand the motivation for this. It seems like something that would seldom be useful.I'm still confused about fees. I was assuming that fees would be paid to the DNS servers, for the service of acting as a gateway from the Bitcoin block chain to the DNS system. I now see another interpretation, where DNS servers don't receive the fees, but they nevertheless demand that transaction fees of a certain minimum level be paid to miners. As long as they see that the domain name was registered with a large enough transaction fee to the miner, they will pass it through to the DNS. Is it possible that this is what was intended?The proposal seems to envision a relatively small set of DNS servers that would be authorities for these new domain names and be the ones who bring the names from the block chain into DNS. These would be somewhat analogous to registrars today. (I may be misunderstanding this!) Each of these DNS servers publishes a schedule of fees for performing this service. To register a new name... hmm, I am guessing now. Would you contract with one particular DNS server to do something else than host your regular DNS records?I had thought it would be ok to expect DNS servers to follow the block chain and honor valid domain name transactions without requiring certain minimum fees. Domain names are so valuable (at least at first) that miners already have ample motivation to demand substantial (like $100 = 500 Bitcoins per transaction) fees. Eventually, if the system is successful, virtually all DNS servers would read the block chain. jgarzik makes a good argument that the complexity of the scripting system is not being used and is unnecessary. Simple in/out transactions are all that are needed. I'm not convinced that there is anything that can be done with Bitcoin scripting that can't be done with a crypto layer on top of Bitcoin to share/split keys, etc.Anyway fancy scripts won't be able to be used until everyone upgrades their clients, after this last change. All the future-proofing that the scripting was meant to enable is lost. So there's even less reason to keep it. What if the consensus is that the Bitcoin network should not be used to support DNS (as I expect)? Then the only alternative is to go forward with a parallel but independent block chain, creating a second currency. Are we ok with that?I have a couple questions about http://privwiki.dreamhosters.com/wiki/Bitcoin_DNS_System_ProposalWhen you register a name, there is a fee to a DNS server. In the doc, this appears like a Bitcoin transaction fee. The first example shows 10.01 input and 0.01 output, so the 10.00 difference would be a transaction fee. But tx fees go to miners. Is it assumed that miners are the same as DNS servers? Or would there be a 2nd output, a fee to a particular DNS server to get it to register you, in addition to a tx fee to the miner?Are you allowing name changes of the main part of the domain? Like elephantfood.bitdns can change to dogfood.bitdns (if it is available)? Or is this disallowed, in which case, exactly which kinds of name changes are allowed?Would anyone who wants be able to run one of these special DNS servers, or do you envision there being relatively few of these?Thanks - We're at block 96,000+ now and block 100,000 is in sight. At current rates it should show up by Christmas, depending on how much computing power increases by then.Anybody up for a pool betting on when block 100,000 will appear? Say 1 Bitcoin per person? Post your guess here (UTC only) and commit to paying 1 btc to whomever's closest. Let's close the guessing after block 98000 so late guessers don't have too much advantage.I'll start and pick noon Christmas day, for fun. My concern is that there would be a rush to grab hot domains. I would expect that the first blocks generated with this system will all be maximum size and filled with the equivalent of sex.com. These domain names are worth millions of dollars, if the system succeeds. I suppose transaction fees would be enormous, otherwise miners will just fill blocks with their own registrations. Ordinary transactions would be crowded out, if this were part of Bitcoin. I'm not sure how it would work to only create one coin per block. Would this only buy the creation of one domain name?The reason I like the idea of fractional coins is it would give more flexibility in transaction fees. If it costs one coin to register a domain, it might make sense that a good size for the transaction fee would be fractional. This was on another thread but is relevant here. It is true, the first domain name is likely much more valuable than the millionth. So even if we don't reduce the number of DCC per block, the value will decrease much like Bitcoin does by halving the block reward every two years. That means transaction fees might have to rise substantially over time.Is it worth considering to increase the block creation rate above 6 per hour? If we generate blocks every 5 minutes or even every 2-3 minutes instead of every 10, that would be another way to speed up domain name availability. Good point, I'm going to quote this in the BitDNS thread, hope you don't mind. There exists a cryptographic technique called split keys which could be used on top of Bitcoin to solve some problems in needing to trust people to make Bitcoin transfers. The idea is for the payor and payee to jointly generate a Bitcoin address that will receive the payment. Bitcoin addresses are essentially public keys, and knowledge of the corresponding private keys are what let you spend the coins. In this case, though, a public key is jointly generated between the payor and payee, such that each only ends up with, in effect, half the private key. Neither party will be able to spend coins sent to the address corresponding to this split key.The payor then makes a payment of the agreed amount to this special address. Once this is done, the payor has lost the Bitcoins. He can't spend them anymore; they belong to this new address which is split between the two of them. The payee can't spend the coins either, at this point.To complete the transfer, the second step is for the payor to reveal his part of the private key to the payee. Then the payee knows the full private key, which gives him control of the address that received the payment. They are now his Bitcoins to spend as he likes.The advantage of splitting up the payment into two steps like this is that the first step, where the payor makes a payment to the split key, represents a very strong commitment on his part to see the deal through. After that step, typically the payee must hold up his end of the bargain and perform some action he is being paid for. Once that is completed, the second step of the transfer occurs and the payee receives his payment.Throughout, no one has any financial incentive to cheat. The first step does not benefit the payee, and the only way he gets paid is to perform. And the second step does not harm the payor; he is out the coins already and gains no benefit from failing to follow through.It is analogous to tearing a $100 bill in half and giving half to someone, with a promise to deliver the other half if he cooperates. This is a credible commitment and a strong inducement. You have no financial incentive to cheat him if he holds up his end. Actually I am concerned that transactions between BTC and DCC may not be simple. Because both currencies tend to be anonymous, it is hard to make the two transfers in a coordinated way. If Anne wants to sell Beth 1 DCC (allowing 1 domain to be created) for a certain number of Bitcoins, then Beth must send Anne the Bitcoins via the Bitcoin block chain, while Anne sends Beth the DCC on the DomainChain. If the two are anonymous to each other, it seems there must be a trusted third party like a reputable exchange. It seems hard to do peer to peer. On the question of how many domain names to create per day:http://www.domaintools.com/internet-statistics/There are about 100 million active domain names, and 400 million expired ones. About 300,000 changes occur per day, divided equally between creation, expiration, and transfers.If we create only 50 domains per block, 6 blocks per hour, that is 7200 domain names per day. At that rate it would take like 50 years to create 100 million domains. So it seems necessary to make names faster. I also had an idea last night of how/where to tie this into the existing DNS.When you lookup foo.com, software on your computer called a resolver is responsible. It has some caching and local data, but mostly it just asks a DNS server for the answer. You have one or more DNS servers configured as part of your network setup, and these servers respond to domain name lookup queries either directly, or by initiating their own search of the domain name system.Obviously we want existing name lookups still to work. Broadly speaking, then, we would change the software to first check if a name is registered in the BitDNS system, and if not, to fall back to the regular handling.My idea is that the best place to add the BitDNS lookup code is in a DNS server rather than in the resolver. Resolvers are different for every OS, so there's more work. I don't even know if the resolver logic can be changed on Windows. Plus this code is going to need to be tracking the BitDNS block chain, and not every end user should have to do this.Other 'alternative' DNS systems do it like this, with one or more special DNS servers that know about their extra domains.We would choose some open source DNS server as a base, fork it and add the code to lookup BitDNS names. Whether these names all have a distinguishing TLD ".bit" or whether we are more aggressive and take over more namespace, either way it could be done.As I understand it, when a DNS server looks up foo.com, it finds the (or a) name server authoritative for .com, and asks it for what is called a SOA record for foo.com. This tells what name servers are authoritative for foo.com, and the DNS server then tries them to get details on foo.com.We would intercept this first step, and use the BitDNS code to find the authoritative name servers. Maybe we could create a dummy SOA record to hold the data, to simplify falling back into the regular DNS code.People who want to use BitDNS would just have to select one of the BitDNS aware DNS servers. Paranoids could run their own name servers locally and track the block chain. All the usual optimizations of DNS in terms of caching, distribution, etc. would work, so it would not have much negative impact on the net.
