Would be kind of overkill to create a full lightning implementation just for testing :-) Yes, `addfunds` was recently removed and we now rely on tracking the blockchain to tell us about incoming funds. Lucky I was pointed here by someone who saw your message, I only occasionally check bitcointalk. Bug reports and help should go to the github, mailing list or IRC channel, to ensure we see them :-)Thanks for confirming that the patch worked ^^Are you trying to connect the daemon to itself? Not sure why you'd do that, and pretty sure we close self-connections, try connecting to some other node on the network (https://explorer.acinq.co/ for (id, ip, port)-tuples) Hey mocacinno, thanks for giving c-lightning a shot. The value mismatch is actually important, no one has ever tried to give that many funds to a lightning wallet so far, and indeed you stumbled over a bug when reading back the funds from the DB. It is fixed in a PR and should be merged soon, at which point the true value of the output will show up :-)As for the disconnection I don't really know. Are you trying to connect to yourself? `connect <myid> <myip> 9735` seems to suggest that. We just published some results about the use transaction malleability in the Bitcoin network with a special focus on MtGox:The complete results are here: http://bit.ly/1rCqKED Single theft, two claims because 2 transactions were made. By the way the two lists of victim and thief should somehow be separated, as there can be multiple on either side.Code:2012-09-28 8,872 https://bitcointalk.org/index.php?topic=113775.01PwikEnt89thgsMVydpG9uAT1QKyoBLMjZ1JLqF8kZ2w1Pv4ThX9YpxP3kvFsTyrxwXM1U1jTCGkQYRaDVStZdDHMFWUMoSJi4HSc1MQKhQhiRcJfv1X2G7ywgX1oWdVocqvQEw1PHQKAGYKxDRxdpPL6fWNUwWQxEHGA5oxSCode:2012-09-28 350 https://bitcointalk.org/index.php?topic=113775.01PHQKAGYKxDRxdpPL6fWNUwWQxEHGA5oxS1Q2YUKhDNGzFxtqLUGjozgcc1ALpfSer6i1U1jTCGkQYRaDVStZdDHMFWUMoSJi4HSc Yup, MtGox is managed bby Tibanne Co. Ltd. http://www.pyramining.com/referral/fy4q32c8g   2013-03-02 12:06:46 UTC   still activehttp://www.pyramining.com/referral/khc29gnq4   2013-03-02 12:06:46 UTC   still active r4gCHB6hEggLdGpsoB9oSWstPmALMgAv1X Still trying to figure that one out myself, will have more in a couple of days I guess. Yup, just here to clean up misunderstandings: we are not mining, we are just doing some research on the network itself.The reason we show up so often is that in order to do our measurements we are highly connected, and while we're at it we facilitate the information flow on the network by relaying information. Did I miss a rant about my person? @vuce: yes, those semester-theses are just for ETH Students, but I see more and more Universities picking up the Topic and maybe your in luck and yours is open to new ideas.More theses will be made available, and I'm always open for new ideas. Thanks mate, will add this to my gathered data for the police :-)He has since then disappeared (reconnect?) Thanks caffeinewriter, any help is appreciated. I will file a report on Monday, and see what they say.As for the cleaning up I think I'm OK. Just running clamscan over all the files, rkhunter had nothing to complain, but I don't know whether an eventual rootkit wouldn't be smart enough to fool them, any experience about that? I don't understand it either, apparently they got first into my home machine (with password auth enabled), grabbed the private key for my work machine and logged in there. No idea as to how. Well I'm not a security researcher, I'm researching Distributed Computing. And yes the errors were stupid. Still reconstructing everything that happened, but it seems that broadband-178-140-220-181.nationalcablenetworks.ru [178.140.220.181] was able to log into my machine:Same happened a few minutes later on my machine at home (my bash history must have told him were to find it), and from there he must have been able to find my wallet backup (which is really old, but was kept unencrypted, so any key that was in there is compromised).I'll write everything down and file a report, we'll see how open to technology the swiss police are  Could you show me the post, if it's a problem on my side I'll fix it. Nevermind the other Thread, as I already explained it's part of my research, I myself am 82.130.102.160, and yes we developed BitThief, so that's not it.I think showing up on blockchain.info actually put a huge target on my back. I see a few connection to my notebook from Russian domains and the big surprise: they are able to log in...They must have somehow gotten my password or [...few minutes later ...]sorry had to kill the network connection, whoever it was they were still logged in on my machine... There are no new flaws from my side, as a researcher it is my ethical duty to inform the developers of anything that I find. Otherwise I'd be unable to publish my research results 
Thanks, it came really by surprise, and there I was believing I was secure... Well it goes to show that understanding something does not protect you from stupid mistakes.Anyway, sorry to have caused such an uproar, I'm just trying to improve the network, but if you still feel the need to block me I'm using the user agent string "/Snoopy:0.1/ETH Zurich/PlanetLab/" Sorry about that mate. The Paper is from another group (System Security) in the University, I'm in Distributed Computing.As far as I can tell we don't have any relevant computational power working on Bitcoin, I'm just relaying the blocks faster than others in the network. Well that shouldn't be too hard, I can sign a message with the private key belonging to one of the addresses. But I don't see that doing any good. I'm not the only one working with such large nodes btw. There seems to be someone from the university of Munich that is doing something similar:http://blockchain.info/blocks/131.159.18.37http://bgp.he.net/ip/131.159.18.37I wonder what they are doing :-) Yep, that much I knew already. Hm? What do you mean?I can't give you the exact details of what I'm doing until it gets published. I can tell you that I participate in the network as any other node does, I'm just a very big node (5'000 connections open), and am thus considered a Hub in Blockchain.info's vocabulary  Well, just to prove that even long time members are not secure from being stupid. My wallet has just been cleared out:http://blockchain.info/tx-index/27883052/6f85951bcecbe64999ad192275af087c5be2922ee13937693992c1ddf9ae8ce6http://blockchain.info/tx-index/27883028/8e6a2d0b8132d3d9edc1fcffe1b3079de59c10c67522e2abc51c1d84b260fdacAt first I thought maybe it's just an old transaction that has only now been submitted, but I can't find any wallet of mine that owns those keys.I had my wallet encrypted, but this was apparently an old backup of my wallet that I must have stored somewhere.Any tips on what to do next? I'm still a bit fuzzy about the details. Can we blacklist those funds somehow? Well I was wondering how long it would take for people to notice. It's me And no I am not putting lots of hashing power to the network, notice that it just says "relayed by" and not "mined by". I'm performing some measurements, paper is due in a few weeks. What exactly is included in the sale? Is it only the domain or does it include the scripts used to scrape the pools and exchanges? Does it say anything else or just a 404 page. I had the same problem but I solved it easily by installing python-rrdtool and restarting the p2pool daemon. No, the client get's bloated for the benefit of a minority that will use specialized software anyway. I'm wondering how you decide when a direction turn is taken. Do you take a fixed length interval and use a weighted average and compare it to the previous low/high? Hi Kai,kannst du bitte den generator abwandeln dass er Bitcoin Standard URIs auspuckt anstatt nur die Adresse?https://en.bitcoin.it/wiki/URI_SchemeIs einfach besser wenn wir den standard von anfang bis ende durchziehen LG,cdecker Google Wallet is good I'd say as it increases the trust in technologies like NFC and electronic payments over the counter. But since it relies on traditional currencies and is completely centralized it leaves room for Bitcoin to evolve. I just hope not too many people will abandon Bitcoin in favor of Google Wallet. The proxy is quite good AFAIK, I have a consistent rejection rate of ~1%, but that's to be expected. Damn, always when I'm out of town. Have fun guys ^^ Same here, funds are at the ready :-) Uh, that's good news, I'd love a Swiss Bank since it allows both SEPA and Swiss Bank withdrawals :-) I proposed structuring as a Skip-list or hypercube, and instead of broadcasting to all I'd love to have a broadcast to prefix only. A hypercube of dynamic degree, multiple nodes at each edge, taking care of a given prefix. Miners would regularly fetch all transactions and include them into blocks. It would reduce broadcasts and scale better.The idea was shot down pretty early with the usual arguments: too hard, breaks too much,...But I still think it should be considered :-) Too bad, I'm a few hours late 
Rofl you actually calculated 25 plus 1 * 1.3/100 So you summed 1.3 hundredth to your 25 instead of summing 101.3 * 25 / 100>>> http://lmgtfy.com/?q=101.3%25+of+25 That's no problem since I have an ATX 24-pin splitter that turns on both PSUs simultaneously. What I'm wondering is whether it creates some sort of power differential having the motherboard on one PSU and a connected Graphicscard on another. Using the molex-modified PCIe x1 cables, and they work so far. Now I'm at the maximum of my PSU and will order a new one. Just a quick question: is it save to power a card on another PSU than the others? I basically have 3 cards already all on 1 PSU, and the fourth will be on PSU #2, and connect its 6/8-pin connector and its molex to this PSU.Could there be a problem or am I on the safe side? Yup, I guess most questions will be about the protocol anyway, so there's no problem there.Is the mailing list moderated? I think that would be usefull (unless we try to repeat the mess of the forum). This is the classical bootstrapping problem of P2P Networks. We are considering to use BitTorrent trackers as an alternative way to bootstrap. Sounds interesting, until you realize that assuming that at difficulty 1 you'd calculate the whole week, and now at difficulty 567358 you'd only be allowed to calculate for 1.066 seconds (http://www.wolframalpha.com/input/?i=1%2F567358+week). There is no way to coordinate this timeslot worldwide Not to speak that all transactions would be confirmed in that small timeslot... 1) the /admin you use the user and pass from your config, while / is for the workers to contact, so there you'd use the miners username and password2) Since you run the proxy on a webserver you'll probably have to point the workers to http://<ip>:80/ HTH,cdecker Great thanks, looking forward to the list.The forum just became too crowded lately, and a lot of FUD around... You host it yourself, if it goes down you're in trouble anyway  Just a quick question: is this just for mainline client dev, or are we alternative developers allowed to ask questions too?  Or you can use the flexible mining proxy (http://forum.bitcoin.org/?topic=5506) to configure more than one pool and it will switch for you. Compatible with most miners  Yup, got scammed by b4rrydoyle (5184) too. It's just 20 BTC but still... Hopefully dwdollar can publish the payout address for those scammers so we can start collecting all addresses they're using and start to track them. Would you be interested in collaboratively creating a PDF in LaTex that would capture both the message format as well as the protocol behavior (something like the Pseudo-code presented in http://amzn.to/mgpDhH )? I had the idea a while back, but I'm under exams for another week. Super, endlich haben wir einen potenziellen konkurenten zu MtGox TH-R1924 Checksumming and the message magic bytes seem redundant, that's what Mike and I where thinking. Probably Satoshi was hunting down a bug in his code and introduced them. I love the magic bytes however since it enabled me to track down a bug in my protocol implementation (non-blocking IO and not yet completely filled read buffers ). A simple CRC should be enough for checksumming, if we want to have checksum at all. On the other side being a non-trusted network, and since any client may bomb you with anything, the checksum is not needed at all  In order not to waste your precious Bitcoins start the client with the -testnet option, that way you'll use a different network, and you'll be able to test between two testnet nodes. Just to limit your losses Could you post the address you are sending to and the address that shows up in the transaction log?The no-cancel is by design, the transaction being broadcast in the network we cannot guarantee that a cancel will reach an eventual block generator that includes it into its block. Changes to message formatting and byte-ordering do have a lasting effect on the hashes that are used throughout the network. So everything that ends up being hashed is set in stone, unless we want to run dualstack for a really long transition period (until the last input from the old protocol has been spent, which probably will never happen due to lost wallets...).Having to adhere to the existing protocol for large parts makes other changes pretty useless, as sad as it sound...What I would like to do is add some structure to the network in order to reduce message complexity (think DHT for transaction inputs instead of everybody tracking everything), detect network partitions and a more hierarchical network topology (miners in the center, lightweight clients at the edge). Yes, 20min is incredibly good at being bad  As the title says, today is IPv6 day, but not for the mainline client.I'm happy to announce that (theoretically) Mike's bitcoinj and my BitDroidNetwork are in fact IPv6 compatible, the only thing that's missing is the IPv6 address format in the addr messages and we're ready to go  I opened (and closed) the pull request, even if I found it quite stupid to create a pull request for a semantic change...Anyway I wanted to freeze the version number in the version message, and only change it when breaking changes are introduced. This way we could create clients that see a version number and say "ok, I speak that too", and then go ahead and communicate with each other. As it is now each new client version potentially brings breaking changes, and we have no way of being sure that the protocols are compatible.I closed the pull request, because it was just plain stupid to have one for 2 added comments, and I thought it best to wait for the topic to come up again.
AFAIK there is no way beyond the rating system to downrank a user, and there is no way to change a rating once it has been submitted. I'll definitely wait a few hours/days before rating from now on. As hard as it is to admit, I have been scammed.I sold 20 Bitcoins by putting up an order and I quickly received a buy offer. The money came in on my Paypal account and I was happy to confirm the trade and leave a positive rating, but as soon as I did so the buyer put a hold on the Paypal payment. It turns out that the e-mail registered with the BitcoinMarket is completely different from the one associated with the Paypal account (though both are from france). And I believe that the scammer used a hacked Paypal account to pay for the Trade.Now I'm a bit in trouble since I don't know what Paypal will do if I try to resolve the claim by providing the trade details of BCM since they don't like Bitcoin at all.I also contacted a guy that had put a negative rating on the guy for the same reason, and he said that he got his BTC back from the scammer.Any ideas on where to proceed?The suspected scammer is b4rrydoyle (5184) on BCM Die Gebuehren ergeben sich aus der groesse der Transaktion und weniger aus der Menge Bitcoins die uebertragen werden. Um den Betrag zusammenzustellen werden Eingaenge referenziert, und je mehr das sind desto groesser wird die transaction. Wenn du also 1'000 x 0.01 Bitcoins zu einer 10 Bitcoin Transaktion zusammenbuendelst wird das teurer als wenn du 2 x 50 Bitcoins zu einer 100 Bitcoin transaction zusammenbuendelst.Es giebt vorschlaege die kleinen Eingaenge im Hintergrund zusammenzufuehren um kleine Eingaenge zu verhindern, aber das is noch alles zukunftsmusik  The TCP delay is not a limit, even if the RTT is huge the transactions might eventually reach the bitcoin network and be accepted there. Mining is a problem, but simply because due to the delay a block from the lower delay network might have superseeded your block. The longer it takes for your block to propagate the lower the chances of it becoming the next effective block.As for the Mars/Moon/Earth exchanges: they do work. Take MtGox for example, there is no longer delay network than sending money via wire transfer xD Genau, der steigende Preis is zwar ein schoener nebeneffekt, aber nicht mehr.Ich hoffe der Preis stabilisiert sich bald mal auf ein plateau. Ehrlich gesagt hatte ich schon gedacht 1BTC=1USD sei eine psychologische schwelle um die man sich stabilisieren kann, aber weit gefehlt. Fuer Haendler sind stabile Waehrungen wichtiger, fuer Spekulanten sind schwankungen von vorteil.Hoffe bloss die spekulanten treiben's ned zu bunt und bauen sich ne blase die dann platzt und das ansonsten geniale Bitcoin System mit sich in die Tiefe reisst. Interesting :-)Will look into it, but so far I'd say that it depends on what part of the network you want to put on top of the delay-tolerant network. The mining part wont work at all since we try to establish a proof-of-work backed quorum on the network state. Similar to the Marscoin discussion a few weeks back it simply does not work if communication delays are high. On the other hand payment processing might work, as long as transactions are propagated to the mining network eventually and back to the originating client for local book keeping. You might want to use http://forum.bitcoin.org/index.php?topic=5506, it's a flexible mining pool proxy that switches to another pool should the first one become unavailable. You can also put it in front of your own bitcoin client  Ach ja die guten alten Zeiten von 100+ BTC/Tag. Waer' schoen wenn man das heute noch machen koennte, allerdings will ich ned die 44 GH/s bezahlen muessen ^^ Das Netzteil sollte ausreichen. Laut https://en.bitcoin.it/wiki/Mining_Hardware_Comparison verbrauchen die 5850 <200W also ~400W fuer beide, da haste noch genug spatzig.Mit 300 MHash/s pro karte hast du laut http://www.alloscomp.com/bitcoin/calculator.php ฿1.39 pro Tag damit bist du bei jetzigen preisen und gleichbleibender  difficulty in 44 Tagen wieder raus. Just seeing now that you have a payout monitor in there, that would be a cool feature, though it adds a lot of problems since some pools don't provide that info and even worse, they don't adhere to a consistent standard for publishing them. Are there plans to piggyback the longpoll update to changed midstates or will we always be needing an external monitor to trigger longpolls? Hm, falls interesse da ist kann ich mal gucken ob ich einen Pool aufgezogen krieg. Con solo 8 temi nella sezione italiana vuoi introdurre 3 sottotemi? Diventa troppo lunga la lista? Just do a Code:java -cp xyz -agentpath:wherever/your/profiler/lib/is com.diablominer.DiabloMiner.DiabloMinerSince classpath can be a pain, and Maven is quite good at handling dependencies just tell mvn to build the cp string:Code:mvn package dependency:build-classpathand it will print the classpath.Edit: intended as general tip, not just for this case  Uh I'd love that, please let me know if you need beta-testers  A new way to fund popular sites? Think Digg and every user contributes as long as he's on the page  +1Teracoin (just kidding, there aren't so many)MegacoinKilocoinBitcoinmillicoinmicrocoinnanocoinKeep it systematic!Although calling the smallest unit a Satoshi would be great too. I can confirm that, so far nothing changed on my account.Hope your account will be returned to you and you don't lose anything. Sounds strange. The switch should occur either upon work request or work submission. The latter isn't very nice because a share might be lost. We are working on exponential backoff to temporarily blacklist flapping pools (intermittent connection issues). Should it occur again please provide a tcpdump (just let tcpdump run along capturing traffic from/to the pool proxy port 80, and use temporary passwords between pool proxy and the workers). MtGox has had some problems with uptime (DDoS) so maybe you could switch to BitcoinCharts?
How would you go about grounding the PSU to the motherboard? Is is enough to mount them in the same (conductive) case? Thanks for the link, I ordered 3 right away :-)Still the ground differential bothers me quite a lot. Anyone ever tested this? Or how are 3-4x 5970 Rigs possible? I'm not much of a hardware guy, so there are quite a few things I don't get about this setup.I ordered a few new Cards and I think they will put me over the limit of my PSU (Corsair 650W) so I think I'll buy another PSU and attempt a dual PSU setup (shown here http://www.burningissues.net/how_to/power/psu.htm).So here are my questions:Is there an online shop where I can buy prebuild splitters like that? I remember I once saw one on eBayThere were a few people bringing up the problem of a power/ground differential should a card be powered from two PSUs. So am I on the safe side if I use modified PCIe risers with Molex and consistently power each Card from one PSU?Is there anything else to consider? Rehashing would be one option to solve the sha-1 vs sha-256 mismatch. Or we could just keep the last 160 bits of the sha-256 hash trunkating the first 0s so the hash would still be recognizable :-) Should I try and create a separate thread to this?  I'm sure I mentioned it elsewhere already but how about just choosing a random hash (genesis block for example) and then using that hash to find peers from a BitTorrent tracker.I'm sure the tracker won't mind, and exchanging IPs is their main business :-) That's probably because you didn't turn off crossfire :-)The CPU is only used to queue new work to the GPUs (not much of work) and check found difficulty 1 blocks (even less). Just make sure you disable crossfire on all cards and you should be fine :-)And yes: I use phoenix for the 5970 and DiabloMiner for the 5850 (because it tends to lock up when running with phoenix, and I prefer stable runtime over high but unstable hashrate). The PSU is ok, you can never have enough power there  I would consider a dual PSU setup maybe to get the price down.The RAM and CPU are completely out of range, you don't need that much, go with the cheapest thing you can find. My Rig with a 5970 and a 5850 uses 1% CPU and 100MB RAM...Also the HD can be replaced by a memory stick if you're trained with Linux ^^ Ah, the good old days I remember when I first sold my first 100 BTC, for a total of 0.61 You just got a PM  Since I often buy cards from eBay and am tempted to buy one of those "defective" cards, is there a possibility of creating a small utility that stress tests the OpenCL capabilities of a card so that I can send it to the seller and let him check if the card is working before buying? I'd be interested in the modified risers. I'm assuming those are the ones with the power lines connected to a molex adapter, right? Great, it works for me too, just had to change the URL in my scripts. I think using such an API to run cronjobs against is more useful than having it crammed into the web interface.Agreed I guess I can drop the stats branch then, since it already works out of the box from your dashboard. On the worker-hashing branch I made the average interval configurable because it strongly depends on the hashing speed (high hashing speeds can get a more accurate reading with shorter intervals, while slow miners will have the average jump wildly around for small values). I think it is ready to be pulled. Once again sorry for all the noise I created in here ^^ cdhowie started implementing a nice proxy that would switch pools should it become unreachable: http://bitcointalk.org/index.php?topic=5506.0;allWe are also working on exponential backoff, so that the pools wouldn't get hammered all the time, until miners start implementing these features themselves this might be an option for serious miners   Being a stats junky I'm working on a simple page that dumps the data in the dashboard to JSON so that I can then write a munin plugin to monitor the status of my miners, I guess we could use that one with a cronjob to kick off custom scripts. It would make it much easier and more flexible since the web server user is usually quite constrained in what he can do ^^BTW: htdocs/index.php@71 is throwing a lot of errors since in getwork requests the lpurl parameter is not set, and since we already check 2 lines below and then set $lpurl again it is redundant and should be removed ^^Edit: My first attempt on a JSON stats dump is here: https://github.com/cdecker/Bitcoin-mining-proxy/commit/82f8ad9e352352cdbe81d84a8939b817204cb59dEdit2: hope you didn't yet look at the stats and the worker-hashing branch because I was missing two GROUP BYs in the shares subquery which resulted in the hashing rate of all miners to be reported on a single miner instead of distinguishing. I fixed it in the branches ^^ That's why we fixed it on our side. Just wanted to let you know... Guess what, it's my fault. The pool I was using was returning immediately if a long poll came with POST, instead of GET. Diablo was the only miner triggering this problem so far. We fixed it on the other side ^^ Works like a charm, and it fixed my 100% problem with Diablo too ^^ Just issued a pull request for the hashing speed and shares in the last hour on the dashboard for each worker. Hope you like it ^^ I'm not really familiar with the framework you're using, so I started by implementing the hash speed for the workers. As for the routing of the post request, I guess you'd be faster than me :-)  I should have seen it immediately: Diablo uses POST request while well behaving clients (phoenix, poclbm, ...) use GET requests. Should be a simple matter of routing POST to the same handler In the meantime I'm working on a hashrate estimate for the workers, which I'd find quite usefull. Do you accept patches/pull requests?
You and Tyran are off course right. The target for difficulty 1 is (16^56-16^52 = 2^224-2^208), but it can be approximated to 2^224. Since we draw random number from a pool of 2^256 we are left with a chance of 2^224/2^256=2^32, so our average number of draws for 1 block with difficulty 1 is 1/(2^32), giving us an expected 2^32 draws for a winning number.You both get a +1 from me :-)Next up, how does this relate to other difficulties? I have 2.1 installed:Code:$ dpkg -l ati*Desired=Unknown/Install/Remove/Purge/Hold| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)||/ Name                                   Version                                Description+++-======================================-======================================-============================================================================================ii  ati-opencl-dev                         2.1                                    This package contain header files for OpenCL.ii  ati-opencl-runtime                     2.1                                    This package contain runtime files to run OpenCL aplication.And with other miners it doesn't happen. I'm using a vanilla snapshot from git (without my JMX modifications). Will do ^^ I've been mining for quite some time, but lately one of my GPUs (an ATI 5850 OC) started locking up after an average of 12 hours. I'm wondering what I could do to avoid these lockups and what the causes are.The problem started when I switched to the phoenix miner (from Diablo), I think it might be due to a higher usage of the cores (since Diablo in my case was slowed down by CPU, no idea why), so while I now get the advertised hashing speed this single core locks up, making the whole thing not very productive after all.Any idea? I'm having a few problems with the CPU usage of the miner, it's uses 100%. I remember that this wasn't always the case, so I wonder what changed it. I could start the JVM in profiling mode if you'd like  So news pools are desirable because some will fly under the radar and those who don't will divide the attack power of the DDoS between them. It's just a matter of providing enough targets to become too hard to take down  Great proposal, I wish many would be so elaborate While I too don't like the sudden halving of the reward it is a pretty nice and simple algorithm. What is especially nice about it is that the reward from the coinbase (generated coins) never really reaches 0, so miners will not have to rely completely on fees. I somehow feel there is a simpler solution than to estimate backwards from the calculator. As far as I know the target for difficulty 1 is 0x00000000ffff0000000000000000000000000000000000000000000000000000 (https://en.bitcoin.it/wiki/Target#What_is_the_maximum_target?) and we have to aim below that target. So out of 16^65-1 (the above with only FFs) we have to find a number that is lower than 16^56 + 16^53 + 16^52 + 16^51.So a simple division might get us how many hashes we need for a share, but somehow I get the feeling I'm off by one somewhere. Any confirmations?Edit: just noticed that I can actually keep the hex numbers and calculate with them. WolframAlpa says the chances of guessing such a number are ~1.45 * 10^-11 (http://bit.ly/jfJ3Kq ).Did I get something wrong? My knowledge about probability is a little rusty, and I haven't been able to find a simple solution to my problem. Given n difficulty 1 shares submitted in 24 hours I'd like to estimate the hashing speed. It all comes down to the average amount of hashing attempts to find a difficulty 1 block, but that's exactly thing that I can't figure out.Any help? A step by step example would be incredibly helpful ^^ I love this one. It make switching really painless, especially after todays outage of slush's pool this proved a timesaver. What I noticed however that the failing pool will still be asked for work, and only he doesn't return any, the next one will be asked. Are there plans for exponential backoff in order to avoid the extra request and the extra idle time? Just a mechanism to automatically blacklist a pool should it fail, and increase the blacklist time on each subsequent failure would be cool.The problem today is that slush sometimes gives me work, but does not accept the result (timeout/502 errors/...).Also I get a lot of these:Which makes me think that the diablo miner does not really take advantage of the long polling feature, and I start feeling bad for bombing pools with all those long poll requests. Any ideas? Actually no, the difficulty is adjusted each 2016 blocks, so a sudden drop right after an adjustment might take really long to have an effect on the actual difficulty (if we are left with 25% of the hashing power it takes up to 8 months to adjust the difficulty) Yes, having a single instance with >50% is bad for the network, deepbit just happens to be the first ever to reach that limit. I'd encourage people to start creating new pools. Having slush's pool down (for whatever reason) should provide you with enough users to justify investments And hopefully slush's pool comes back up soon  Would be nice though if mining pools and miners would implement session tokens which could be used to identify different instances running with the same credentials  Let's hope we never experience a huge drop in hashing power, otherwise we'd have a similar problem like the one we already experienced back when ArtForz, for fun, redirected his rigs to the testnet. Once he stopped the remaining nodes where left with an incredibly high difficulty and the rebalancing would have taken months (2016 blocks at 3-4x the actual hashing power in the network would take 2 months to rebalance) and confirmations would be really slow.It's hard to make promises but if my mining equipment survives that long I'll continue mining ^^ Would you consider shipping overseas? I'd start by asking Magnatune to accept Bitcoins. Magnatune is a "pay as much as you feel is right" kind of site and it has a decent selection of artists  If you are tech savvy you could create a ram-disc, copy the datadir to it and then start the client against it. This works especially well when you download a snapshot from one of the HTTP mirrors Once your client has caught up you can stop the client, copy the updated datadir to the original datadir.HTH,cdecker Isn't there a problem with 6990 Cards? Or are they supported by 2.1 too? Some miners do check the results before submitting them to a pool or bitcoin client (DiabloMiner does for sure). And there I was thinking that I figured out everything ^^ Thanks for the correction.
I actually think it is useful. It would be even more useful to allow most of these options configurable through the config file.+1Edit: as for security reasons: we do trust peers exchanged from others, so there are easier ways to inject and propagate malicious contacts. We could pass all revisions through Gerrit to enforce Code review and sign-off...  Me too ^^ Got them yesterday, thanks ^^Do you have a web-of-trust account so I can rate you? I actually welcome the CIA's initiative. It gives the Bitcoin community to explain its views directly to an interested public, that might have a lot to say when it comes to governmental ruling about it. The CIA doesn't make the rules it advises people who make them and execute them. Gavin having an intimate knowledge of the inner workings of the protocol and the community is a great choice for representative  I think I got the Non-Blocking Reactor to work nicely. Just testing it in two instances:Long term test with 250 open connections (running for the last 24 hours), without a single hitchSpeed and memory testing: this is actually on an emulated android with 8 open connectionsI'm quite pleased that the android version only takes 4 MB of Heap to run, and I will try to get it down even further to make room for the crypto stuff. Next thing for the reactor are scheduled tasks and repeating tasks (similar to twisted's Deferred). Oh I'd love to have some for my garden, do you have some more?Shipping would be again to switzerland :-) It's rather strange, when connecting to the local client it all works nicely, it's only when trying to connect to remote clients, which means I cannot check it as easily.Not asking for the addresses helps and most connections will survive Still trying to reproduce the error Edit: sorry for hijacking the thread, I'll create a new one if needed ^^ I think WOT can be a nice, user moderated, input signal for the karma rating just like others. I hope there's a nice way to contribute back to WOT ^^ A fork is not easy to detect. It is the consequence of a network partition which can be caused by ad luck or a connectivity problem (chinas firewall blocks bitcoin traffic => fork). If a fork happens the networks might rejoin again later, discarding the shorter chain (probably the smaller partition).Structuring the network might be a first step towards a partition tolerant network but currently there's no easy way. I wonder whether my problem with my own implementation applies here. I seem to get disconnected when asking other peers for their known peers:Code:323275 [main] INFO Received /205.185.123.216: null of type OUTGOING_CONNECTION_TYPE323276 [main] Sent /205.185.123.216: VersionMessage[proto=31700] of type VERSION_TYPE323454 [main] Received /205.185.123.216: VersionMessage[proto=32002] of type VERSION_TYPE323454 [main] Sent /205.185.123.216: VersionMessage[proto=31700] of type VERSION_TYPE323454 [main] Sent /205.185.123.216: VerackMessage[] of type VERACK_TYPE323763 [main] Received /205.185.123.216: VerackMessage[] of type VERACK_TYPE323763 [main] Sent /205.185.123.216: net.bitdroid.network.messages.GetAddrMessage@1128f5a of type GET_ADDR_TYPE326227 [main] Received /205.185.123.216: AddrMessage[addresses=1000 1.148.88.47:8333[Services=1] 1.152.220.152:8333[Services=1] 2.36.83.47:8333[Services=1] 2.68.109.202:8333[Services=1] 2.92.120.37:8333[Services=1] 2.94.192.18:8333[Services=1] 2.102.32.14:8333[Services=1] 2.138.178.76:8333[Services=1] 8.3.224.32:8333[Services=1] 8.18.115.2:8333[Services=1] 12.43.161.87:8333[Services=1] 12.47.114.47:8333[Services=1] 12.71.233.34:8333[Services=1] 24.0.228.170:8333[Services=1] 24.2.12.155:8333[Services=1] 24.2.243.57:8333[Services=1] 24.4.139.99:8333[Services=1] 24.4.172.88:8333[Services=1] 24.4.216.211:8333[Services=1] 24.4.250.252:8333[Services=1] 24.5.171.161:8333[Services=1] 24.9.187.70:8333[Services=1] 24.16.124.154:8333[Services=1] 24.21.68.223:8333[Services=1] 24.21.181.152:8333[Services=1] 24.22.98.156:8333[Services=1] 24.22.180.66:8333[Services=1] 24.36.99.165:8333[Services=1] 24.49.39.196:8333[Services=1] 24.53.130.151:8333[Services=1] 24.60.18.78:8333[Services=1] 24.60.85.3:8333[Services=1] 24.61.104.245:8333[Services=1] 24.61.145.229:8333[Services=1] 24.63.35.214:8333[Services=1] 24.63.86.32:8333[Services=1] 24.67.16.168:8333[Services=1] 24.72.80.236:8333[Services=1] 24.73.232.230:8333[Services=1] 24.73.252.170:8333[Services=1] 24.83.9.72:8333[Services=1] 24.84.30.183:8333[Services=1] 24.90.16.243:8333[Services=1] 24.90.236.191:8333[Services=1] 24.98.29.224:8333[Services=1] 24.99.250.75:8333[Services=1] 24.117.24.237:8333[Services=1] 24.117.176.129:8333[Services=1] 24.126.59.67:8333[Services=1] 24.127.235.108:8333[Services=1] 24.128.175.1:8333[Services=1] 24.130.12.194:8333[Services=1] 24.130.130.192:8333[Services=1] 24.131.81.110:8333[Services=1] 24.137.73.230:8333[Services=1] 24.138.120.7:8333[Services=1] 24.143.242.65:8333[Services=1] 24.145.31.10:8333[Services=1] 24.145.247.228:8333[Services=1] 24.158.184.45:8333[Services=1] 24.161.186.32:8333[Services=1] 24.165.162.72:8333[Services=1] 24.182.67.94:8333[Services=1] 24.183.25.189:8333[Services=1] 24.208.56.50:8333[Services=1] 24.209.183.157:8333[Services=1] 24.215.154.30:8333[Services=1] 24.216.232.164:8333[Services=1] 24.222.40.193:8333[Services=1] 24.224.153.118:8333[Services=1] 24.224.176.192:8333[Services=1] 24.228.26.241:8333[Services=1] 24.236.255.210:8333[Services=1] 24.240.34.29:8333[Services=1] 24.242.210.31:8333[Services=1] 24.247.43.212:8333[Services=1] 24.248.196.235:8333[Services=1] 24.250.247.240:8333[Services=1] 24.251.117.46:8333[Services=1] 24.253.235.179:8333[Services=1] 38.100.222.91:8333[Services=1] 41.3.197.175:8333[Services=1] 41.132.7.80:8333[Services=1] 41.146.207.59:8333[Services=1] 41.181.55.138:8333[Services=1] 41.241.13.220:8333[Services=1] 41.241.35.200:8333[Services=1] 46.0.111.62:8333[Services=1] 46.4.89.172:8333[Services=1] 46.9.6.86:8333[Services=1] 46.15.188.87:8333[Services=1] 46.59.16.42:8333[Services=1] 46.59.17.182:8333[Services=1] 46.158.71.166:8333[Services=1] 46.158.218.38:8333[Services=1] 0.0.0.0:0[Services=0] 0.0.0.0:0[Services=0] ... lots and lots more of 0.0.0.0:0[Services=0] ... ] of type ADDR_TYPE326368 [main] INFO net.bitdroid.monitor.BitcoinMultiConnectionTest - Received /205.185.123.216: null of type DISCONNECTED_TYPEDirectly afterwards I have to disconnect because I lost sync (probably I'm just noticing late that I was disconnected and I'm reading only 0-bytes). Strangely enough it seems to work with some peers but some others will just disconnect.Is it the flood protection hitting me or do I have something seriously wrong? I don't think you'll ever want to mine bitcoins on a phone, so that's not required. The bounty is not controlled by a single person so the requirements might differ. Most pledgers will probably agree that:It needs to participate as a node in the network (e.g. no remoting of a Bitcoin client running on another machine)Be able to receive and send bitcoinsBe open source (GPL, Apache, BSD, you name it, but the source must be distributed and we must be allowed to reuse it in other places)Backup and restore would be niceAnd as for the "Java Bitcoin client" there is none yet. There are only two implementations of the networking protocol: [mike]'s great work with bitcoinj (quite complete, and already at the base of a test client on android) and my BitDroid-Network implementation (which is quite unfinished because I wanted to put the blockchain and crypto operations into another module but never got to it, but I still maintain that for many connections mine performs better ^^).I hope to see some of your code someday  Just noticed that I didn't add a neutral answer for "no" or "yes" to the poll, sorry. Ok, right now we're pretty 50:50 on a possible change.The things I'm missing the most are (in no particular order and incomplete list):Daily/Weekly digest of new postsPortal with only my subscribed topics (changes on top)Subscribe to subforums (the chinese kids write so much non-sense, and I'm a techie, why should I have to wade through those topics too?)Better code highlightingMore control over the profile pageI'm sure this list will get longer over time. Mainly its stuff for users that are on the forum on a daily basis and makes little things easier.Edit: Is it true that SMF 2.0 has been under development for 6 (!!!) years? (source: Changelog) Could we add a way to tell the client to consolidate inputs by transferring inputs to an address owned by the client. I was planning to do so for the android client to save stored data (blocks to remember and time to aggregate enough inputs). Please don't shoot me :-) The downside is that more transactions are broadcast to the network.  That's what the bounty is about ^^ Same here, I was invited but the invite was never delivered. Hope it gets fixed soon  It's a quite cool way to share files with other people too. I like the Simple Machines Forum, but there are definitely some nice features I miss. I wonder whether this is felt by more users.The main problem I see is that there are far too many links from the outside to the existing forum so that a migration is not really feasible, but adding a second Forum and making the old one read only, or making it read only subforum by subforum.What do you think? Fragt sich wie sinnvoll es ist die Protokoll schicht und die Daten-intensiven Seiten zu uebersetzen. Sie aendern sich oft und wenn man sie uebersetzt werden sie gezwungenermassen out-of-sync sein.
I would love to have an invite, is there someone that can invite me?Otherwise is there an alternative to sell bitcoins for paypal? So what's the current situation? It's been a while since the last update and when trying to get a tester account I never get an answer. I would love to see the market be opened to the public again. Actually there are currently 3 things called Bitcoin:Bitcoin the clientBitcoin the currency unitBitcoin the communication protocolThe article needs a clear distinction  Great job, I love XKCD :-) I opensource BitDroid-Network, but once [mike]'s implementation hit there wasn't much interest in it so I stopped developing it. One of the main advantages is that I do in fact allow multiple connections and splitting the requests over multiple connections is a simple matter of implementing an actionlistener. Did I mention it uses non-blocking IO which allows for several hundred connections on a computer or dozens on an android phone? That's the main idea, but the addresses may have been used for change too. It's worth a try.If you already had that address before the crash you'll definitely get your coins back, I myself used a deleted block chain several times, and I always got my coins ^^Let us know what happens. Just improved my ventilation, got it 15 degrees colder (from ~83C to ~70C) will check back if anything changes. I had two complete lock ups of my system (probably due to me using aticonfig to adjust the fan speeds in a cronjob) at 30 hours between each other (100'000 seconds ~= 30 hours). I was wondering whether this is a known bug or one of my cards is dying on me:Code:[109453.772] [mi] EQ overflowing. The server is probably stuck in an infinite loop.[109453.905] Backtrace:[109454.293] 0: /usr/bin/X (xorg_backtrace+0x3b) [0x80ef31b][109454.293] 1: /usr/bin/X (mieqEnqueue+0x1ab) [0x80ecb5b][109454.293] 2: /usr/bin/X (xf86PostMotionEventP+0xd2) [0x80bd662][109454.330] 3: /usr/lib/xorg/modules/input/evdev_drv.so (0x684000+0x4961) [0x688961][109454.330] 4: /usr/lib/xorg/modules/input/evdev_drv.so (0x684000+0x4a56) [0x688a56][109454.330] 5: /usr/lib/xorg/modules/input/evdev_drv.so (0x684000+0x5296) [0x689296][109454.330] 6: /usr/bin/X (0x8048000+0x62e7f) [0x80aae7f][109454.330] 7: /usr/bin/X (0x8048000+0x121b4e) [0x8169b4e][109454.330] 8: (vdso) (__kernel_sigreturn+0x0) [0xdaa400][109454.365] 9: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (ulReadMmRegisterUlong+0xd7) [0x12f90b7][109454.368] 10: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (0xf89000+0x351733) [0x12da733][109454.368] 11: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (0xf89000+0x351691) [0x12da691][109454.368] 12: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (0xf89000+0x35163a) [0x12da63a][109454.368] 13: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (MCIL_WaitFor+0x99) [0x12b4a29][109454.368] 14: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (Cail_MCILWaitFor+0xc8) [0x12da4f8][109454.368] 15: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (Cail_WaitForMCIdle_Internal+0x77) [0x12ccd37][109454.368] 16: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (CAIL_WaitForMCIdle+0x3e) [0x12c50ee][109454.368] 17: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (swlCailWaitForMCIdle+0x1f) [0x12ab25f][109454.369] 18: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (MCIL_WaitForMCIdle+0x22) [0x12b4b52][109454.369] 19: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (swlPPLibCwddepm+0x67) [0x12bb787][109454.369] 20: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (0xf89000+0x2f3cbb) [0x127ccbb][109454.369] 21: /usr/lib/xorg/extra-modules/modules/drivers/fglrx_drv.so (0xf89000+0x2f151c) [0x127a51c][109454.369] 22: /usr/bin/X (0x8048000+0x26ee7) [0x806eee7][109454.369] 23: /usr/bin/X (0x8048000+0x1a5da) [0x80625da][109454.369] 24: /lib/libc.so.6 (__libc_start_main+0xe7) [0x28ace7][109454.369] 25: /usr/bin/X (0x8048000+0x1a1b1) [0x80621b1] April fools day? Also gegen Zurich fuer das naechste Meeting haett ich nichts, bin momentan etwas Ortsgebunden  I prefer Munin as it works more out of the box, but I'll give it a try  If it's as easy as IntenseDebate's API it is just a matter of putting a JavaScript where you want the comments. I don't think these "Satoshi is the reincarnation of Jesus" rumors will ever end, unless Satoshi comes forward. But I find them quite amusing  This is great, I was one of the guys scraping the page (5 minutes, I figured what's the harm), but this makes it so much easier.For those of you using Munin, now you can monitor the pools like I do:Code:#!/bin/bashcase $1 in  config)    echo "graph_title Pool reward"    echo "graph_vlabel BTC"    echo "confirmed_reward.label Confirmed Reward"    echo "total_reward.label Total Reward"    echo "graph_category Bitcoin"    exit 0;;esacCURL_OPTS="-b /tmp/cookies.txt -c /tmp/cookies.txt -L -s --max-time 3 -k"URL="https://mining.bitcoin.cz/accounts/profile/json/YOUR_TOKEN_HERE"PROFILE=`curl $CURL_OPTS $URL`CONFIRMED=`echo $PROFILE | grep -E '"confirmed_reward": "[0-9\.]+"' -o | awk '{print $2}' | sed 's/"//g'`UNCONFIRMED=`echo $PROFILE | grep -E '"unconfirmed_reward": "[0-9\.]+"' -o | awk '{print $2}' | sed 's/"//g'`TOTAL=`echo "scale=8; $CONFIRMED + $UNCONFIRMED" | bc`echo total_reward.value $TOTALecho confirmed_reward.value $CONFIRMEDJust add your token and drop it into /etc/munin/plugins/ ^^The graphs look like this: Having many smaller chains actually weakens both the bitcoin economy (many incompatible flavours of Bitcoin) and the network as an attacker could just go through them and destabilize each one after another using less computing power than he'd need for a single big one. Well as long as the super computer stays it's all ok because the protocol still works and transactions can be processed, the scenario where he leaves is unlikely because he has an incentive to stay (Bitcoin generation).Beowulf? Why couldn't Bitcoin have started earlier, I had access to the ETH Zurich/EPFL Beowulf cluster, damn  Well, yes, but this is a catastrophic scenario where it would be easy to get all developers of all clients to agree on resetting the difficulty to the last known good value. As long as we can get 50%+ to use a client we can do whatever we want with Bitcoin ^^ I think we can actually have a tradeoff between fast confirmations and network size. Right now every single node gets all transactions, but what if we segment the network? The network would be segmented into a hypercube with variable degree. Each vertex is a cluster of nodes (mini-networks) which gets assigned there by hashing their IP (forcing nodes into a specific position of the overall network) and they'd take care of small amounts of outgoing addresses (to mark spent inputs), achieving consensus with a much faster block chain construction (micro-tick if you will). The miners still compute the usual proof of work, but if they find a lower difficulty block, they report it to their cluster to advance the local block chain. If a miner finds a global block it starts collecting transactions from all other vertices and announces the block.I proposed this first way back while arguing that it would allow the network to scale better, but the micro-ticks look a lot like the block creation speedup you guys are looking for  I was looking into the chain storage and as far as I see it you'd just need a few recent blocks to track transactions you're interested in. I'd keep them in a stubbed "quarantine" chain as long as I'm not satisfied that they were confirmed, and then stub them off at ~10 confirmations, and just store the potential inputs for transactions I'm going to send. It's just that right now I'm swamped with 2 theses, and I wont be able to actually implement it for some time... Little Endian is a pain, and I've said it often enough.Then the protocol version should evolve independently of the client version. Consolidate some stuff, like "do we really need size fields that can have a length of UINT64?". It's just a cheap trick to optimize the length of the messages, but each message has a fixed header field for the command that is never used fully, why start hacking exceptions in?And then finally comes my argument for structuring the network topology, in order to scale better and detect partitions (think dynamic degree hypercube).Edit: nearly forgot my old capabilities proposal: http://bitcointalk.org/index.php?topic=894.0
Just starting to build the wallet itself, and we got our own little page (you might have guessed it from the package names): http://bitdroid.net (as soon as my ISP finishes the scheduled maintenance which was supposed to end 3 hours ago...).First goal: identify my own transactions and store possible inputs for future transactions. Not really true, we can define a future switch block, after which a new set of rules applies. If all developers are notified early enough they can make the switch, and allow time for users to make the switch, when the block arrives old implementations will fork off creating their small network, while the new clients take over the main chain (assuming most of users have made the switch).Evolving the system is hard, but it's not impossible. It would however be nice to have a nicer protocol (yes I know, I've been saying that for ages ) +1 Well the idea was to close new threads after pointing them to already discussing topics, and then close the duplicates, so the discussion is kept alive in the old thread adding helpful information to the big thread.I'd love to see mods to discourage flaming and offensive language. I think that moderation gets more important as the board grows, the potential for trolling increases and it gets increasingly hard to find the interesting stuff in a mess of spam.Even today most topics are dupes, which can be resolved by posting a link to the old thread and closing the dupe thread. There have been some calls for Moderators to close resolved threads, reduce trolling, keep a clean forum etiquette and merge duplicates. Others love the chaos and freedom to write about just anything.So should moderators start being more restrictive and create strict rules?  We could also selectively moderate some sub-forums  Actually no, DNS queries are a nice way to collude additional information about users, that can be used to target Ads ^^ Somehow Google DNS adds an IP that is not in my records:Code:$ dig mtgox.com @8.8.8.8; <<>> DiG 9.7.1-P2 <<>> mtgox.com @8.8.8.8;; global options: +cmd;; Got answer:;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 57886;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mtgox.com.   IN A;; ANSWER SECTION:mtgox.com.  79921 IN A 174.121.74.59mtgox.com.  79921 IN A 74.52.143.58;; Query time: 23 msec;; SERVER: 8.8.8.8#53(8.8.8.8);; WHEN: Sat Mar  5 14:44:25 2011;; MSG SIZE  rcvd: 59Whereas my bind installation says just:Code:$ dig mtgox.com; <<>> DiG 9.7.1-P2 <<>> mtgox.com;; global options: +cmd;; Got answer:;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 18322;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0;; QUESTION SECTION:;mtgox.com.   IN A;; ANSWER SECTION:mtgox.com.  63531 IN A 174.121.74.59;; Query time: 0 msec;; SERVER: 127.0.0.1#53(127.0.0.1);; WHEN: Sat Mar  5 14:45:53 2011;; MSG SIZE  rcvd: 43 Selbst das is nicht wirklich so, der Fall vom gesperrten MtGox Account von Baron zeigt man kann sehr einfach die transaktionen verfolgen und dann rueckschluesse auf die Person dahinter machen. Es ist immer die Schnittstelle die kritisch ist. Ich denke Blockexplorer sollte noch ein feature bekommen um leuten die chance zu geben inputs als gestohlen zu melden damit man die tracken kann ^^ Well there would be a few things I'd love to see, like the ability to ignore sub-forums or subscribe to specific ones (not interested in marketplace or language specific stuff, just dev), daily summaries via mail would be so great (but they would be available in SMF too, if it were not for the spam problem), limiting signatures (not yet a problem, but it really gets annoying once the signatures are longer than the threads), ...I'll find more ^^Oh and Tapatalk support would be nice, and would enable us mobile users to browse and respond from Android and iPhone ^^ My first ever accepted pull request on GitHub , you just made my day ^^ I just resuscitated my account. And I'm pleasantly surprised that they changed alot. When I last played it was incredibly boring ^^My ingame name is Snyke, what's yours? So he's connecting 5 cards, by taking the powerlines of the respective extender cables and soldering them into _one_ molex female plug, and them he plugs it into the power supply? Or does he use a molex from the PSU for each card? Looks pretty sophisticated, anyone tried that direct PSU feeding trick yet? I can't seem to understand what connectors he's connecting to and to which PSU plug it is hooked up. Das Problem momentan is einfach dass Bitcoin nicht unbedingt mit kriminellen machenschaften in verbindung gebracht werden sollte. Das argument dass Cash auch dafuer verwendet wird, zieht einfach nicht wenn jemand mit genuegend Nachamern sich auf die Flagge schreibt dass man das boese boese Bitcoin verbieten soll.Wir sollten definitiv erst versuchen das vertauen in Bitcoin zu staerken bevor wir grossartig spekulieren wie toll es doch fuer all die illegalen sachen is  Actually I think the default client will detect it. there was an early pool that used to split the gained coins directly in the generation block :-) Looks promising to me, although I didn't test it yet. Looks clean ^^+1 for inclusion I'm using a combination of LastPass for the Web and KeepassX. KeepassX is easy to distribute with Dropbox, so I have the same keyfile on my desktop, my notebook and my phone (android KeePassDroid application, http://www.appbrain.com/app/keepassdroid/com.android.keepass) Just a heads up: this is not production ready code (hopefully it will be soon^^)The API is still changing frequently, but that is also good since it allows you to get to help me design it, just tell me what you'd like and I will consider adding it Edit: the code runs perfectly fine on my Android Wildfire with 50+ connections, no noticeable slowdown  Looking forward to implementing the block storage ^^ If you trust your friends you could just create a new pool for you and your friends by using jgarzik's http://yyz.us/bitcoin/poold.py, it does not include cheating prevention and you'll have to figure out how to split the reward yourself, but it's a start :-)
I would love that ^^If [mike] allows I'll write an adapter for his code to be connected to my protocol layer  Well since I've not implemented the crypto part yet you'd have to create a transaction object by specifying inputs, outputs and scripts and then just submit it using sendMessage in the bitcounNetwork implementation you chose. More on that tomorrow ;-)  Well,  there may be several optimization targets. One is what you described to minimize the number of inputs to reduce the transaction size. Another may be to use the smallest possible inputs which increases transaction size but also reduces the number of inputs we have to track (long term optimization). And finally we could try to use the oldest inputs which would allow the network to Stub off old blocks since the only useful information we can get from it is its hash which has been confirmed. I'm not sure yet which one is best  I strongly support removing the option from the menu, let's make it harder to find I may actually be cutting myself here as I am a strong supporter of having large decentralized computation power, unlike the professional multi-GPU setups and pools, but overall having the option in there just turns off alot of people. The getwork interface still enables people interested in supporting the network with their computation power to just start the cpuminer or one of the GPU flavours, but at that point they'll probably have informed themselfs about how long it will take and what probabilities underly the mining process. Some good news: I have implemented the non-blocking IO reactor, which should allow us to handle all connections in a single thread. That frees up a lot of resources and should be performing nicely.As for examples on how to use the library see https://gist.github.com/839394 and https://gist.github.com/839395 (the first using a single BitcoinClientSocket, while the second one uses the NonBlockingBitcoinNetwork to do the same).BTW: welcome to the forum dabron, hope to see your implementation some time ^^ ~100byte * clients /5 second Well an X display usually starts without any interaction, but to use it you'll have to enable autologin.Then in the SSH session you want to run the command in you have to specify the display you want to talk to by setting the DISPLAY variable.There are two ways to do so:Code:$ DISPLAY=:0 yourcommand$ export DISPLAY=:0The first will apply it only to yourcommand, while the second will save it into the shells environment variables, so it applies to all following commands.Also you have to know which display you want to talk to:DISPLAY=:x.y will use the device y controlled by driver xDISPLAY=:0 is a shortcut used by ATI to indicate all devices under the fglrx driverHTH,cdecker I do have a fork of the DiabloMiner to add hashrate via a JMX interface, I'm using it myself with munin. Feel free to take a look https://github.com/cdecker/DiabloMiner/tree/JMXI will add more statistics Edit: this is a sample from one of my machines Ok, got it. I filed a pull request and also uploaded a branch to my repo with my JMX enabled code for 5 minute averages. What good is the $COMPUTE? I have a problem with stripping the digit from the $DISPLAY variable, as I'm using it to turn off single cards in my setup, would be nice if there where an easy way to enable/disable single cards by specifying lists of cards on the command line. Actually come to think of it I'll add it myself and file a push request ^^ I have been planning to do this for a long time and finally I decided I had to opensource my Bitcoin network protocol implementation. I was hoping to have it ready and robust by the time I'd release it into the open but my master thesis is about to start and I still have to complete some papers I've been writing for quiet some time, so I'm forced to release an unfinished implementation.My goal was to create a stable and versatile implementation of the P2P protocol the clients use to communicate with each other in Java. This is not a simple frontend but an attempt to create a clean room implementation of the actual protocol! I know there are quiet a few people out there trying to do exactly the same, and I would love to get them on board with this project.The need for an alternative client is there, especially if we want to get Bitcoin to go mobile, as an Android app, or simply because we don't want to put all eggs in one basket (right now, should a bug be discovered in the Mainline client the whole network can be taken down by a single attacker).As for what is implemented:Client can connect to other clientsA connection can be maintained (proper handshake, pinging, ...)All messages except getblocks and getdata have been implemented and work correctlyThe code can notify any number of listeners about incoming messages and messages can be sent back70%+ code coverage with our unit tests!What will soon follow:A simple driver to keep a pool of connections aliveSwitch to Non-blocking IO in order to avoid having threads idling waiting for incoming messagesMore unit tests Less ugliness, more coolnessWhat will not be implemented in the network part:Crypto stuff: I wanted to keep the network implementation as small as possible, and cool things can be done even without the crypto stuff (network crawling, relaying messages, ...) so I decided to move the crypto stuff out of this module and implement it as a listener that will plug into the network core.Block storage: again this is to keep things simple, and it would be cool to have multiple implementations of this (flat file/SQL storage, keep everything/keep only inputs for my transaction, ...)Using itAs I said, it is a library and not a standalone program. In order to use it your program has to provide an implementation of the BitcoinEventListener interface which allows the library to notify your code about messages from the network, and also allow your program to send messages back. For an example about how to use it see BitcoinClientDriver which is the code that does the handshake and keeps the connection alive.CodingAs I said, I'm hoping to get more people on board with this. The code is released under the Apache License, which should make it possible for you to reuse it. I tried to keep the number of dependencies as low as possible (come to think of it, the only dependency is SLF4J, which allows you to plug in any logging facility you want).The code is on GitHub (https://github.com/cdecker/BitDroid-Network), feel free to fork it, I'm only asking you to help me improve it by contributing changes back to the me (just send a pull request and I'll merge it in if it's a reasonable change).I'm using Maven2 as a build tool, to get started check out the code and run mvn package and it'll build.Under src/test/resources we have 24 hours worth of network dump split into single messages, they are used in the unit tests, which I'm proud to say cover most of the code. Should you find a bug please create a unit test that illustrates the problem.And now start flaming about the quality of the code  As pointed out by other users bitcoin:// would imply a hierarchical structure (like URLs) while bitcoin: is preferred since the Address is a first level citizen while all other parameters are optional. BTW it's not an invention of js-remote, we discussed it a long time ago, but I'm happy that they adopted it ^^ It actually is I'm still looking into using the non-blocking IO package to avoid having a thread for each connection, making it a little bit more speedy, and less of a resource hog.The crypto stuff is designed to be built on top using a simple event listener interface that passes the messages from one module to the others and back. I'll make it ready for GitHub tomorrow, but don't expect too much, it is after all only a translation from network to POJOs  Changing the P2P protocol is not going to happen anytime soon for the above mentioned reasons (although I would welcome it)  because it would require a transition phase for the entire network to switch. I just mentioned it because someone asked me about it. For the pushwork patch i think you are forgetting that only because you decide to use one over the other for speed reasons doesn't do anything. You have to make the format easy to implement since the miners do have to support it. The getwork interface must be enabled anyway so if the coders of the miners don't adopt the protocol you'll not have changed anything,  except a lot of work spent in a useless interface.  I'm wondering if the split is technically possible at all since the attacker is signing the transaction with his private key, and changing the amount transferred would effectively invalidate the signature. My guess is that blacklisting the "change" is a lot easier, but also easier to trick.A double spending attack can only be detected over time, since we need a consistent view of the state the network is in. Blocks are used to synchronize and recreate consistency. You mean the P2P protocol? I'd already be happy using JSON, but it won't work because the whole block hashing and transaction hashing relies on the binary representation of the message itself... I have to say that I agree with slush, after implementing the Bitcoin protocol in Java I hate binary protocols.Encoding it in JSON would allow easier implementations since most languages have some form of understanding JSON. Compression is not needed but we might simply add another port that compresses all that goes through it (think OutputStream Chaining in Java). The size of the messages will double, yes, but as far as I'm concerned that's the only downside to using JSON. Any PCI-E x16 risers/extenders? They would be really popular in here ^^ Great stuff, finally I can wrap my head around how mining works without having to crawl through additional stuff  I don't quite get it, how's that supposed to change anything? Could setting the DISPLAY variable be a workaround? After all I'm able to start the miner via an SSH connection which has nothing to do with the Displays at all...Also for the second core of the 5970, I think crossfire is still turned on but I can't figure out why and how to turn it off (CPU is being bombed also, which I guess is Crossfire too).
Investigating a little further: it's only the second core on the 5970 which gives me problems (Invalid block found on Cypress (#2), possible driver or hardware issue) it does however produce correct blocks too, so I'm getting nowhere with that one. The 5850 isn't detected by Diablo, although it does show up in aticonfig.Any ideas? Solo mining has the advantage of strengthening the network itself. Pooled mining creates single points of failure, which could be attacked or compromised, which could result in large portions of the computational power being used to revoke transactions at will or be lost (slowing down transaction confirmation). It would take several weeks to recover from the loss of slush's pool for example.So solo mining does not directly provide you with any benefits, but it strengthens the network, resulting in a more stable currency. I have a protocol implementation ready to be open sourced, but it does not have the crypto stuff ready yet, which doesn't really have much to do with the protocol itself.Still looking for motivated developers to help me create a stable and peer reviewed implementation of the protocol :-) I'm having a few problems with my newly setup box, with a used spare 5850 and a 5970, it keeps throwing error messages at me telling me that the card has found an invalid block and that it might be a faulty driver or hardware, neither of which is really calming, but the hardware failure is what I dread the most.I used a freshly installed Ubuntu 10.10, Sun Java6, ATI Stream SDK from http://orwell.fiit.stuba.sk/~nou/ati-opencl-runtime_2.1_i386.deb and http://orwell.fiit.stuba.sk/~nou/ati-opencl-dev_2.1.deb and the ATI Driver from https://a248.e.akamai.net/f/674/9206/0/www2.ati.com/drivers/linux/ati-driver-installer-10-12-x86.x86_64.run .Any idea on where to start with this one? Sounds like a reasonable enhancement, especially since the miners will be notified of a new block and will be able to start on the new one right away  It's another frontend to bitcoind. Good point, verifying transactions close to the originating node means stopping spam earlier, but adding to the load of those nodes. I think we have to distinguish between spam (invalid transactions) or valid transactions increasing in size.Actually this reminds me my idea of using a hypercube, transactions are always forwarded to the nodes that check the inputs, should the network ever run out of computation power we just add a new degree locally and have successfully halved the computation power needed (by adding an additional bit to the prefix matched), reduced the network load to 1/4th (half the nodes fully connected 1/2n => 1/4n^2), all that for adding an additional hop to the final destination  I'm trying to build my own small pool which I'd use to gather statistics about the miners I'm deploying. Would that script work for that purpose? I guess that validation is not necessary if I trust my miners, right? I assume it didn't go all that well, I'm sorry to hear it. It's always been my opinion that if we really must have pools (instead of running hundreds of independent miners) we should have many of them to chose from, as to avoid central points of failure. Should slush turn out to be taken down or replaced by a malicious entity we'd have a problem at hand.Meanwhile, thank you for publishing part of your code, I'll use it in my own mining rig if that's ok, and if someone can confirm that it actually works  Sounds better, thanks ^^Anyway, I agree that right now the "work" done by the client to elect a tie-breaker is quite useless. It would be nice if we could leverage other, more useful, computation tasks to let the time tick in the Bitcoin universe.Right from the start I can think of the entire Boinc stack which is (kinda) useful, but we have to consider certain problems:Blocks have to be generate at regular intervalsDifficulty has therefor to be adjustibleProof-of-work dictates that once a result if found it has to be easily verifiedSo SETI does not really qualify (too unpredictable, ...), maybe the prime number sieve might be a good candidate (find a prime number of a certain length), but it destroys the chainability (I can start calculating any length number without knowing the predecessor). Shall we open another thread? I don't want to stray too much from the subject.[OT]Light needs 20 minutes to travel from Mars to Earth, even assuming we could get a client up there it'd be much more practical to establish a MarsCoin and let it build up resources locally, rather than trying to tie it to EarthCoin ^^The better option is to set up an exchange that allows to buy MarsCoin for EarthCoin should we need them[/OT] Since Bitcoin will only work on earth (speed of light and everything) we only have to consider the earths population: 7 billion people currently.That's ~2^33 (don't you love working in binary?)Given 2^64 minimal fragments of a bitcoin we still have 2^64/2^33 ~= 2^31 = 2147483648 fragments per person, or expressed in other terms: every living person on earth can have an average of 21.47 Bitcoins.Anyway since making the change would break all signatures, we'd have to run both protocols in parallel, making it as hard now as it'll be in a few years. That's random for you I'm having some connection problems, quite regularly a connection is lost every 7-10 minutes, is it just me? As discussed in many other places Bitcoin does not have intrinsic value, it just has the value people are willing to pay for it, for an easier faster, cleaner way to transfer money.Mining has to be seen as the act of securing the future value of the Bitcoins in your wallet. Getting additional Coins in exchange for computation power is a nice extra, but it's just that, an extra. Additionally the gain from mining will decrease, since the mining reward is set to half at certain stages in the network development. Nope, android.com even tells me that it isn't available for my phone  Great work :-)Sadly it's not available for my HTC Wildfire (Android 2.2). Would love to port it, is it open source? My best bet is that he's still active here, but was annoyed about all the requests and questions from new Bitcoin users, so he changed his username and is participating ignotito  It was great finally meeting some of you guys, I'm definitely looking forward to the next meeting ^^ My bad, the meter is fluctuating a bit more, I'll check if it stabilizes. Does this justify a 3% performance increase? I'm not sure how precise the hash meter is.
Once again a change of plans: I'll be there at 16:00 Looking forward to meet you all ^^ According to my own measurement there are 321 clients accepting incoming connections online over the last 24 hours. No idea on how many NATed nodes are online. Sorry, I'll not be able to show up. My gig has been moved up and I'll have to show up earlier. I'll attend next time though ^^[mike]: are you still up for that beer? We could meet sometime next week  Ohoh, somehow this is worrying me:Any idea what might be causing this? I'm getting it along with a few connection errors to slush's pool There's an idea: offer your pool over Tor Would be a nice alternative to using Tor exit nodes and would reduce latency (bigger choice of intermediate nodes) ^^ Well the client actually is pretty easy to reimplement. The problem is the protocol which is much harder to change. The SHA1 algorithm and Elliptic Curve algorithms are in fact anchored in the protocol. So my wishlist should the protocol be designed from scratch:Pluggable algorithms, that can be replaced once a vulnerability is found (with a transition time, and reaggregate all bitcoins with the new algorithms by sending them to a new address)Network Byte ordering (Big Endian!!!)Not a binary protocol, or the possibility to use another transport, like JSON (right now we hash the binary content of the transaction to get the transaction hash, same for Blocks)Not relying only on TCP (other transports such as HTTP, SMTP and UDP would allow more people to participate and it would be harder to filter)Better structured network to be able to detect network partitionsBetter structured networt to scale together with the network (I already proposed dynamic degree hypercubes in another thread)And many more to come  You'd have to be really unlucky, it would be more lucrative to just replace all ads on the Webpages you visit with it's own The Tor Proxy would have to be custom coded to intercept your pool communication and we're far from being big enough for it to pay for the hack. Not a really good comparison since you'd have to have the hash of the password, and we could compile a rainbow table for almost anything. One way to defeat Rainbow tables is salting the password hashes (you are salting your passwords MtGox aren't you?)  Yeah, that's exactly my problem. It was fluctuating like hell but it stabilized over time right now I have a 5 hash/s standard deviation which is incredible. I had only a 5 minute warmup phase,a 5 minute hot phase and measured the average over the 5 minute hot phase and it didn't look nice. But with a longer warmup phase it looks better. Here's my monitoring graph for the last 24h.Notice the high fluctuation and then the stabilization to a higher average  Any chances of an open source pool? So until now we have 1 confirmed compromised account (cryptofo) and several other reporting some strange transaction 4 days earlier.IMHO that transaction has nothing to do with the attack at all. Could cryptofo please check the strength of the used password?Just trying to keep panic down and get the matter resolved  Next best guess: sniffing traffic. Are you using the HTTP or the HTTPS URL to log in? Just to add another statement: I too am seeing the Payment Process united transaction, with exactly the same time, looks a lot more like a cron job to me. If the database were compromised as some people suggested there would not be any entry, they'd just sent the money off without being so polite as to inform the users where the money went. Same for the platform compromised discussion.My best guess is that it was in fact a dictionary attack. Could the affected people please share the strength of their password using http://www.passwordmeter.com/ to not publish real passwords on the Forum?My account doesn't seem to be compromised since it still shows me my dollar balance like I left it a few weeks ago.Still waiting for an official statement by MtGox  It is possible as long as you stay on a managed platform with a shared wallet (so far not really different from stock trading), but should the transactions go out to the Bitcoin network the Bitcoins used in a trade will have to cool down for a few minutes before being able to reuse them for a new trade.All this assuming that you don't trust the other side, and wait for confirmation, should you have a closed set of traders trusting each other you can in fact create new transactions with unconfirmed coins. Time to extend the FaQ?  Strange, with -f 10 it now gives me similar results to what I got before ArtForzz's kernel was introduced. But I have a standard deviation of ~10%! Still not perfect but I'm going to tweak my settings further  Great work ^^We do not need to be concerned too much about adjusting the testnet difficulty since it's all throw away anyway :-) I do have a working implementation of the protocol that uses an event driven approach to communication. It'll allow you to get real time events from the wire without having to rely on the Bitcoin client to notify you or even worse, having to pull data out of it at regular intervals.What sort of backend are you using? A database? Exactly, it'll return to 0 and never confirm Btw: all transactions could be invalidated, it's just incredibly unlikely, because someone would have to fork the chain before the transaction and overtake the current chain. I'd be in for something between 200-1000 BTC 
Oh damn That's one of my addresses, yeah  I don't know what's worse, me being in the top100 list or me recognizing my address among all other just by looking at the list... So referring to your code from the other post you'd simply replace the "ECDSA" String in the methods signData and verifySignedData with "NONEwithECDSA"? How are the 69xx performing compared to the 59xx series? The chart under https://en.bitcoin.it/wiki/Mining_Hardware_Comparison could use a small update ^^ Basically yes, it's because the network has to agree on a consistent state, and the smaller group will eventually be overtaken by the larger one and all incompatible blocks are lost (Bitcoins generated in those blocks will no longer be accepted by the network).It's not really a vulnerability, you'd be free to keep on working on the smaller chain, resulting in a network fork, but you'd have to convince people to (a) accept your coins and (b) join your network.As long as network splits are short I don't see a big problem, but should for example china decide to drop all bitcoin connections to the outside world we'd end up with a Bitcoin block chain for China and one for the rest of the world. I guess we'll see it sooner or later. But "Don't Panic"  Short answer: no!They'd be far better off with creating their own chain. The fact is that even should they generate a block, the time to send it back to earth would be far longer than the 10 minute timeframe. Probably someone on earth would have generated a block and other would already be chewing on build on that block before anybody's ever heard of yours coming from mars (http://www.wolframalpha.com/input/?i=Distance+between+earth+and+mars)P.S.: which doesn't mean that bitcoin is not applicable, you'd just have exchange rates between Earth Bitcoins and Mars Bitcoins  Just a quick test reveals that the performance drop is due to commit dc5b12ee55c0dd3971591cfb7e1420de06bb5e59 (ArtForz's Kernel). Too bad I was really looking forward to this one. Is it just on my side or does the kernel not work with ATI Stream SDK 2.1? Wow, just pulled the latest commit, added my JMX patch and started the worker again and it maxes out at 14 Mhash/s on my 5850, whereas I got 254 Mhash/s before. Somewhere I got a problem ^^ I'll try to track it down next week  I have a few dumps done with wireshark and I use them when unit testing my networking code, it's incredibly usefull to have actual conversations to test against. Also the format of the messages makes it quite easy to split the dump into single messages.BTW: 0x6763 would you be interested in joining efforts? I heard you are developing a network stack in Java too, I'd be keen to get a good networking code done that is peer reviewed. It could serve as a basis for many different services. All the more reasons to create pools by meeting the people in real life and verifying them personally. Also the only machine that needs to be audited is the one holding the bitcoin client administering the pool, the miners themselfs can be torn down and reset up in a matter of minutes, no point in securing them too much. Using a PXE setup we can even go further and just plug the miners in and they'll install and run everything from a RAM drive (machine fails => reboots and registers at the master) making administration a breeze. Also regular payouts to the members decrease the temptation to take over the master. Monitoring hashing performance and adding statistical tools to make the system verifiable should suffice for the members, only a judge board has to know the technical details. Not my point, I'd like to see the setup being disclosed publicly and the legal framework to be open so that other groups can start and create their own pools, and not create just one additional huge pool. I'd love to create a local pool in Zurich actually, if someone's interested in joining  Would be nice to create a basic framework for people to adopt, so we can create many groups distributed all over the world. To be more correct: the more independent miners there are the stronger the network, pools still are a single point of failure  Yes I know but I really love to see what happens when varying the parameters, I was surprised that with odd multiples of 32 for the worksize the hashrate dropped for example It's not really for the sake of getting more out of the cards, as it is for curiosity That got me an additional 15-20 MHash/s, thanks for the tip. I'll redo my measurements and share them with you. Would someone else be interested in sharing their Cards benchmarks? I could create a driver that will collect all the measurements needed. We actually made it onto the front page Welcome Diggers ^^ I automated the benchmarking as far as I could and this is what my ATI 5850 looks like:Setup:Moving average over 5 minutesDiabloMiner with JMX patch to read Hashrate and Std DeviationNot sure why it behaves like this, and the outliers on the left are not reproducible in the measurements (gnuplot just doesn't like 3D graph at their boundaries). What kind of ROI can one expect from this? Or is this purely a way to stabilize the network by throwing yet another cluster at it? If it's the latter I'd say let's create multiple small ones instead of a central one that increases vulnerability. I think the growth will be slowed down as soon as we hit 0.50$ because someone has an order in place, selling 20'000 BTC at 0.51$ and it will take some time to work that down. Hopefully we'll get over that one fast enough :-) Well I can share single classes there but as I said I don't want to make it world accessible yet.What I want is a community working on improving a single network/protocol core implementation in Java, and having 10 independent forks just reduces the collaboration. I want to create a functional core before releasing mainly to group interested people around it to help improve and maintain it, and then we can make it completely public.
Actually the reasoning behind not needing the encryption is because we always assume an adversarial peer we're communicating through. The only thing that should be considered is reducing timing attacks which would enable to track back the origin of a client, but that's a pretty slim chance, and partially solved by using Tor. Any favorite communication/sharing channels?I'm personally trying to get to grips with gerrit, which might be a good way to ensure code quality by code review, also it allows automatic builds and checks via hudson   Still, by reducing the number of generators to a few we reduce the computational power in the network, making it easier (read not yet easy) to attack the network. It is by the way also my main criticism of the pool, which could be taken over and misused. Already discussed here http://bitcointalk.org/index.php?topic=2454 I managed to get everything I needed by adding JMX capabilities to the DiabloMiner and monitoring it with munin. That also works nicely to monitor temperatures and other stuff  I'm working on it in my spare time, and also a few others have started.I'm not sure when I'll be able to release anything, but I got a pretty solid protocol layer worked out, just has to be tested against the Devices capabilities. The Crypto APIs are a bit harder because Android has a crippled version of the Bouncycastle, that don't provide RIPEMD-160 and ECDSA secp256k1, but I think I got that figured that out as well. I'm kinda slow with the crypto stuff, but I should get it running sometimes after my exams ^^Edit: nearly forgot the important stuff: the network and wallet code will be released under the Apache License 2.0, the Android client itself will not, but everyone will be able to write their own :-) Also I'm interested in sharing the open source code as soon as possible, but releasing it now would just end up in thousands of forks that do not contribute to each other, so if there are developers interested in joining the java library effort please tell me, and you can start judging the ugliness of my code, or start contributing. The goal is to have a solid base implementation on which to implement additional services and interfaces. Why do I feel that at some point we'll drop the main network and stick with the test network  It's a way to verify the authenticity of a Website connection and to encrypt traffic through it: https://secure.wikimedia.org/wikipedia/en/wiki/Transport_Layer_Security http://www.startssl.com/ is offering free ones, but if you want a higher security than the free one, I guess you're stuck with mailing them, and asking about the exchange rate. Why not go the easy way and keep the accounts on the server,  surely this thing is backed by a database of some kind and it 's easier to create a Frontend to that instead of having to distribute and maintain a custom client.  The other way is to cache the values in the profile page so only the first hit will actually show something new and the underlying data provider isn't feeling additional load from reloads. Just put a caching timeout of 1-2 minutes. In another topic we had a discussion about proving that the client is correct, and in Bruce Wagner's interview the question of tamper proofing was raised, but I think both miss the point since the client is replaceable, we are not putting our trust in the client but in the protocol. Should the client be vulnerable to attacks (buffer overflows, ...), if we can prove that the protocol underneath is correct it won't matter since we'll just create new clients (as some already are) and we'll pick up from where it all went wrong.So let's start a community effort to put under the microscope the protocol, and let's find possible flaws. Let's make it a scientific one by clearly stating assumptions and consequences and not put statements into the empty room.Anyone interested? Once we got enough material I'm sure we can whip up a nice Wiki article that might be able to convince the critical, but open minded people, about the stability of our system  Let's come back from all the porn non-sense.I quite like the idea of teenagers becoming our target audience, since they are likely to adopt Bitcoins should we be able to create virtual goods they can buy (think FarmVille). Young people are easier to convince to join a movement like Bitcoin. Yup Well to be precise there are quite a few messages without payload that have checksums (see ping for example) I don't think this should be labeled as a bug, it's simpler not to have a special case for empty payload messages when stripping the message header :-) I had the same problem, but yes the checksum for an empty message (byte[0]) is 0x5DF6E0E2 so that's correct  Useless but correct. It's a small world isn't it?  I think it's a quiet innocent hack, and an interesting one if it comes to that. I'd have never thought using a cloud designed to deliver web content to do real calculations But I'd neve risk my Google account over it ^^ Looks nice, could be used to break race conditions (double spending) by tracking outgoing coins in the DHT, but we'd have to trust the responsible nodes. Should the node be cheating it can invalidate entire transaction chains.Still a project to keep in mind, as alternative double spending prevention. Still cool though  I love this kind of crazy things 
Count me in  I'd love to meet some of you guys. Saturday 5th is ok, as long as its not in the evening. So far I count 3 votes for the new Wiki, and none for the other options. I'll go ahead and mark the Wiki and the stub on http://code.google.com/p/pybitcoin/wiki/BitcoinProtocol as obsolete, and start referring to bitcoin.it instead. Finding an implementation in Java that would not conflict with the BC version on Android was a bit hard, but I found flexiprovider[1] which has a decent implementation in Java, no idea if they use some of the speedup tricks. But for mobile devices being able to verify transactions involving my own address is a must have, and then using a simpler/faster algorithm would make sense :-)[1] http://flexiprovider.de/ Interested in comparing notes,  I would love to see your approach to it :-)  Yeah, I guess there's no point in changing the protocol in depth, but we can still add places to create backward compatible changes, make the protocol extensible.I had some pretty big issues implementing the protocol in Java, due to the endianness, but I worked around it, so that's fine, even if it's a bit of a byte array copy hell What I do hate however is the ever increasing version number. A new version of the main client increases the version and it is impossible to distinguish whether another implementation is still compatible, the version number should be used for the protocol version and not for the client version (there's the version string for that). Good point, I'm using the Android BackupManager to save and restore the wallet once it's implemented, so keeping things on a phone wont be too risky, just restore and transfer to another account :-) Wait a second, I thought this is about a full implementation of Bitcoin on top of Android and not some remoting. I'm implementing the whole stack in Java for a native Bitcoin app. As the original author of the pybitcoin document my vote goes to the Wiki too.  As for the evolution of the protocol it can only improve, little endian, strange design choices like unsigned int 64 length fields and then fixed size fields are a really strange mix. Also we need to create a minimalistic core protocol with places to extend (see the capabilities discussion on this forum) : make it easy for people to implement the core and make it hard to get it wrong! I was even starting to think about creating my own protocol with gateways to the existing one just to get it right with a well thought through structure.  Nice. Where was the picture taken? It looks incredibly familiar  Great I love these little toys Looking forward to see the first commit in the Channel Logs  +1 really disconcerting for new users As far as I know the FLOPS (floating point operations/s) are not indicative of the final performance since hashing is a purely integer operation. Is there a convention on which the transactions are ordered in the block? That might allow users to selectively fetch branches in the from other in order to get the same result as the block generator. Simply check if we by chance have the same merkle root, if not ask for the two child hashes, repeat. That might actually get the size down a constant length, but would put strain on the clients in order to check which transactions are in a block.Edit: might be time to split the thread in order to collect ideas for network improvements? It's not so much the block, but the collecting and verifying of the transactions. AFAIK only the merkle root will be in the block (source http://www.bitcoin.org/wiki/doku.php?id=bitcoins_draft_spec_0_0_1#block).I could of course be wrong since I'm only starting to implement the block verification now, and haven't dedicated much time to it yet. Please correct me if I'm wrong. My point exactly, if I had a better solution now I'd be happily hacking on my own version of Bitcoin, but I don't (yet)  I don't think Bitcoin is the ultimate solution. It will eventually disappear and be replaced by a new system. But I still stick to it, because now (and in the near future) it has value. Should a new, better, system be developed I'm sure the two will coexist for a certain time and allow people to transition to the new system, a few will stick to the old system which will lose value while the new one gathers momentum.We cannot foresee the future, but we can express our trust to the current system by investing in it.Right now Bitcoin availability for new Users and Services accepting Bitcoins are IMHO the major limiting factors. Acknowledging about the problem certainly the first step to solving it, so keep the brainstorming up ^^ Yep, that's the main downside, the complexity increases. We'd have to introduce a voting mechanism to collectively decide if a split should be done. Then we'd add selectively forwarding a broadcast to it's destination. and then a mechanism for the hash winner to collect the transactions he's going to sign.Basically I think we can already modify the client, without touching the protocol, just switch a few inner workings. As for the fragility of the network, if we have about 50 nodes at each vertex that decide to split the vertex should they reach 100 nodes or join together when going below 25 nodes we'd have a really stable network.Basically we can look at the current network as such a hypercube of dimension 0.As for the size of the messages, yes I know they are small since only hashes are broadcast, but when comparing a 32 byte hash against a transaction of 100 byte, that's not really much of an improvement, but its pull based design is really nice, and might help keep transfers low, and first of all it helps keeping size deterministic. Wow, nice analysis, it really makes me confident that we do have considerable room to grow. Being a distributed systems guy, I'm a bit concerned however about the waste of messages. As each transaction results in potentially O(n^2) messages (random broadcast) being sent around the network. Even if small that might result in quite a lot of traffic.My point is that we could easily create a hypercube structure with forced node membership (hash the IP and join the hypercube vertex that uses the same prefix) where each transaction is sent to the nodes sharing the prefix of the transaction hash. Should the number of nodes in a vertex grow too high just make a longer prefix (add a dimension) and splits the vertex. Scales well, transactions are sent to specific storage points and the winner of a hash can collect all transactions he needs when reestablishing the network consistency.Am I shooting completely over the target or is this a reasonable idea? A hugely popular Site with some pretty nice sponsors, this'll be interesting: http://rww.to/fXa5cv  Looks to me like a Map/Reduce framework with the storage being replaced by Bitcoin. This will only work when the peers are highly trusted, or the results are easy to check.If the peers cannot be trusted I could just take my slice and add advertisements or return garbage.
Would be nice through to add it in the details view  Yeah, but then you're back at 0, since you'd have to convince users that they can trust you. Not really a good argument, why impose the need to keep up, if simple changes can lower the barrier? Remember that if we can think of it, others will too, if we don't implement it, others will. And if they do you can be sure they'll start a new block chain, eventually surpassing our community in size, because of the added flexibility, and thus making all our hard earned Bitcoins worth less.Which is basically the implementation of a 2 hierarchical system as proposed earlier. It is by no means the definitive solution to everything, since even the inner network will eventually become too busy to handle the message complexity.Making everyone else pay? To be really resilient we have to make the network Dos proof, and while there is no definitive solution to this, we can make steps in the right direction. I actually think we're going at it the wrong way, the problem is not so much that micropayments are prohibited by the current implementation, that was just a reaction to people voicing the concern of a DDoS, which then actually was carried out (don't remember the thread right now).The thing is that the current network topology and message routing is not scalable and a large number of transactions will actually bring it to its knees. It just so happens that using a nanobitcoin makes it really easy to put heavy load on the network, hence the code avoiding small transactions. But I do see a huge increase of the number of transactions in the near future, and we will see the same limits be hit again.One of the very frequent questions I have to answer to is "how scalable is the Bitcoin network?" and my usual answer is that it isn't at all scalable. Simply the fact that every transaction is broadcast in a random fashion is incredibly wasteful. Were we to adopt a nicer system (pulling transactions only when a block is found, upstream aggregation, DHT style responsability sharing, ...) it would work so much nicer and would scale better.The current limitation on the size of transactions is just trying to cure the symptoms but the root cause can only be cured by a better structured topology, improved routing mechanisms and a reduction in message complexity! The base certificates should have been shipped with your OS or your Browser, otherwise it is not really secure, because you trust the certificate issuer that they are who they claim. Well and there I was assuming the really nice part of Bitcoin was it's being completely decentralized, by letting "banks" do the aggregation you not only create single points of control but also single points of failure. It's nice that they also act as aggregation points, there's no discussing this, but the system should be developed in a direction where it becomes better scalable and may potentially handle all transactions natively, as long as we're not there I'm be fine with having aggregation points but the ultimate goal should always be a currency handled only by the peers.P.S.: micropayments is not the only place this applies, basically the network does not care if I move 0.01 Bitcoins or 100 Bitcoins, but we'll incur the same problems when growing in the near future. Should I ever need to fill Bitcoin equivalents in my tax declaration I'll use the exchange rate at the beginning of the year, since I expect value to increase over time ^^ Well I think a set of small changes could make the bitcoin network scalable and add the ability for micropayments. First of all a structured network is needed since the just broadcast to everybody method used now is incredibly network intensive, then we have to split the network in two parts, one is composed of all generating nodes (they need to know all transactions) and non-generating nodes (just publishing blocks with aggregated transactions is enough for these). Also one might start thinking about segmenting the network by adding a second smaller difficulty which aggregates transactions in a small cluster which would then be aggregated and signed off by the core network composed of the current implementation.The current network design does not scale at all, we need to either change it or build a micropayment system around it  Well there is a way around all the hassle, just declare bitcoins a digital asset, which is then distributed among the employees And finally some people are seeing the need to embrace governments to survive  On what ground and what's bad about svn? svn does have an established community and many programmers are familiar with it, git just addresses a more distributed scenario, which is not always needed.I love bitcoins from an academic viewpoint, not so much the so celebrated anarchic, self regulating side. I can confirm the cryptopp_asm algo to be working and also got the shortest ever waiting time for a yay Code:$  ./minerd --userpass user:pass --url http://mining.bitcoin.cz:8332 --threads 2 --algo cryptopp_asm322 miner threads started, using SHA256 'cryptopp_asm32' algorithm.DBG: found zeroes in hash:78bf640434f5b45f8095269ed74d04ce23ea3fdaf6e16f0233006b8400000000HashMeter(1): 1336480 hashes, 887.16 khash/secPROOF OF WORK FOUND?  submitting...PROOF OF WORK RESULT: true (yay!!!) Nothing a good API couldn't fix ^^I love the idea   Just for reference again the logs for that moment: http://veritas.maximilianeum.ch/bitcoin/irc/logs/2010/12/20#l2461 Oh yeah, forgot to say: I got 2 payouts until now, so thanks slush ^^ Great news I was already dreading I'd have to setup a Windows machine ^^ Ultimate Mining Infrastructure: UMISounds cool, doesn't mean anything  Does anybody have a comparison on how Linux against Windows machines are performing when running the GPU miners? Oh please no! Automatically stealing a few cents per transaction would start the whole mess about the puddinpop cuda client again, don't worry I'll probably stick to opensourcing the core and make an ad based Frontend and give people the option to disable the ads by sending me a few coins :-)  First of all welcome ^^What you're computer is doing, when generating, is trying to find a hash matching certain criterias. It's basically a proof-of-work which is hard to do at first, but easy to check for everyone once you finished.Think of it this way: it's a lottery, and the winner will be the one that first finishes his work. He'll be the one taking all the transactions, checking them and if it all seems right he'll use his newly gained authority (lottery winner) to sign them off as accepted.He'll be the authority checking that no one is double spending in the network for the past ~10 minutes. For his work he'll earn the blocks 50 Bitcoins as a reward.The whole proof-of-work scheme is used to have a single authority that decides what transactions are valid, and which aren't, and having completed the proof of work all others will accept the decision. Also it is used to distribute the initial Bitcoins among all users, and not have Satoshi sell them (single point of failure). I'm glad that it has been cleared now, I really love your Pool and it works like a charm (for me). Just wanted to get everything on track and stop some whiners from influencing too many 
Well investing now in the generation of Bitcoins is a two-way bet: you are betting that the increase in generation difficulty  is not going to outrun the value increase at exchanges, both when the difficulty leaps to an incredible high, or the exchange price drops, you're screwed. Ok, just to make the situation clear, please post the amounts outstanding and which blocks they were generated in (if you know). So we can actually try to solve the mistery. If Slush would please confirm the amounts and blocks?Then we can start figuring out which blocks already matured (and are therefore eligible for payout) and which will have to mature first.I'm guessing this is not the case, but sub cent amounts will not be payed out, since it'll be seen as a DOS attempt by the network and thus swallowed whole as transaction fees. So basically you're running the bitcoind Process right? Also I guess we should create some alternative pools, as not to accumulate too much computational power in a single site, which would then become a single point of failure  That would be great, at least for people that are over their minimum payout limit with this block, but keep the really small amount back and allow specifying higher payout limits. As for the rest: great work slush, I'm happy you took the pool over 100% of the surveyed Bitcoin users said that heating with Bitcoin makes for a nice and cozy home  As far as I see it the Bitcoin client has 3 interfaces:The User interfaceThe API interfaceThe Network interfaceApart from the first there are others relying on the fact that the interfaces do not change, so I think that changes to them should be slowed to a regular update intervall and should be well documented, as it would be incredibly hard to reverse engineer them at every change.This is also supported by this ticket: https://github.com/bitcoin/bitcoin/issues#issue/5 Because sub 0.01 amounts will end up in the transaction paying process anyway so there's no point in paying them out. Well, that's a massive investment, are we sure that doesn't tip over the balance of Bitcoin? We do need to have the computation distributed among all peers. It's not that I don't trust ArtForz, he's done very much to improve Bitcoin, and he's trustworthy, but accumulating so much computational power in one place strikes me as insecure. Assume he disappears (casuality, governmental intervention, ...) it would leave the difficulty sky high, so high in fact that for months generation would not go back to it's regular pace, making transaction confirmation extremely slow.So for the good of the network and to keep other miners interested, please do not invest such large amount all at once. You can stay ahead of others, but don't crush everybody else. The rapidly increasing complexity is a good point, is there an estimate on how fast it'll keep on growing? Once everybody's using their GPUs in the free time the complexity increment will slow down, won't it?At that point longterm speculations might make more sense, I'll delay my investment until then. I'm actually just trying to figure out that sweetspot myself, there is a lot of overhead, so getting the GPU setup right is important: better GPU -> Faster payback of overhead but also more expensive upfront investment.I'm starting to realise that there is no single sweetspot, that fits everybody's needs. Wow this is pretty extensive coverage. But I don't get why you'd divide by 4@slush: I want to come out +/- 0 in the end, I love playing with new stuff, so it'd be just for entertainment. Problem is that the overhead of buying a new rig is quite high, so I'm trying to find the right balance between expensive GPUs and time to get the investment back. It's been quite some time that I've been wondering whether I dare to tip my toes into GPU mining. But since I only have my working notebook I'd have to buy a dedicated mining rig for it. So just to get an idea about what size of an investment that would be I wanted to ask you what performances can be expected from the various GPU's. To be fair please add the miner you're using on it, as to avoid flaming about which miner is better.I've heard a value of 625Mhash/s floating around for an ATI Radeon HD5970, is that realistic? Maybe I'll create a comparison matrix from the collected values ^^So let's get started: what are you getting? Well since there is no single person selling tickets to win the generation lottery (market niche? xD) it isn't technically a lottery. I'd simply say that it's a way to select an attorney that is going to sign and thus verify your transaction. Wow, how many people are living in Zurich? Including myself I counted 5 so far. This has to be the single most active city in the Bitcoin universe  Congratulations nanotube for the first ever share to be bought by BTC ^^ Just wondering, running the miners on 3 workers at 2 MHash/s each and after 24 hours I didn't get any shares? Sounds a bit odd. Tor?  7.5 BTC ^^ I quite like the idea, no one forces you to use the tracker but if you do, you'll have great seed count, even for old torrents. I think I'm going to give it a shot :-) Being on the move a lot I love using my Phone to catch up with latest news. Sadly forums are pretty hard to navigate on small screens, but there is a nifty little app for iPhone and Android that makes it easy to navigate Forums and write posts: Tapatalk.For this to work we'd need to add the SMF Tapatalk plugin to the Forum, and I was wondering whether there is interest from the other users and if it is possible that an admin could add it for us  Any comments?
Ok then here's my offer: I'll be delivering 6 (really good) Koestritzer to the first person bidding 110 BTC in the greater Zurich area  These aren't using the bitcoinr miners are they? It's using the standard JSON API, right? Well the award for the first Pizza paid by Bitcoin's already taken, somebody needs a beer delivery for Bitcoins in Switzerland? I'm pretty sure that I'll open source the protocol and wallet implementation, to improve reliability by peer review and augment trust in my code. What I'm still playing with is the thought of creating an Ad supported Android client, which would not be opensourced right away, since I know pretty good how that would turn out (people would just strip my ads and take the code and republish it without them). Since there is some serious time involved in creating the infrastructure needed to run an Android client (and the Java Protocol implementation for that matter) I think it would be nice to get something off it  Even if it's cold and twice the usual rate it still beats the Swiss Pizza delivery systems: they're incredibly expensive and always late! Nice to see that we're over the micro-bitcoin increments.Put down a 2.5 BTC for me ^^ ROFL, I like your thinking. But the idea was serious, most of the time people complain because of lack of seeders, why not let them put their bitcoins where their mouths are? Let them pay for seeders! The releaser gets bitcoins out of it and the users pay according to their ratio, users with a sharing ratio <1 pay for the download, and people with a ratio >1 get money for their bandwidth ^^ Nice to find people from around here, yes we should definitely grab a beer sometime.1'000 BTC is quite a large order, I'm not sure I can spare that many at the moment :-) Why am I starting to think about a private tracker that accepts Bitcoins as a way to say thanks, pay for leeching habits and reward seeders? 1.5 BTC If he doesn't I do: I hereby bid 1 BTC for 1 eBay Share :-)Would be nice to be the owner of the first share ever sold via Bitcoin ^^ Working on the Java implementation of the protocol: this protocol really has everything a Java Programmer doesn't like, lots of unsigned numbers (unsigned long requires to be mapped to BigInteger...) and little endian, which makes it particularly awful to read stuff from the wire. Anyhow today I read my first single message from the wire dump ^^I hope in the lecture break I'll find some more time to spend on this one :-) You're referring to this right?http://veritas.maximilianeum.ch/bitcoin/irc/logs/2010/12/14#l3216I already switched to the new server and it actually gives me a higher khash/s count, so my guess is that previously the server was slowing me down, while controlling my metahashes ^^ How many would you buy and where do you live? I myself live in Zurich so if your from Switzerland a meeting wouldn't be that far off ^^ I would like to change that: http://bitcointalk.org/index.php?topic=2183I guess a new address/account is good for sites keeping balances for their users but a reference id would be nicer, wouldn't you agree?  I myself banged my head against Wikipedia not allowing self published articles as references, but I understand the reason. I for one would love to have a respected expert take a look at it and actually put it under test, at least we'd know what we're all putting time and money into  That's settled then ^^Looking forward to join the pool. I'd be willing to host one of the pool miners, but I'm a bit strapped for time in near time. Also I'm wondering what resources I need. I can create a virtual machine with quite some resources but I cannot use all of the resources. May I host it through Tor? A really easy way would be to release a statement distancing ourselfs from WikiLeaks, we don't want to do that either.Let's just see if Wikileaks jumps aboard, if so, let's make the best of it (press notbaility, influx of new users) and if not, we'll still be at the same place we were before. I guess that the whole discussion is going a bit awry, I'd hope that stores would put up a small access point for people to connect to when checking out. And actually there could be a lightweight setup keeping transfers low (do not request blocks you don't know yet) and just contact a single node which gets the transaction from you. That would allow people to quickly send transactions. As for the receiving side there is actually no way to tell it went through without listening for transactions and blocks.With this setup spenders just need to transfer something in the order of 1-2KB, using 3G or even GPRS, while the receivers need an internet connection.
Well if there's one thing I fear more than little old men, it's hundreds of skript kiddies going at it with LOIC (such unsofiticated tool isn't it?). I guess if MyBitcoin does not want to be associated with Wikileaks that's fine by me, but we do not want Bitcoin being associated with censorship and closed mindedness. I think we should definitely add a warning not to use MyBitcoin addresses until the problem has been found. I guess whether or not Wikileaks will adopt Bitcoin as a way to collect donations is out of our hands, it might be a huge popularity boost, but it may also bring the system to it's knees (speaking as a major critic of the current network topology, and as one that fears the wrath of little old men from Capitol hill).I think we should make it clear that just because Bitcoin may be used by some shadowy figures we do not want to be solely attributed to them, we work for the great positive aspects that are coming out of Bitcoins. That's the beauty of an open system, it may be adopted by whoever wants to and no one will be disallowed from using it. I'm currently working on a Java implementation of the Protocol, which in the end should end up in an Android client. I'm however not planning on releasing the Android app as open-source since I quite like the Ad supported software, but I'd be willing to open source the Protocol implementation with all it's hooks to add it to an application. Benefits would be a clear interface on which other people could build their clients, a peer reviewed Protocol core, for better quality.I guess with that I'm not eligible to claim the Bounty?   Just a minor correction, the name Bitcoin (or bitcoin) is used threefold and should be clearly stated:There's Bitcoin the Protocol: the underlying communication agreements and mechanisms that are platform and software independent, well sort of, as soon as we get alternative clients.There's Bitcoin the Software implementation, what I like to call the main stream client, written by Satoshi and maintained by the community on this ForumThere's bitcoins the actual currency unit managed by the clients in the network.So before starting the wikipedia article I think we should be clear about what we are writing for. I'd say the network as such is more important than any single implementation, and we should write about Bitcoin the Software as a section in there, and not make it the main character in our narration. Here we are with the Language war once again. Please just stop!As for the topic, yes please get an alternative implementation started, the more the merrier Maybe some good code actually makes it out there, helping future generations of clients to build on top of your code.+1 on the D implementation (I'm starting a Java one in the holidays) That was on purpose :-)Yes off course the reference ID would have a fixed size. Therefore comment might be the wrong choice for a name, I chose the title mainly to catch the eye of all interested people. Hashes would be one way to go, but as stated above I think UUIDs is the way to go, because Hash always implies something else being hashed, question is "of what?" whereas a UUID is easy to generate, there is no attempt to associate it with anything else. Sad but true, it's gotten incredibly hard to generate coins, which can be frustrating to new users. I think the Pooled mining effort is a really good idea :-) Actually no, I believe the problem is more likely that the library is linked against a different version of the Sun JVM. The headless problem can be easily solved using -Djava.awt.headless=trueSince GeForce are buggy I will wait for them to work before having another go  It should be possible, but since we're linking statically I'd rather have it as an intree version as to not give people the impression that we provide a fully functional wxWidgets build.I haven't had a shot for some time, I might try again these holidays  Well a reference is part of the transaction, so it should be in the main chain. There is no "reference chain" to add references and comments to the transactions in the main chain is there? I agree that the main chain should only be used for the main Bitcoin purpose which is tracking and exchanging Bitcoins, but IMHO the comment/reference is just as important as the amount being spent. Using an address per transaction is actually more of a hack than adding a comment would be.So I guess you'd vote against it on behalf that it opens the discussion for a lot of other "nice to have" data in the transactions? Ok, right now there's a huge discussion going on in http://bitcointalk.org/index.php?topic=2162.0 and I would support the changes to accepting only standard transaction would it not disallow exactly what I've been looking for: the ability to reuse a BC Address for multiple transaction and being able to distinguish their purpose.Admittedly it's a hack, but a rather clever one, it was possible to insert a comment to a transaction followed by an OP_DROP which would remove it when checking the TX on the clients.Why would one do this? Right from the terminology it's clearer, I wouldn't create a new bank account just to receive a single payment from someone, what I'd do is give him a payment slip, with a reference ID, and I'd later check if I have received a transaction with that ID.And for the more practical minded people, it's safer! Why? Because if you generate a new address for each transaction, and you then loose the wallet, but have an old backup, in which the new keypairs aren't, you will be able to recover the Coins that you have received for keypairs in your wallet but the new ones will be lost forever.You see it's rather more logical to separate transactions and accounts (as the new name suggests for addresses).I therefore put it to a vote to include an official means to add a reference ID into transaction should one be supplied. To keep it simple and to keep the block chain small we could agree on allowing UUIDs in their 16 byte representation as IDs.Any comments? Basically this is duplicating the work we are doing on the bitcoin URI scheme. Since we can encode the URIs can easily be represented using QR codes I think we should stick with the bitcoin:-URI Scheme  Just my 0.02 BTC Actually the openSuse Build Service is more meant for packages that have to be reliably built for a multitude of systems and updated consistently across all of the distros, but adding a small cron job can pull SVN and push the changes to the Build Service, kicking off a recompile. I wouldn't abuse it though.I think we should sooner or later add a continuous integration tool, to check code submissions against the (until now inexisting) unit tests. That would also be able to create nightly builds ^^ I have got access for a limited time to a small cluster running some Geforce cards, and I'm wondering if I can get your miner to work on them at night. Problem is they are debian machines and they are headless. The headless is not so much a problem since I can run Java in headless mode, what is a problem is this:Code: ./DiabloMiner-Linux.sh -u bitcoin -p xxxException in thread "main" java.lang.UnsatisfiedLinkError: /bla/DiabloMiner/target/libs/natives/linux/liblwjgl.so: /usr/lib/jvm/java-6-sun-1.6.0.20/jre/lib/i386/libjawt.so: symbol awt_FreeDrawingSurface, version SUNWprivate_1.1 not defined in file libmawt.so with link time reference        at java.lang.ClassLoader$NativeLibrary.load(Native Method)        at java.lang.ClassLoader.loadLibrary0(ClassLoader.java:1803)        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1728)        at java.lang.Runtime.loadLibrary0(Runtime.java:823)        at java.lang.System.loadLibrary(System.java:1028)        at org.lwjgl.Sys$1.run(Sys.java:73)        at java.security.AccessController.doPrivileged(Native Method)        at org.lwjgl.Sys.doLoadLibrary(Sys.java:66)        at org.lwjgl.Sys.loadLibrary(Sys.java:82)        at org.lwjgl.Sys.<clinit>(Sys.java:99)        at org.lwjgl.opencl.CL.<clinit>(CL.java:51)        at com.diablominer.DiabloMiner.DiabloMiner.execute(DiabloMiner.java:185)        at com.diablominer.DiabloMiner.DiabloMiner.main(DiabloMiner.java:90)Any idea as to why? If you're interested in getting a few bitcoins right now there's the faucet https://freebitcoins.appspot.com/, it isn't much but you can use the bitcoins to start playing with them.Also if you prefer having a few bitcoins distributed more or less evenly over shorter periods you might want to try joining a generation pool, where all users contribute to one client which then divides the 50 coins according to who contributed what. http://www.bluishcoder.co.nz/bitcoin-pool/HTH I guess we have the first official release that is disputed by the majority of computation power, Bitcoin's coming off age :-)I do however like that the changes are communicated in an open and unbiased way. One thing that would be nice is to have links to the particular Threads, Checkins, whatever to be able to track/understand changes more easily. That's why we need moderators. The discussion about a unified URI schema for bitcoin now is spread over 7+ threads and it's getting really hard to follow the overall discussion.Please continue discussing the bitcoin URI scheme here: http://bitcointalk.org/index.php?topic=55 We are currently having a discussion on how to make the BitCoin protocol extensible here http://bitcointalk.org/index.php?topic=894.msg27723#msg27723 .I personally don't have anything against extensions to the protocol, and services built on top of it, but it has to be clear that they are extensions that may not be implemented by all nodes in the network. The goal I think should be to keep the core protocol small and easy to implement, and then give people the ability to add their functionality on top.However I think distributed storage would be a stretch, and it would certainly slow down the network as a whole.One idea I can actually see happening is a decentralized DNS replacement as discussed here http://bitcointalk.org/index.php?topic=1790 Well making the network extensible is a way to allow evolution while keeping things backward compatible. 
Well the trick is to make the base protocol incredibly solid and easy. Just make it hard to get wrong. Then give people the ability to build their protocol extensions on top of that, all the while requiring that the initial minimal set of functionality must be maintained compatible, and then you'll have a good protocol that challenges people to improve it, but not to break it.I think the capabilities extension is the way to go   What exactly is this used for then: http://www.bitcoin.org/wiki/doku.php?id=bitcoins_draft_spec_0_0_1#variable_sized_data ? I'd be interested too, please PM me with an address and I'll be sending the coins. Any idea on how long it takes for the signups with invites to be back up? I wonder when they changed that one. It was incredibly hard to get the size out of the message, and we had to switch between size length according to the first byte. I'm quite happy that my proposal finally got some attention :-)+1 for the capabilities.The Protocol spec should have a minimal set of instructions and an overall message format, while all the rest should be built on top using capabilities or as they are called in BitTorrent protocol extensions. And I'd rather use an array of descriptive names instead of the bitfield bittorrent is using, but that's a detail. You could put haproxy [1] in front of both servers so that the less charged one gets new connecting clients and you even have transparent failover :-)[1] http://haproxy.1wt.eu/ Sometimes I cant resist but question satoshis choices: a UINT64 size field? It's incredibly hard to implement in Java ( well not really BigInteger helps) and do we really need messages larger than 4GB (4 bytes)? UINT 64 would allow for messages of 18.45 Exabytes. That's more than all the world movies put together.I think I'll simply drop messages requiring UINT64 sizes. Theymos went ahead and added his, previously pastebin hosted, schema definition to the Wiki, I guess we should really start thinking about merging all the ideas before someone start implementing the one rather than the other and we end up with completely incompatible URIs. I wonder what this might mean:Any ideas? Not to mention the ed2k links on filesharing sites. I guess all these schemas have a right to exist in their communities and sometimes a schema becomes ubiquitous. As for the Mime idea, it sounds a lot like the VCF cards that were meant to be used to exchange contact information but they are rarely seen today, whereas microformats can be found all over the web.So +1 on the bitcoin uri schema. Tor Hidden Services would have my suggestion too. It allows hosters to allow access while being hidden from prying eyes   Let's try to keep this thread alive and unbury it with new findings while we go along. One fact that I stumbled over (for several hours today, hurting myself as I went) is that all numbers in the protocol are not encoded in network byteorder, but rely on little endian. I guess that would be pretty important if we are to create a documentation.I think there are two ways to look at the protocol, a high level one, where everything is expressed in nice words and comparisons, and another dearly needed one that details the actual information and format on the wire.One nice detail to add is for example that each messahe starts with a 4-byte magic Code:_magic = '\xf9\xbe\xb4\xd9'.Also in the original design a lot of attention went into how the size of a message is encoded:Code:    def getSize(self):        first = self.getUByte()        if first == 255: return self.getUInt64()        elif first == 254: return self.getUInt()        elif first == 253: return self.getUShort()        else: return firstBut message types are simply encoded with a padded 16 byte string. So I'm starting to wonder about the design choices. Why make the size field optimized when the other part of the message is large always? No offense intended, but this kind of things just make it hard to implement.Oh and when using Java you might pay close attention on how to read unsigned data types (again, something I had to bang my head against before realizing my error  ) While this is certainly useful for a site accepting donations it'll not be a solution for Online Shops because the receiving end of the transaction has no way to distinguish payments, and where they came from. For this purpose it is solicited to generate a new address for each transaction, which in DNS and link-rel is not a given. Seems to be ok: +1 I'm all for a specification of some kind of the protocol. We gave it a first shot when trying to get a working Bitcoin Client to work with pybitcoin, but it turned out the protocol is both complex and hard to understand at times. Also a high level overview of how the different scenarios play out would be incredibly helpful.We do need alternative clients for the Network, as proven by the huge interest in a native Android client, and for that to ever happen we need a specification of the underlying protocol. Eigentlich wollte ich die ganze Debatte auskuehlen lassen indem ich nichts schreibe aber ich denke da muss ich stellung nehmen. Ich bin seit Block 1500 dabei und insofern hatte ich's einfacher Coins zu generieren (keine GPU Miner, keine Cluster, ...) aber damals war das Zeug auch absolut nichts Wert, von daher ist's verdient weil man Zeit und Resourcen in ein System mit ungewisser Zukunft gesteckt hat, und einfach darauf gehofft hat es Zahlt sich aus.Es war eben Goldrausch ^^ So shall we put it to vote which URI schema is to be used and promoted by us (the Bitcoin Forum users)?Putting things together options are:bitcoin://IP:port?addnode=1 only applicable to directly invoke commands on a running mainstream clienthttp://127.0.0.1:8330/?to=<bitcoinaddress><separatorchar>1.2.3.4&amount=200.00 again quite limitingbitcoin:1U1jTCGkQYRaDVStZdDHMFWUMoSJi4HSc?dn=MyAddress&amount=10.00 Bitcoin address as main information, everything else is optionalbitcoin:period=12,monthly;address="me":17ujzChRb6VPQGyANVyktc1du2Hrjfwhsz,"friend":1FaBVwRg99UcH332AV6BSWmDCnTRHdro5B;amount=1.23;title="subscription to bitwow" same as above but without the address as main entity and with colons, semi-colons and commas as separator (basically a hash set)Did I miss something?Also I think before voting we all should agree on what resource (URI is Uniform Resource Identificator) we are actually trying to describe. The first few proposals concentrated on how to issue commands to the mainstream client, whereas the latter (to which I personally tend) try to describe a bitcoin address, along with additional information, that could be added to an address book and could be printed to receipts or invoices.I'll start a poll once we gathered all proposals   Thanks theymos, this is a great tool. I've been playing with the idea myself, but I'm happy you were faster :-) Any chance of pooling resources in a joint effort? 1 really good app >> 5 average apps :-) I was thinking on working on an Android client (not just an interface to the desktop client, but a standalone client), so I'm intrigued by the Bounty.Sadly I'll only have time after christmas, so I'll contribute if someone's faster than me.One more thing: conditions have to be a bit better specified. I'd go for standalone app (no desktop client needed), manages it's own wallet, barcode scanner that recognizes the URI format, anything else?
As much as it must hurt for Americans but they are not the only players in the field. Sure if the so feared MiB are the only ones interested in taking over the entire network we'd be in trouble, I therefor suggest making Bitcoin a Project of interest to other nations as well. Should it ever become important enough I can see coalitions of agencies keeping a close eye on what the others are doing in the system and out balancing each other.So the options are really twofold: keep under the radar or become prominent enough to gain vetting from multiple parties with comparable investment powers :-) So now the question is what kinds of central authorities can be replaced by this type of quorum? Since more and more of these ideas to uniquely acquire some virtual resource appear, why not abstract away the entire, domain specific, logic and just create a service that does p2p proof of work all day long, on which the services can be implemented? It might help strengthen the main chain, by basing multiple applications on it, and might reduce the repetitive work for each system, since the basis is already there. Ich finde zwar die Idee neue Benutzer zu "kaufen" indem man ihnen ein starterkit gibt nicht schlecht, aber leider seh ich das Potential fuer Missbrauch. Sobald es auch mehr services gibt die Bitcoins auszahlen wird das ganze Huhn-Ei Problem auch in den Hintergrund geraten, aber bis dahin muessen wir uns mit dem Faucet zufriedengeben.Und als programmierer und early adopter find' ich es ausnahmsweise sehr angenehm dass meine Arbeit auch mal "bezahlt" wird :-) Just for reference, the discussion on IRC starts here http://bit.ly/9qjLL5 I'm pretty interested in having a good URI schema for Bitcoin addresses. I think the most fitting would be somthing like this:Why? The address is clearly the only really important thing about these URIs, everything else is just cosmetics it is therefore comparable to the authority in URLs. Everything else is just additional (optional) parameters. Some common ones should include:dn: descriptive name, a name for the address, so that it is easier to recognize in the address bookamount: only really interesting when actually having a payment (think about an invoice)ref: a URI to the resource containing details about the transaction (only in combination of amount). For example to point to the invoice Of course I'm open to suggestions :-) How did you arrive to this result? This is great news. Time for me to dip my toes into OpenCL mining :-) +1The request is certainly reasonable and we would get a leaner, cleaner, main stream client, with less dependencies and easier to distribute, also the modularization proposed by some people (Wallet manager separate) would be desirable for people trying to implement their own network, wallet or mining clients as long as the communication interfaces are well documented. Still working on it but 2 jobs and my studies are taking their toll on free time to spend on Bitcoin related projects. People offering to help understand the protocol are always welcome: http://code.google.com/p/pybitcoin/wiki/BitcoinProtocol Damn Oracle, I started to hate that company...Anyway, I guess we're better off with the FSF for now. I think the main problem is that currently we have a single client that can be used. This puts a lot of trust in the developers of this client. So what I think tentative is alluding to is the possibility that the developers may become greedy and release a modified version of the client that plays unfair and gives them a certain advantage. The problem with proving this is that users are not forced to update to the latest version if they do not trust the developers, in fact (except for bug fixes) people could run their current client endlessly, since the protocol itself seems to have solid foundations.As soon as we have multiple implementations the trust that we have to put into the developers of any of those clients is reduced, but sincerely I don't see satoshi turn evil anytime soon  We are philatelists, only that we collect signatures :-) Bitcoins are a way to trade without intermediary on the Internet According to http://www.ccc.de/de/office: Incredibly bad idea, as suggested above microformats is the way to go, since it's standard compliant XHTML 1.0 strict and it is easy to process. Ok, I created a regular expression to replace IPs so they should not appear anymore. If the replacement does not work, please tell me and I'll fix it as fast as possible  Oops, I'm incredibly sorry, I will ofcourse remove the ips. I've forgotten about them, but since the logs are not indexed by the search engines it shouldn't have too many repercussion.  It's more like:The rest sounds pretty solid  Ok, I'll be releasing the logs starting from October 1st, I have them from 1st September but since it was undecided then I'll leave them out as a grace period So here you go: http://veritas.maximilianeum.ch/bitcoin/irc/logs/Comments and requests are always welcome 
Interested in creating a MicroFormat for BitCoin payment options? Na dann oute ich mich auch mal als deutscher :-)Wenn wir schon mit sport anfangen, hat jemand interesse an einem Wettportal mit Bitcoins? Oh I'd love to get the CCC on board with this :-)I'm German so I could help out, but my formal german got a bit rusty and mixed with italian (long story don't ask   ) theymos is right about the code having to be readable by the processor, but this is possible by using smartcards which have their own processor and only talk through a well defined interface, never revealing important parts of their internal data. Sim Cards are probably the most widely used smartcards right now, and they hold a shared secret between you and your service provider, would someone be able to clone the contents they would be able to listen in on your communication.Anyway for a game I'd use a server that awards the coins upon completing a level, since it does not require special hardware on the client side. +1 Well the problem is that there is no typical CPU, or typical GPU for that matter. So you'd have to write down exactly your configuration and test that same configuration against all miners. I was thinking more in terms of list the requirements, and then what you usually get when fulfilling the requirements. It's not meant to be precise, it's just indicative of where users can go with certain miners. If results then vary +/- 10% the user wont care.It's a wrapper around the Main client, not a miner flavor.Looks like the patch by puddinpop, I have no viable benchmarks on this one.I'm quite interested in this one, would like someone with a good GPU posting some benchmarks.This is the main thread I took the idea from, but except puddinpop's code, it's all just generic talk.These are improvements to code that exists elsewhereAgain just a fundraiser for puddinpop's code.This one I actually didn't know yet Prehistoric thread on how to build the main client on Mac.Anyway the wiki is open, feel free to add anything important Oh and since I don't have a GPU in my notebook (not one I could use anyway) I'd be especially interested in benchmarks of the CUDA and openCL miners, since I can't provide them myself. Since I myself am losing the oversight on the various miners that are currently available or in use I started a wiki page that might introduce users to alternative miners: http://www.bitcoin.org/wiki/doku.php?id=bitcoin_minersIt would also allow us to collect some real world comparisons about how they perform against each other Feel free to add yours   Is there a plan for this to be merged into the main tree at some point? I don't think we should question satoshi at every step. He gave us this great protocol (it's no more than that actually) and that's it. If we are not happy about a decision, we can change it, should the network deteriorate we can switch. Satoshi's done very much, and I don't think he has all these evil intentions everyone is dreading. I understand the need to be skeptical sometimes but in this case I think we have a fairly good idea of what satoshis intentions are: creating a nice little payment system that could one day be able to compete with the big players out there, not the world domination   Well it's after all a dev channel, so probably we should create a public discussion channel that would not be logged. As a developer myself I find it quite usefull to refer to earlier technical discussions, so a single link can replace having the discussion all over again :-)Anybody against the channel split? Just adding myself to the game 1DEcTfUsHpPscf1qC2BE1v5JugweEyQVcr No I only have a smaller brother, and he's not listening in *ROFL* I seem to miss the point. Please tell us these reasons to either convince us to change our minds or create a public debate as to why they are relevant :-) I guess we all agree that as soon as we write something in the channel or here on the forum, it will be associated with our pseudonym (nickname), so yes we could add additional barriers to recognize the person, heck we could even replace all the nicknames by their Numeric ID, and the discussions would still be meaningfull, however such a mechanism will be hard (if not impossible) to implement, and buggy.I will of course remove all mappings from pseudonym to IP address (IRC Join, Part, Whois, ...) but I guess keeping the nicknames in place would be acceptable for everybody, unless there are more people requesting rot13 on the nicknames, I'm always open to suggestions ^^ The main problem right now is that the network is completely unstructured, there is no guarantee that the network will not split and then continue on two different chains. This is a problem since any coins generated after the split will not be accepted by the other networks. If this happens often enough the whole system becomes pointless (what's the point of having 1m coins if you have nowhere you can spend it?).Also the fact that each transaction is broadcast to all clients will never scale. For Bitcoin to work properly the node that signs the block must have all transactions.What I'd like to see is a structured network (think torus or hypercube), at whose joints we create highly connected clusters of machines to be redundant, then each of these cluster tracks a certain prefix. Once a hash has been found the node that wishes to announce it just fetches all unsigned transactions (echo-algorithm), signs it and floods the block (hypercubes have incredibly efficient flooding, remember?).So to restate the constraints:We do not want to allow network segmentationA node that generated a hash does have to know all transactionsTransaction fetching can be delayed until a hash has been generatedA block (hash + transactions) has to be broadcast to all nodes in the networkAdvantages of a Hypercube with node clusters:Highly redundant transaction tracking (depending on the size of each cluster)Flexible dimension (should a cluster become too big we just increase the dimension)Very efficient routingVery efficient broadcastLogarithmic storage needAnd yes, I think the network topology should be documented and evolved on its own Wiki page :-) +1 The log files are not indexed by search engine indexers, at least not the big ones who respect the "Robot: nofollow, noindex" headers so there shouldn't be a huge problem. So far we have the following standing:For logging: 8Abstained: 2Against logging: 2Strangely most of the people that agree on logging are from coming from IRC. In some cases I was unclear on whether you're for or against logging so there might be an error on my side in a few cases, so please correct me :-)As for the censoring, I'll do my best to come up with regular expressions to wipe personal data from the logs (telephone numbers, usernames that requested it, ...), but I can't guarantee that it'll work perfectly  We are in fact trying to build a small network module to interface the BitCoin Protocol in Python, if you'd like to help feel free to contribute: http://bitcointalk.org/index.php?topic=231.0 robots exclusion: noted 
So far we have 3 pro and 2 con, not really decisive. I'll add an onjoin notice to the bot pointing to this thread and should it go through I'll replace it with a notification and the URL of the archive, so that everybody is warned   I think we all agree that setting the system time is a no go, but why can't we just use an offset internally and just circumvent the whole issue? We already have ways to synchronize (approximately) the clients, so why not make use of that? This is probably one of the best reasons we should switch the main client to a more restrictive license, that wouldn't allow to redistribute a closed source client based on the original client.Anyway am I the only one who's wondering if the reported performance is actually what is going on under the hood? It doesn't take a lot of effort to just multiply the real number of khash/s by a constant factor, which would urge people to use the modified client which in turn sends part of the coins to the author, without providing actually any benefits?Has anyone verfied the odds of generating coins with the theoretical number [1]?[1] http://www.alloscomp.com/bitcoin/calculator.php While I agree that reverse engineering is always a possibility, protocols can be licensed under different Intellectual Property regulations, that may or may not include licenses (see patents...) There would of course be the way to simply redact all lines that contain the usernames that chose not to participate. There would be a limit above which the logs become completely useless but if there are a few people who decide they can't be hold to what they say in a public chat it could be a simple solution. I'd go for a small server that returns a unix timestamp, the client fetches it, computes the clock drift (difference in time) and all the protocol related times are based on that drift. The clocks would still drift a little (they'd do it anyway on the system clock) and we would not get perfect synchronization (impossible in distributed systems), but it would solve our current problems.The code is about 5 lines and some simple math (sums) when calculating the timestamps. I still think we are talking about two different components:The clientsThe protocolThe protocol is open (not well documented but it's out there), while the clients do not have to abide to any special restriction AFAIK. Even if we were to enforce a license on the clients by adding a special clause to the protocol agreement, there would be users that modify an open source client, but then they don't sell it so that they can still keep it closed source.In one of my projects we are using the RPL, which isn't open source in that sense, it specifies that any modifications to the project have to be shared with the original community, but still that doesn't avoid a client being kept closed source from the start.Once the network has grown enough it'll get really hard for a single entity to ever tip over the balance like ArtForz because there are more people with the resources and they will compete for the top spot, and thus balance things out.How about a bounty for both the best performing source enhancement and for the best performing community driven rig? Something like the Netflix 1'000'000$ bounty for code improvements? While I'm not really concerned about the privacy of such a log site, since it's an open for everyone chat, I do understand people that are questioning whether it should be done. So before collecting the logs from previous months we should clarify whether the users want the archive and if we should extend it backwards in time (collecting logs).For me personally I'd like to start from lets say the 01st September since then we'd all have a say in the issue, and we'd just forget about the logs that were created before this agreement So please just tell us how you feel about the archive   The Network as it is right now appears to be a random graph with fixed node degree (8 connections each host), this indeed will never scale, and we have to find a better structure. eDonkey and others fixed it with a two-hierarchy network with supernodes and nodes, while this might solve some issues I don't think it's perfect. I'd rather go with hypercubic networks as they are truly P2P and have no single points of failures. I think we can generalize the idea: having multiple currencies is an additional roadblock to the adoption when it comes to interchangeability. If on the other side you intend to create a parallel community that does not aim to be interchangeable world wide, it might be in fact advantageous to split from the main chain.Having multiple currencies create problems since then you'd have to exchange what you have for the currency the seller expects, and if such exchangers that have the right amount available are scarce there is the opportunity to have a personal gain.I'd stick to the main line as long as possible, to facilitate ease of use and attract more people. Just thought: why not create a poll? So here it is: https://spreadsheets.google.com/viewform?formkey=dDdnZmtuWTA2bnVhTy1sU2NNZjN1RGc6MQThey should be pretty anonymous and I'll publish the results and the raw data   Great, thanks for the support guys. As for the aforementioned reverse engineering of the protocol, it's located on Google Code http://code.google.com/p/pybitcoin/wiki/BitcoinProtocol.We were considering putting it on the Wiki on bitcoin.org, but we thought it important to have it as redundant as possible, and we'll try to contribute the details back to the mainstream client and the local wiki.We are far from knowing all the details of the protocol, so every helping hand is welcome   We're trying to reverse engineer the protocol so we can create custom clients, that will work together on the main network, to create some competition, and to allow for lighter clients running on a wider range of devices.I'm personally against forking the network for each client as it segments the network, in the meantime weakening the main network. I don't see the objection about failing clients to be actually to comply with the protocol to cause problems, because if we don't exercise all possible scenarios, someone sooner or later will come along and cheat the others. It's about strengthening the protocol by checking the boundaries, and it's better that we expose these issues to the developers of the various clients, than someone abusing and keeping the issue silent. My point exactly, the protocol needs to be standardized and well documented. In its current state the Protocol would pass no standardization process anyway, variable headers with/without checksums, variable length size fields, 30% of all fields are just placeholders, ...Anyway I'm trying to work on a python client that has no dependencies except the default python installation   @lachesis: I started my own bitcoin client to play with the protocol and I have to say you did a great job with your Writer and Reader classes, I adapted them slightly as to have a socket writer/reader and a string writer/reader, they are just so much easier than to use pack and unpack all over the place ^^ Ok, some of you already know that we are trying to create an alternative client in order to play around with the network a bit, and try to diversify the way people build on top of the bitcoin network. Currently we are trying to create a python client that interacts with the network, but does not itself participate in the race for the next block.Now we noticed that the whole protocol is layed out for only one client, so for example the client version is sent in the initial handshake as an integer. Out idea would be not to use that version number as the client version but as the protocol version the client is using (right now it's 310), this way clients could agree on which version of the protocol to communicate with. Another improvement would be an additional message that would simply list all the capabilities the client can understand. This way the underlying protocol would be decided by the version integer and then clients could allow or disallow extension. There are already many ideas for extensions on this forum, a broadcast mechanism for example that would alert old clients that there is an update, ...All in all it would allow us to make a more effective use of the network and gradually add new feature, without having to go through a whole release cycle.What do you all think? It would be a great help for the packagers and people upgrading if there were a changelog in the repository itself. Right now it is extremely timeconsuming to scour the commit log and then try to find out what changes relate to what patch, contributed by whom and where to get more details.Also a tasktracker or issue management which to refer to when talking about bugs, improvements and similar would be nice. One simple solution would be to let the Client generate a new address but tell him not to use it, then transfer the coins to that address, and then send the details (pirvate key, address, ...) to the recipient, using whatever transport you want. The recipient then imports the data into his client and can receive the coins  I'm a huge fan of the Soekris Boards, and there is a new version coming out in autumn: 1 Ghz completely fanless  Yup, the real strength would be CUDA/OpenCL enhanced code making use of the Graphics Cards.
Your right of course, I was grepping for PushMessage(" instead of strCommand Apparently though subscribe, sub-cancel, publish and pub-cancel are never used in the code, at least I was unable to ever capture one of the messages.By the way, the "version" message does not include a version number only a string, where is the version number transferred? Since the most common question is about where to get a stable version for the respective operating systems and distributions, I thought it might be a good idea to start collecting a number of repositories into a reference thread.My nightly builds from SVN (not stable, but always up to date) are on the openSuse Build Service (https://build.opensuse.org/package/show?package=bitcoind&project=home:cdecker). Just add the respective line (the one that matches your OS) to your /etc/apt/sources.list file:After an "apt-get update" you should be able to install bitcoind (the headless daemon).Please list your builds and their specialities (patch level, revision, ...) The ability to auto update the client would be nice for Windows users, as for us Linux users it's already a default that we have auto updates through our repositories (I for one push a new version of the Subversion code into the openSuse Build Service once a day, so people using my repositories always have the newest clients)   GUI builds are quite a bit harder since they also require WX to be built along with it.I'll try to create a statically linked version on OBS soon. I started the Wiki page here http://code.google.com/p/pybitcoin/wiki/BitcoinProtocolSo far we have the version message pretty worked out, except the nLocalServices, nLocalHostNonce and the nBestHeight, which I can't fathom what they are used for.As for the other messages I have identified these so far:versionverackgetdataaddrinvgetaddrblockpingreplysubscribesub-cancelpublishpub-cancel Thanks mate I'd go too with websites offering escrow services. The network is quiet complex as it is, without having to add all the confirmation, delay and dispute stuff.Currently when a transaction is broadcast it'll sooner or later be added to the block chain, what you are asking for is a mechanism to tentatively add a transaction and then dispute it later.Also who do you think will be the third party moderating the dispute? There is no real advantage in adding it to the protocol itself. 32Bit and 64Bit versions for Ubuntu 10.04 are available on the openSuse Build Service: https://www.bitcoin.org/smf/index.php?topic=644.0 I finally managed to get the openSuse Build Service (OBS) to build working nightly packages of bitcoind (the client without the wx GUI). openSuse and SLE will follow soon.To install the Ubuntu packages add the following line to your /etc/apt/sources.list:Code:deb http://download.opensuse.org/repositories/home:/cdecker/xUbuntu_10.04/ ./Next update:Code:sudo aptitude updatesudo aptitude install bitcoindIf you get a warning about not being able to verify the validity of the packages, just ignore them, I wasn't able to find the public key yet :-)Then just create a config file ~/.bitcoin/bitcoin.conf to configure the RPC password:Code:rpcpassword=<yourpassword>After this just start the daemon viaCode:bitcoindand control it using the JSON interface.I'll be trying to create openSuse and SLE packages too, Debian would be possible too, but compiling wx, boost and libdb sounds a bit excessive to me, anyone interested in helping? Would you add me to the maintainers of the project on launchpad? My username is cdecker and I have ready built deb packages from my efforts on openSuse Build Service http://bit.ly/bUqiRY Great point. I got the bitcoind (without the wx GUI) compiling for Ubuntu 10.04 I'll try to get the other version to work too, but it's quite annoying that BC needs such a new version of libdb and wx...https://build.opensuse.org/package/show?package=bitcoind&project=home:cdecker The on google code or github wiki looks very nice to document our efforts. Could I get access to it? Thank you very much.Using this I finally managed to get the openSuse Build Service to create a running version of bitcoind for Ubuntu 10.04. Hopefully some more systems will follow, but there's always the problems with the dependencies.https://build.opensuse.org/package/show?package=bitcoind&project=home:cdecker Great, I was able to reconstruct the IP address from my dump and it turns out correctly. So just to sum it up:version{0xf9,0xbe,0xb4,0xd9}"version" (0x00 padded)4 byte message size4 byte checksum8 byte nLocalServices (always 1 if !fClient, no idea either what that means)8 byte timestamp (remember to use network byte order)Remote address (the address this Node thinks he is):nServices - uint64 (8b), still cryptic, don't know the meaning yetpchReserved - (12b): some reserved space, apparently for later IPv6ip - uint (4b)port - unsigned short (2b)Local address (the address this Node sees you under):nServices - uint64 (8b), still cryptic, don't know the meaning yetpchReserved - (12b): some reserved space, apparently for later IPv6ip - uint (4b)port - unsigned short (2b)8 byte nLocalHostNonce (needed for a handshake, if I'm not mistaken)A subversion string ".0" in my casenBestHeight - int (4b): appears to be the last block number That sounds reasonable :-)Any idea what Checksum algorithm this is? And is the header (4bytes and message type) also considered in the checksum and message size?Edit: Just checked: the size is the number of bytes following the size byte itself, I guess that the checksum is for that range also. The whole episode seems to have turned out in favor of BitCoin, and not against it :-)Nenolod apparently has some plans for us and his BitCoins, and I'm curious on what he will do   I actually stopped thinking of the BitCoin adresses as my Account number, and started considering them a reference number for each transaction  That's exactly what I was thinking :-)A simple reference client that just implements the protocol without the heavy duty computation and not even the data storage would be great. That's the reason I started this thread: https://www.bitcoin.org/smf/index.php?topic=231.0Anyone interested in helping reverse engineer the protocol?  I'm starting to reverse engineer the protocol, but my C++ is incredibly rusty  As far as I understand it the protocol is based on simple messages each 16 bytes long with variable argument lists. Each message starts with the sequence {0xf9,0xbe,0xb4,0xd9}, and the command itself is 12 bytes (0x00 padded). Depending on the type of the message we have to parse some arguments. Thus far I've analyzed the "version" command, whose goal is to exchange some initial information (both parties send and receive a version message):version{0xf9,0xbe,0xb4,0xd9}"version" (0x00 padded)4 byte message size4 byte checksum8 byte nLocalServices (always 1 if !fClient, no idea either what that means)8 byte timestamp (remember to use network byte order) Two adresses which I was unable to recognize (~44 bytes)8 byte nLocalHostNonce (needed for a handshake, if I'm not mistaken)A subversion string ".0" in my caseThe adresses are exchanged only if we are not proxied, this way the nodes can learn their external address. Anyone else interested in byte-guessing   I'd volunteer to manage a bot that logs the sessions and puts them online, just tell me which network and what channel ^^
