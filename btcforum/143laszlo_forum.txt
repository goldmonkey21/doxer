Wow thanks, I do still have access to it.  You should never delete a wallet, even if you've spent what was 'in' it.I appreciate the donations, but nobody owes me anything.. I generated my share and I spent it, it was just at a time when the value was lower, but so was the generation difficulty, and the block reward was 50.Laszlo Thanks for the kind words guys.The pizza thing was a lot more popular than I thought so I made good on as many trades as I could.  Other than a little bit of single digit change, I spent everything I mined.  As you all know, the difficulty rises to adjust to hashing power, so eventually the mining wasn't worth it for me.As far as I know I was the first to release a GPU miner.  I contributed the hash meter back then too, that's what the screen shot was all about.  I used to maintain the Mac OS builds but others have taken that up now.  It was a fun project and I learned all about OpenCL.  I can't find the thread on the forum anymore but you can find it in my web dir ( http://eclipse.heliacal.net/~solar/bitcoin/sha256.cl ).  That was back in May 2010.  Maybe there were other people who were doing it in private too, though.  For a long time I had been looking for a reason to learn how to write a shader, and this was a great project for it.  The way I looked at it, I was helping out with an open source project, and I was making pizza with my code.You guys will laugh now but I mined everything with an nvidia 9800 GTX+ on Mac OS (hackintosh, another scene I used to help out in).  I ended up getting 2 AMD Radeon 5970s with the bitcoins I was mining, but at the time, the OpenCL libraries from AMD and nvidia both were really buggy and I never got it to work right on more than one GPU.  The same code that would work on the nvidia on linux wouldn't work on windows and vice versa.  I was trying to make a generic OpenCL miner that everyone could run on all 3 platforms, and I spent months tweaking different kernels for each GPU, but I was also working two jobs at the time and so I never finished it.  I ended up just leaving bitcoin on the back burner for a few years, then it exploded and people started asking me about the pizza trades.  Every time the value goes up on exchanges, people email me asking me to comment on it, but really there isn't much more to tell than what I explained here. This is the old GPU mining release I made for Mac OS, probably won't work anymore though: http://eclipse.heliacal.net/~solar/bitcoin/Bitcoin-MacOSX-Intel-svn-75-opencl-2010-05-10.dmg Pics are still in the same location for anyone interested.  I didn't trade bitcoins for the child - she's my daughter, Amy.  Only the pizza was traded.http://eclipse.heliacal.net/~solar/bitcoin/pizza/ I heard from one person who bought a house with their pizza bitcoins, indirectly, by trading it for cash first.  Apparently it was a lot of hassle with the bank due to AML and just their general distaste for currencies they don't control.  I wish I could say I did the same, but the pizza didn't appreciate the same way as the bitcoins  At the time, Gavin had a bitcoin 'faucet' that gave out bitcoins for free, and a few people were trading them for less than a cent each, but nothing serious.  You can probably find all the old posts on this forum still.  I was learning OpenCL programming and mining bitcoins with a video card so the pizza was a good deal for me.  I couldn't have known that my pizza trade would end up being such a big deal, or that so many others would become interested in bitcoin and thus drive the value up.  The people I traded with didn't know it was going to explode either, they just took a risk - spending their 'real' money to buy some guy pizza in exchange for some internet Monopoly money.  Laszlo I spent it all on pizza long ago:  https://blockchain.info/address/1XPTgDRhN8RFnzniWCddobD9iKZatrvH43-4 years ago there were less than 100 people frequenting this forum, and I was pretty happy to trade 10,000 coins for pizza.  I mean people can say I'm stupid, but it was a great deal at the time.  I don't think anyone could have known it would take off like this. Laszlo You should check out ntp.org if you're interested in accurate time keeping.  The built in windows time sync will not adjust your clock if it's more than a few minutes off and you have to bring it within tolerance by hand first.  A better choice is to use the NTP daemon and start it with the -g option which allows it to make a large adjustment at startup. No, it wouldn't make much difference if the IRC network was compromised.It is just used to get a list of hostnames to try to connect to, but you only need to connect to one real node in order to be able to receive the majority block chain.  It is just one of many methods used to find other nodes - the address messages broadcast on the bitcoin network are the primary means, and once you've been connected to the network the client keeps a local cache of the addresses it has seen.  The ones it sees on IRC are just added to the list. Just so everyone understands..* LFnet IRC network is primarily used for bitcoin - a few others and I maintain it and we're all bitcoin users.  * I am a regular bitcoin contributor.  I'm also the guy that bought the 10,000 bitcoin pizza in case anyone is wondering.  I'm a moderator on this forum, I maintain the Mac OS build and I wrote the original GPU miner (http://heliacal.net/~solar/bitcoin/opencl-v2-svn-95-2010-06-30.patch)  - I hope that's enough credentials to prove to anyone that I'm not some BOFH IRC admin * We will make sure the #bitcoinXX channels are not 'taken over' or anything like that.* The IRC servers have been configured to limit the number of records returned when a client joins #bitcoin and issues a WHO request.  This greatly reduced the bandwidth and memory requirements.* We use and monitor IRC and will keep an eye on the #bitcoinXX channels.  The channel modes will be locked to a reasonable normal setting like #bitcoin is today.I would like to add an option/preference to disable IRC in the client.  It should be on by default, since that's the whole point, to bootstrap new users, but then the user should be able to switch it off.  There will still be plenty of people who leave it on to provide booting to others, but not everyone needs to do that; especially if you don't have the inbound port open.I also think that alternative bootstrap methods are a good idea, but it should be possible to switch it all off once you're connected to the network.Thanks,Laszlo Hmm I can't reproduce the problem on my 10.5.8 machine..the output of 'otool -L' produces this for me:Code:Bitcoin.app/Contents/MacOS/bitcoin: /System/Library/Frameworks/IOKit.framework/Versions/A/IOKit (compatibility version 1.0.0, current version 275.0.0) /System/Library/Frameworks/Carbon.framework/Versions/A/Carbon (compatibility version 2.0.0, current version 152.0.0) /System/Library/Frameworks/Cocoa.framework/Versions/A/Cocoa (compatibility version 1.0.0, current version 15.0.0) /System/Library/Frameworks/AudioToolbox.framework/Versions/A/AudioToolbox (compatibility version 1.0.0, current version 1.0.0) /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 125.2.1) /System/Library/Frameworks/OpenGL.framework/Versions/A/OpenGL (compatibility version 1.0.0, current version 1.0.0) /System/Library/Frameworks/QuickTime.framework/Versions/A/QuickTime (compatibility version 1.0.0, current version 1756.0.0) /System/Library/Frameworks/WebKit.framework/Versions/A/WebKit (compatibility version 1.0.0, current version 533.19.4) /usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0) /usr/lib/libstdc++.6.dylib (compatibility version 7.0.0, current version 7.9.0) /usr/lib/libgcc_s.1.dylib (compatibility version 1.0.0, current version 103.0.0) /usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 227.0.0) /System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices (compatibility version 1.0.0, current version 44.0.0) /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 550.42.0) /System/Library/Frameworks/ApplicationServices.framework/Versions/A/ApplicationServices (compatibility version 1.0.0, current version 38.0.0) /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 751.42.0) /System/Library/Frameworks/AppKit.framework/Versions/C/AppKit (compatibility version 45.0.0, current version 1038.35.0)I think otool is from the development tools but this shows all the dependencies.  All of those are standard frameworks that are part of a base install as far as I know.  The graphics dependencies and other odd looking things are brought in by wx-widgets which can be built with support for those.  They could probably be hacked out, but since those are part of the standard footprint on that OS, they don't add any external dependencies.Laszlo So at this point, would a client that has not upgraded also have the correct chain? No sorry I don't have any of those for sale. If someone takes the ip address method to the next level it really should be changed to provide some kind of security, like agree on a password/address or something ahead of time.  Sending to an address and creating the key automatically provides no authentication and there's no recourse if it went to the wrong place; the intended receiver is unaware you even tried to send anything.  It is trivial to proxy it and MITM that kind of activity and with the value of bitcoins rising it might just be worth doing eventually.I consider the ip address sending a local testing feature more than a production level feature in the way it is currently implemented.  One possibility that could work is if the receiver provided a public key (address) to you first and you used a combination of internet address and public key.  It is not as convenient but the alternative is to just send it to the ether and hope nobody grabs it before it gets to your target.  If anyone has used liberty reserve or something similar you know it is certainly not convenient to log into and such, but when it comes down to a choice of losing your money or dealing with an inconvenience I think most people would prefer the latter. Great idea, thank you for providing this exchange service. It's been a while since I posted this.. I will sell it for 900 BTC OBO.  If nobody is interested I'll just put it on ebay or something.  I have more stuff like this for sale I might try posting too. Well I didn't expect this to be so popular but I can't really afford to keep doing it since I can't generate thousands of coins a day anymore   Thanks to everyone who bought me pizza already but I'm kind of holding off on doing any more of these for now. Sorry I've been kind of MIA lately.. I will try to look into these problems, thanks for the detailed information.  I think it would be nice to enable the Command-H method of hiding the app.. the tray thing probably doesn't make much sense for Mac OS. All of the actual network protocol messages will have to have the values byte swapped where appropriate and the number handling functions, etc.  It's probably not worth it for the mediocre hashing performance you would get from a sparc.. it looked like a lot of work when I tried to do it for PPC. The Quicktime message is because it's 32 bit only but it isn't used anyway, it's just linked in by wxWidgets.  I believe if you disable the 'media control' features with configure it won't link them in, but I don't know off the top of my head what the right options for that are.  I noticed that even disabling the 'debug_flag' with configure, the latest svn of wxWidgets still pops up the assertions.  I'm not sure how to disable it completely, maybe I'll dig around in the wxWidgets code.  The 2.9 release of wxWidgets doesn't look very good on mac for me, so I used the latest from their svn.  They are doing a ton of work rewriting it with Cocoa. If you're using another JSON-RPC client that you wrote you can take care to protect the password, but using the bitcoin binary as the client and passing the password on the command line has the same issue as starting the daemon with it.  It's still visible to every user that way.So both the server and the client mode invocation need to use the file and not accept the password on the command line.  Generally programs like this refuse to start if the mode on the file isn't 600 or something like that, because that means other users can read it.
I guess it's ok for remotely doing it but if your concern is that someone else on the same unix machine can steal your bitcoins this still doesn't help because they can see your command line in /proc, top, ps etc.  It could read the password on stdin or use readline or something, to guard against that particular thing at least.  Allowing it to be passed on the command line is not good, in my opinion.Even better might be to use a key file, then you can use unix permissions to make it readable to only that user, kind of like ssh does.. then the bitcoind could have an 'authorized_keys' file with the public keys.  Anyway I don't mean to be an ass but the command line thing is just a false sense of security. Both, I have a 10.5 and a 10.6 machine both running it.  I suspect the problem is the processor.  Some of the frameworks and such have a CPUID check in them to prevent them from running on non-intel processors, from what I've heard. For low value items like that you would normally accept the transaction without any confirmations.  If the bitcoin node that the vending machine is talking to accepted the transaction then it's probably valid.  I think the only danger in that is if it was somehow double spent in a short time window - then it may never get into any blocks.  I'm not sure if that's really possible, maybe it is, but it seems like it would be hard to pull it off reliably. The current bootstrapping mechanisms are working pretty well and we can scale them as demand goes up.  If you're unable to connect through IRC or the alternate built in seeding system then you can always use -addnode=1.2.3.4 to specify the address of a running node.  Once you have discovered a node and connected you will get the addresses of all the other nodes via the bitcoin protocol and don't need the seeding systems to be able to get on the network.  Even if IRC failed you could use one of the addresses from the Static IP Address thread here to connect the first time. Try running it with 'bash' instead of 'sh'.. if that doesn't work try to execute the commands one at a time by hand.  I just linked em all together with those &&s but I think that's a bash thing. To extend on this you can connect to the remote host and request a new key before you send, as right now that reuses the same address over and over.To connect to the remote server and get an address you could set up pubkey auth with ssh and do something like this : ssh solar@eclipse.heliacal.net bitcoin/bitcoind getnewaddress The JSON-RPC interface can be used to query the balance and send it. Try something similar to this.. this will also start bitcoind if it's not running already.  You can run this every few hours from cron.Code:#!/bin/bashNICE=/bin/niceBITCOIN=/home/solar/bitcoin/bitcoindADDR=1XPTgDRhN8RFnzniWCddobD9iKZatrvH4NODE=192.75.207.66date${BITCOIN} getbalance 2>&1 | while read balance; do   if [ "${balance}" == "0.000000000000000" ];  then    echo "zero balance";  elif [ "${balance}" == "error: couldn't connect to server" ];  then    echo "server not running, starting...";    ${NICE} -n 19 ${BITCOIN} -daemon -addnode=${NODE}  else    echo "sending ${balance} BTC to ${ADDR}"    ${BITCOIN} sendtoaddress ${ADDR} ${balance};   fidone Still interested in this if anyone has any lenses and such they want to convert to cash/bitcoins. Are there any errors maybe in dmesg or the syslog (usually /var/log/messages or /var/log/syslog or something like that)?  It's hard to diagnose without seeing it first hand, sorry. Ok I really want to get this right.. sirius-m can you try it one more time?  I removed the static link to libgcc which was pulling in the dependency on the newer glibc.I replaced the binaries in this location with new ones : http://heliacal.net/~solar/bitcoin/builds/Linux-amd64-SVN-103/ Berkeley DB He tried to double spend his coins and the system prevented it.  In the process he also lost the coins he didn't spend because he lost one of the wallet files while swapping them around.It is enough to back up the wallet.dat, try it out with some free coins from the bitcoin faucet. I want some nanocomputers! You can do a base only build of wxWidgets - Satoshi is in the process of writing replacement functions for the few hooks that bitcoind still needs from wxWidgets and then it will be possible to do without it completely.Make sure you use wxWidgets 2.9 not 2.8 when you build it.  These notes might help you get started, then you can fine tune the configure command from there for your system - http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdfAlso take a look at the wx-config usage in this makefile: http://heliacal.net/~solar/bitcoin/makefile.unix2 grep the debug.log file for 'hashmeter' Here is my ldd output for these binaries: Updated to link the C++ library statically, can someone with the GLIBCXX_ version problem please try this and let us know if it works?http://heliacal.net/~solar/bitcoin/builds/Linux-amd64-SVN-103/ Here is a guide on how to exclude a process:http://maximumpcguides.com/windows-7/set-microsoft-security-essentials-to-exclude-a-process/You need to exclude bitcoin.exe from live protection. What kind of computer is it?  I only tested on 10.5 with a core 2 duo based mac.. A 'whole attempt' is actually 3 blocks.  2 blocks of data are hashed to produce a 256 bit result, then that result is padded to make another block and hashed again.  Each block is given the usual 64 pass treatment of SHA-256.  The interesting part that generates the coins uses a simplified implementation in c++ rather than OpenSSL.
Slightly used, in good condition.Looking for 2000 900 BTC OBO, thanks!http://www.compusa.com/applications/searchtools/item-details.asp?EdpNo=4398715&csid=ITD&body=MAIN#detailspecs Yea, I tried that too, after seeing it at 90C temps for a while I decided to not generate with my MBP It's great that it's working for you - I'm not sure if it's possible to ask the OS to switch to the high performance video automatically, as far as I know you have to go to the power settings and tweak it manually, like you did. Is it possible to statically link the c++ library?  If it is possible, is it something that is an acceptable practice or does it cause problems?  Maybe just include the library with the program?  When I said static I was only referring to openssl  The data that is being hashed is based on the previous block.  For a node to accept a new block into its chain it must 'connect' to the top block otherwise it just ignores it.  This means the problem is changing each time a new block is created because you must now connect to that one instead of the one you were previously using.  This is why if you have a flaky connection or excessively high latency, you end up wasting computing time working on hashing a block that would never be accepted by the other nodes. We would need to write code to use this hardware, there is no automatic acceleration, btw. That does sound interesting, I might go pick one of those up to experiment. I like MMORPGs and bitcoins, so this sounds interesting to me, please elaborate  Aside from the housekeeping fields needed to make sense of the data, the rest of the data that is being hashes is just random.  Everyone's is different and you never get any closer to solving it.  Every time it is twiddled and re-hashed you have the same chance of finding a solution.  This is just like buying raffle tickets.  Everyone's numbers are different and they could all be winners, however the guy who gets more raffle tickets might win more often, if this process was repeated over and over.  Computers that can try hashing faster have more raffle tickets but every hash calculation has the same chance of being a winner. Maybe because you're giving out nickels some people are just asking for a ton of them to supplement their generation income. It is ok to use the same address more than once for manual transactions but for someone running a merchant site or other such service it would be best if they generated a new address each transaction to prevent analysis of their income.  If you see they sell bags of heroin for 500 BTC for a small one and 5000 BTC for a big one, and they always use the same address, you can just count how many bags they've sold, it's like having your accounting books open for everyone to see. This is great, thank you! I think this would be interesting.  I myself play one of those games occasionally - I think there is probably a good crossover between geeks that play computer games and geeks that like bitcoin. I was going to try creating one but Satoshi pointed out that the 32 bit windows one will work for everyone.. the only reason we need a 64 bit linux one is because not everyone has a multilib system that can use the 32 bit one.  The only difference between building a normal 32 bit version and a 64 bit version is that the 64 bit one will use more memory.  The Mac OS version is both 32 and 64 bit, the system selects the proper version automatically when you start the app. It is not lowered, it only goes up. It will not be lost.  They will see it show up in their transaction list once all the blocks are downloaded.  Every other node has a copy of the transaction too. I wonder what other possibilities there are though.. some of the new people hooked up hundreds of computers (someone said 300 workstations?) so the network adjusted difficulty.  To give you some perspective, in all the time it has been running the difficulty rose to 23.  The previous jump was very large, it went from 19 to 23.  When all the new users showed up it jumped from 23 to 45.  It's based on fast the new blocks are showing up, if they're being generated very quickly then the difficulty jumps accordingly to target 1 block every 10 mins average. I'm not sure which random number thing you're referring to, but here is a quick outline of how the generation works:Prepare a block of memory organized as a struct - certain fields like the hash of the previous block, the current time and some other housekeeeping information is filled in.  The struct has an integer field and another 'expansion' field where the data is free form.  This free form data is altered (simple increment of a number) and then the struct is hashed.  The resulting hash is interpreted as a large integer.  If it is equal to or less than the current difficulty function then the proof of work has been found and this block is added locally and broadcast to other nodes.This is similar to having a 100 sided die - if you roll below 70 you win.  To make the game harder you have to roll below 50, then 40, etc.  Basically there is no known shortcut to go from a desired hash value to the original input, we only know how to do it quickly in the other direction, so it is simply a brute force iterative process.  Statistically, less blocks of data will be below the target value, the lower the target value is.  Finding a block that hashes below the difficulty value proves that you worked on the problem, or got lucky and hit it on the first try, but over a long period of time you won't keep getting lucky, you'll have to try lots and lots of different values. I will give you some coins to start out with if you post your address.  I think generating faster would be more difficult for the network to arbitrate as it scales up.  The target of the algorithm is 1 block per 10 minutes, that is how the difficulty is adjusted.  If the generation difficulty targeted a block per 1 minute (but maybe worth 1 BTC instead of 50) then latency would invalidate a lot more generated coins.A generated block must be based on the previous block, so if a new blocks is received from the network, the header that's being hashed must be updated to point at the new highest block.  If two nodes both generate block #70,000 then whichever one's broadcast propagates first wins.  It is expected that collisions will occur during normal operation but there would be a lot more if the difficulty was scaled down.I think what you're saying makes perfect sense and we would like to keep the difficulty low for as long as possible to allow new users to get coins quickly.  Unfortunately it is not possible to keep it low forever because of the technical details. It generates a new address and puts it in the main window for you if a payment is received for the previous address.  This is so each time you click 'copy to clipboard' to send it to someone, it's easier to get a unique one.  The old one is still valid and it's still in your address book.Try renicing bitcoin and see if it helps.   Find the pid in top or ps and then renice +19 1234 where 1234 is the pid. It will always use max CPU to generate but the generating thread is scheduled at a low priority so it should yield to other processes.  I can compile code and do other things on my windows machine with 0.3 running and it doesn't seem to slow it down for me at least.
Maybe it's the UAC stuff - like perhaps the %APPDATA%/Bitcoin dir was created while it was running as administrator but now it's running normally?  Maybe you could try running it as administrator to see if it's related to that. The difficulty doubled since all the slashdot users showed up, so expect it to take significantly longer.  New 8 core workstation, probably several coins a day, but 3-4 year old computer, probably one every couple days.  Each block is worth 50 BTC right now. Couldn't I just run 500 instances of the proposed capped client?  This is more about trading than generating - the generation is just to make it so the supply is limited. This is mostly for those having troubles on fedora with newer openssl than the binaries on the front page of the site were built with.Please try these or compile yourself using these instructions: http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdfhttp://heliacal.net/~solar/bitcoin/builds/Linux-amd64-SVN-102/ Here is a similar script written for bash that I use, in case someone else finds it useful.  It will also start bitcoind for me in case it is terminated or if the computer is rebooted.(replace /home/solar with the dir where you keep your home directory: $HOME)Code:#!/bin/bashNICE=/usr/bin/niceBITCOIN=/home/solar/bitcoin/bitcoindADDR=149iLTM499LvvktTSbub77dJYvZ7YVGtXoNODE=192.75.207.66date${BITCOIN} getbalance 2>&1 | while read balance;do  if [ "${balance}" == "0.000000000000000" ];  then    echo "zero balance";  elif [ "${balance}" == "error: couldn't connect to server" ];  then    echo "server not running, starting...";    ${NICE} -n 19 ${BITCOIN} -daemon -addnode=${NODE}  else    echo "sending ${balance} BTC to ${ADDR}"    ${BITCOIN} sendtoaddress ${ADDR} ${balance};  fidoneI invoke it from crontab like thisCode:0 * * * * /home/solar/bitcoin/sendbalance.sh >> /home/solar/bitcoin/sendbalance.log 2>&1 This seems like a commonly reported problem now - something to do with the block downloading being really slow.  It may be related to the excessive amount of disk I/O that is generated during the initial download.  The database file is flushed to disk every time a block is added so this is being really slow for some people.  I think we can probably fix this up now that we know about it.. I for one didn't do much testing without having all the blocks, so it never occurred to me to try this under different systems. If you're ok with hacking the makefile to update your paths and such, try looking these notes I took to get you started:http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdf The 32 bit binaries work on both 32 and 64 bit windows. Currently the code is heavily little endian so it is not just a recompile to support PPC unfortunately.  I wanted to try working on a big endian patch but I couldn't really find a good enough reason to  "difficulty" : 45.38582234101263It jumped from 23 in a couple days.  I think this pretty much puts an end to generating a block a day with a personal computer.. but you can still get lucky.  Now you'll need to build a cluster or hijack a college computer lab for it to be worth doing   I expect the trading value will increase significantly over the next few weeks as the supply slows down; should be interesting. It sounds like the slow block downloading is a problem for some people but not others, regardless of the platform.. I will try to look into it more, thanks for the report. Would be interesting to see if you get better results without it - someone else reported trouble with that until they added an exception for the %APPDATA%/Bitcoin directory. I have some notes I wrote to help build it on linux - my notes are for x86_64 but the same thing applies for 32 bit just change the openssl target.http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdfAlso very similar, slightly outdated but should give you a start (no patch is needed):http://heliacal.net/~solar/bitcoin/mac-build/Bitcoin-MacOSBuildInstructions.pdf Basically anything that's generated while the node doesn't have all the blocks just ends up being rejected because it would fall in the middle of the block chain not at the end (but your node thought it was at the end because it didn't know there were a lot more blocks).  The blocks are small but it takes a while for your computer to validate each one so that's why the initial download takes a while.  I'm not exactly sure why it's taking so long for some people, maybe it's because the database is flushed to disk constantly and some kind of antivirus is scanning every file write, but it takes about 10 minutes for me to get it all back if I remove my data directory. Those with more computing resources will generate a larger portion of bitcoins over time but it is definitely not a maintainable thing as the algorithm adjusts difficulty in response to how fast the generation gets and it can only get slower thus limiting supply even if a lot of compute power is added. You will not be able to generate if you're not connected.  Generation will stop until at least one connection is made and the most up to date block is received - it is a block chain after all so you can't insert links in the middle, you always are adding to the end. Looks like your wxWidgets and STL - you should compile your own wxWidgets from the 2.9 release.Use something like this to configure it and adjust the reference paths in your makefile.unix Yea SSDs rock, I finally bought one a few months ago and it's a huge difference.  It doesn't really matter if you buy the super high end one or a regular mainstream one, they all are better than a rotating disc.There is an unfounded fear about them wearing out from writing but this is true for magnetic platter drives too and it will still outlast your computer even if you format it every day. The blocks are just random data - the only purpose of the hashing and block generation is to limit supply and provide a way to arbitrate double spending. You could try using tor maybe and see if that works better, though it will increase your latency even more.
You can send a billion small transactions, it doesn't slow anything down, except the user interface because you end up with a ton of items in the list.  Just go ahead and try it, see for yourself.All of the transactions are included by nodes that are attempting to generate the next block and only the header is hashed so it is not harder to generate a block that represents a million transactions than it is to generate a simple coinbase only.  This is what the confirmations are, blocks that include your transaction. Sorry I misread, it's possible that you just weren't connected properly and it couldn't broadcast a transaction, what was the exact wording of the message?  Can you include a screen shot?  I might have been describing a different problem than you were having especially if it cleared up after restarting.. It is normal for some blocks not to be accepted.  One connection is enough, the others are just redundant.  The client will make 8 outbound connections but will accept all inbound connections (on port 8333).The blocks are generated in sequence so if two nodes happen to generate at almost the same time there will be a collision and one or the other will win.  If the current block count is 5000 and your node finds a suitable block 5001, but meanwhile some other node already created a 5001 and your node just didn't know because it's on a laggy connection possibly, your block won't be valid and you have to start searching for 5002.  I think this is explained in the pdfs, I'm not sure.Are you seeing a lot of these happen or was it just one? Please try running with 'nice -n 19 ./bitcoin'or renice +19 1234 where 1234 is the pid of the running bitcoin.There is a bug in the released linux version which prevents it from successfully lowering its own priority. Are you using some sort of alternate permission framework like selinux?  I believe some linux distros like ubuntu come with this by default.  Per the man page for setpriority (even on ubuntu), only root can lower (make more favorable) the priority so it should not be possible for the adjustment to work on linux.  Anyway the reason it tries to raise its scheduling priority is so that it can quickly save a generated block and then go back to low priority for generating again.  Your issues should all be fixed in SVN and you shouldn't have to manually set the priority anymore - you can just change the PRIO_MIN to your preferred priority, or use the PRIO_MAX macro.http://www.kernel.org/doc/man-pages/online/pages/man2/getpriority.2.html Why do you say that?  Pretty much every P2P system works by replicating the information across all the participating nodes, even 100G movie packs for BitTorrent - we're talking about less than a kilobyte of information for a transaction. This is fixed in SVN but I think that was after the release was cut.  The workaround is to run bitcoin like:..otherwise it hogs the CPU as you noted.I spent some time experimenting with this and contrary to what the documentation states, on ubuntu you can actually adjust the priority to be more favorable (numerically lower) after raising it to a higher number.  I believe this might be due to selinux?  That seems non standard and I think on any 'normal' system using the usual behavior the generating thread will end up staying at the less favorable (numerically higher) priority even when an attempt to change it is made. I think it is similar to IRC.. I haven't measured it but the bandwidth requirements are very low.  The messages are very short like chat messages, just containing a few bytes.  Nodes ask for addresses all the time, and new blocks are broadcast regularly, so think of it like being on a few very active IRC channels where people are talking all day.It is however very active on the disk I/O because it flushes the database to disk every transaction - this is what iTunes does too every time you change tracks. I think loans would be useful, that way if I want to go on a pizza binge I can buy a bunch of it and pay it back later.  I don't think you would want to give someone a loan anonymously though, you'd want to know where they live so you can break their legs, etc.I think interest would be cool too - like a certificate of deposit? I don't mean to be a hater, but I really dislike anything that wants me to update.  I don't mind having a 'check for update' option but I really don't care if a new version is out if I'm happy with the current one.  If I actively use something I will likely check the site for news when I feel like it, not when the software pops up something.  If I don't use it much, then I really don't care if I have an old version..  If my old version stops working because the network has been upgraded, then I will probably want to check for a new one anyway.It may also be seen as a breach of privacy if the software 'calls home' to check for a new version, at least that's how I feel about all those Adobe products and other stuff that always wants to install some kind of update checker or download manager or other useless (in my opinion) junk. The addresses are valid forever unless you lose your wallet.  The only disadvantage is that the address receiving a transaction is visible to all nodes.  It is easy to automatically generate a new address each time a page is refreshed on a donation page using the JSON RPC interface. The windows thing is a function of having different operating system versions.. on Vista at least it goes into this Roaming directory, because they reorganized it and wxWidgets is just using the OS standard place.  There is a -datadir option you can use to keep it on the desktop or whatever.  I believe if you use the token %APPDATA% in your script, or $APPDATA if you're using cygwin/msys, then you will always have the right place regardless of XP/Vista.So something simple like a scheduled task on windows or a cron job on another system like Mac OS or a BSD/Linux distro..Windows batch file style with another windows machine as a file share, going from the bitcoin host to a file share:Code:SET DTS=%DATE:~4%SET DTS=%DTS:/=_%SET DTS=%DTS%-%TIME::=.%xcopy /E "%APPDATA%\Bitcoin" "\\myserver\backup\Bitcoin-%DTS%"Shell script style, still initiated from the bitcoin machine - set up public key auth so no password is needed firstCode:DATE="/bin/date"DATESTR="$(${DATE} +%Y-%m-%d-%H%M)"scp -r "$APPDATA/Bitcoin" "user@host:backup/Bitcoin-${DATESTR}" You can change it to print it every 30 seconds or whatever if you edit the code.. but it's really not going to change except when the computer is busy. It really only makes sense for nodes with the port forwarded to remain on the IRC channel, right?  Maybe it could just ping a php script or another node randomly (this might be a better idea) which tells it YES/NO on whether the connect-back is working, and then just terminate the IRC thread if it's not needed anymore.  It could re-probe every 6 hours or so in case the user changes their port forwarding settings, or it could just be an option even.. Pretty much all of the encryption software in use on the internet takes advantage of a trapdoor function - you can multiply 2 numbers together but you can't easily determine what the 2 factors were if all you have is the resulting product.  As it is today the only way most of us know to do it is to try every number.  If someone were to figure out a better way that took less time, it would make it easy for a regular guy like me to use that method in some software to decrypt HTTPS traffic and such.Hashing is slightly different but the idea is the same - it is not possible to work the hash in reverse to determine what the possible inputs were, you just have to try every plausible input and compare your hash.None of these things are perfect but bitcoin is only taking advantage of existing methods that are in use by a lot of other software which has been accepted for a long time.  If a basic flaw is found, bitcoin is probably the least of anyone's worries  Other nodes don't have to accept your transactions.. but many will want to use the official well behaved software anyway so there should always be some people who will accept them.I think it's similar in some ways to web browsers - a web site author wants you to see a bunch of ads so he created something that uses javascript and opens pop under ads.  You're using a browser that doesn't have javascript so you don't see the ads.. but then he has this cool page that lets you pan a webcam around and it uses javascript but you can't use it.  So maybe you outsmarted the system by avoiding the ads but you end up losing out on the webcam panning page so you're just hurting yourself with your modified browser.There are similar things you can do in bitcoin but I think the author has designed it to be pretty well protected against the kind of things that would allow someone to subvert the whole system or profit from it.  You might reject everyone's generated coins and not include them in your blocks, but it doesn't make you any richer, and some other nodes will accept them anyway.  You can send garbage and find ways to crash them but then those nodes will just blacklist you.  These protections will be implemented as needed I think, since it's hard to know ahead of time what types of things to protect against.BitTorrent clients are a good example to look to - they disconnect and blacklist clients that are sending them bad data.The majority of the network will likely always be comprised of cooperative nodes. So would there be any legal issues (int the US or elsewhere) with running a bitcoin lending service similar to a traditional bank? You can't destroy them all, more will be generated constantly.  That 21 million number is not going to be reached in the foreseeable future.  As you know, the generation algorithm adjusts itself to slow the generation rate intentionally. I don't think you understood my point.It is a lot easier to arrest and lock up the prominent bitcoin users than to manipulate the market.  Like it was pointed out, a market is not just a single currency, it can be a lot of different types of currency and goods.  Trying to manipulate one end or the other would be difficult.  It is better to just get the people - fear of being arrested is much more effective than trying to shake up confidence in the currency.Destroying a large amount of currency just causes deflation and makes the remaining currency that much more desirable - imagine if you had a pallet of gold bars in your garage and nobody else did.Maybe you don't agree with my assessment of the situation but what you posted was far from constructive.In response to your original post, I don't believe the situation you describe is a big risk. My daughter ripped a dollar bill in half earlier when she got into her mom's wallet.. It's not really worth it for me to try to get a dollar bill replaced by the treasury so I just consider it destroyed - but it's not really going to affect my budget and certainly not the economy of the United States.  There are about 65000 blocks so over 3 million bitcoins have been in circulation.  Many of them have probably been destroyed by accident when someone lost a wallet file or whatever.. If you want to buy a bunch of bitcoins (or dollar bills) from me and destroy them let me know, I can give you a good exchange rate for bulk transactions like that For dollar bills I would charge 1.03 to make it worth my while but I will have them sent by air mail or courier depending on the distance.I think if a government wanted to get rid of bitcoins they would just take us away in black helicopters - probably Satoshi first..
The coin generation is just a clever (in my opinion) way to limit the supply; the rate at which they're created.  It lets everyone feel like they can get a piece but it still makes it so you can't just mint a billion of them overnight.It is not about consuming energy or resources - it's meant to be used on computers that the users already have.  I understand that some people may turn their computers off at night and leaving it on for bitcoins indirectly consumes energy but that's not the point of it; it's like folding@home and such, using resources that are already 'wasted' if you consider potential CPU usage a resource.If you plan to set up a datacenter full of computers to generate more coins then you would be investing dedicated resources into it and that's your own business decision with its own set of risks.. but it is not necessary to do that in order to trade bitcoins. It says there are only 4 bitcoins for sale when I try to buy some. Mac OS version - requires Intel processor and 10.5 (10.4 not supported)http://heliacal.net/~solar/bitcoin/builds/MacOSX-Intel-0.3/bitcoin-0.3.0.zip I'm not sure if it's correct to assign cost to bitcoin 'production' in that way.. Your rate of production will decrease over time by design anyway and the whole thing with proof-of-work being required is just to limit the supply.  If bitcoins continue to grow in popularity it will not really be feasible to generate coins on a regular personal computer and trading for them will be the best way to acquire them. BitTorrent clients can do hundreds of connections easily - this is why they end up killing those little embedded routers.  It should be no problem for a regular IP router but the little embedded things are doing NAT so they're tracking state on all those connections and run out of memory.. also they're very slow SoC style computers so everything going through them suffers.Torrent clients generally have options for configuring a global maximum number of connections, maximum inbound and maximum outbound connections.I think it would be good to allow configuration of unlimited inbound/outbound connections for those who have the capability to do it, and provide a conservative default for those who are using NAT, tor, proxies, etc. I would recommend using a self signed certificate over a third party one.. anyone can pay verisign or thawte for a buybitcoins.com certificate so it means nothing. All that stuff is run by the CIA (like tor exit nodes).. you just need to get your own VPS - pay for it with some kind of prepaid payment card, use a bogus name obviously.. and just run your own proxy.  Don't use things like youtube, google, yahoo, wikipedia etc.. because regardless of proxies and javascript and whatever, they're in the business of tracking usage and controlling your thoughts through control of what you read.The VPS thing isn't perfect but there are uses for a VPS besides anonymous proxying.. services that are advertised as anonymous proxies will obviously attract people who want to be anonymous so they're probably 'up to no good' and are worth spying on.I guess I'm just reiterating the original point that you can't trust someone else's proxy unless you trust that person.  I have a few friends who use my proxies but I know them in person so they know and trust me.  I wouldn't use someone else's proxy unless I knew them well enough to trust them.. I especially wouldn't use a paid service that is specifically aimed at someone looking for anonymity.The image I get in my head is some spook sitting around nailing up signs that lead to a bank you can rob.. and his buddies are waiting inside behind the door grinning. I'm not much of a marketing guy or anything but it makes sense to me to refer to software like this by the version in source control, like Bitcoin r82 or whatever.. maybe that's too geeky for some people. Well, I'm not sure what the perfect system is but majority/democracy is certainly not it..  Look at what's happened in the United States, everything is illegal.  Smoking is being outlawed in phases because the majority doesn't smoke so nobody cares that it infringes on the rights of the smokers.  In California they make a law against anything that bothers someone.. imagine something comes to vote:  "Let's outlaw X because it's annoying" then the idiot majority goes "Hmm yea X is annoying and *I* don't do X anyway so whatever.."Sooner or later something that you do comes around for vote and you can't do anything about it because you're not the majority.Basically democratically deciding things is a sure fire way to infringe on absolutely everyone's rights because the majority is not one group but rather a complex overlapping structure.  You might be included in one majority but you're the minority in 100 other ones. I'm not sure why but I noticed that as well - my Win32 build was a lot slower than the linux/mac builds I did.  I used MinGW and all that but maybe I made a mistake somewhere..  I probably used a different version of Berkeley DB than Satoshi too so that's why the logs weren't binary compatible. I don't think you can realistically make a program control the CPU temperature - it's just too indirect and you'd just create a weird oscillation at best, at worst it just wouldn't work at all.  The fan speed, duty cycle and target temp are options that can be set in the BIOS of enthusiast level motherboards usually, not in regular OEM computers though.  Most motherboards, even OEM stuff, have some support for 'smart' fan control where they spin it up faster when the temp rises.. you could try to disable that so it's always 100% but if it's still not reaching the target temperature then the only thing you can do is install a better cooler and improve the air flow in the case.Intel CPUs made since the Pentium 4 have the ability to stop the clock in response to overheat conditions.  Pentium 3 had a similar ability but it just locked up hard and never restarted.  The current Intel CPUs oscillate the clock so what ends up happening is your CPU is about as fast as 486 from 15 years ago but it doesn't melt.  This 'feature' ends up being used on pretty much any laptop because they have such poor cooling.If the thermal protection is kicking in, it's only to save the CPU from melting and it means that the CPU can't work so you're losing a TON of performance in your bitcoin generation.  On Linux there is a kernel compile option to monitor these interrupts and print a message, so you can tell if it's happening.. but in general if your CPU is getting over 70C you probably have this problem.I personally would not recommend using a laptop for bitcoin or anything like that..  Oh so with all that being said, you guys are all welcome to IRC on irc.lfnet.org.  It is a small network that me and a couple of guys run.. we don't have services or k-lines or anything like that. Whether it's right or wrong, when people who know what IRC is hear that IRC is involved in something, they immediately think malice..  This is not without foundation as a lot of antisocial behavior takes places on IRC channels.  The other thought is botnets which use IRC to bootstrap, control or communicate.  A program which connects to IRC is by definition called a 'bot' and to IRC people that means something bad, especially if it's not an IRC bot program specifically.What Satoshi did here is use IRC simply as a matchmaking service but I could see how someone could draw the wrong conclusion when they see a channel with hundreds of randomly named bots idling in it.  Perhaps you could put these people's minds at ease if there was some pop up asking them if it's ok to bootstrap from IRC.. because if they just write it off as a trojan or botnet they may never bother to find out how it really works. The current user interface doesn't support smaller than 0.01 increments but it is possible to support it in a future revision. They are lost for good.  Think of it like someone losing their wallet in the ocean.  It seems like it would be a problem but it's really not that significant.  People lose their gold jewelry all the time but it doesn't make much of a difference to the value of gold.I wonder though, is there a point where the difficulty of generating a new coinbase is so high that it would make more sense to try to recover keys for lost coins or steal other people's coins instead?  The difficulty of that is really high so for now it makes a lot more sense to generate but I just wonder what the real figures are.. would that ever become more productive?  Maybe Satoshi can address this.. It will always benefit you to have the fastest computer, or have more computers than anyone else.  The hits per day you get will go down statistically over time as the difficulty rises, but you will still get a larger share than everyone else if you control the biggest pool of resources.This is all based on the theory that statistics mean something though..  The guy with the 1Ghz computer could 'get lucky' and generate a thousand a day while the guy with the compute cluster gets none.  I think this 'get lucky' theory is what gambling is based on. Cool, I just hope you don't take it the wrong way when guys like me and Gavin are trying to shoot holes in it.. I think we're all here to see this thing develop and turn into something bigger but we're also interested in finding ways to break it (so it can be fixed).  It seems like you have done a great job covering the bases so far because you've been able to add features without breaking compatibility. How long have you been working on this design Satoshi?  It seems very well thought out, not the kind of thing you just sit down and code up without doing a lot of brainstorming and discussion on it first.  Everyone has the obvious questions looking for holes in it but it is holding up well  Yay 32 bit linux?  Yea I can do that.
Joozero I'm sorry if it doesn't work for you..  I noticed that the performance with the windows client seems slower than the other two I built.. I'm not sure if this is because of a mistake I made or something I overlooked in the code but I will take another look and let you know if I find anything.  Maybe there is something else wrong with it besides just the performance.. Joozero, what is the problem with it?  I use that binary myself and it works for me. I would be willing to pay a combination of bitcoins and USD for used Canon compatible photo equipment.. lenses and filters and such.  If anyone is looking to sell this kind of stuff let me know.Thanks,Laszlo Is this really true for modern web browsers, or would the web page have to be loaded from localhost as well?  Can you make an HTTP call from javascript to the localhost if the page was loaded from an internet host? I run an IRC server you can use, it's fairly stable but it's not on redundant connections or anything.  It is only two servers right now but we don't mess with it or anything, it just runs.My box is a dedicated irc server: 2:28PM  up 838 days, 20:54, 1 user, load averages: 0.06, 0.08, 0.08You can use irc.lfnet.org to connect.I hang out on #linuxos if anyone wants to drop in. He's giving it away, it's an honor system, so don't take more than you need  This is an open offer by the way.. I will trade 10,000 BTC for 2 of these pizzas any time as long as I have the funds (I usually have plenty).  If anyone is interested please let me know.  The exchange is favorable for anyone who does it because the 2 pizzas are only about 25 dollars total, maybe 30 if you give the guy a nice tip.  If you get me the upgraded extra large ones or something, I can throw in some more bitcoins, just let me know and we'll work something out.My 1 year old daughter really enjoys pizza too!  She just smears it all over her face if you give her a whole slice, but she does eventually manage to get most of it in her mouth (minus a few loose toppings of course). Thanks! Please note that I'm not the Bitcoin author - if you don't trust me then don't use these.  I have written instructions that should get you started if you want to build your own (look around at my other posts).Some unofficial builds that I created:Mac OS X, Linux (64 bit) and Win32 builds availablehttp://heliacal.net/~solar/bitcoin/builds/This includes a tiny patch I added to show how many hashes per second are being processed.  A picture of the hash counter is attached.If you want the patch so you can build it yourself it is available here:http://heliacal.net/~solar/bitcoin/bitcoin-svn-81-perfcounter-2010-06-12.patch What do you imagine the iPhone app doing?  Just looking for some ideas on how it should look and what it should do.. Awesome! I don't think you can do that with iptables.. is there some module that lets you match a locally generated packet against the UID of a process? If you give me some bitcoins I'll give you a bucket and a spoon and you can go scoop up your own oil in the Gulf!  As much as you can carry! I wonder why they're able to get away with that stuff, aren't there groups like the ACLU and the NRA and such that are trying to protect people's liberties anymore?  I guess with all the anti-terrorism (witchcraft?) laws on the books these days, the government agencies are above any law or form of control.If something doesn't stick, or they get called out on being like the gestapo, they can just pull the terrorism/national security card and they can do whatever while people cheer them on. The software doesn't know anything about idle time, but it changes the generating thread's priority to be low.  This should cause the operating system to schedule it whenever a higher priority item is pending.  The result is that when your computer is idle, in between higher priority processing becoming runnable, bitcoin becomes runnable and so all the CPUs are always at 100%. The destination address and amount that is sent is visible to every node on the network (the UI just doesn't have a tab right now for viewing it, it filters down to only your own addresses).One time addresses don't use any resources but they are good from the regard that it's not possible to find out how much money you have unless you make public all the addresses that you have keys for.  Some people might not care about it, but if it's common practice to re-use addresses and maybe some commonly used web framework is implemented in this way, it makes it trivial to profile the network as a whole and figure out who is receiving how much money, thus undermining one of the primary goals of the bitcoin network.  I'm working on something like that, for iPhone, but not really for generating, more for spending.. the problem is it's really hard to type in a bitcoin address on that little thing. So when/where can I place an order? It doesn't mean anything - it stays unconfirmed for the first 5 then it just says blocks I think.  The number is how many confirmations it's gotten.  I guess the idea is that the more confirmations, the more likely it is a 'legit' transaction according to other nodes, so the more likely you are to be able to spend those bitcoins later. Sounds interesting.. but the US government has endless resources and nothing to stop them from doing things they're not supposed to.. I think if it's high profile enough you would still get busted somehow, something you didn't think of.  If you're always shipping them from the same post office they might figure it out..  
Having more computers will increase your chances of generating blocks regardless of your internet address.  As long as they're all able to connect to at least one node and stay connected you're all good - it doesn't matter if they all share the same internet address through a proxy/router. http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdfIf you follow these instructions and build 'bitcoind' it's all linked statically to wxWidgets, boost, openssl and libdb.. for me it looks like this:Code:$ ldd bitcoind        linux-vdso.so.1 =>  (0x00007fff31dff000)        libdl.so.2 => /lib/libdl.so.2 (0x00007ff1a0a78000)        libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007ff1a0768000)        libm.so.6 => /lib/libm.so.6 (0x00007ff1a04e4000)        libgcc_s.so.1 => /lib/libgcc_s.so.1 (0x00007ff1a02cd000)        libpthread.so.0 => /lib/libpthread.so.0 (0x00007ff1a00b1000)        libc.so.6 => /lib/libc.so.6 (0x00007ff19fd41000)        /lib64/ld-linux-x86-64.so.2 (0x00007ff1a0c7c000) Try this: http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdf What's wrong with IRC?  It's just another method that's used to exchange the peer list.  You can just prevent it from connecting and use -addnode=1.2.3.4 to connect to a known node for bootstrapping if you want..If nodes disconnect from IRC after they get their list then it makes it less useful for bootstrapping since it will be empty except for the node that's trying to bootstrap at the time.IRC has been around forever and it's well documented (and easy to understand for newcomers) - why create something more complicated? Really sorry about this but there was a typo in the patch.. I replaced the original version with a fixed one.  The original patch was actually not incrementing the nonce so it messed up the generation new patch: http://heliacal.net/~solar/bitcoin/bitcoin-svn-79-perfcounter-2010-06-02.patch Can you post it on a web server or something?  It sounds pretty large.  I could take a look but it's probably hard to find anything among all the spam. The debug.log is truncated when you restart the app, not sure if it does it periodically too.. are you perhaps getting disconnected/reconnected frequently or having really high latency?  A poor connection could prevent you from generating, though I wouldn't think you would be having that issue at the VPS. Athlon FX-55 (socket 939) on linux**Perf - thread 1 : 575k iter/sec**Perf - total : 575k iter/sec (1 threads) That seems odd.. are you seeing any instances of 'proof-of-work' if you grep debug.log? Some notes on how to build the linux client.  I used a 64 bit system but the process is almost identical for i386 linux.http://heliacal.net/~solar/bitcoin/bitcoin-linuxbuild.pdf So would it be smarter to only process transactions which profit you?  That way if you want to send money you need to include a courier fee or nobody will confirm it.  That seems reasonable to me, where you can add a fee yourself to each transaction, and people can configure a threshold of how much of a fee they expect before accepting a transaction. -O2 is generally the preferred optimization for gcc, -O3 can produce larger code which is slower, but you should experiment around with it.. it also seems to depend on the time of day or the phases of the moon for me at least, some days I'm getting a lot more hashes per second. Cool, I was just playing around with trying to make it adjust the rate without taking much of a performance hit.. that's why it tries to adjust that variable, to keep it to a few per second or so.. maybe you can figure out a better formula, I just kind of did that by experimenting around with it. You should compile for 32 bit windows (mingw).. 64 bit would just make it use more memory but you'll have to build all the dependencies that way too, if it's even possible with wxWidgets and stuff.. You did the right thing.. none of it works on big endian anyway. E2200 C2D 2Ghz CPU**Perf - thread 1 : 495k iter/sec**Perf - thread 2 : 495k iter/sec**Perf - total : 990k iter/sec (2 threads) Make sure you guys try compiling with -O2 instead of -O0 (check your makefiles).  It improved performance a lot for me. Be careful trying to value a VM in bitcoins..You will generate less and less with the same hardware over time, by design.  As the number of blocks grows the difficulty increases proportionally to the rate at which the generation is happening so it will always slow down.  If you have a big chunk of the network's compute power you will be generating more than other people but even if you're generating 10 an hour today, in a few weeks you'll be down to a couple a day and everyone else with lesser capabilities will be down to a couple a month.This is all just an artificial way to limit supply to direct the focus to trading rather than just generating, as I understand it.  If everyone is mining gold in their back yard and hoarding it in their garage, it's kind of worthless.  But once the supply of gold starts running out and most of it has been mined (or if you need to dig for 10 years to find an ounce of it), if you want gold you need to trade something for it.. so by design the supply will diminish. Bank sites and such use end to end encryption which makes intercepting more difficult and there is usually two way authentication.  The website authenticates itself to you by showing you your personally selected image/phrase, thus you recognize that this is the site you wanted to visit, and then you authenticate to the website so they recognize you as the customer you claim to be.  It's not perfect but it's like putting a pad lock on a box full of money to keep honest people honest.  Sometimes they use a bigger/thicker pad lock so the effort/gain ratio makes it not really worth trying to break it.I agree with you in a way about security, if it's too inconvenient then it's not very useful... though encryption and authentication are generally good enough to deter trivial things and they provide some reassurance.It is certainly convenient to be able to send to a paypal email address, but even there you get two way authentication.  PayPal will display the name of the person you're sending to, before you commit to how much you're sending.  PayPal is very popular and is riddled with fraud.. if Bitcoin was accepted on Ebay and the IP address based sending was used as it is today, it would never get there because people would just intercept it along the way, TOR or not.If you've used ssh you know that uses two way authentication as well - you verify the server's key visually before you present your own authentication credentials.  This technique is problematic in a way because if it's the first time you're connecting you don't know what it should be.. you have to call up the person operating the server and ask them to read you the key.  I think the idea of putting it into the URL or other address notation is that you declare what you expect it to be and the local client will tell you if the peer presents something different.  I suppose you could go the ssh route, just let someone accept whatever is presented.. though right now the key is dynamically generated, it could be changed so that it would present some key that changes once a day or something.. then you could show it on the web site that's expecting the payment, but then why wouldn't you just show the bitcoin address itself and send that way.I guess I don't really understand your point with simplification.. if you have to copy/paste an address already, what does it matter if it's an internet address, a DNS address or a bitcoin address?  Maybe you just use a regular old URL or URN.. Kind of like namespaces in XML.URN:urn:bitcoin.org:19vcWM6EEbQHVdN2W8NXv9ySgsPjbZ6gU3@12.34.56.78URL (not for using with a web browser, but it's unique):http://bitcoin.org/12.34.56.78/19vcWM6EEbQHVdN2W8NXv9ySgsPjbZ6gU3
I created a little performance counter for myself to use locally, you guys are welcome to try it.Satoshi, maybe you could integrate this or something similar and put an option in there to turn it on/off?  It spams up your debug.log and shows the performance of each thread.. it also shows on the UI in the status bar where it used to say 'Generating'.Patch: http://heliacal.net/~solar/bitcoin/bitcoin-svn-79-perfcounter-2010-06-02.patchScreenshot: I'm not sure what you mean by again (I'm not the developer)..  anyway I'm just trying to explain why I don't think you should use it to accept payments.  Sending payments to a hostname is not reliable for the reasons I said above, and the biggest problem is that there is no way to even know that the payment went to the wrong place, for the sender.  There is a better (reliable) alternative using one time bitcoin addresses.What I was getting at is that there is no authentication and no way to know if the payment got there with internet address based transactions.  I think the internet address based payments are only for testing locally.  The option is there but I don't think it's suitable for using on the internet or any multi-user network.If there was any real amount of internet address based transactions and tor users I would set up an exit node just to intercept any tor based payments.. I still may do it just to see if I can get any because it's just another way to make a few more bitcoins per day.I guess what I'm trying to say that it is the equivalent of leaving a pile of cash in your driveway with a rock on top of it to keep it from blowing away in the wind.  Anyone can just go pick it up and so if you're a service provider you would not want to encourage your customers to pay you in that way, because it would just cause problems when the customer says they paid and the service provider says they didn't receive it.  The only reason it's even possible to use on the internet right now is because unlike cash which has perceived value to a lot of people, bitcoins are like a pile of rocks to random internet users, they just walk by.  If there are all these piles of bitcoins in everybody's driveway and people start figuring out that they're valuable, you can bet they'll start disappearing, so it's best not to put them there in the first place.Laszlo I think the idea is that if NLS is using a tooth pick to go mining and he's valuing the bitcoins based on his time/materials invested, you can just get a bulldozer and mine faster than him and compete, which would encourage him to find a more efficient method or invest in cheaper internet or something.  The value of it, as always, is what someone is willing to trade for it, not what any one individual claims it is. There are security implications with sending payments to a 'hostname' instead of an internet address.  TCP is difficult to forge, however DNS is trivial.  It is not a good idea to send payments to a hostname.  Whether it is an oversight or intentional, it probably should not be used for anything where fraud is a concern.Here's something I quickly googled up for anyone interested: http://adventuresinsecurity.com/Papers/DNS_Cache_Poisoning.pdfIt is not even really an attack, it's just how it works..  This is why once people figured out that DNS was unreliable, things like .rhosts for rsh went out of style and ssh uses public keys instead.  It still does some DNS checking to see if the key changed, which could indicate that the DNS has been used to divert your connection to another host.It is very easy for me to make your computer think that someone-accepting-bitcoins.somedomain.sometld is MY computer, especially if I know you will be sending payment to it.. however if somedomain.sometld is some popular well known service like an exchange, I can just go trying to poison every bitcoin user's cache randomly and see how many I get.  I know every node's network address so I can figure out who their provider is, thus I can easily narrow down which recursors they're likely to be using, so it makes attacking it a lot nicer rather than blindly messing with a bunch of random resolvers that may or may not have any effect.Many internet DNS servers will just accept any random data you send them, though there have been attempts to patch these things and work around some of the really trivial attacks.  In the end though, it is the DNS protocol that's at fault and it is not easily patchable without replacing it.  There are things in the works to make the protocol more secure and such, but until it's adopted by the entire internet, there will always be places to mess with it.It is not even a good idea to send payment to an internet address in my opinion, because the way it is implemented in bitcoin right now, you don't know if you connected to the right node.  There is no pre-shared password or public key to verify manually.  While it is not feasible to take over an existing TCP connection, it is possible to use NAT to divert it.  In this case the attacker would have to have control of a router along the way to your destination, but in the case of Tor anyone can run an exit node and just accept all the bitcoin payments.. it's really easy to do that because they're all on port 8333 so I can just DNAT every connection to 8333 to my own bitcoin host.Just don't use hostnames or internet addresses - use bitcoin addresses. Thanks for the trade BitcoinFX! I ran into some technical problems while experimenting with this and didn't get much farther than the Mac OS version.  It seems that the NVIDIA CUDA 3.0 SDK for linux at least is very buggy when it comes to OpenCL.  It never quite worked right on Mac OS either, it just leaks a lot of memory (the OpenCL implementation, not bitcoin).  I will post an update if I come up with some solutions but I think the issues in the CUDA SDK will just have to be addressed by the vendor.. this stuff is all very beta right now, but I will keep my eye open for any new developments with the SDKs.  I do not have an AMD GPU so I have not been able to develop for that at all, but their support is pretty spotty right now too, almost all of the current cards are listed as experimental support.I think this tech has a lot of potential but I think most people who are using it for anything real are rolling their own vendor specific solutions.  I would rather not pass out something that only partially works and only works for a few people. It only verifies the last few as it is, to speed things up, but it doesn't work backwards.Satoshi has mentioned a simplified payment verification system that he is planning to implement, which would allow payment only clients which do not have to verify all the blocks - he just hasn't written it yet.I think even if you could just have someone 'click here to install instantly' it wouldn't do any good because they wouldn't have any bitcoins and they wouldn't know what a bitcoin is  So the bank wire thing, I need an account in europe for that to be free?  It seems like I would need to exchange a ton of bitcoins to make the 30 euro fee worth it.Is there some way I can establish an account online for that? I just want to report that I successfully traded 10,000 bitcoins for pizza.Pictures: http://heliacal.net/~solar/bitcoin/pizza/Thanks jercos! BitcoinFX, I requested an exchange, however the 'Your Bitcoin address' field would not accept a bitcoin address - it would only let me continue if I put an email address in there. I just think it would be interesting if I could say that I paid for a pizza in bitcoins  So nobody wants to buy me pizza?  Is the bitcoin amount I'm offering too low? The payments won't get lost because bitcoin writes the data to disk immediately, but in your game you would definitely want to perform the same 'flush' operation to commit the transaction to disk before you display the address to the player.  Other than that, everything you described sounds good to me.. the JSON-RPC communication to the daemon is exactly how it is intended to be integrated right now and it sounds like you have a good understanding of the concept already. Teppy, there is a JSON-RPC feature built into the client and that is how people generate integrate it into a web site or other software.  You can send a command to the client to generate an address.  The address that is created is yours forever, and it just allows you to receive payments, but regardless of which address the payment went to, it goes to your wallet.  The coins are 'in' your wallet file and not owned by your address - you don't have to forward it back to your main one.Check out this thread http://bitcointalk.org/index.php?topic=63.0 You can create new addresses all you want.. the way most people are doing this is they generate a new address for the user and display it to them.  When payment is received to that address it credits the user.  You can just generate a new address for each transaction, like a transaction ID essentially.  Link2VOIP automated it all and some others have as well, simply by using the built in JSON-RPC functionality.Satoshi would have to address the other questions about including messages.. Teppy, just so you know, you can't include a message if you send to a bitcoin address, only if you send to an IP address.  The way we usually do it is we issue a new address to each person we ask to send us money so that we know it was that person who sent it. If it only has 15 connections and you say you've opened the port, it doesn't sound like you did it right.If you are using a NAT router and are not directly connected to the internet you need to set up your router to 'destination NAT' that port to your bitcoin computer.  You are using a NAT router if your computer's internet address is 192.168.x.x, 10.x.x.x or 172.16.x.x.On the other hand, you aren't losing out on anything by not having the port open.  It will work fine even with just 1 connection.From your screen shot it looks like everything is working correctly and you are generating coins, you just need to wait about a day for it to 'grow' before you can spend it. A lot of pizza places have online ordering, my wife and I use that sometimes with Papa John's.  Almost all of them will accept credit cards by phone as well  Jacksonville, Florida zip code 32224United States I'll pay 10,000 bitcoins for a couple of pizzas.. like maybe 2 large ones so I have some left over for the next day.  I like having left over pizza to nibble on later.  You can make the pizza yourself and bring it to my house or order it for me from a delivery place, but what I'm aiming for is getting food delivered in exchange for bitcoins where I don't have to order or prepare it myself, kind of like ordering a 'breakfast platter' at a hotel or something, they just bring you something to eat and you're happy!I like things like onions, peppers, sausage, mushrooms, tomatoes, pepperoni, etc.. just standard stuff no weird fish topping or anything like that.  I also like regular cheese pizzas which may be cheaper to prepare or otherwise acquire.If you're interested please let me know and we can work out a deal.Thanks,Laszlo
