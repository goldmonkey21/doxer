No, not specifically my address.  Although after I posted this someone did send a small amount there.  If you look at the blocks in the first post there are other addresses with previous activity that have had very small amounts sent to them recently. Has anyone else been the recipient of unexpected subcent transactions?  I've received some very small (<0.000001) transactions in the last few days.  They weren't from myself and I wasn't expecting them.  Browsing the block chain, I see other address receiving such transactions as well.  I find this very odd, as they are paying more in tx fee than the transaction itself.  Is this some sort of probing attack, or is it just a misbehaving client?  I hope nothing nefarious is happening.  Does the client handle receiving transactions for yourself differently than other transactions?  Is there any info leak here?  I could see someone trying to probe clients with transactions to get info on which client owns what and then go into attack mode when a suitable target is found.Here are a few examples of some blocks I noticed with these small transactions.  The destination addresses seem to be used, so I don't think these are the change address.  There are many more than these.block 132736 has an output for 0.0000001block 132738 has an output for 0.00000001block 132751 has an output for 0.00000005block 133374 has 3 outputs for 0.00000001block 133431 has 2 outputs for 0.00000001If anyone knows what's happening here, I'd be interested in the explanation. There's a crash caused by accessing an array element past the last one in base58.h, in the SecretToASecret function.Code:vch.insert(vch.end(), &vchSecret[0], &vchSecret[vchSecret.size()]);vchSecret.size() is one past the last element, so it crashes here.Since vchSecret is just a vector anyway, we can use this safer alternative:Code:vch.insert(vch.end(), vchSecret.begin(), vchSecret.end()); It means you edit the serialize.h file in a text editor, and add the lineCode:using namespace boost;after the #include lines.Because not everyone has the same version or configurations of the necessary libraries and compile tools, and it would be next to impossible to test all possible configurations.  This is released free and open source.  This means that while it may not work out of the box, you are free to modify it to make it work.  This does not mean you can or should expect it to work out of the box with your particular configuration.Maybe I'll add long poll support if I'm incentivized enough to do so.I have given a significant amount of my time to develop this and release it for anyone to use.  A few good words from a few people and a bunch of complaints from others isn't really enough to provide motivation to continue to enhance this. Update first post with latest release.  The connection to the RPC server will now be kept open if the server supports it instead of opening a new connection for each request. Update first post with latest release.  The connection to the RPC server will now be kept open if the server supports it instead of opening a new connection for each request. It's returning unauthorized because you're not supplying the password correctly.  The parameter is -password not -pass. Updated first post with latest release.  The only major change is this release will let you know if there was an issue getting work from the server and will stop hashing stale blocks. Whatever version of libCURL you linked against isn't redirecting to the correct URL.  Use the correct URL and password parameter in the arguments instead and it should work.Code:./rpcminer -url=http://mining.bitcoin.cz:8332/ -user=user.1 -password=pass If you don't see a line that says "Target = " with something other than all ffs, then the miner couldn't connect to the RPC server and couldn't download work.  Check that your arguments are correct, particularly the login info. Aggression would be the main parameter that affects desktop responsiveness.  Set it to 1 and slowly increase it until you find a balance you like.258.96 is an old driver.  You need a driver that supports at least CUDA 3.2 if you use the supplied binaries.  Alternately, you can compile the source with whatever CUDA toolkit you have available.As I said before, if you don't see a line that says "Build program rval=0" the kernel didn't get built successfully and you're not going to be doing any hashing.  You can try this kernel.  If that doesn't work you'll have to edit the kernel and find out what's causing it not to build. What rendering issues, specifically, are you referring to?  I compiled SVN revision 241 just fine on Windows, and I'm not seeing any rendering issues.  The only issue that I occasionally see is the status bar clearing all values and only repopulating when the window is resized, but it's been like that even in the vanilla client for a long time. Did it build the kernel successfully or not?  You'll just have to find out what in the kernel is causing it not to build on your machine.You don't need wxWidgest to compile just the rpc miners.  Set the appropriate CMake options to not compile the GUI.bitcoinr is the remote miner that works with my open source pool.  It does not work with the various RPC pools that others have.  And the readme does include the various options for the different binaries.4way uses SSE2 instructions, which may be faster depending on the CPU.  The -cpu miner just uses the standard CPU mining found in the vanilla GUI client.You need to compile the .cu file targeting the 1.1, 1.2, and 2.0 CUDA architecture, and give the resulting cubin the appropriate name, and place it in the working directory before you start the miner.Maybe try to #include <limits> in minerheaders.h, before serialize.h is included. Updated source to bitcoin SVN rev 241.  Download available in the first post. Updated source to bitcoin SVN rev 241.  Downloads available in the first post. You need to install the Microsoft Visual C++ 2005 Redistributable Package (x86) Did you put the screensaver and related files in the SysWOW64 directory?  If you put it in the system32 directory, that might be why you cannot see the settings.  system32 is only for 64 bit files on 64 bit Windows, but the screensaver is a 32 bit application. The last release does not need cutil when compiling the CUDA RPC miner, and likewise the CUDA daemon or GUI miners, since they all share the same miner code.  Only the remote miners still need it.  If you are using CMake to create makefiles, it is likely you didn't turn off building of the remote miners. Did you get it to work with the older kernel?No.  The hash rate is constant here whether the window is in the foreground or background.  You can try different graphics drivers (newer AND older) to see if that helps.  It could also be something with Windows 7 interfering with the priority of background apps. You can use the .cl file from the last release.  If you are so inclined, you can edit the current .cl file and see which changes are keeping the kernel from building.  There weren't too many changes, so it should be obvious what the culprit is.
I see at least 2 issues there.  The first is that you don't have a "Target = " message, which means you have not successfully retrieved work from the RPC server.  The second is that you don't have a "Build program rval=" message, which means the kernel is still being built.Did the previous release of the OpenCL miner work on the same machine, and does the current CPU miner work on it?  Did you extract all the files in the archive to a new directory, not just over the old ones?  What graphics card do you have? I just double checked the cpu and CUDA miners in the archive, and they are working fine here.  If you are indeed passing the same parameters, your issue is most probably caused by not being able to connect to the RPC server.  It could also be a corrupt download, or incomplete unzip. Here are RPC miners that work as Windows screensavers.  They have all the functionality of the RPC Miners.  Place the files in your Windows system32 directory if running a 32 bit OS, or SysWOW64 directory if running a 64 bit OS, and configure in the standard Windows screensaver dialog.  You can use the console RPC miners to determine the best settings for your computer, and then configure the screensaver with those settings.Download (Updated 2011-02-27)Windows Screensaver RPC MinersUse the CUDA screensaver for NVidia cards.Use the OpenCL screensaver for ATI cards. I've updated the first post with a new release.  The CUDA miner is now using the driver API instead of the runtime API, and there's no more excess CPU usage when CUDA is running.  Also the CUDA and OpenCL kernels were optimized a bit to improve hashing speed. I've updated the first post with the latest release.This includes some make file fixes and speed improvements for the OpenCL miner.  Tweaking the compiler options have also tremendously increased the speed of the 4way hash in the Windows binaries for processors capable of SSE2.Remember, to get the most out of the CUDA and OpenCL miner, you must tweak the options.  The defaults are just there to give you a baseline.Use CMake. I think there are a few CMake build files for bitcoin already in existence.  For instance, there's one I put together, which you can find in the source package here. You can download the source from the first post and compile the GUI or daemon with the CUDA miner built in. rpcminer-cuda -url=http://127.0.0.1:8332 -user=username -password=password -gpu You have totally incorrect parameters.  Do rpcminer-cuda -help to see the available command line options.  You'll need at least -url, -user, -password, and -gpu if you want to use your video card. I've updated the first post with the latest release.  This fixes a crash that would occur when the work being hashed became stale due to connectivity issues with the server. openldap.dll is in the binary zip file. I've updated the source package in the first post with some of the compile fixes.  I think I got most of the issues in your paste, but I don't understand why this error happens here.Code:#/home/uncaer9/bitcoin-remote-rpc-20101229-src/src/rpcminer/../minercommon/../util.h:155:5: error: previous declaration of int OutputDebugStringF(const char*, ...) with C++ linkage#/usr/include/stdio.h:359:58: error: conflicts with new declaration with C linkage#/home/uncaer9/bitcoin-remote-rpc-20101229-src/src/rpcminer/../minercommon/../util.h:156:5: error: previous declaration of int my_snprintf(char*, size_t, const char*, ...) with C++ linkageMaybe some of the other fixes will resolve this as well. At the top of httprequest.cpp and rpcrequest.cpp add this right after the other #includesCode:#include <cstring> You can safely remove the line from the CMakeLists.txt file where that message appears. It looks like it's still trying to build the remote miner.  You can edit the CMakeLists.txt file in the top directory, and turn off all the options except the RPC miner and the CUDA option if that's what you want. Turn off the daemon compilation as well.  You only need the RPC miner.  Although you will run into the same issue with the miner, see below for the workaround that should compile.  GCC doesn't seem to support returning an iterator as the result of an erase on a container.In rpcminerclient.cpp, replace the CleanupOldBlocks() method with thisCode:void RPCMinerClient::CleanupOldBlocks(){ std::vector<int64> m_erase; for(std::map<int64,std::pair<int64,std::vector<unsigned char> > >::iterator i=m_blocklookup.begin(); i!=m_blocklookup.end(); i++) {  if((*i).second.first<GetTimeMillis()-60000)  {   m_erase.push_back((*i).first);  } } for(std::vector<int64>::const_iterator i=m_erase.begin(); i!=m_erase.end(); i++) {  m_blocklookup.erase((*i)); }}There's a windows binary in the first post.  All other platforms need to compile for themselves. You can try to edit the cmake generated makefiles with the workaround found in this thread The first post has been updated with a new release.  Now you can specify how often work gets requested from the server, and you can specify a url to show server stats in the client. Use the CUDA miner for NVidia cards.  The OpenCL kernel code was unable to compile on your system, that's why it doesn't work. Play with the -aggression, -gputhreads, and -gpugrid parameters.
Alright, so there really is no reason why the current client couldn't determine the best inputs so that <0.01 wouldn't happen unless there are no other better transactions available.Questions about the RPC miners should go in the RPC miners thread. Bitcoin as a protocol can handle sub cents perfectly fine.  In fact, the generation of such blocks demonstrates that capability.  The issue is with the GUI when selecting which transactions to include in new transactions and then ignoring the sub cents left over.  The 0.01 fee is for entire transactions less than 0.01, correct?  So you should be able to include as many sub 0.01 inputs as needed to get over the 0.01, or use a larger input transaction with sub cents, and get the correct sub cent change back.Anyway, since the source of the pooled server is open, you can easily change the generation behavior if it doesn't suit you. No.  Those clients are only for those miners using the RPC method.  This thread is about the open source pooled mining, which uses different miners.  People should continue using whatever miners they've been using for this pool. Here's some RPC miners for all those mining via RPC.  There's a CPU miner based on the Crypto++ code, a 4way miner using the 4way code included with Bitcoin, and a CUDA and OpenCL miner.  The included readme.txt has instructions on how to supply arguments to the miners.  Supplying a -help argument to the executable will show you the available options as well.Want these miners as a screensaver?  See this thread.Downloads (Updated 2011-02-27)RPC Miner Windows BinariesRPC Miner SourceUse the CUDA miner for NVidia cards.Use the OpenCL miner for ATI cards.Use CMake to compile from the source.Tweaking command line parameters for the CUDA and OpenCL miners will be necessary if you want to get optimum performance. The first post has been updated with the latest release.  The source was updated to SVN 205 and there's just some other minor code changes.  No need to update unless you really like having the latest release. We already have an alternative to this closed source cooperative mining service.  It's fully open source, nothing's hidden.  Anyone is free to look at and modify the code.  Due to the way work is distributed, every client can verify they are getting their share before they start hashing.  If the server crashes and burns immediately after a block is generated, you'll still get your share.  Anyone can run a pool server.  Please check it out and help make it better : Pooled/Remote Mining The fist post has been updated with a new release.  In addition to some small code tweaks, the server now displays the bandwidth being used in the GUI, and there is a miner client using the 4way hash code. Where was the trouble when you attached the debugger?  I tried to duplicate this here, but I don't have enough hash rate locally to overload the server.  It sounds like a network issue to me, but it's possible it could be something else.  Are you sure you have enough upload bandwidth to the server?  Is your host throttling it? A few bytes of header info and a json object.  The source is the best resource to look at if you need specific info.Yeah, and the GPU sources need remoteminerclientgpu.cpp changed to remoteminerthreadgpu.cpp.The clients I posted before my last post had a bug that would cause that, so if someone is using those clients you'll see that.  It could also happen if you just restarted the server, and clients are still hashing blocks from before the restart.  It should go away after a few minutes. Try to add this at the top of the cl file.Code:#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable There actually was another issue with the clients that I just fixed and reuploaded.  If you downloaded the source or binaries before this post, download them again and add the line to the cl file. The first post has been updated with a new release.The server will now send the contribution type to the clients, and the clients will display it upon connecting to the server.  The server will also save timing stats to a text file periodically so that we can narrow down what the bottlenecks are.  If you are running a server, please post your timing stats after the server has been up for a while.The clients are now multi-threaded, so you won't have to load the CPU client multiple times if you have more than 1 CPU core.  There is also an OpenCL client included. Just the server.  Any client since the 2010-12-02 release should connect and work fine. I've updated the first post with the latest release.  The "contributed" distribution method should be working now.  That is the only substantial change in this release. It will distribute the coins in the block the same as it did before.  If you see the message that the address wasn't found after the client gets its second block, that means something isn't working quite right on the server.  Check the bitcoin log file to see if there are any messages about clients failing metahash verification.  Most likely, if you are compiling the server yourself, you ran into the same issue I have with release builds in Visual Studio.  If this is the case, try to compile without optimizations turned on.I've tested with the binaries that I've uploaded, and I can confirm that they are working as they should be. I've updated the first post with a new release.  As before, the client and server must be at least the ones from 2010-12-02 to work with each other.  This release should help alleviate the hash rate fluctuation, especially if it is caused by CPU usage on the server.  The CPU usage itself won't be reduced, but it should be more stable.  Also, there is an experimental remote CUDA client included in the release.  Expect half the hash rate you get with the regular CUDA miner built into the standard client.Please note that the way to specify options for the remote miner has changed.  Now you use = instead of space between the option and the value. I've updated the first post with the latest release.  This includes a backwards incompatible change.  Clients and servers both need to run either the old version or this version.  Otherwise the clients will hammer the server with connections, only to be disconnected over and over.  I suggest server operators let everyone know the time they will be updating, and everyone else make their best effort to update their clients at that time. If a client disconnects who was generating a large amount of hashes, and the block was subsequently solved, then he wasn't involved in the creation of the block at all.  It doesn't matter if he provided 99.99% of all hashes up to that point if none of those hashes generated a block.  One and only one client generates the block.  You value total hashes contributed more than hash rate at a point in time, but others may not value this distribution method as much as the current method.  Some may think one method is more fair than the other.  Both methods will be available in the next release, and the server operator will need to decide what to use.Well, as you can see, some people like the "count all hashes contributed" approach, and some prefer the "connected client hash rate" method.  I'm in the process of uploading a new version which includes the new method. I'm at a loss to understand why you think sending a deluge of valid hashes near the end of block generation, or any other time for that matter, would somehow result in a flawed implementation.  The hashes are either valid or not.  It doesn't matter how many are sent, or when they are sent.  They are either valid and counted, or not valid and discarded. That's not a bug, that is how it was designed to work, and you're not losing anything, as no blocks were generated while you were connected.  You need to be connected and actively contributing to get a share of the coins.  Now I am currently working on an alternate distribution method that would count all hashes sent to the server since the last solved block, and distribute based on that.  The server operator will have to select which distribution method they want to use. Try to move the #include for serialize.h before the #include for uint256.h in remotebitcoinheaders.h, and see if you get further.
I've updated the first post with the newest source and binaries.The main changes areDecreased bandwidth utilization, especially for incoming bandwidth to the server.  This will only take effect is both server and client are running this new version.  If there is a mismatch between client and server version, the bandwidth usage will actually be slightly increased.More details displayed by the CPU miner, including the number of blocks generated by the server since it was started, and how many coins the client will get if the current block is solved.  Please note that the first block sent by the server to the client won't have any coins being distributed to the client because it has effectively 0 hash/s at that time. The calculated hash rate is averaged over a period of time, so it will start off low and increase until it approaches the actual hash rate.  There is overhead in calculating the metahash, finding the best hash, and networking, so you won't get the hash rate you get with the vanilla bitcoin client.As long as you can run random executables, have the firewall allow the traffic, and have the Visual C++ 2005 Runtime files installed it will work, but I don't suggest you run this anywhere you don't have permission to.It's based on the proportion of the contributing node's calculated hash rate to the total hash rate of all nodes.  If you contribute 1000 khash/s and all other nodes contribute 4000 khash/s, you get 1/5 of the 50 BTC.The distribution of payment is determined by which clients are connected at the time the block is created.  If you connect and disconnect multiple times, only the last active connection will be valid.  In addition, because of the averaging of hash rate over a period of time, the client will start off with a low calculated hash rate after each connection.Yes there is.  All the bitcoind in that file should be bitcoinr. It's not complicated at all.  Someone sets up a server that is publicly accessible, and everyone else runs the miner client with the -server parameter set to the server's IP address.  If the server operator wants to use a port other than the default, or have a password required for connection, you simply add those parameters as well when you run the client. Is there a particular reason that the pooled miner I created is not sufficient?  It has the basics there already.  It checks the best hash from each client to make sure the clients are doing the work they say, and it distributes the generated bitcoins based on the calculated hash rate of each connected client.  I just updated this thread with the latest source and binaries for pooled mining. I've updated the initial post with the latest binaries and source based on SVN 191. The first post has been updated with binaries.  Because of the issue I was having with the hash generation, I had to turn optimizations off for the bitcoin and bitcoind binaries.Now you're getting closer to just sending every hash the client generates.  I thought the argument was against that. The original post has been updated with the latest source.I've added the best hash to the results when the client sends back the metahash, and as I thought, the results are highly erratic.  Averaging over 10 minutes doesn't reduce the error to an acceptable level.  Averaging over longer periods would either mean clients must stay connected longer, or the server must save the client's work between client connections, and I'm not prepared to write all the code involved in tracking and saving client state.I think a dual approach would work best.  Use the metahash for accurate hash rate and complete verifiability of hashes reported by a suspicious client, and use the best hash to quickly check a client's work.  This will allow both scalability of verification and accuracy of the hash rate.I've also added the full block to the message sent to the client when sending work for the client to do.  This way the client can verify the block has an output to their address.Also, I've added the ability to ban clients by adding them to a file named banned.txt.As far as verifying that the server isn't lying, I don't think that's possible with a multi client, single server architecture.  The server can lie about anything to any client, and each client will be none the wiser.  The only way around that is if each client has perfect knowledge of the other clients connected to the server.  One way to do this is setting up something similar to a torrent tracker, where the server and each client register with the tracker, and the clients can use the tracker to verify the work they are doing and verify the server is also accurately reporting the work other clients are doing. Obviously you don't compute every single metahash sent by the clients.  You hash them periodically, and when an erroneous one is found, or you have a suspicious client, you check more of them.Erroneous results would be a factor for any method of client verification.  The solution is to allow a certain amount of error.Indeed, there is a lot of randomness involved, causing the block generation rate to vary widely.  Smoothing the client's reported hash rate out would require averaging over an unacceptable long time period.  This unfairly penalizes clients who wish to hash for short periods of time, requires complex calculation logic, and results at best in rough estimates.You compare 1 byte of the hash and only if that byte is 0 do you fully check the hash.That's exactly how it is now.The server is capable of sending the block with all transactions to the client for verification.  It does not do so now, but the code would not be too difficult to add.  There is actually a comment in the code to add this feature later.  This way the client can verify they will get their share.  If you would like more detail, the code is the best source of detail you can get.I understand what this suggestion is, but I don't see it as a reliable method.  It assumes you will generate a specific difficulty at a specific hash rate in a set amount of time.  We all know this doesn't happen.  How do you factor in unlucky clients?  What about the lucky ones?  The best you can do is take an average over an unacceptably long period of time to smooth out the hash rate.  I think this method is too imperfect, and has potential to penalize or over reward clients too easily.  I certainly wouldn't want to be the client penalized because I couldn't generate a good hash in a given amount of time. It's only 1 byte of the resulting hash, so 4GiB for 2^32 hashes, which a modern card can transfer to main memory faster than the hashes can be computed.  Memory on the card wouldn't factor into it anyway as you just send the results back in small blocks.What's to stop a client from lying?  They simply generate a few hashes just to send and tell the server, "These are the best hashes I came up with, honest."  In reality the client is spending the rest of the time trying to generate his own block.  There is absolutely no way to verify that the client is not lying this way.  With the metahash approach, you can verify every individual hash a client has reported solving.  If they are lying, even about 1 of those hashes, you will know because the metahash doesn't match.The server creates the block, which obviously doesn't include transactions utilizing the coins that are generated by that same block, mainly because there are no transactions derived from the block since no one knows about the block yet except the server.   I see what you mean now.  Sending hashes for the target block that are a low difficulty.  Well that could work, but I see 2 issues immediately.  The first is that these hashes may or may not be produced in a regular manner, and there is not even a guarantee a client would produce one.  The calculated hash rate based on this metric would have to be taken from a large sample size.  The second issue is that each miner would now need to check the calculated hash against the target after every hash.  This is another operation the client must perform and it will slow down generation. If you did that, the client would then only have to send low difficulty hashes as fast as possible.  There would be no incentive to hash the actual block trying to be solved.  In order to make sure the client is hashing what it is supposed to and know how fast the client is hashing, the metahashes must be derived from the actual block the client is attempting to solve.  There might be other ways to do this, but I think this is the easiest and most convenient. No, there is no code in there to send anything to anyone other than the remote clients and the left over coins from rounding errors to the server operator.It is based on the rate that they send their metahashes back to the server over the previous 60 seconds.  Since the server verifies that the metahashes are correct periodically, you can be reasonably sure that this rate is a good estimate of the client's hash rate.Since the creator of a block determines the fees it wouldn't make sense to include fees for our own blocks.  The distribution of bitcoins are actually included in the output of the generated block, so everyone gets their share as soon as the block is generated and no fees are needed.That only affects the calculation on the server, and everyone will still end up with the same ratio of their khash over total khash.  All the client can do to affect this calculation is send valid metahashes as fast as possible.  If they send invalid ones they will be detected.  If they send duplicates ones, they are ignored. Due to the small likelihood that an individual CPU miner will find a block in a reasonable amount of time, and the expectation from new users to see results quickly, I have developed a server/client for bitcoin that will allow many individual miners to cooperate on solving blocks.  This will effectively aggregate their hashing speed, allow solving blocks faster than individually possible, and distribute the generated bitcoins weighted by the contributing node's hash rate.  This can also be used by an individual who doesn't want to run the full bitcoin client on a computer, but would still like to generate blocks with it.Here is a basic overview of how it currently works.  Someone runs bitcoin as a server, with optional connection password, to accept connections from remote clients.  The server creates a unique block per client, keeps it in memory, and sends it to the client to hash.  The client then hashes the block, appends the first byte of the generated hash to a buffer, and creates a metahash of the buffer when it is full and sends it to the server for later verification.  The client increases the nonce of the block after every hash, but does not modify the block timestamp.  The server will periodically send new blocks for the client to hash, either every 2 minutes, or when the client requests a new block because the nonce is close to overflowing.  Every 10 seconds, the server picks a client with the oldest verified metahashes and verifies the last metahash from that client.  The server will also send status updates to every client every 10 seconds.Currently there are absolutely no built-in negative consequences for a client sending erroneous data, other than being disconnected for sending malformed packets.  The debug log will contain information about misbehaving nodes though.  However, at this early stage in development, it might be bugs causing the issues rather than malicious clients, so this should be taken into consideration.Some things to consider:The generated coins are distributed either based on the contributing client's khash/s divided by all nodes khash/s, or by each clients total hashes contributed divided by all hashes contributed.  This means the generated coins will have precision all the way down to the smallest decimal place bitcoin allows.  Because of rounding issues inherit with floating point operations, the server will accrue all left over fractional coins, which almost always be a single digit number at the smallest decimal position.Because of the metahashing and network activity, the miners will not be as fast as miners strictly dedicated to block hashing.The generated blocks may hit the maximum block size if enough clients are connected.  I haven't looked into this deeply to see what the limit is, but just know that it could be possible to reach this limit.The supplied remote clients are simple proof of concepts.  A client may be created in any language that is capable of handling socket connections and using json, and use any means of generating blocks available to it, such as GPU.The bitcoin binary may have issues displaying and/or using coins generated that are less than 0.01 BTC.  I'm assuming they won't display in the client at all.  I haven't thoroughly tested this.It is possible that the server will need lots of bandwidth if many clients are connectedbitcoin server command line options-remoteserver           Turns on remote server-remotebindaddr=x.x.x.x Bind server to specific adapter.  The default is 127.0.0.1.  Note that this will only accept connections from the local computer.-remotebindport=xxxxx   Bind server to specific port.  The default is 8335.-remotepassword=xxxxx   Set a password to access the server.  The default is a blank password.-distributiontype=connected|contributed    Sets method used to distribute bitcoins.  "connected" will distribute coins only to those clients that were connected when the block being solved was created.  The distribution is based on each connected clients calculated hash rate against the total hash rate at the time a new block is created.  "contributed" will accrue all hashes sent to the server for a given address since the last generated block.  A client may freely disconnect and reconnect and will continue accumulating hashes to whatever address the client specified.  The distribution of coins with this method is based on the hashes accrued by each address against the total hashes accured by everyone.  The server will save the values when it shuts down and load them back up on startup.-resethashescontributed    Resets the count of hashes contributed from each address.client command line options-server=x.x.x.x        The address of the server to connect to.  The default is 127.0.0.1.-port=xxxxx            The port of the server.  The default is 8335.-password=xxxxx        The password to use when connecting to the server.  The default is a blank password.-address=xxxxxxx       The bitcoin address you want generated coins sent to.  The default is blank.  A blank address will make the client's share of generated coins be kept by the server.-threads=x                Start this number of miner threads.  The default value is the number of cores on your processor if using the CPU miner, or 1 if using a GPU miner.There is one issue I haven't been able to resolve.  The hashing functions seem broken in release builds in Microsoft Visual Studio.  In particular, the midstate buffer contains a bogus midstate when sending to the client.  I have checked for buffer issues, and initialization issues, but I can see none.  Upon placing error checking code and logging AFTER the hashing takes place, the results come out correct.  Removing the checking code causes the issue to reappear and the midstate to be erroneous.  Go figure.  Anyway debug builds do not exhibit this issue.  There probably is a bug somewhere, so maybe someone else can spot it.Downloads (Updated 2010-12-24)Pooled Miner Server/Client source based on SVN 205Windows BinariesSee the following thread for details on connecting the miner to a server run by doublecJoin a pooled bitcoin mining effort So that points to you not using the CMake build files.  So your first step should be to use cmake to generate appropriate makefiles with CUDA enabled and then use those to make bitcoin. Why are you assuming it doesn't display any debug info?  If you look in the debug.log, you'll see lots of info on what is detected and what it is doing.  Why was this info not useful to you?Anyway, it sounds like you either don't have a CUDA capable driver installed, or you somehow compiled with CPU emulation turned on.  It's probably the CPU emulation.  A 9800 should get 21 Mhash/s. Here's some CMake build files to make compiling this easier.  Just put the bitcoin source in the src directory and run cmake on the top level directory.  You can compile the GUI and/or the daemon with or without CUDA.CMake files Here's the latest version of my CUDA client.  I've added some options to fine tune performance, and to allow multiple clients to run on the same machine to utilize more than one CUDA device.Other than -gpu, these are optional when using the CUDA miner.-gpu=XTurns on GPU processing on specific GPU device.  Indexes start at 0.  If you just use -gpu without =X it will pick the device with the max GFlops.-aggression=XSpecifies how many hashes (2^X) per kernel thread will be calculated.  Default is 6.  It starts at 1 and goes to 32, with each successive number meaning double the number of hashes.  Sane values are 1 to 12 or maybe 14 if you have some super card.-gpugrid=XSpecifies what the grid size of the kernel should be.  Useful for fine tuning hash rate.-gputhreads=XSpecifies how many threads per kernel invocation should run.  Useful for fine tuning hash rate.-port=XSpecifies the port that bitcoin will listen on-rpcport=XSpecifies the port that the rpc server will listen onpatch against SVN 158full source Code:start bitcoind I just tried your latest patch.  I noticed a few things:Your post, and the patch name, makes it seem like the patch is against revision 157, which does not yet exist.  Upon looking at the content of the patch, it is obvious the patch is against revision 155.You have an extraneous curly brace on line ~3077 when FOURWAYSSE2 is not definedI get about 6200 khash/s with your patch using the GPU only (limit set to 1 CPU).  However without the CPU limit, and using 2 CPUs, I only get 6500 khash/s according to the counter.  That can't be right. You can't be seriously asking what you get out of open source code.Well what?  It's open source.  Do whatever you want with it under the MIT or GPL license.  Don't wait for me.  If you're not willing to put any work into getting it working, why should you expect it to benefit you?Anyone can maintain this, create build files, release binaries, etc.  It is open source.  You wanted it open source, you got it.The sense of entitlement here is just astonishing.  It seems like very few want to do the dirty work and everyone else wants to benefit from the work of others without giving anything themselves.
I have some good news.  Because of a generous contribution by jgarzik, I am releasing the code for the CUDA client.Open sourced by The Bitcoin Store:CUDA enabled source based on SVN 153, MIT licensedAdditionally, I am releasing a GPL licensed version, which is where I will be making further enhancements:CUDA enabled source based on SVN 153, GPL2 licensedpatch for above source What license would be preferred for an open source CUDA implementation? If there would be a 10000 BTC bounty I would open source it right now.  You understand I spent a considerable amount of time and effort creating this and want a return on my investment.  People cracking it and nit picking about perceived license issues when it is clearly not open source just makes me not want to bother with releasing anything.  Why should I bother if people don't respect it?  Anyway, like I said I'd release all the source given a large bounty, and If I discover some magic way to increase the hashing rate in the future (not likely) I would not want any more. His geographic location only has a bearing on his rights under the license, not the license itself.  One license doesn't magically become a different license based on where you are, unless he really is in that parallel universe. No matter how hard you try, it doesn't change the fact that my modifications are not MIT licensed, nor do you have the right to alter and redistribute them. You missed the point that my modifications are not MIT licensed, so you do not have the right to distribute any derivative work. I suggest you reread this portion of the readme.txt:Code:This is a Windows 32 bit CUDA enabled build of the bitcoin client, based on SVNrevision 153.  By using this release, you agree to send the author,1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM, 5 bitcoins every time you generate a blockwhile using the CUDA bitcoin miner.  This payment will be automatically sentwhen a block is generated.  If you do not agree to this, you must not run theclient or attempt to modify it in any way to circumvent this. I won't deal with those who openly attack my work and provide cracks.  Remove your link and promise not to do it again and we'll talk. Or everyone could do the obvious thing and donate to me to open source it.  Why do you find my work so worthwhile to crack, yet you won't help the community by donating to open source it?  You do realize that you can crack it all you want, but without the source code you'll get stuck with an outdated client very fast.  I'm on the verge of releasing an OpenCL enabled build as well.  Do you really want to be the person who changed my mind about releasing it and providing enhancements to the CUDA version?  I'm sure the community will let you know how they feel about this. My client is CUDA only for now.  Unless you have another CUDA device, it's not going to work on a Radeon. Here's the latest binary based on SVN 153.  It includes bitcoind and has an added command line option to squeeze out more hashes/s at the cost of a less responsive desktop.See my signature for the latest download. So you use satoshi's pots and pans and my special spoon to make the whole thing go quicker.  Everyone is free to create their own special spoon, but not too many will do such a thing.  If you want to use my special spoon, you have to give me a portion of what you create.  In a given amount of time, however, using the special spoon will net you more than if you didn't use it. No, it's 5 coins per block.  It doesn't matter how many blocks you've already generated or how many you're going to generate, it's always 5.  If you have 0 balance when you generate a block, the payment will wait and accumulate if you generate more blocks until you have a balance. I just triple checked the amount by connecting 2 clients together and the payment is definitely only 5.  Did you use the same wallet to do testing and then go on the live network?  The wallet will accumulate the payment.  If you post an address I'll send back your coins, but first delete your wallet or it will probably happen again. The 5 per block are cumulative, so If you had a 0 balance and generated multiple blocks it waits until a balance is available and sends 5 * generated blocks.  Did you really generate 10+ blocks so fast? Satoshi and the others wrote the code that made it possible to write the client, but they did not write this code that uses the GPU to generate the blocks.  I would be more than happy to add an extra 5, 10, 20, or whatever payment for satoshi and any others who worked on the bitcoin client if you like.  Anyway, are you really donating to them now after every block you generate?  Are you going to donate to them after every block you generate on your CUDA client?  After all, they made it possible for you to write it.You are perfectly capable to make that payment yourself when you generate a block. There is no ransom involved.  Use of the client is at the will of the user, and the cost is explained and known about up front.  Would you feel better if there was a single large up front cost for each user?  The way it is now, the cost is proportional to the number of blocks you generate, which I think is much more fair.  Otherwise it will be severely disproportionate for those who use it very little or have a slow GPU and those who use it a lot on a fast GPU.Now I have seen a few say they would be willing to donate for an open source client.  I would be willing to release the source provided a large enough donation is made. Here's a build with the latest svn, 149.See my signature for the latest download. If I were to receive a sizable donation, I might be willing to open source the code.  However, any talk about hacking or cracking the current client makes me less likely to do this, and I will not accept donations from anyone who has already advocated for such measures.Here's a little story to think about.There is an apple tree growing in some public place where everyone is free to take apples whenever they wish.  Everyone is happy and content eating the free apples directly from the tree.  Now some start to think about all the possibilities that the apples can provide.  You can make apple juice, apple cider, apple pie, etc.  Most only think about the possibilities and don't take action.  Either because they can't cook, or they don't have the time or resources.  Now someone comes along and decides to make apple juice.  He sets up a stand and sells the juice to the people.  Some people are fine with this, and happily pay.  They understand the value added to the apple by processing it into juice.  It took time, effort, and resources to do so.  Others are upset that the apples they had been getting for free have been processed and that they now have to pay for the refined product.  They would rather take the apple juice by force rather than paying for it or making their own.I understand that some of you are uncomfortable with the client.  If that is the case the obvious solution is not to use the client. Sure, if someone wanted to code a screensaver they could do that.
