Secretary work?Lindsay WAS the Foundation at the beginning, and did EVERYTHING (including single-handedly organizing the San Jose conference).She, like me, got a huge salary boost because the Foundation's original policy was to set the exchange rate for paying salaries once per quarter. That policy changed pretty quickly (neither Lindsay or I had any influence on our own salaries or the policies for how they were paid) to "use the CoinDesk price index on payday."You have to remember that even simple things like "which exchange rate should be used to pay employees" didn't have simple answers back then (nobody had created a cross-exchange, volume-weighted price index).I believe she left the Foundation partly because of annoying misogynistic Internet trolls like the ones found in this very thread.... You can't, the reference implementation wallet always pays some-amount-per-1000-bytes-of-the-transaction.The rules for the 0.10 release are:+ By default, you always pay a fee (this is different from previous releases that would send transactions without a fee if they had high enough priority)  (run with -sendfreetransactions=1 to get the old behavior of sending high-priority transactions without a fee)+ By default, the fee-per-kilobyte is estimated based on recent transaction confirmation history.To get close to what you want (pay a fixed fee per transaction), run with -paytxfee=0.whatever  : that tells the wallet code to pay 0.whatever BTC per 1000 bytes. Most transactions are about 500 bytes big.See here:  http://core2.bitcoincore.org/smartfee/fee_graph.html  ... for how high to make -paytxfee=0.whatever based on how long you're willing to wait for the first confirmation (that page graphs estimates from the latest&greatest fee estimation code from Alex Morcos that will hopefully be in the 0.11 Bitcoin Core release). Finally a reasonable question:The problem people are worried about if the maximum block size is too high:  That big miners with high-bandwidth, high-CPU machines will drive out either small miners or I-want-to-run-a-full-node-at-home people by producing blocks too large for them to download or verify quickly.An adaptive limit could be set so that some minority of miners can 'veto' block size increases; that'd be fine with me.But it wouldn't help with "I want to be able to run a full node from my home computer / network connection." Does anybody actually care about that? Satoshi didn't, his vision was home users running SPV nodes and full nodes being hosted in datacenters.I haven't looked at the numbers, but I'd bet the number of personal computers in homes is declining or will soon be declining-- being replaced by smartphones and tablets. So I'd be happy to drop the "must be able to run at home" requirement and just go with an adaptive algorithm. Doing both is also possible, of course, but I don't like extra complexity if it can be helped.It is hard to tease out which problem people care about, because most people haven't thought much about the block size and confuse the current pain of downloading the chain initially (pretty easily fixed by getting the current UTXO set from somebody), the current pain of dedicating tens of gigabytes of disk space to the chain (fixed by pruning old, spent blocks and transactions), and slow block propagation times (fixed by improving the code and p2p protocol).PS: my apologies to davout for misremembering his testnet work.PPS: I am always open to well-thought-out alternative ideas. If there is a simple, well-thought-out proposal for an adaptive blocksize increase, please point me to it.  Are you this annoying in person, or just online?I spent last week talking to some of the largest Bitcoin businesses (much bigger than Paymium/Bitcoin-Central or anything anybody in #bitcoin-assets is involved with), and they all want the maximum block size to increase.The poll in this thread says people support it by a three-to-one margin.It is going to happen sooner or later. I want it to happen sooner because Very Bad Things will happen if we get to 100% full 1MB blocks: http://hashingit.com/analysis/34-bitcoin-traffic-bulletinI'm busy writing benchmarks, finding bugs in current code, and generally making sure nothing will break when we increase the maximum block size. If you want to be helpful instead of being an annoying troll, I have a TODO list you could help out with. Although the last time you agreed to help out, Dave, you didn't follow through on your promises (do you remember when you agreed to help with the testnet?). With economic reasoning like that, I see why Paymium has such low transaction volume (if you're making massive profits because your costs are so much lower processing so many fewer transactions than the bigger exchanges, then I'll adjust my priors). Yes, I meant revenue, not profit.I need to stop saying "profit" entirely, even when I mean "profit"-- it has different meanings for economists and ordinary people. Why do we need transaction relayers? What vital function do they provide?Miners need to be connected to each other, and to transaction creators (individual users, exchanges, merchants, online wallets, etc).And transaction creators need to be able to connect to miners, but it seems to me transaction fees should certainly be enough incentive for miners to arrange for there to be plenty of opportunity for transaction creators to send them fee-paying transactions (it's cheap to run nodes that have tens of thousands of incoming connection slots). Why do you want miners to have an incentive to make smaller blocks?Smaller blocks means fewer transactions, so fewer opportunities to collect fees, so less profit.Miner profit in fiat currency = number of transactions * average transaction fee * btc-to-fiat exchange rateExperience (and common sense) says that more usage of Bitcoin means a higher btc-to-fiat exchange rate, so if you want to maximize miner's fee revenue then increasing the number of transactions is the obvious way to do it.If you think that putting an artificial cap on the number of transactions will increase overall miner profit, then I urge you to find a Real Economist and talk to them about the wisdom of trying to use production quotas to keep prices artificially high. ... I managed to be wrong twice:  I forgot about the AreInputsStandard check for P2SH transactions that makes any transaction with more than 15 signature operations non-standard.So if you REALLY need a m-of-16-to-20 transaction, use a non-standard raw CHECKMULTISIG, don't bother with Script gymnastics to try to workaround the 520-byte push limit. Very nice work, DeathAndTaxes.The 0.10 release makes almost all P2SH Script forms standard, opening up possibilities for working around the 520-byte-push limit.Warning: half baked thoughts off the top of my head here, check my work and TEST TEST TEST:There isn't room in 520-bytes for all the compressed public keys needed for m of 16-20. Can we safely move the public keys out of the serialized P2SH onto the scriptSig stack?e.g. go from a scriptSig that looks like:Code:0 signature  serialized(1 pubkey1 ... pubkey20 20 CHECKMULTISIG)to:Code:0 signature pubkey1 ... pubkey20 serialized( 1 ... something ... 20 CHECKMULTISIG)That's easy to do unsafely; ... something ... is just:Code:21 ROLL ... repeated 20 timesThat's unsafe because anybody can redeem it with any 20 keys.To be safe, you need a secure digest of the 20 public keys inside the serialized P2SH stuff. We've got HASH160 to create 20-byte digests, so we can get 26-bytes-per-pubkey with:Code:21 ROLL DUP HASH160 pubkey1hash EQUALVERIFYUsing PICK instead of ROLL you can probably save a byte per pubkey; if it can be done in 25 bytes then that gets under the 520-byte-push limit.Aside: It would've been lovely if Script had a "hash the top N items on the stack, and push the result onto the top of the stack" operator.  Ah well.BUT you're now putting 33+26 = 59 bytes per key into the scriptSig, so the 1650-byte-for-scriptSig-IsStandard limit will bite. If I counted everything correctly (and I almost certainly didn't), you could get 1 through 6 -of-20 as standard (20-of-20 as non-standard but valid).EDIT:  I already see a mistake:  pushing 21 onto the stack requires two bytes, not one..... I think it will depend on the release.Adoption of 0.10.0 is looking really good: https://getaddr.bitnodes.io/dashboard/?days=90#user-agents... going from about 3% of nodes to 12% in just the last three days.Different versions existing on the network isn't a problem until there is some incompatible change in either the consensus code (a hard fork) or the p2p networking protocol (and even that doesn't have to be a problem if there are "bridge" nodes that speak both versions of the protocol and relay blocks/transactions across the incompatible networks). I agree.My guess is that we will end up with a very secure system with a modest amount of hashing in the future, because PoW hashing does three things:1) Gives a steady 10-minute 'heartbeat' that limits how quickly new coins are produced2) Makes it expensive to successfully double-spend confirmed transactions3) Makes it expensive to censor transactionsThe first becomes less important over time as the block subsidy halves.I think we could do a lot to mitigate the second (see https://gist.github.com/gavinandresen/630d4a6c24ac6144482a for a partly-baked idea).And I think the third might be mitigated naturally as we scale up and optimize the information sent across the network (there will be strong incentives to create "boring" blocks that don't include or exclude transactions everybody else is excluding or including). Interesting idea, but I'm afraid I disagree with your premise.There is no tragedy-of-the-commons race to zero transaction fees, because miners do not have infinite bandwidth, memory or CPU to accept and validate transactions.We used to have a tragedy-of-the-commons situation with zero-fee transactions, but we solved that by rate-limiting them based on priority. And we have a working market for zero-fee transactions (see the graph here).Assuming network bandwidth is the eventual bottleneck, and assuming there is demand for transactions to fill the available network-wide bandwidth (even if that demand is transaction spammers), nodes will start dropping transactions before they relay them. Prioritizing them based on fee paid and dropping the lowest fee/kb transactions will result naturally in a working market for fee-paying transactions.As justusranvier points out, off-the-blockchain deals between transaction creators and miners doesn't change that logic, because low-fee transactions that are not broadcast break the O(1) block propagation assumption and have a direct cost to the miner.I think you are trying to solve a different problem: I think you are trying to ensure that "enough" fees are paid to secure the network as the block subsidy goes away. Yes? Huh what?I am not proposing infinitely sized blocks, so I obviously acknowledge the concept of a too-high limit as being plausible.If you want to continue the conversation, please be very explicit about what problem you think needs solving, and how whatever solution you're proposing solves that problem.We might agree or disagree on both of those points, but we won't have a productive conversation if you can't say what problem you are trying to solve.To summarize my position: I see one big problem that need solving:Supporting lots (millions, eventually billions) of people transacting in Bitcoin.  Ideally at as low a cost as possible, as secure as possible, and in the most decentralized and censorship-resistant way possible.It is hard to get consensus on HOW to solve that problem, because no solution is obviously lowest cost, most secure, and most decentralized all at the same time, and different people assign different weights to the importance of those three things.My bias is to "get big fast" -- I think the only way Bitcoin thrives is for lots of people to use it and to be happy using it. If it is a tiny little niche thing then it is much easier for politicians or banks to smother it, paint it as "criminal money", etc. They probably can't kill it, but they sure could make life miserable enough to slow down adoption by a decade or three."Get big fast" has been the strategy for a few years now, ever since the project became too famous to fly under the radar of regulators or the mainstream press.The simplest path to "get big fast" is allowing the chain to grow. All the other solutions take longer or compromise decentralization (e.g. off-chain transactions require one or more semi-trusted entities to validate those off-chain transactions). I'm listening very carefully to anybody who argues that a bigger chain will compromise security, and those concerns are why I am NOT proposing an infinite maximum block size.There is rough consensus that the max block size must increase. I don't think there is consensus yet on exactly HOW or WHEN. If I ever go insane and suggest increasing the 21 million coin limit, please put me on your ignore list.I will remind everybody again of Satoshi's second public post where he talked about scalability:If you didn't do your homework and thought that Bitcoin == 1MB blocks forever, well, that's your fault.I signed up for a Bitcoin that would scale. What's wrong?Lets say those million dollar transactions are 250 bytes.  That is 4,000 of them in a 1MB block.So $40,000 total reward to the miner -- about eight times current block reward.BUT YOU ARE SECURING TRANSACTIONS WORTH SOMETHING LIKE 2,000 TIMES MORE VALUABLE THAN TODAY'S TRANSACTIONS (estimated average transaction USD value for today's average transaction is about $380). And I GUARANTEE that attackers would have a much easier time pulling off a double-spend of one million-dollar transaction than 1,000 $1,000 transactions.The math for "large value transactions will generate enough fees to secure the chain" just doesn't work.The math for "lots of small transactions will generate enough fees to secure the chain" might.Also:I still haven't heard a coherent argument on why large value transactions are necessarily also high-fee transactions.I'd suggest you go research existing high-value-payment networks and see what typical fees are for multi-million dollar transactions. FEDWIRE is running at 6 transactions per second, average transaction value over $6million, with fees per transaction UNDER ONE DOLLAR.Why? Because if you are giving somebody one million dollars for something, you almost certainly have built up real-world trust, and probably have a longstanding relationship, signed contracts, etc etc.If you think Bitcoin is different, please explain the scenario where I send a stranger who I don't trust (so have to rely completely on the blockchain) $1million for something. I think we should target somebody with a "pretty good" computer and a "pretty good" home internet connection.And assume that network bandwidth, CPU and storage will continue to grow at about the rates they've been growing for the last 30 or more years (see the wikipedia pages on Moore's Law and Nielson's Law for pointers to discussions on those).250gb per month is plenty for a 20MB block size(20MB every ten minutes times 6 blocks per hour times 24 hours/day times 31 days/month == 90GB; we currently transmit all transaction data twice (haven't optimized that yet), so double that and you're still well under 250gb per month).I believe it is extremely important to maintain the fundamental properties that Satoshi laid out -- because the system he described is the system that all of us who own bitcoin bought in to.If the collective decision is to change some of those fundamental properties, then there must be extremely good reasons to do so.On the block size issue, Satoshi said on Sun, 02 Nov 2008 on the metz-dowd cryptography mailing list (in reply to a question about scalability):When I first heard about Bitcoin, it was small enough I could read everything, and I did, including all of those mailing list posts. The promise of a system that could scale up to rival Visa is part of the vision that sold me on Bitcoin.I feel bad suggesting that we limit the block size at all, or that the target be home computers and internet connections -- but I think there are plausible concerns about centralization risk, and I think starting small and scaling up as technology advances is a reasonable compromise. No, it really wouldn't, any more than a business-as-usual temporary blockchain race/fork creates confusion or breaks applications. Like the one-block fork we had today. No, please report security-critical issues (including consensus bugs) to the bitcoin-security mailing list: bitcoin-security@lists.sourceforge.net Why would a miner want only half the network to build on their block?That makes no sense... what is the +2hr timestamp miner trying to accomplish?
Even in that case, the certificate is "a" weak link, not "the" weak link. Think through what would have to fail to pull off a steal-bitcoins attack in the multisig-wallet case:1) User has to be directed to an attacker-controlled payment website. That means either DNS lookup is compromised or the user's connection to the Internet is compromised (weak link number 1).2) Attacker serves up a signed PaymentRequest with a valid certificate signed by a compromised root certificate authority (weak link number 2).If the attacker can accomplish (1), it is likely they would just serve up unsigned payment requests from a non-secure website and bet that the user doesn't notice the lack of a padlock in the web browser UI and agrees to pay to an unauthenticated bitcoin address.(1) is mitigated if the payment website uses HSTS headers so any repeat visitors get a HTTPS connection-- that pushes the attack to "must compromise both the connection and be able to spoof the web server certificate".  Strike that, if their computer is compromised HSTS headers won't help.In any case, I wouldn't say the root certificates are a single point of failure. https://bitcointalk.org/index.php?topic=815712.0;allThere are other threads going back a long way, but I'm too lazy right now to dig them up. A search for "maximum block size" or "1MB blocks" in the Dev&Tech forum should find them. If your system is compromised, and you are using a single-signature wallet, then the first time you unlock your wallet ALL your coins are gone.root certificates are not the weak link in that case; the keys being on one device is the weak link. Really?If your luddite parents' computer might already be compromised, they cannot securely connect to coinbase (or circle or any other easy-enough-for-a-luddite-to-use service) to set up an account. The might THINK they're connecting to coinbase/circle/whoever, but malware could be man-in-the-middle attacking the website they're looking at.They think they're opening an account at coinbase/circle/whatever... but they're just giving the attacker all their bank account information, getting bitcoin 'deposit' addresses from the attacker, etc. Your parents will have no clue until their bank tells them about odd wire transfers or they try to send bitcoin somewhere, it fails, and coinbase customer support tells them "Sorry, can't help you, you don't have an account with us."I would say the same about traditional online banking, except your luddite parents almost certainly already have a relationship with their bank, and the bank already knows their name and how to contact them. And it is harder for an attacker to man-in-the-middle the fiat banking system and get away with it, since identities are tied to bank accounts, wire transfers, etc.I don't know how the "Bitcoin for Luddites" problem will be solved. Maybe hardware wallets, maybe hardware authentication tokens, maybe Apple or Google will get iPhone or Android security tight enough to trust, maybe it will take "come to our branch to set up an account" to get good-enough security and usability. +1I don't get to write the headlines, though... "Three sir!"Actually, 1 and 2 aren't correct: the one-output and only-40-bytes checks are "what is a standard transaction" policy rules. If you can get a miner to include it in a block, a transaction with 11 100-byte OP_RETURN outputs is valid. RE: can't wrap your head around what the Bitcoin Foundation does:It is in big letters at the new https://bitcoinfoundation.org/ home page:See the blog post from last month on the Foundation's "pivot" to focus on development and infrastructure:  https://blog.bitcoinfoundation.org/everybody-pivots/RE: "The Board appears to have not settled on an exact date":Settled 11 days ago; see https://blog.bitcoinfoundation.org/elections-update/ for the exact dates for the two individual seats.The election dates for the 'affiliate member seat' isn't yet set, the process for affiliate organizations to nominate and then cast their votes is still being worked out (and you don't need to care, unless you are part of the leadership of one of the Foundation's affiliate organizations and need to figure out how you and your members will come to consensus on how to vote). Huh what? Field report from my talk at the CFR?I barely remember it, there were probably 50 people in suits in the audience, nobody I recognized. The whole thing is on video, there were no secret meetings, I got there 10 minutes before my talk and left 10 minutes after (I had a bunch of interviews with DC-based journalists scheduled... and I think that was the trip I had lunch with Jim Harper and got a tour of Cato, although I might be mis-remembering). I am not a lawyer, but...... the money transmission laws and regulations are written very broadly. They almost certainly apply even if you are exchanging one crypto-currency for another, and no "real money" is involved.The only saving grace is that the laws only apply if you are operating "a business" -- so occasional lowish-value person-to-person exchanges done as a favor to friends at no markup from the current exchange rate is probably perfectly legal. Excellent advice.I'd add: you never have infinite time, so you will have to prioritize.Cryddit's original post talks a fair bit about preventing data leakage in side-channel attacks; I'll just say that if you only have time to either get 100% code path unit test coverage or hand-code some assembly to workaround your compiler leaving a private key in memory instead of a register... I'd work on the test coverage.And if the choice is between 100% test coverage versus 91% with support for threshold signatures on multiple devices-- I'd choose threshold signatures.And, of course, the highest priority is creating a product or service that is both trustworthy and that people want to use. If you want to work on IBLT stuff...... start with Matt's fast-relay code: https://github.com/TheBlueMatt/RelayNodeThat is an "I know what I've already told my peers, so I won't tell them again" optimization for transaction data. I haven't tried to figure out how far that already-written-and-running code lets us scale, but I think that would be the first step.Once you understand what Matt is doing, then figure out how an IBLT can further optimize to eliminate sending even lists of transaction IDs. The first step there is to figure out what software miners are using to build their blocks, and figuring out how hard it would be to get that software to do the IBLT thing (have similar policies for selecting transactions, and identical policies for ordering transactions inside the block). You don't seem to have the "jump in and help" mentality needed to participate in a radically open project like Bitcoin.As I have said repeatedly in the past: you don't have to ask anybody for permission or advice. You are part of the process-- make it happen.Personally, I don't know nuthin about "opfor teams" ...  (but am the creator of the Bitcoin testnet, so am offended by you saying there is no ability or desire to bring more testing rigor to Bitcoin). There seem to be a few people who want some OTHER algorithm for increasing the block size, but I'm hearing very broad consensus that we do need a hard fork to increase the size.That is progress.I'll be running some experiments using actual blockchain data to see where the current code breaks; if it can already handle 20MB blocks then I'll work through the details to propose a hard fork (write BIPs, write code, write tests, ...). Please be more precise.Nobody "increases the block size" -- miners choose to create larger or smaller blocks, up to the maximum block size limit.And quoting myself: (from my recent blog post): See https://bitcoinfoundation.org/2014/10/a-scalability-roadmap/ Wait... no... that example is only valid for the "attacker takes over existing mining pools" case, where formerly honest miners are co-opted to be evil (or gang up in a cartel to be evil).If somebody collects as much hashing power as the rest of the network combined and then suddenly attacks, then yes, indeed, difficulty stays the same, the attacker gets all the mining rewards, and there are twice as many stale blocks as before.  Attacker gets 6 block rewards per hour.If they were to mine honestly, blocks would be created twice as fast until difficulty adjusted, so they'd get 6 block rewards per hour for a week (same as if they decide to attack). Then difficulty would double, and they'd get only 3 per hour. You are wrong.Example that should make it clear:Honest miner with 50% hash power:  will mine 6 blocks every two hours (on average). Rest of the network will mine the other 6 blocks.Attacking miner with 50% hash power: will mine 6 blocks every four hours (on average), because they refuse to build on anybody else's blocks.Result: if the attacker is the longest chain, they'll get half as many BTC as honest mining (if they are unlucky and are not the longest chain, they'll get zero).If they could keep up the attack for a full month until difficulty adjusts then they'll start making what they would have been making if they were honest. Or maybe I just ate too much peyote one night (and, happily, decided to read bitcointalk instead of write some code).(and for the humor-impaired: NO, NOT SERIOUS. Everybody knows I don't eat peyote, I spend my money on hookers and blow.) I'd also slightly prefer 'mikes', but consensus is for 'bits' among the people who will actually Make This So (the big merchants/exchanges). YES THAT WAS TOTALLY AND COMPLEETLY A COINCEDENCE!!!! HE WUZ PLANNING ON LEAVING WAY BEFORE THAT!I THINK THE OP IS RIGHT, SO I'M GONNA MOVE THE SOURCE CODE TO SUMPLACE MORE SECURE WHERE THE GOVERNMENT CAN'T SEE IT ANYMORE. AND I WENT AND GOT ME A GOOD HAT TO WEAR WHEN I WRITE CODE SO THEIR SATELITES CANT HEAR ME EITHER.FOR THE CHILDREN!
"patches welcome"In general:  "meh"  -- most testing is done in -regtest mode in a more controlled environment these days. I couldn't resist peeking at the literature; the first hit on a google search for "experimental economics free rider" turns up this 1984 paper: This is a very important concept to internalize. I don't think Satoshi realized it, and I think if he did Bitcoin Script would be very different from what we have.In a future ideal world where arbitrary zero-knowledge-proofs are time-tested and have robust implementations, everybody except for the N entities directly involved in a transaction would validate a short, opaque proof that some computation took place authorizing the transaction.If you're designing a better transaction system, you should design with that ideal in mind. How do you imagine you will be able to keep transaction fees artificially high?I can imagine a future with 1MB blocks full of zero-transaction-fee transactions (all fees paid off-blockchain through special cozy relationships between big merchants/exchanges and big miners. Or simply big merchants/exchanges mining their own transactions).I think network security CAN be funded through transaction fees-- that is easy, if you want to buy some security just attach a larger-than-strictly-necessary-to-get-confirmed fee to your transactions.I don't think we know yet whether network security WILL be funded through transaction fees; there might be a free-rider problem that keeps people who want a secure network from actually paying for a secure network.This is where it would be lovely for some academic economists who have studied the free-rider problem to chime in and predict what is likely to happen, and how other markets have solved (or not) the problem. You seem to have a very narrow definition of "decentralized system." In the future I imagine nodes might probabilistically check a random subset of transactions, and broadcast "this transaction is fraudulent" if they find anything wrong.  If you imagine a million nodes, each fully validating one-in-ten-thousand transactions then you get each transaction validated on average 100 times.That's not so different from your 'treechains' idea (just simpler and easier to reason about, in my humble opinion).If you think that hardware costs are going to dominate decentralized-versus-centralized payment network costs, then I think you're wrong. Hardware is cheap, people are expensive.But all of this is really arguing angels-dancing-on-the-heads-of-pins; we've got years before we have to worry about how to fund network security, and a whole lot of things to work on before then. You can mitigate the attacks described in the paper by running bitcoind with more lenient banning behavior.E.g. put this in your bitcoin.conf:Code:bantime=11... so if Tor peers sharing an IP address are banned, they are only banned for eleven seconds.If you want to live dangerously, you can also set:Code:banscore=10000... to make it a lot harder for an attacker to cause you to ban naughty IP addresses. But this might make it easier for an attacker to fill up your node's memory with garbage. That is easy, the first. But that is a straw-man argument.If the decision is:  costs 1.001 kWh and gives 99.99, versus 1kWh and gives 99%, I might decide the extra purity is worth it.The "centralized is more efficient" might be theoretically true, but in practice the difference might be so slight it doesn't matter.Theoretically, it would be more efficient if all of our computing happened in huge data centers located near cheap hydroelectric power.Practically, though, only some of our computing happens that way (e.g. searching terabytes of data), because it is more convenient for us to carry around powerful little computers and we value that convenience. I still feel that way.I believe that if people want a secure network, they will figure out a way of getting it. My justification is the same as my belief that if people want clean, cheap, safe drinking water they will figure out a way of getting it.I don't claim to know how, and it is very possible the how will offend the sensibilities of either (or both) of the "PRIVACY AT ANY COST!!!!" or "DECENTRALIZATION AT ANY COST!!!!" factions. Just like government regulations and institutions around clean water offend the "INDIVIDUAL LIBERTY AT ANY COST!!!!" faction.I can imagine a lot of possible futures, from big merchants and exchanges investing in mining to save themselves on transaction fees and ensure that their transactions are confirmed securely, to assurance contracts, to a cartel of miners regulated and funded and licensed as a global public utility.I hope that last one doesn't happen... "Huge stashes" is a bad assumption. Tweet from Jeff Garzik earlier this year:  "As such, I dare to do what few if any others do:   My #bitcoin balance is 348.006 BTC."I'm guessing other frequent contributors have this mindset:And I'm sure lots of early adopters thought: RE: O(1) versus O(some-function-of-total-number-of-transactions):Yes, it will depend on whether or not the number of differences goes up as the number of transactions goes up.The incentives align so it is in everybody's best interest to make the differences as small as possible. I wouldn't be surprised if that causes innovations to drive the actual size to O(1) minus an increasing constant, as code gets better at predicting which transactions our peers do or don't have. Start a new thread.  HAVE you read my Scalability Roadmap blog post? When you respond to me saying patronizing things like "there are other problems with the way scalability is limited," I have trouble not thinking you are either confused or insane. Or just lazy, and did not read my "Scalability Roadmap" blog post.It is certainly true that nobody can predict the future with 100% accuracy. We might get hit by an asteroid before I finish this sentence. (whew! didn't!)But extrapolating current trends seems to me to be the best we can do-- we are just as likely to be too conservative as too aggressive in our assumptions. I think you are confusing MAX_BLOCKSIZE with the floating, whatever-the market-demands blocksize.MAX_BLOCKSIZE is, in my mind, purely a safety valve-- a "just in case" upper limit to make sure it doesn't grow faster than affordable hardware and software can support.Ideally, we never bump into it. If we go with my proposal (increase to 20MB now, then double ten times over the next twenty years) I think it is reasonably likely the market-determined size will never bump into MAX_BLOCKSIZE.I think it is very unlikely that in 20 years we will need to support more Bitcoin transactions than all of the cash, credit card and international wire transactions that happen in the world today (and that is the scale of transactions that a pretty-good year-2035 home computer and network connection should be able to support). Please stop trolling. I think what I think and do what I do because I want the Bitcoin Project to be even more wildly successful.If I was motivated by greed I would have a much higher salary. And lots of stock options.The majority of Bitcoin users here want transaction fees less than a penny; I want them to be as low as practical. The only way to get there is to increase the block size. Is there really any disagreement? Everybody I have talked with believes that transaction fees will rise if Bitcoin is successful and the 1MB limit is kept.How much we won't know-- that depends on how much demand for transactions moves somewhere else (fiat currency, altcoin, or some off-blockchain solution).There is a small minority of people who believe that it would be BETTER if transactions moved to fiat currency, an altcoin, or some more-centralized off-blockchain solution. I strongly disagree. Did you read my "blocksize economics" blog post?I don't understand why you think MAX_BLOCK_SIZE necessarily has anything to do with "supporting mining" (aka securing the network).What stops this from happening:Big miners accept off-blockchain payments from big merchants and exchanges that want their transactions confirmed. They are included in very small blocks with zero fees.  The blocksize stays at 1MB forever.Lets look at incentives:Big miners: have cozy agreements with Big Merchants. Those agreements keep the little guys out.Big Merchants: same thing. The need to get an agreement with a miner to get your transactions accepted is a barrier to entry for the Little Guys. I am trying to get consensus. The process will look like:Get rough consensus. I need to write some code to find out what size blocks the current code can handle, but other than that I think we're close to rough consensus on the approach.Note: Getting consensus that we actually need to change something NOW will be harder; it will be much easier to get consensus after we hit the 1MB blocksize limit and transaction fees spike up. It would be lovely to avoid that panic/pain.Implement the change / Write a BIP (these happen at about the same time).Submit a pull request, after code is reviewed pull it into the reference implementation.... wait until there is a release containing the change...... wait until supermajority of miners have upgraded to the new release...Voila, the possibility of bigger blocks. The answer cannot be in the blockchain, because the problem being addressed (resource usage rising too quickly so only people willing to spend tens of thousands of dollars can participate as fully validating nodes) is outside the blockchain.You will go down the same path as the proof-of-stake folks, coming up with ever more complicated on-blockchain solutions to a problem that fundamentally involves something that is happening outside the blockchain. In this case, real-world CPU and bandwidth growth. In the POS case, proof that some kind of real-world effort was performed. If you're using the GUI:  File->Backup Wallet...If you're using bitcoind: use the backupwallet RPC command. Uhhh.... okey dokey. That sounds really dangerous, because it means a blockchain re-org can change the meaning or behavior of a transaction. "There Be Dragons"
It is already being done, so yes. Optimizations to how transactions or blocks are communicated between peers don't require any sort of fork. I'm confused. In the lottery example:What is the timestamp for a transaction? When the node receiving the transaction receives it? The timestamp of the block in which the transaction is confirmed? I think you're reinventing Matt's fast block relay code.  See:  https://bitcoinfoundation.org/2014/08/a-bitcoin-backbone/ Pure coincidence, but I had lunch today with a local developer who will be putting up a building in downtown Amherst. They are planning on running fiber to the building, because they want to build for the future and the people they want to sell to (like me in a few years, when we downsize after my kids are in college) want fast Internet.If I gaze into my crystal ball...  I see nothing but more and more demand for bandwidth.We've got streaming Netflix now, at "pretty good" quality.  We'll want enough bandwidth to stream retina-display-quality to every family member in the house simultaneously.Then we'll want to stream HD 3D surround video to our Oculus Rift gizmos, which is probably another order of magnitude in bandwidth. To every member of the family, simultaneously. While our home security cameras stream to some security center off-site that is storing it as potential evidence in case of burglary or vandalism....Then... who knows? Every prediction of "this will surely be enough technology" has turned out to be wrong so far. Okey dokey.  My latest straw-man proposal is 40% per year growth for 20 years. That seems like a reasonable compromise based on current conditions and trends.You seem to be looking hard for reasons not to grow the block size-- for example, yes, CPU clock speed growth has stopped. But number of cores put onto a chip continues to grow, so Moore's Law continues.  (and the reference implementation already uses as many cores as you have to validate transactions)PS: I got positive feedback from a couple of full-time, professional economists on my "block size economics" post, it should be up tomorrow or Friday. The fear is that a cartel of big, centralized, have-huge-data-pipes miners would drive out smaller miners by forcing up the block size high enough so the smaller miners have to drop out. Because network bandwidth, CPU, main memory, and disk storage (the potential bottlenecks) are all growing exponentially right now, and are projected to continue growing exponentially for the next couple decades.Why would we choose linear growth when the trend is exponential growth?Unless you think we should artificially limit Bitcoin itself to linear growth for some reason. Exponential growth in number of users and usage is what we want, yes? Yes, today. But not at some point in the future. Please read about "UTXO commitments" in https://bitcoinfoundation.org/2014/10/a-scalability-roadmap/ That does not address the core of people's fears, which is that big, centralized mining concerns will collaborate to push smaller competitors off the network by driving up the median block size.Yes, that is a good point, made by other people in the other thread about this. A more conservative rule would be fine with me, e.g.Fact: average "good" home Internet connection is 250GB/month bandwidth.Fact: Internet bandwidth has been growing at 50% per year for the last 20 years.  (if you can find better data than me on these, please post links).So I propose the maximum block size be increased to 20MB as soon as we can be sure the reference implementation code can handle blocks that large (that works out to about 40% of 250GB per month).Increase the maximum by 40% every two years (really, double every two years-- thanks to whoever pointed out 40% per year is 96% over two years)Since nothing can grow forever, stop doubling after 20 years. I'm sending a follow-up blog post to a couple of economists to review, to make sure my economic reasoning is correct, but I don't believe that even an infinite blocksize would drive fees to zero forever.Commodity prices never drop to zero, no matter how abundant they are (assuming a reasonably free market-- government can, of course supply "free" goods, but the results are never pretty). The suppliers of the commodities have to make a profit, or they'll find something else to do.That has very little to do with whether or not transaction fees will be enough to secure the network in the future. I think both the "DON'T RAISE BLOCKSIZE OR THE WORLD WILL END!" and "MUST RAISE THE BLOCKSIZE OR THE WORLD WILL END!" factions confuse those two issues. I don't think adjusting the block size up or down or keeping it the same will have any effect on whether or not transaction fees will be enough to secure the network as the block subsidy goes to zero (and, as I said, I'll ask professional economists what they think).Okey dokey. You can join the people still mining on we-prefer-50-BTC-per-block fork (if you can find them... I think they gave up really quickly after the 50 to 25 BTC subsidy decrease). Thanks for checking my math!  I used 31-day months, since I assume that is how ISPs do the bandwidth cap.RE: what happens with Tor:Run a full node (or better, several full nodes) that is connected to the network directly-- not via Tor.But to keep your transactions private, you broadcast them through a Tor-connected SPV (not full) node. If you are mining, broadcast new blocks the same way.That gives you fully-validating-node security plus transaction/block privacy. You could run both the full node and the SPV-Tor-connected node on a machine at home; to the rest of the network your home IP address would look like a relay node that never generated any transactions or blocks.If you live in a country where even just connecting to the Bitcoin network is illegal (or would draw unwelcome attention to yourself), then you'd need to pay for a server somewhere else and administer it via Tor. I'm working on a follow-up blog post that talks about economics of the block size, but want to get it reviewed by some real economists to make sure my thinking is reasonably correct. But I'm curious: why do you think an extremely large block size will mess up the economics of mining?  What do you think would happen?RE: geometric growth cannot go on forever:  true, but Moore's law has been going steady for 40 years now. The most pessimistic prediction I could find said it would last at least another 10-20 years; the most optimistic, 600 years.I'd be happy with "increase block size 40% per year (double every two years) for 20 years, then stop."Because if Bitcoin is going gangbusters 15 years from now, and CPU and bandwidth growth is still going strong, then either the "X%" or the "then stop date" can be changed to continue growing.I did some research, and the average "good" broadband Internet connection in the US is 10Mbps speed. But ISPs are putting caps on home users' total bandwidth usage per month, typically 250 or 300GB/month. If I recall correctly, 300GB per month was the limit for my ISP in Australia, too.Do the math, and 40% of a 250GB connection works out to 21MB dedicated to Bitcoin every ten minutes. Leave a generous megabyte for overhead, that would work out to a starting point of maximum-size-20MB blocks.(somebody check my math, I'm really good at dropping zeroes) When I say "soft-fork" I mean "a majority of miners upgrade and force all the rest of the miners to go along (but merchants and other fully-validating, non-mining nodes do not have to upgrade)."Note that individual miners (or sub-majority cartels) can unilaterally create smaller blocks containing just higher-fee transactions, if they think it is in their long-term interest to put upward pressure on transaction fees.Would 40% initial size and growth make you support the proposal?Anybody know economists who specialize in this sort of problem? Judging by what I know about economics and economists, I suspect if we ask eleven of them we'll get seven different opinions for the best thing to do. Five of which will miss the point of Bitcoin entirely. ("...elect a Board of Blocksize Governors that decides on an Optimal Size based on market supply and demand conditions as measured by an independent Bureau of Blocksize Research....") Yes, that is what I am saying."Safer" : there are two competing threats here: raise the block size too slowly and you discourage transactions and increase their price. The danger is Bitcoin becomes irrelevant for anything besides huge transactions, and is used only by big corporations and is too expensive for individuals. Hurray, we just reinvented the SWIFT or ACH systems.Raise it too quickly and it gets too expensive for ordinary people to run full nodes.So I'm saying: the future is uncertain, but there is a clear trend. Lets follow that trend, because it is the best predictor of what will happen that we have.If the experts are wrong, and bandwidth growth (or CPU growth or memory growth or whatever) slows or stops in ten years, then fine: change the largest-block-I'll-accept formula. Lowering the maximum is easier than raising it (lowering is a soft-forking change that would only affect stubborn miners who insisted on creating larger-than-what-the-majority-wants blocks).RE: a quick fix like doubling the size:Why doubling? Please don't be lazy, at least do some back-of-the-envelope calculations to justify your numbers (to save you some work: the average Bitcoin transaction is about 250 bytes big). The typical broadband home internet connection can support much larger blocks today. That is a feature of Bitcoin-Qt. Unconfirmed dust transactions don't enter the memory pool, so they are not relayed, not included in blocks being mined, and not displayed by the wallet.If I recall correctly, if they DO get mined into a block by somebody then they are displayed. Ignoring them and not adding them to the wallet in that case might be a nice feature, although today's dust might be tomorrow's treasure if prices rise another couple orders of magnitude. I think we'll see non-clone coins being broken after two things happen:1. They become valuable enough for attackers to bother, and there is some way for them to cash out.2. The attackers have some time to do what they need to do to mount an attack-- write code, deploy botnets, hack into some big exchange(s), get their hands on some early-adopter's wallet backups, or whatever.Once the tools and techniques are developed, then I think we'll see what we see in PoW 51% attacks: attacks against even mostly-worthless clonecoins, because if they've already got the tools then they might just attack for the lulz.I'm surprised you count peercoin a PoS success-- they're still running with centralized checkpoints, aren't they? Is there a rebuttal from the PoS crowd to this:  https://download.wpsoftware.net/bitcoin/pos.pdf... other than "sure, the original PoS ideas were flawed, but the latest MegaUberPoS system gets it right and nobody has figured out exactly how to break it!" Probably just some anti-Foundation skiddie who saw this:  https://bitcoinfoundation.org/2014/09/bitcoin-org-walk-down-memory-lane/ I needed that, so hacked together a disconnectpeer RPC call:  https://github.com/gavinandresen/bitcoin-git/commit/499ae0b3d77e1c41d79f34329d555980676d1f3aNeeds more thorough testing-- I'm not sure if calling CloseSocketDisconnect directly from the RPC thread is the cleanest way of disconnecting a peer. Thaddeus Dryja's "proof of idle" idea hasn't been getting enough attention. See https://www.youtube.com/watch?v=QN2TPeQ9mnAThe idea is to get paid NOT to mine, because it is economically rational for everybody to keep the difficulty lower rather than higher (everybody saves money on electricity if everybody can somehow agree to keep their equipment idle). Thaddeus figured out a way of solving the coordination problem so nobody can lie about how much mining power they have or profit from cheating and running miners that they promised to keep idle.Having lots of idle mining capacity is appealing for at least two reasons -- it is more energy efficient, and if an attack of some kind is detected it could be brought online instead of kept idle to help fight the attack.However... I suspect that taking that idle mining power, pointing it to a big mining pool, and then performing a winning-share-withholding-attack (if you find a share that satisfies full network difficulty, don't submit it to the pool -- just throw it away and pretend it never happened) could be a way of doubling your profits, because you drive down difficulty, get paid for "idle" capacity, AND get a share of the profits from the mining pool you're attacking.
I think we're seeing some people submitting lots of tiny, trivial commits -- perhaps because they get more of the tipping pie.I'm not sure how to combat that bad incentive.... Glancing at block explorers for Monero and ByteCoin... I'm not seeing crippling bloat right now. I see lots of very-few-transactions blocks.Glancing at recent release notes for ByteCoin, it looks like transactions were not being prioritized by fee, which is a fundamental to getting a working fee market.Have Monero and ByteCoin fixed the bloat problem, or did the transaction spammers just get bored and go away? It is absolutely true! I heard the main guy even visited the NSA's headquarters in Fort Langley, Maryland! Block re-orgs need some thought.If I have chain A-B-C, and get IBLT's for an alternative chain A-B'-C'-D'...... then the current memory pool won't work to try to reconstruct B' C' D'.Using B and C to reconstruct B' and C' should work pretty well. Then the remaining memory pool transactions can be used to reconstruct D.If any of the reconstructions fail, just fall back to fetching all of B' C' D'.Then again, re-orgs are rare enough that always falling back to fetching full blocks would be OK. That is exactly what the 'smartfee' code in the reference implementation does.RE: where does the market information come from:Like any market, it comes from the collective action of lots of individual decisions. Different wallet software has different fee policies, and there is already a little bit of "I sent a transaction using wallet XYZ and it took FOREVER to confirm, WTF?!?" (or "why does exchange/wallet/service ABC charge me such high transaction fees").As wallets mature, I expect them to specialize ("Save on Fees! Use UberWallet!") and/or compete for best cost/speed/reliability/predictability.The default for the reference implementation will be "follow the herd" -- but the price will be set by the minority of people 'at the margins' who REALLY want their transactions to confirm quickly or REALLY want spend as little as possible on transaction fees. They will set -paytxfee and/or -txconfirmtarget  to override the default behavior.And "they" are likely to be high-volume-transaction-creators-- like exchanges (probably want their transactions to confirm quickly; fewer customer support calls) or watch-a-video-get-a-few-bits services (probably want to cut costs any way they can, don't care if their customers have to wait a while for a withdrawal to get confirmed...).RE: sybil/isolation attack:Again, not a likely attack. You would have to:1) Find some high-transaction-volume service and identify all of their bitcoin-network-connected nodes2) Control ALL of those nodes' connections (expensive to do reliably with the 'connect out to 8 random peers' rule) FROM THE BEGINNING OF TIME (well, beginning of when it started running the smartfee code).3) Let that node see only extremely-high-fee transactions (there aren't very many of those, so you'll need to manage to control the node's connections for a while).4) Expect the node's operator to send a lot of transactions and not notice that they were paying abnormally high transaction fees.If you are running a high-transaction-volume service you probably already have several connections into the bitcoin p2p network because you have probably already been the target of a distributed denial of service attack....Definitely not an issue for Bitcoin-Qt, because you're shown the total amount + fees you'll pay before every transaction. ... demonstrated in a completely artificial -regtest environment...If you can Sybil somebody and control their view of the network, then it seems to me there are more potentially profitable attacks than "make them pay more in fees than they should."But please feel free to demonstrate an actual, effective Sybil on the fee estimation code. bitcoincore.org is running a wallet-less bitcoind on port 8333 that generates the graphs at bitcoincore.org/smartfee/(hacking into the web server to make it LOOK like the fee estimation code failed doesn't count, you have to manage to control it's p2p network connections and then manipulate the memory pool). Smart (dynamic, floating) fees for the reference implementation wallet was pulled today:  https://github.com/bitcoin/bitcoin/pull/4250... and should appear in version 0.10.The estimation code only considers transactions that are broadcast on the network, enter the memory pool (so are available to any miner to mine), and then are included in a block. So it is immune to miners putting pay-to-self transactions with artificially high fees in their blocks.Right now if you use the default fee rules your transactions will take 2-6 blocks to confirm:  http://bitcoincore.org/smartfee/fee_graph.htmlThe priority estimation code is even more broken; the reference implementation wallet will send a 56-million-priority transaction with no fee, which is nowhere near enough priority to get confirmed quickly:  http://bitcoincore.org/smartfee/priority_graph.html(the smart fee code estimates priority, too).Release notes from doc/release-notes.md in the source tree:Transaction fee changes=======================This release automatically estimates how high a transaction fee (or howhigh a priority) transactions require to be confirmed quickly. The defaultsettings will create transactions that confirm quickly; see the new'txconfirmtarget' setting to control the tradeoff between fees andconfirmation times.Prior releases used hard-coded fees (and priorities), and wouldsometimes create transactions that took a very long time to confirm.New Command Line Options========================-txconfirmtarget=n : create transactions that have enough fees (or priority)so they are likely to confirm within n blocks (default: 1). This settingis over-ridden by the -paytxfee option.New RPC methods===============Fee/Priority estimation-----------------------estimatefee nblocks : Returns approximate fee-per-1,000-bytes needed fora transaction to be confirmed within nblocks. Returns -1 if not enoughtransactions have been observed to compute a good estimate.estimatepriority nblocks : Returns approximate priority needed fora zero-fee transaction to confirm within nblocks. Returns -1 if notenough free transactions have been observed to compute a goodestimate.Statistics used to estimate fees and priorities are saved in thedata directory in the 'fee_estimates.dat' file just beforeprogram shutdown, and are read in at startup. It seems to me having miners share 'near-miss' blocks with each other (and the rest of the world) does several good things.As Greg say, that tells you how much hashing power is including your not-yet-confirmed transaction, which should let merchants reason better about the risk of their transactions being double-spent.If the protocol is well-designed, sharing near-miss blocks should also make propagation of complete blocks almost instantaneous most of the time. All of the data in the block (except the nonce and the coinbase) is likely to have already been validated/propagated. See Greg's thoughts on efficient encoding of blocks:  https://en.bitcoin.it/wiki/User:Gmaxwell/block_network_codingSo there could almost always be no advantage to working on a smaller block rather than a larger block (it would be very rare to find a full-difficulty block before finding-- say-- a 1/100'th difficulty block).Near-instant block propagation if you 'show your work' should give un-selfish miners an advantage over miners who try any kind of block withholding attack. And it should make network convergence quicker in the case of block races; miners could estimate how much hashing power is working on each fork when there are two competing forks on the network, and rational miners will abandon what looks like a losing fork as soon as it looks statistically likely (based on the previous-block pointers for near-miss blocks they see) that they're on the losing fork.We can do all of this without a hard fork. It could even be prototyped as an ultra-efficient "miner backbone network" separate from the existing p2p network-- in fact, I'm thinking it SHOULD be done first as a separate network... The best way to understand reference implementation accounts is to think of bitcoins like real, physical coins.Like how a bank works:When you deposit coins in your account, they are credited to your account. And then mixed in with all the other coins the bank gets.When you withdraw, you get coins from the Big Old Pool of Coins-- not the coins you put in, necessarily.That said: general consensus among core devs is that the accounts feature should go away. It is not appropriate for "enterprise-scale" multi-user use (never optimized for that case, doesn't do ACID transactions with whatever back-end database you're using for customer information, etc etc etc).And it doesn't do what most people seem to WANT it to do (act as multiple wallets, keeping coins separate). Excellent!I've been accused in the past of "not caring about privacy" -- when I do care a lot about privacy. But I am not a privacy researcher, and I have a deep respect for how difficult it is to create a truly privacy-preserving system.I'm very happy that somebody who is an expert is thinking about, and working on, countermeasures. I haven't been paying to the whole "cloud hashing" thing, but it seems to me a great cover for an old-fashioned Ponzi scheme.1. Take investors BTC, "buy" gigahashes of mining.2. Pay them back for a while using new investor's BTC.3. Once you've got enough investors, take the BTC and run.  (maybe claim "oops, sorry, got hacked")I'm not saying CEX.IO is a tarted-up Ponzi scheme. I have no idea.I'm just asking how everybody who is giving them money knows that they aren't a Ponzi. Or aren't selling the same hardware twice or three times, operating a kind of 'fractional reserve' system (that will eventually fall apart).Excuse me in advance if this has been discussed and I'm just missing something (e.g. a variation on Greg Maxwell's exchange auditing scheme might work: e.g. "they publish all the blocks found and an auditable merkle tree of all customers and how much hashing power each has"). Yes. I think most people believe that successful technology companies spring up very quickly, but in my experience most (all?) of the "overnight successes" were busy working for years before finding the winning combination of features, user interface, market, etc. New 'estimatefee' and 'estimatepriority' RPC commands were just pulled into Bitcoin Core.And I threw up a web page that updates estimates with every new block found:  http://bitcoincore.org/smartfee/Assuming I got the crontab correct, daily fee/priority estimates will be archived there starting tomorrow. The hard-coded setting for "high priority" is just wrong (it is much too low for the number of free transactions competing to be included in blocks these days).  The "smart fees" pull request fixes that, and will (by default) only send a transaction for free if it is pretty darn sure it will confirm quickly. That is like 9/11 conspiracy theorists saying "there is a real debate to be had!"  ... after they repeatedly fail to listen to rational arguments ("Jet Fuel doesn't burn that hot! It cannot melt steel!" ... after being patiently told about the physics of furnaces: burning in a heat-trapping chamber).I still haven't heard any rational arguments on how the payment protocol is worse for privacy. If piotr_n makes one, please let me know. You are going back on my ignore list, because you have no idea what you are talking about.Maybe if I use simple, easy-to-follow steps I can convince you that you are wrong:1.  Copy and paste this URL into your web browser:  http://www.comodo.com/home/email-security/free-email-certificate.php2. Click on the "Free email certificate: sign up now" button (the big orange one).3. Enter whatever name you like, and a valid email address (an anonymous one, if you like) and a revocation password.I just used "knownothingtroll@mailinator.com" to make sure it actually does work to give a fake name, anonymous email address (and no address or phone number).Done deal, you've now got a certificate-authority-signed X.509 certificate for an anonymous email address that you can use for the payment protocol.That wasn't so hard, was it? See https://github.com/bitcoin/bitcoin/pull/4250 and https://github.com/bitcoin/bitcoin/pull/3959A future release will automagically figure out the right fee (or will figure out it doesn't need a fee) to get into a block quickly (or slowly, if you want to pay lower fees and are willing to wait).As for your original question: set the -paytxfee command-line option for current Core releases and you WILL always pay a fee. Login as ubuntu, password "ubuntu"I think, if I remember correctly.Wait... no, maybe not.  According to the README there, you need to ssh in using the private key in the ssh_key.tar file. That super long "password" is not a password, but is the ssh public key. In another thread marcus of augustus says:I'll break my rule about feeding trolls again to debunk for about the hundredth time the myth that the use of X.509 certificates in the payment protocol is bad for privacy.It is not.If you are in a customer/merchant situation, the customer's privacy is not affected AT ALL. The merchant's identity is in the X.509 certificate, the customer is as anonymous as always (which is very often "not anonymous", because the merchant needs to know something about the customer to deliver their product).If you are a merchant, then part of the PURPOSE of the payment protocol is to provide a cryptographically secure, verified-in-some-way identity.If you are a merchant and want an pseudanonymous then that is easy: set up an anonymous email address and then get a free email certificate from any of the certificate authorities that provide them.If you have a philosophical hatred of X.509 and certificate authorities... then please invent a better identity verification system and get the world to adopt it. The payment protocol is specifically designed to make it easy to slide in a better system.(but if you have a philosophical hatred of X.509 then what are you doing posting here at bitcointalk, whose security relies on the very X.509 certificates you find so despicable? There ARE alternatives, you should go hang out in forums.i2p or a Tor-based forum...) I'll break my "don't feed the trolls" rule:You need two things to get private bitcoin transactions:1) An anonymous connection to the Internet.  Bitcoin Core does a good job of this, working nicely through Tor and/or as a hidden service (thanks to Pieter Wuille for writing that code).2) A privacy-aware wallet.The Bitcoin Core wallet needs to be completely rewritten, not just for privacy but to get rid of the Berkeley DB dependency, implement HD keys, implement multisig, CoinJoin, etc etc etc....Nobody has stepped up to do that, so it hasn't happened; in fact, we are going in the opposite direction, moving wallet functionality out of Core (and we might eventually drop wallet functionality entirely to concentrate on transaction validation and blockchain handling).Why do you ask?
The Bitcoin Foundation does help pay for dev efforts; it pays me, Wladimir, and Cory Fields (and gives quarterly grants to fund other worthwhile efforts).I disagree with the original poster; Bitcoin development is increasingly decentralized over time. It started out as centralized as it could possibly be-- Satoshi wrote all the code himself (or herself or their-selves).Now we have multiple implementations, multiple altcoins, and multiple wanna-be-Bitcoin-2.0 contenders, all with their own dev person-or-team (well, some altcoins probably don't have any developers).As for your specific ideas: go for it. If you think they're good ideas, implement them (or hire or convince somebody to implement them) and see what happens. Feel free to create some; code here: https://github.com/gavinandresen/paymentrequest transactions send via sendrawtransaction are always debited from the default "" account. Raw transactions and accounts are not designed to work together, use one or the other .And preferably not accounts: unless somebody steps up and volunteers to make the accounts feature "industrial-strength" (scalable, integrates with whatever back-end database your company is using to track user information, can be robustly backed up, etc) it is very likely it will be deprecated and then dropped. There is a lot of competition for the free transaction area in blocks these days; you need a much higher priority to get confirmed quickly, 57.6 million is not enough any more.A future version of the reference implementation wallet will automatically estimate the priority needed. On further testing, it looks like OSX and Linux payment protocol requests with the released 0.9.0 binaries are not vulnerable.The released Windows 0.9.0 binaries are vulnerable, so Wladimir just sent an alert message urging everybody running 0.9.0 to upgrade.Check again; see the use of CKeyingMaterial/CPrivKey which uses a secure_allocator (which asks the operating system not to swap the memory to disk, and which zeros memory on free). If I recall correctly, the RPC importprivkey should be the only place where the normal memory allocator is used (the keys exist as ordinary hex strings in memory before they are processed by the importprivkey code).Careful review (and testing and patches) is always welcome, of course. You shouldn't trust my famously faulty memory. https://github.com/Lekensteyn/pacemaker is a little SSL server to test SSL clients for heartbleed vulnerability.I installed Bitcoin Core version 0.9.0 on my Mac (compiled against the vulnerable openssl 1.0.1f), created a web page to launch a payment request fetch from pacemaker...... and I get good news:Code:Connection from: 127.0.0.1:62937Possibly not vulnerableStep-by-step so you can help test on other OS'es :git clone https://github.com/Lekensteyn/pacemaker.gitcd pacemakerpython pacemaker.pyRun Bitcoin Core GUI version 0.9.0In your browser, visit https://bitcoincore.org/~gavin/heartbleed.html  pacemaker.py should report a connection, and then either say "Client returned blah bytes" or "Possibly not vulnerable"It looks to me like pacemaker.py IS working; visiting https://127.0.0.1:4433/ in Chrome pacemaker tells me:Code:Connection from: 127.0.0.1:62514Client returned 7 (0x7) bytes0000: 15 03 03 00 02 02 2f                             ....../This isn't a definitive "no need to worry even if you HAVE clicked on payment-protocol-enabled bitcoin: links at an untrustworthy website" ... but given the evidence I've seen, it seems to me extremely unlikely anybody's private keys have been compromised. For low-priority transactions, it doesn't look to me like many miners are accepting lower fees.Right now, a 999-byte transaction paying the reference-implementation-default fee of 0.0001 BTC will wait 2-3 hours to get into a block.A typical 250-byte transaction paying the default 0.0001 BTC fee will see its first confirmation in 5 or 6 blocks (about an hour on average). If you want your transaction to confirm quickly, then right now you need to pay about double the default fee.Some results running https://github.com/bitcoin/bitcoin/pull/3959 (more review/testing welcome) :Code:$ for i in {1..25}; do ./bitcoin-cli estimatefee $i; done0.000778210.000446430.000444440.000442480.000442480.000389110.000387600.000268100.000247520.000228310.000200400.000175130.000161550.000147060.000138020.000125310.000117790.000110130.000103630.000101110.000089050.000086360.000074740.000067430.00004444 Sounds familiar...... I think I ran into a similar problem that turned out to be ssh being upset that the file permissions on the id_dsa file used to login to the virtual machine were too permissive (because I was running from a FAT32-formatted USB stick that didn't support file permissions at all, if I recall correctly, which I probably don't). This was a release process bug; I re-built/signed/uploaded the OSX .dmg to fix it (and updated the SHASUMS files).The warning is harmless, and no code was changed, so if you don't want to re-download and install you don't have to.Thanks to lots of hard work from Luke Dashjr and Cory Fields we should (fingers crossed!) have deterministic OSX builds working before the next release, which will make this kind of error impossible. Thanks, k99 and Vitalik, that helps clear it up.  I've put "On Transaction Fees, And The Fallacy of Market-Based Solutions" on my to-think-about-deeply list.I'm curious about this, though:If my contract needs more than 16 computational steps to execute, then other people CAN send transactions to it to intentionally bankrupt it? That is what I was worrying about when I said "publish the attacker's transaction and take the fee but ignore any other effects of the transaction, but you'd have to be careful to design THAT mechanism so it couldn't be abused." Okey dokey... so how do fees work in Ethereum?Or do you have some other clever distributed way of preventing flood-the-system-with-bogus-contracts DoS attacks? How do transaction fees work in Ethereum?One of the non-obvious reasons Bitcoin works is transaction fees are based on the size (in bytes) of the transaction. And since there are no loops executing a transaction, CPU usage is bound by transaction size.If CPU usage to verify a transaction is NOT related to the transaction size, then you open yourself up to denial-of-service attacks. Like:Create an Ethereum transaction with a (huge!) fee that will pay for 60 seconds of CPU execution time.... but craft it so execution takes 61 seconds (or, heck, make it an infinite loop, maybe you'll tickle a bug in the execution termination code).Now broadcast it.  It will be rejected for insufficient fee, but only after peers have wasted 60 seconds of CPU time. And if the transaction is rejected, the attacker won't pay the fee.Then tweak it slightly and broadcast it again, maybe from a different IP address if you got banned for bad behavior.I haven't thought deeply about whether or not there is a way to punish the attacker; my first thought would be to publish the attacker's transaction and take the fee but ignore any other effects of the transaction, but you'd have to be careful to design THAT mechanism so it couldn't be abused. I'm usually pretty careful not to call people names.  Did I screw up?I DO think there are lots of crazy conspiracy theories. I might even believe some of them myself, but that doesn't make me crazy (just "almost certainly wrong.").RE: child exploitation:  Good example.  We all agree that child exploitation is BAD, right?We might disagree about what (if anything) we should DO about it, but isn't it worth discussing whether or not there is something we MIGHT do about it?  For example, maybe offering mostly-anonymous bounties to reward anybody who gives information that leads to the arrest and conviction of people abusing children for profit or pleasure is a good idea.  Maybe those bounties could be paid in Bitcoin.Maybe that is a terrible idea that will have awful consequences, but instead of rational discussion there's a knee-jerk GOVERNMENT BAD! that, in my humble opinion, is counter-productive to making the world a better place.I don't like people assuming that they know what I'm thinking, or assume that because I'm willing to talk to people that I agree with those people, or assume that because I'm pragmatic about regulation I "want regulation."  For the record:  I'm mostly libertarian, I think we'd be just fine if we replaced 99.911% of regulations with voluntary, private, market-based solutions. But that ain't gonna happen any time soon. Bilderberger meetup is in Barbados this year.  But don't tell anybody, it is a secret.PS to dewdeded: Mike Hearn and I both own non-US passports, so putting us on Team USA is funny. We should be Team Global Conspiracy (mmm... gotta get T-shirts made...). No, not possible, given what we know about the properties of SHA256 hashing. I've accepted an invitation to do a question and answer session at the Council on Foreign Relations (CFR) in Washington, DC on Thursday, February 6, 2014.I've been told anything related to the Council on Foreign Relations tickle's peoples Grand Conspiracy buttons, so I thought it would be best to be open about exactly what will happen. I hope it doesn't spark as long a thread as my visit to the CIA, but Bitcoin is a lot bigger than when I visited the CIA...Anyway, here's the invitation I received:The format of the event will be a 90-minute question&answer session, moderated by somebody yet-to-be-determined. It will be "on the record," meaning press could be invited to attend and recordings and/or transcripts may be posted on CFR's website.The audience will be CFR members and invited guests (and maybe press); it is not open to the public. I am not getting paid by the CFR. Bah, I forgot to code-sign the Windows .exe. Expect an updated .exe and SHASUMS soon. https://gist.github.com/gavinandresen/5616606 sketches out one way to do it. You disgust me. Participating in a ponzi is immoral.You might as well ask "Anybody know some good scams I can make money from?"Do something productive that makes the world a better place instead. It looks like maybe some pools have reacted; the average block size is going up:  http://www.quandl.com/BCHAIN-Blockchain/AVBLS-Bitcoin-Average-Block-SizeFor those that haven't, the relevant bitcoind command-line arguments are:Code: -blockminsize=<n>      Set minimum block size in bytes (default: 0) -blockmaxsize=<n>     Set maximum block size in bytes (default: 250000) -blockprioritysize=<n> Set maximum size of high-priority/low-fee transactions in bytes (default: 27000) -mintxfee=<m.n>        Minimum  fee-per-kilobyte to qualify as fee-paying (default: 0.0001)Adding:Code:blockmaxsize=500000blockprioritysize=45000... to your bitcoin.conf and re-starting bitcoind (or running with the command-line arguments) will really help with the transaction crunch.I'm still hard at work (nearly done!) on making the reference implementation much smarter about transaction fees, but until wallet software gets smarter about fees we need to rely on big pools doing the right thing so Bitcoin users don't get frustrated by long transaction confirmation times.
Yes, I did misplace the decimal point.  I'm really good at that. DeathAndTaxes: I'm normally impressed with your posts, but I think you've got some details wrong.First, RE: the orphan cost of transactions:  Decker/Wattenhofer measured 80ms for a 1K bigger block. The math to compute orphan cost is:Code:orphan cost = (block_reward+fees) * (1 - e^(-(1/target block time)*delta_time)Plugging in 25 XBT block reward, 600 target time, 0.08 delta time, and assuming no fees (to make the math easier):Code:orphan cost = 25 * (1 - e^(-(1/600)*0.08) = 0.0033So 3.3 millies per kilobyte is the orphan cost.Even if we assume Decker/Wattenhofer are off by a factor of two (we have made some improvements since they measured block propagation; better measurements welcome), default transaction fees (1 to 5 millies per kilobyte) are in the right ballpark to minimize orphan costs. the .1 default transaction fee does not come close to covering the orphan cost (edited: thanks foxpup).It should be fairly easy to get about another factor of about 10-20 reduction in orphan costs. And as I said in another thread, if EVERYBODY produces larger blocks then EVERYBODY bears the increased orphan cost, and the result is better for everybody . There is a fixed number of new bitcoins to be earned, regardless of the orphan rate; everybody's share of that fixed number will be the same if everybody has a slightly higher orphan block rate. But everybody will earn more fees, and their bitcoins will be worth more because bitcoins will be more useful. Transaction fees are likely to go up (in dollar terms) for a while, until some engineering work is done to reduce the "orphan cost" for miners to include more transactions in their blocks OR mining pools / miners collectively agree to include more transactions for the good of the whole system.In the very short term, you can ask mining pool operators to create larger blocks. If they refuse, then switch your miners to a pool that does.If they all create larger blocks, then we get more transactions and more orphan blocks, but the cost of those extra orphan blocks is spread across everybody mining, so everybody gets just as many bitcoins (on average) as they would with smaller blocks. No. By the way:I really like your proposal, ByteCoin. I think it captures the intuitive notion of "incentivize publishing blocks immediately as the best policy".IF all proof-of-work-valid chains are relayed (and, as I said, my intuition is that they should be) then highest-number-of-transactionseconds seems like a very good criteria for resolving ties. Unconfirmed wallet transactions are automatically rebroadcast by bitcoind/Bitcoin-QT until they are confirmed. A surprising number of people will trade anything that has a price. Yes.I am much more worried about transaction fees right now than "selfish mining". That is why I've been working on better fee estimation in the reference implementation.I agree with Mike-- we need better measurement, and we need to make "full-match merkle block relaying" the default to drive that 80ms number way down.  Nice! Can you open source this?Is the simulator accurately modeling how orphan blocks are (not) relayed?It would also be useful to see total revenue, and total-revenue-expected-if-everybody-mines-honestly for both the entire network and the attacker. I have several partly-formed thoughts.First, on "is there REALLY a problem" -- I think Ed Felten makes a good argument that, at least in the current world of mining pools, the incentives work to prevent "selfish" mining:  https://freedom-to-tinker.com/blog/felten/bitcoin-isnt-so-broken-after-all/Related, I think it is important to remember that the current structure and behavior of the p2p networking code is NOT part of the fundamental consensus algorithm. It is easy to change, and, as I've said in the past, I would really like to see blocks and transactions being broadcast over some completely different networking protocol.I think there is a really interesting theoretical question that I don't know the answer to; I'll try to state it clearly:As the p2p network is currently implemented, nodes only have a partial view of competing best-chains, because nodes only relay the first node they see at a given height.If there are two blocks at the same height announced at approximately the same time, they propagate exponentially fast across the network in two waves, and only the nodes at the edges of where the waves meet will see both blocks.Given that network behavior, assuming no selfish mining, there is a strong incentive to announce your block as soon as possible, because in an exponentially fast race any delay is very likely to make you lose.There are lots of ideas for fixing selfish mining that rely on changing that behavior, and having nodes relay orphan blocks. I think it is important to remember that no matter what rules we SAY the network will follow, we can't stop individual nodes from implementing whatever rules they wish to follow; any solution that begins "If all nodes do THIS..." is not a solution.That applies to the behavior we have now about not relaying orphan blocks, too, of course. The interesting theoretical question I'm pondering:  does the security of the Bitcoin system depend on the relaying behavior, or on how ties are resolved in block races?My intuition is that we SHOULD be relaying all orphan blocks, and should let each node decide how to resolve races, but before we talk about how to resolve races I think we should consider the incentives that arise from the current relaying behavior. +1This is the kind of analysis that I think we need more of before jumping to the conclusion that there is actually a problem that needs to be fixed. I'm not claiming that HorseRider is correct, but his logic looks plausible and I tend to listen harder to reasonable people who say things like "please check whether my logic is right". See:  http://www.tik.ee.ethz.ch/file/49318d3f56c1d525aabf7fda78b23fc0/P2P2013_041.pdfYou can calculate the "orphan cost" of including an extra 1kilobyte of transactions in your block from that, which gives a floor on reasonable transaction fees.RE: can we decrease that delay:  sure, up to a point. But across-the-world network latency gives a physical limit.See, for example:  http://www.verizonenterprise.com/about/network/latency/ Which "bitcoin client" ?The client-side of Multibit and electrum should have no problem handling that transaction volume.  Only the transactions relevant to your wallet are sent to your machine when you are running those clients.The reference implementation can't handle that transaction volume today, but I 100% guarantee that version 11.11 which I 100% guarantee will be released on November 11'th, 2022 will be able to handle that transaction volume.I feel obliged to insert my standard disclaimer:  Bitcoin is an experiment in progress.  Only invest time or money that you can afford to lose, there is still a chance the experiment may fail for some reason we don't forsee.  Past results are no guarantee blah blah blah.That said, I'm more confident than ever that the network will be able to scale up and remain decentralized. No; miners have a natural incentive to want to be closely connected to as many other miners as possible (to reduce orphan costs).RE: Evaluating sybil resistance: I would still like to see blocks and transactions being broadcast over another completely different networking protocol, either peer-to-peer or not. More diversity so we're not relying on the one p2p network would be great, and, depending on how it was implemented, might automatically bring sybil resistance. No. If their anonymous credential scheme is successful (and I hope it is!), then the payment protocol should be extended to use it. The payment protocol is quite carefully designed so that replacing the public key infrastructure system is easy. Mmm.  Maybe.That sounds a lot like the alternative local currency movement-- create a local currency that somehow expresses the local community's values.I'm probably just a too-logical, cold-hearted geek, but building community around a currency doesn't strike a chord with me. To me, community is about people, and a currency is just a tool for transactions. I guess an analogy would be a bunch of carpenters who build a community around some Extra Special brand of nails that they create and trade amongst themselves. You're right, I apologize. I just added libbitcoin to that list. RE: bitcoin-security mailing list:  bottom line is I don't trust you. I think you have made irresponsible decisions in the past, and I don't trust that you would handle sensitive security issues responsibly.  Happily there have been approximately zero cross-implementation security issues in the last six months, so it is more of a theoretical issue that you're not on the list....RE: foundation phone call:  I personally agree that fundraising for a vaporware wallet is less newsworthy than a 9 million dollar reputable VC investment.RE: libbitcoin: when there is significant software using it and it has been "battle tested" a bit I'd be happy to mention it. But last I heard even Intersango was not using it because it was too slow/immature. Don't do that; spamming is evil.RE: hyper-complexity of the multi-coin paradigm:uhhh...  Were you a postmodern lit major in college?I've got a pretty simple, but I think fairly accurate, view of money/wealth.I believe you can't create wealth just by printing money.  You can create the illusion of wealth (and I imagine some Keynesians would argue the illusion is enough to lubricate the economy and somehow increase productivity and growth and wealth; lets set aside that argument).You can create wealth by making it easier for people to transact (and money is the world's best invention for doing that, barter is terribly inefficient).I'm still stuck on how y'all think altcoins create wealth. I don't see any of them being any easier to transact than Bitcoin. Please don't say "official client" -- there is no "official.""Reference implementation" is more accurate.Lack of SPV mode in the reference implementation is mostly due to lack of testing / code review resources.
Exactly right, in my humble opinion.I suspect you're going to have a hard time figuring out how to arrange yourselves without becoming a Corporation of some State and still have a business model that sustains sufficient quality assurance and customer support to make Dark Wallet a success.PS: I'm really happy to see other implementations happening!  Diversity is great!PPS: y'all should give the Foundation at least a LITTLE bit of credit for funding CoinPunk... See: Average block size chartSince implementing the "dust rule", block size has been pretty steady; I would guess we won't hit the 1MB hard limit for another two years, but that is just a guess, we could easily hit it sooner or later than that. Consensus is the block size limit will have to rise.Us geeks were/will/are arguing over how and when, not if... I feel like we're talking past each other.You said:  dev coin is a good model-- e.g. writer creates something, uses devcoin, 90% goes to them, 10% to devcoin miner.I don't understand why a writer wouldn't just use dollars-- create something, sell it for dollars, writer keeps 96%, PayPal gets 4% for processing the transaction.Or Bitcoin: create something, sell it for Bitcoin, writer keeps 99% BitPay gets 1% for processing the transaction (Bitcoin can do this because it is more efficient than PayPal/credit card/traditional fiat, that is where the wealth is created).Or is there some magical way that using an alt coin creates wealth out of thin air?  I don't see it.... If I am a good writer, why would I pay out 10% of my income?  That is more expensive than credit card charges!Again, don't confuse money for wealth.  Writers produce wealth in the form of the stories/articles/whatever they are writing. The currency used to trade that wealth only matters as far as:+ What can the writer buy with it+ If the writer saves it, will it buy more or less in the future Good idea. I nominate you to be the Official Checksum Publishing Person. I don't follow.  Where does the real-world wealth come from?  What will those pull-up-by-their-own-bootstraps people be doing that makes the world a better place and makes them wealthier?I suspect you might be confusing "money" with "wealth." Time-in-the-future transactions are non-standard (as of 0.8?  I can never remember when things happened...)Why: because there is a fill-up-memory denial of service attack, and it really isn't reasonable to expect the entire network to store your timelocked transactions "forever".Even in the past, the statement "unspendable by the sender because of replacement not being implemented" was not true.  Wait long enough and only a subset of the network will have the timelocked transaction (because new nodes, old nodes restarting, etc). Broadcast a double-spending version without a timelock and it will get mined fairly soon. Peter's dust-b-gone:  https://github.com/petertodd/dust-b-gone If you're on OSX you can do this:  http://mac.tutsplus.com/tutorials/productivity/how-to-tag-files-and-create-spotlight-comments-on-a-mac/I don't know if Windows or Linux have a similar way of adding metadata to arbitrary files.PS: there will be (or maybe is, can't remember when the option was added) a -wallet=<name> option to open up a different .dat file for the wallet. ... then volunteer to run through the test plan and help shake out any bugs. Code that touches the wallet is particularly sensitive, because an obscure bug might cause lots of people to lose lots of money. SERIOUSLY, SHADOWOFHARBINGER:I LOVE IT WHEN PEOPLE SHOUT AT ME! IT IS A GREAT WAY OF MAKING ME REALIZE THE FOLLY OF MY WAYS, GIVES ME WARM FUZZIES, AND MAKES ME WANT TO COME BACK TO THESE WONDERFUL FORUMS AGAIN AND AGAIN! Great idea!If implemented, it would probably make sense to create a little protocol for the server and client to negotiate the amount of storage needed to "rent" a connection slot. Maybe the server reports something like "I've got 0 slots free, min/median/max proof-of-storage for my other connected nodes is 0/1MB/11MB." "Impress with this protocol" ??My primary motivation for the payment protocol can be seen in this mock-up of multi-signature transaction authorization:  https://moqups.com/gavinandresen/no8mzUDB/p:af7339204I want much more secure wallets, but we can't get there unless the "who am I paying" piece is authenticated.You should save the "Gavin is trying to impress evil institutional investors" mud-slinging for when I get around to laying out the argument for increasing the block size, because that would be closer to the truth. Relying on any single piece of hardware to secure your bitcoins is a bad idea. In the future, you should use two pieces of hardware created in two different parts of the world by two different organizations in two different legal jurisdictions to secure your bitcoins.Right now... "only invest time or money you can afford to lose." We all think we're very clever at coming up with unique ways to obscure our data.We are wrong.We tend to think alike, so pretty much any process you can think up is likely very similar to a process somebody else will think up.In short: humans are really bad at creating randomness (aka entropy). And we're even meta-bad, because we THINK we're good at it. No, they can't. You just extend the taint-tracking through the newly minted coins (e.g. if you try to "melt" 75 BTC with the 25 BTC reward, then the resulting 100 BTC should be considered 75% tainted).RE: orphans:  orphans happen naturally when two nodes on the network find blocks at approximately the same time. Somebody should do a rigorous analysis to determine what are the most important factors affecting orphan rates (number of connections? quality of connections? bandwidth available to "blast out" the new block? block size? Number of not-previously-seen transactions included in the block?) "Patches welcome."A watch-only wallet that has a bunch of public keys (and multisig groups of public keys) is a good idea. But first you'd need multi-wallet support.There is a pull request that adds watch-only addresses, but I think that is the wrong way to go. Mixing up fund that can be spent with funds that cannot be spent (e.g. because they're a multisig escrow you want to watch) is a bad idea, and as soon as we have hierarchical deterministic wallets we'll want watch-only wallets that are derived from a master key (or a set of master keys in the case of multisig) where the local bitcoind doesn't have the private seed for the key. No, not if you use Tor.Tor (or i2p or some other anonymizing proxy solution) is the only way to keep online merchants from figuring out your IP. After all, if you browse to their website without Tor, then your IP is sitting right there in their web server logs. No, I don't have time to clean up the code, port it to the latest AppEngine API, etc.The Faucet was the simplest possible project I could think of to get my feet wet with Bitcoin; the hard part is preventing cheaters who try to get more than their fair share, and I was never able to come up with a really good solution (that is tied into the whole identity-on-the-Internet thing, which nobody has solved).
Bitcoin-Qt version 0.8.5 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.5/This is a maintenance release to fix a critical bug;we urge all users to upgrade.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.5 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine.0.8.5 Release notes===================Bugs fixed----------Transactions with version numbers larger than 0x7fffffff wereincorrectly being relayed and included in blocks.Blocks containing transactions with version numbers largerthan 0x7fffffff caused the code that checks for LevelDB databaseinconsistencies at startup to erroneously report databasecorruption and suggest that you reindex your database.This release also contains a non-critical fix to the code thatenforces BIP 34 (block height in the coinbase transaction).--Thanks to Gregory Maxwell and Pieter Wuille for quicklyidentifying and fixing the transaction version number bug. There was an interesting research paper (which I can't find) that claimed that high frequency trading is largely driven by the artifically high limit on bid/ask spreads. The claim is that if trading was allowed in much smaller fractions of a dollar traders would compete by underbidding/overoffering instead of competing to be first in the trading queue.That seems plausible to me-- set an arbitrary constraint ("bids must be in multiples of a tenth of a penny" -- or whatever it is these days) and you often get unintended consequences.I still plan on writing up why I disagree with the idea that a larger block size will lead to centralization, but I'm working on some higher priority things first. I really don't understand why you would think that our current, arbitrary 1MB limit is the Best Size For All Time. I think that arbitrary constraint will have bad unintended consequences. Most likely explanation is one of your blockchain data files is corrupted, but the old version doesn't care. You might be serving up a corrupted blocks to anybody who downloads from you, but you wouldn't notice that either. I wrote a big comment in init.cpp describing how shutdown works:Code://// Thread management and startup/shutdown://// The network-processing threads are all part of a thread group// created by AppInit() or the Qt main() function.//// A clean exit happens when StartShutdown() or the SIGTERM// signal handler sets fRequestShutdown, which triggers// the DetectShutdownThread(), which interrupts the main thread group.// DetectShutdownThread() then exits, which causes AppInit() to// continue (it .joins the shutdown thread).// Shutdown() is then// called to clean up database connections, and stop other// threads that should only be stopped after the main network-processing// threads have exited.//// Note that if running -daemon the parent process returns from AppInit2// before adding any threads to the threadGroup, so .join_all() returns// immediately and the parent exits from main().//// Shutdown for Qt is very similar, only it uses a QTimer to detect// fRequestShutdown getting set, and then does the normal Qt// shutdown thing.//I don't know nuthin about Windows' SetConsoleCtrlHandler(), but just setting the fRequestShutdown global variable should do the right thing. My build environment changed and the first -linux.tar.gz contained ._foo files (see http://superuser.com/questions/61185/why-do-i-get-files-like-foo-in-my-tarball-on-os-x ).So I untarred and re-tarred with the magic "don't be clever, please, OSX" environment variable set and uploaded a new .tar.gz and SHASUMS. Bitcoin-Qt version 0.8.4 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.4/This is a maintenance release to fix a critical bug and threesecurity issues; we urge all users to upgrade.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.4 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine.0.8.4 Release notes===================Security issues---------------An attacker could send a series of messages that resulted inan integer division-by-zero error in the Bloom Filter handlingcode, causing the Bitcoin-Qt or bitcoind process to crash.Bloom filters were introduced with version 0.8, so versions 0.8.0through 0.8.3 are vulnerable to this critical denial-of-service attack.A constant-time algorithm is now used to check RPC passwordguess attempts; fixes https://github.com/bitcoin/bitcoin/issues/2838(CVE-2013-4165)Implement a better fix for the fill-memory-with-orphan-transactionsattack that was fixed in 0.8.3. Seehttps://bitslog.wordpress.com/2013/07/18/buggy-cve-2013-4627-patch-open-new-vectors-of-attack/for a description of the weaknesses of the previous fix.(CVE-2013-4627)Bugs fixed----------Fix multi-block reorg transaction resurrection.Fix non-standard disconnected transactions causing mempool orphans.This bug could cause nodes running with the -debug flag to crash.OSX: use 'FD_FULLSYNC' with LevelDB, which will (hopefully!)prevent the database corruption issues many people haveexperienced on OSX.Linux: clicking on bitcoin: links was broken if you were usinga Gnome-based desktop.Fix a hang-at-shutdown bug that only affects users that compiletheir own version of Bitcoin against Boost versions 1.50-1.52.Other changes-------------Checkpoint at block 250,000 to speed up initial block downloadsand make the progress indicator when downloading more accurate.Thanks to everybody who contributed to the 0.8.4 releases!----------------------------------------------------------Pieter WuilleWarren TogamiPatrick StratemanpaktGregory MaxwellSergio Demian LernergrayleonardCory FieldsMatt CoralloGavin Andresen It bloats the UTXO set, which is bad.MasterCoin transactions should all be spendable or provably prune-able. There are plenty of ways to accomplish that, the easiest of which that works today would be to stuff data into unused public keys of an OP_CHECKMULTISIG transaction. Yes, please stop polluting the UTXO set. There are much better ways to accomplish what you want to accomplish. So, one thought:Instead of "staging" all of the dependencies and then modifying the makefile/.pro to look for the dependencies in six different places, it would be cleaner to configure with --prefix=<somewhere>  and then 'make install' to put all the dependency libraries/include files in one spot. Ideally, none of the makefiles/.pro files would contain specific version numbers for anything.Specific notes as I worked through doing that on a Windows system, putting dependencies in C:\deps :Openssl:  /bin/perl Configure --prefix=/c/deps mingw ...etcBDB: ../dist/configure --prefix=/c/deps ...etcBoost: b2.exe --layout=system --prefix=C:\deps link=static threading=multi runtime-link=static toolset=gcc ...etcQt: configure.exe -prefix=C:\deps -I "C:\deps\include" -L "C:\deps\lib" ...etc How big is your wallet?getbalance() is O(N) where N is the total number of transactions in the wallet. (actually, it can be even worse than O(N) if you have long chains of unconfirmed transactions in your wallet)"Patches welcome" to fix that, I expected one of the big bitcoind-using services would submit a performance fix patch long ago. That's incorrect. The following command-line or bitcoin.conf configuration parameters let miners set their transaction acceptance policy:The -mintxfee / -minrelaytxfee options currently control how large a fee-per-kilobyte is needed for a transaction to be considered "fee paying" versus "free". I would much rather people help test individual pull requests or 'git HEAD' rather than "random collection of changes". Putting eleven unrelated changes together makes figuring out what caused a bug/regression much harder. I spent a bunch of time getting the mingw-cross-compiled Qt compiled with -openssl-linked for the payment protocol work (it uses QtNetwork to fetch PaymentRequest/PaymentACK messages via https).The magic configure incantation was:Nothing special needed to be done for the openssl build:The payment protocol code add a couple more depedencies to Bitcoin-Qt:+ QtNetwork with OpenSSL support+ Google's protocol buffer library and compiler. Nice work!RE: gcc creating different binaries:The gitian build does two main things to make builds reproducible:1. Uses libfaketime.so so all calls to time()/etc during compilation return the same time. (I don't know if it is the compiler, linker, or archiver that likes to put timestamps in binaries)2. Passes -frandom-seed=constant  to g++, so it doesn't create random names for generated methods. The problem is that there is a mismatch between the criteria used to accept a transaction into the memory pool / relayed and the criteria most miners use to choose transactions for their blocks.The fix is not conceptually hard; just modify the memory pool code so the memory pool is treated like it is an extra-large block, and only relay/store the transactions that are likely to be mined in the next few blocks.That hasn't been implemented yet because it just hasn't been a high priority. Bitcoin-Qt version 0.8.3 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.3/This is a maintenance release to fix a denial-of-service attack thatcan cause nodes to crash.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issues0.8.3 Release notesTruncate over-size messages to prevent a memory exhaustion attack.Fix a regression that causes excessive re-writing of the 'peers.dat' file.Thanks to Peter Todd for responsibly disclosing the vulnerability( CVE-2013-4627 ) and creating a fix. No. Sold!  (I hope)Two offers over 26 BTC, best offer was 30 BTC. Pieter and Wladimir are not US citizens, so a US judge can't order them to do anything.If I was ordered to insert a backdoor, I'd just resign as lead developer and find something else to work on.But this whole scenario sounds like a paranoid delusion; has there EVER been a case where a judge has ordered a software developer to do anything other than stop distributing their software (because of some copyright or patent issue) ? It is mining over 0.2 BTC per day right now, so if difficulty doesn't change (HAH!) and you have free electricity (DOUBLE HAH!) you'll break even in 4 or 5 months.PS: best offer so far is a private offer of 26 BTC plus shipping.
This gives me warm fuzzies; a University of Chicago professor speculating about how a wildly successful Bitcoin might affect the International Monetary Fund!I don't really care what is said, just the fact that Bitcoin is being talked about in the elite Ivory Towers is a very good thing. Yes.  If you're feeling helpful, please create a wiki page or other document that organizes all of the pro/con arguments: economic and technical. And maybe another wiki page that organizes all of the various proposals for how to increase the block size.I've been derailed the last week by a death in the family, and still need to finish up some payment protocol work. I'm doing well this month, so far I've been called an "Angry Internet Troll", a "coward", and a "nazi". Selling my Butterfly Labs BitForce 5 GH/s SC (aka Jalapeno) ASIC miner.It has been reliably cranking out about 5 and a half GH/s at about 35 watts fortwo weeks now; I'm selling it just so I have one less thing in my life to think about.I paid 25.9 BTC for it; best offer over 26 BTC before 16:00 UTC Sunday, 9 June gets it.I'll ship it UPS/USPS/Fedex on the 10'th or 11'th, you must pay shipping (e.g. if youwant it overnight, add shipping charges from Amherst, MA 01002 to your payment).PGP signed version of the above, so you know this is really me and not a scammer who managed to hack my forum account:Code:-----BEGIN PGP SIGNED MESSAGE-----Hash: SHA512Selling my Butterfly Labs BitForce 5 GH/s SC (aka Jalapeno) ASIC miner.It has been reliably cranking out about 5 and a half GH/s at about 35 watts fortwo weeks now; I'm selling it just so I have one less thing in my life to think about.I paid 25.9 BTC for it; best offer over 26 BTC before 16:00 UTC Sunday, 9 June gets it.I'll ship it UPS/USPS/Fedex on the 10'th or 11'th, you must pay shipping (e.g. if youwant it overnight, add shipping charges from Amherst, MA 01002 to your payment).-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)iQIcBAEBCgAGBQJRrftpAAoJECnZ7msfxzDBeZQP/iver66p7TpihqndjdcCAlAre5ZYdOWtsB2xqosnodk+ikhZIqwq4qPrYlRg3BvanIzLsrM90EbvmPso7yaxKElARezhg6gMEfTiFAQqin6mi5ZcUHjKngLXWfYBd7cByzCwgxN6UUdljFntbEpStteCE2eA5rO+UTs2dZsxTu3yEployLPoA1Abv5nN7EcCYvQ/EVsGW3C9Zewb0Q5pE3132ULIeHg55I3nBPcy9IrA4Hjumt743AmtCWYLeKlAQcKgR5Z+4MsCzOeJwvHN/QeXuVhE0Mb4x49buoGN/bQwy//MZD1NqLJnzuBTsfgcC5Yp8Hfpvs+nUBYqXFMhYC35okPx/RIJxbIGz8yFjj9rrSEbIbSs4aP4SHXZS4+Ku/mBxvx9yKzlVr5ef/bnzU3iw0trdxkmADDEpaZREUKoi8EvDthC9k5XVViDLbINOO+MsndL4vwMbGC98OiBCudl8Zb+YvG+ghiJQyemcgCsFkDIz6jP9lqo/yush8L5H0zZ29dVwiC/O1CfwFa4bv0HTcyaaSycIvK4OuRXOFjWoybmlv2LWJmeK6d7JCchIsHpsCMQZlpVce5oAjicmpg9o3fesjkwqDj8Yii8KTiqmEcWzVz3m3cycDtDyw6AaEnnpE+aJCe0jJBTO0l6YNB7gOYmhDypG2VCqCbthBML=GtFS-----END PGP SIGNATURE----- No, absolutely not. The process for a hard fork looks like:+ Get rough consensus that the change is necessary.+ Write the code.+ Get it reviewed and thoroughly tested.+ Release software that will support it when X% of hashing power agrees... where X is a super-majority (like 75% or more).  If 70% of hashing power disagrees, then it doesn't happen. Miners will express support by producing block.version=3 blocks (just like they are now producing block.version=2 blocks that MUST include the chain height in the coinbase transaction).It is possible the X% threshold will never happen if 1MB is plenty big enough. It is possible it will only happen when transaction fees start going up and pressure increases on pools to make their blocks bigger (or maybe merchants tired of paying high fees figure out they'll save money by mining or operating pools themselves, will get X% of hashing power, and will increase the block size).Again, I spent a lot of time at the conference talking with people about the block size issue, and there is definitely consensus that 1MB just won't be big enough eventually. That has nothing to do with microtransactions, normal growth in "macrotransactions" will bump up against the limit in a year or three. Which "bigger powers" and which "people" ?Is there some secret cabal out there I don't know about?If you mean "Peter Todd has convinced some big mining pool operators not to increase the size of the blocks they create" -- then great!  That's the free market at work, big mining pools should be free to create blocks that are as large or as small as they like, and to accept or reject other's blocks for whatever reason they like. Thanks!PS:  I'm still giving away 10 BTC per month from those funds to the Minecraft Faucet (I committed 100BTC to the Minecraft Faucet folks before the EFF announced they'd accept Bitcoin donations again)... The block size will be raised, that is the overwhelming consensus among the people who are actually writing code and using Bitcoin for products and services that it needs to happen.And there is a tiny minority of people who will loudly proclaim that isn't true and that the core developer are going to destroy Bitcoin if the block size is raised.If you want to be helpful, please organize a list of objections to raising the block size limit and responses to those objections.I believe the last objection raised was that a higher block size limit would make it impossible to mine anonymously, but I think that has been debunked with the notion of "read the firehose of transactions non-anonymously, then broadcast just new block header + coinbase + listof(truncated transaction hashes) anonymously."I'll soon be writing up a plan for how we can safely raise the block size limit.RE: central planning:No central planning is why I would like to eliminate the hard, upper blocksize limit entirely, and let the network decide "how big is too big."RE: "the plan"  :   The plan from the beginning was to support huge blocks.  The 1MB hard limit was always a temporary denial-of-service prevention measure. How do you prevent Sybil attacks-- somebody creating a gazillion n-client and/or hatching nodes, and voting themselves lots and lots of new currency?And how does a node choose a "random" node-- does every node know about every other node?  If yes, then how do you avoid getting O(N^2) communication as the number of nodes (N) rises and every existing node must be told about every new node? Security, yes (including potential for denial-of-service attacks of various sorts).But demonstrate a spiffy, compelling use of new opcodes on testnet and we'll talk about making them standard. I've started and then stopped writing about Zerocoin three or four times now; my thoughts about it are still muddled.It adds a whole lot of complexity to transaction creation/verification to solve one problem:  how to mix coins/transactions with zero trust in the mixing process.  That's technically nifty, but I wonder if it is the best engineering solution.I wonder if just using a couple of semi-trusted mixers would be a lot faster/smaller/simpler.And then I start thinking about "tainted coins" in general. If we imagine a world with either mandatory or voluntary "taint tracking" (I have no idea whether or not that will ever happen), then it seems to me any mixing scheme that isn't "always on" is likely to fail in practice-- all coins coming out of the mix will be considered tainted.Why? I assume that most users (if you are reading this are NOT "most users") don't care much about privacy/anonymity. So I would assume most people would choose the lowest cost, fastest, most convenient method for their transactions. Anybody using a mixer will be either a weirdo, principled privacy nut (like us) or a criminal. I don't see other "privacy first" projects taking over the world, but do see lots of big, successful "quick and easy and free" projects.Then my thoughts get muddled, because "it is hopeless, just give up" is not an answer I'm willing to accept. But it feels to me like finding an essentially zero-cost way to increase transaction privacy that everybody uses by default is the best answer. Making your network connection more private is the other piece of the puzzle, though, and all of the solutions for that (either route through a couple of semi-trusted proxies or use Tor or i2p) add significant convenience/speed/financial costs. Bitcoin-Qt version 0.8.2 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/This is a maintenance release that fixes many bugs and includesa few small new features.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to UpgradeIf you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.2 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine.0.8.2 Release notesFee Policy changesThe default fee for low-priority transactions is lowered from 0.0005 BTC (for each 1,000 bytes in the transaction; an average transaction isabout 500 bytes) to 0.0001 BTC.Payments (transaction outputs) of 0.543 times the minimum relay fee(0.00005430 BTC) are now considered 'non-standard', because storing themcosts the network more than they are worth and spending them will usuallycost their owner more in transaction fees than they are worth.Non-standard transactions are not relayed across the network, are not includedin blocks by most miners, and will not show up in your wallet until they areincluded in a block.The default fee policy can be overridden using the -mintxfee and -minrelaytxfeecommand-line options, but note that we intend to replace the hard-coded feeswith code that automatically calculates and suggests appropriate fees in the0.9 release and note that if you set a fee policy significantly different fromthe rest of the network your transactions may never confirm.Bitcoin-Qt changes* New icon and splash screen* Improve reporting of synchronization process* Remove hardcoded fee recommendations* Improve metadata of executable on MacOSX and Windows* Move export button to individual tabs instead of toolbar* Add "send coins" command to context menu in address book* Add "copy txid" command to copy transaction IDs from transaction overview* Save & restore window size and position when showing & hiding window* New translations: Arabic (ar), Bosnian (bs), Catalan (ca), Welsh (cy),  Esperanto (eo), Interlingua (la), Latvian (lv) and many improvements  to current translationsMacOSX:* OSX support for click-to-pay (bitcoin:) links* Fix GUI disappearing problem on MacOSX (issue #1522)Linux/Unix:* Copy addresses to middle-mouse-button clipboardCommand-line options* -walletnotify will call a command on receiving transactions that affect the wallet.* -alertnotify will call a command on receiving an alert from the network.* -par now takes a negative number, to leave a certain amount of cores free.JSON-RPC API changes* fixed a getblocktemplate bug that caused excessive CPU creating blocks.* listunspent now lists account and address infromation.* getinfo now also returns the time adjustment estimated from your peers.* getpeerinfo now returns bytessent, bytesrecv and syncnode.* gettxoutsetinfo returns statistics about the unspent transaction output database.* gettxout returns information about a specific unspent transaction output.Networking changes* Significant changes to the networking code, reducing latency and memory consumption.* Avoid initial block download stalling.* Remove IRC seeding support.* Performance tweaks.* Added testnet DNS seeds.Wallet compatibility/rescuing* Cases where wallets cannot be opened in another version/installation should be reduced.* -salvagewallet now works for encrypted wallets.Known Bugs* Entering the 'getblocktemplate' or 'getwork' RPC commands into the Bitcoin-Qt debugconsole will cause Bitcoin-Qt to crash. Run Bitcoin-Qt with the -server command-lineoption to workaround.Thanks to everybody who contributed to the 0.8.2 release!APerson241Andrew PoelstraCalvin OwensChuck LeDuc DíazColin DeanDavid GriffithDavid SerranoEric LombrozoGavin AndresenGregory MaxwellJeff GarzikJonas SchnelliLarry GilbertLuke DashjrMatt CoralloMichael FordMike HearnPatrick BrownPeter ToddPhilip KaufmannPieter WuilleRichard SchwabRoman MindalevScott HowardTariq BashirWarren TogamiWladimir J. van der Laanfreewilgladoscckjj2mb300sdsuper3 latency of what? getblocktemplate?  getbalance? 0.8.2 rc2 never made it out the door; two crash-on-shutdown bugs and a bitcoin.ico file that made the windows gitian build non-reproducible made us jump to rc3 instead.So:Bitcoin-Qt version 0.8.2 release candidate 3 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/test/This is a maintenance release that fixes many bugs and includesa few small new features.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.2 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine.0.8.2 Release notes===================Fee Policy changes------------------The default fee for low-priority transactions is lowered from 0.0005 BTC (for each 1,000 bytes in the transaction; an average transaction isabout 500 bytes) to 0.0001 BTC.Payments (transaction outputs) of 0.543 times the minimum relay fee(0.00005430 BTC) are now considered 'non-standard', because storing themcosts the network more than they are worth and spending them will usuallycost their owner more in transaction fees than they are worth.Non-standard transactions are not relayed across the network, are not includedin blocks by most miners, and will not show up in your wallet until they areincluded in a block.The default fee policy can be overridden using the -mintxfee and -minrelaytxfeecommand-line options, but note that we intend to replace the hard-coded feeswith code that automatically calculates and suggests appropriate fees in the0.9 release and note that if you set a fee policy significantly different fromthe rest of the network your transactions may never confirm.Bitcoin-Qt changes------------------* New icon and splash screen* Improve reporting of synchronization process* Remove hardcoded fee recommendations* Improve metadata of executable on MacOSX and Windows* Move export button to individual tabs instead of toolbar* Add "send coins" command to context menu in address book* Add "copy txid" command to copy transaction IDs from transaction overview* Save & restore window size and position when showing & hiding window* New translations: Arabic (ar), Bosnian (bs), Catalan (ca), Welsh (cy),  Esperanto (eo), Interlingua (la), Latvian (lv) and many improvements  to current translationsMacOSX:* OSX support for click-to-pay (bitcoin:) links* Fix GUI disappearing problem on MacOSX (issue #1522)Linux/Unix:* Copy addresses to middle-mouse-button clipboardCommand-line options--------------------* -walletnotify will call a command on receiving transactions that affect the wallet.* -alertnotify will call a command on receiving an alert from the network.* -par now takes a negative number, to leave a certain amount of cores free.JSON-RPC API changes--------------------* fixed a getblocktemplate bug that caused excessive CPU creating blocks.* listunspent now lists account and address infromation.* getinfo now also returns the time adjustment estimated from your peers.* getpeerinfo now returns bytessent, bytesrecv and syncnode.* gettxoutsetinfo returns statistics about the unspent transaction output database.* gettxout returns information about a specific unspent transaction output.Networking changes------------------* Significant changes to the networking code, reducing latency and memory consumption.* Avoid initial block download stalling.* Remove IRC seeding support.* Performance tweaks.* Added testnet DNS seeds.Wallet compatibility/rescuing-----------------------------* Cases where wallets cannot be opened in another version/installation should be reduced.* -salvagewallet now works for encrypted wallets.Thanks to everybody who contributed to the 0.8.2 release!---------------------------------------------------------APerson241Andrew PoelstraCalvin OwensChuck LeDuc DíazColin DeanDavid GriffithDavid SerranoEric LombrozoGavin AndresenGregory MaxwellJeff GarzikJonas SchnelliLarry GilbertLuke DashjrMatt CoralloMichael FordMike HearnPatrick BrownPeter ToddPhilip KaufmannPieter WuilleRichard SchwabRoman MindalevScott HowardTariq BashirWarren TogamiWladimir J. van der Laanfreewilgladoscckjj2mb300sdsuper3 Except they're not learning from Bitcoin's mistakes; how many alt coins have fixed the problems on Bitcoin's hard-fork wish list? I received my pre-ordered (day 2, I think) Jalapeno today. Yes, after NUMEQUALVERIFY the stack will be empty, and for a script to be valid it must leave a true value on the stack.Use NUMEQUAL and it should work. Couple years ago it was "Don't talk to the CIA! They're Evil, and will Destroy Bitcoin!"Now it is "Don't get involved in DC lobbying! That's Evil, and will Destroy Bitcoin!"In a few more years, I bet it'll be "Don't go to the United Nations! They're Evil, and will Destroy Bitcoin!"I'll quote myself from a related thread on google+ You are wrong.  If Bitcoin was using (double) MD5 for its proof-of-work hashing algorithm, we'd be just fine. If there is a longer fork with more work that your node thinks is invalid, you'll get this alert:    Warning: Displayed transactions may not be correct! You may need to upgrade, or other nodes may need to upgrade.(see the GetWarnings() function in main.cpp).If you are on the fork with the most work... I suppose if the second-best chain was forked more than 6 blocks back and contained more than... oh,  5 blocks and the timestamp on the last block in that chain was less than ?an hour ago? that could trigger another alert.All that might be tricky to implement-- either (or both) forks might themselves have forks.  Or, theoretically, there could be three or more active forks, some of which might have equal proof-of-work...
Okey dokey.Have you contributed any patches to p2pool to make it more efficient / easier to install / etc? If not, why not if you're so worried about centralization?(honest question, I don't keep up with p2pool development because I'm personally not terribly worried about mining centralization) Who gets to decide how slow is too slow?Mining these days requires investing in ASIC hardware. Solo mining or running a pool will very soon require investing in a reasonably fast network connection and a machine with at least a few gigabytes of memory.Knocking the slowest N% of solo miners/pools off the network every year (where N is less than 20 or so) is not a crisis. That is the way free-market competition works. Bitcoin-Qt version 0.8.2 release candidate 1 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.2/test/This is a maintenance release that fixes many bugs and includesa few small new features.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to UpgradeIf you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.2 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine.0.8.2 Release notesFee Policy changesThe default fee for low-priority transactions is lowered from 0.0005 BTC (for each 1,000 bytes in the transaction; an average transaction isabout 500 bytes) to 0.0001 BTC.Payments (transaction outputs) of 0.543 times the minimum relay fee(0.00005430 BTC) are now considered 'non-standard', because storing themcosts the network more than they are worth and spending them will usuallycost their owner more in transaction fees than they are worth.Non-standard transactions are not relayed across the network, are not includedin blocks by most miners, and will not show up in your wallet until they areincluded in a block.The default fee policy can be overridden using the -mintxfee and -minrelaytxfeecommand-line options, but note that we intend to replace the hard-coded feeswith code that automatically calculates and suggests appropriate fees in the0.9 release and note that if you set a fee policy significantly different fromthe rest of the network your transactions may never confirm.Bitcoin-Qt changes* New icon and splash screen* Improve reporting of synchronization process* Remove hardcoded fee recommendations* Improve metadata of executable on MacOSX and Windows* Move export button to individual tabs instead of toolbar* Add "send coins" command to context menu in address book* Add "copy txid" command to copy transaction IDs from transaction overview* Save & restore window size and position when showing & hiding window* New translations: Arabic (ar), Bosnian (bs), Catalan (ca), Welsh (cy),  Esperanto (eo), Interlingua (la), Latvian (lv) and many improvements  to current translationsMacOSX:* OSX support for click-to-pay (bitcoin:) links* Fix GUI disappearing problem on MacOSX (issue #1522)Linux/Unix:* Copy addresses to middle-mouse-button clipboardCommand-line options* -walletnotify will call a command on receiving transactions that affect the wallet.* -alertnotify will call a command on receiving an alert from the network.* -par now takes a negative number, to leave a certain amount of cores free.JSON-RPC API changes* listunspent now lists account and address infromation.* getinfo now also returns the time adjustment estimated from your peers.* getpeerinfo now returns bytessent, bytesrecv and syncnode.* gettxoutsetinfo returns statistics about the unspent transaction output database.* gettxout returns information about a specific unspent transaction output.Networking changes* Significant changes to the networking code, reducing latency and memory consumption.* Avoid initial block download stalling.* Remove IRC seeding support.* Performance tweaks.* Added testnet DNS seeds.Wallet compatibility/rescuing* Cases where wallets cannot be opened in another version/installation should be reduced.* -salvagewallet now works for encrypted wallets.Thanks to everybody who contributed to the 0.8.2 release!APerson241Andrew PoelstraCalvin OwensChuck LeDuc DíazColin DeanDavid GriffithDavid SerranoEric LombrozoGavin AndresenGregory MaxwellJeff GarzikJonas SchnelliLarry GilbertLuke DashjrMatt CoralloMichael FordMike HearnPatrick BrownPeter ToddPhilip KaufmannPieter WuilleRichard SchwabRoman MindalevScott HowardTariq BashirWladimir J. van der Laanfreewilgladoscckjj2mb300sd +1 I think this is a terrible idea.If it was "higher fee with superset of outputs of first spend" then that'd be fine.Zero-confirmation transactions will never be safe because of potential Finney attacks. But we don't need (and, in my opinion, shouldn't) make them less safe by encouraging anti-social behavior via default mining policy. ... hire a lawyer. Nah, I'm not in the underground facility any more. I packed up the hookers and blow and we're all living the sweet life in a penthouse suite now. +1Knock yourselves out, no fork needed, just add this to your bitcoin.conf and convince a few big miners or mining pools to do the same:    minrelaytxfee=0 Awww, that is cheating!You really have no business creating your own block chain if you don't understand the code well enough to figure out how to mine a new genesis block without somebody else's help. Ummm... it is a wiki.  They should just update it themselves (after asking questions if they have any), it is much more efficient. Yes, please, feedback from re-implementors is very helpful. Yes.If you want to get geeky about it, it sends an ECDSA signature derived from the private key and the transaction data, and the full public key that corresponds to your bitcoin address (the address is a shorter version of it). Sure. That's one of the reasons why I'm reluctant to upgrade the distro/dependencies for the deterministic build process, and generally prefer to use older dependencies rather than the "latest and greatest" of everything. But there's a tradeoff between "risk that an Evil Maintainer slipped something in" and "risk that we ship with an upatched bug" -- e.g. we tend to be on the latest version of OpenSSL, but a few releases behind of Qt4.PS: if you really want to be completely paranoid, you should only run bitcoin on old hardware/OS manufactured before 2009 so you can be sure the  hardware/firmware/OS doesn't have any wallet-stealing circuits/code lurking.... RE: NODE_RELAYCOST :I'm generally against any "take my word for it" settings.  What would stop somebody Up To No Good from setting NODE_RELAYCOST and then lying about what they will relay?  Miners might decide to try to increase fees by Sybil-attacking the network and lying about NODE_RELAYCOST.... Minimum transaction output is (conservatively) calculated from the minimum relay fee setting.  It did exist before, it was just set to '1 satoshi'.We made 0-satoshi outputs non-standard a couple of releases ago, but consensus is that was a mistake-- 1-satoshi is not the right number, because the marginal cost of spending a 1-satoshi output is greater than its value.Again, eventually it might be economical to spend 1-satoshi outputs. When it is, the minimum relay fee will be on the order of a satoshi or two, and this code will do the right thing. Bitcoin Foundation uses CloudFlare to protect bitcoinfoundation.org from distributed denial of service attacks.As the message says, either your computer or a computer on the same network / ISP as yours was sending lots of spammy requests to CloudFlare. So they ask you to solve a CAPTCHA to prove that you're not part of the bad guy's botnet. A transaction is final if:All of its sequence numbers are INT_MAX  ORlockTime has passed.I'm still of the opinion that non-final transactions shouldn't be broadcast over the p2p network; I think the parties negotiating using them should keep them to themselves until they are final, and broadcast then. Y'all read the pull request, yes?So: if you have a better suggestion for fixing the problem of new users wasting lots of time gathering tiny drips and drabs of bitcoins, and then getting upset when they can't spend them (because it costs more in fees that they are worth), I'm open to suggestions.RE: "what about when bitcoins are worth a million dollars apiece" Umm, that's what the "un-hardcode TX_FEE constants" part is all about?RE: trolling about Foundation setting the fee:Go back under your rock, please. This pull request is the first step towards a market between miners (who want higher fees) and merchants/users (who want lower fees, but also want their transactions confirmed). Miners can already control what fees they accept, this pull lets users control (very clumsily, improvements on the road map) the fee they are willing to pay. Network bandwidth is currently growing about 20% per year, or roughly doubling every four years.Satoshi's original code had a 32MB block size limit, which he dropped to 1MB as part of a bunch of band-aid fixes to make denial-of-service attacks harder.RE: density of full nodes:  In my opinion, if it is affordable to run a full node (less than, say, $100 per month in server costs-- that is a trivial monthly cost for most businesses and some individuals) then we'll continue to see tens of thousands of full nodes.Median cost of a dedicated server with lots of bandwidth, disk and CPU is under $100/month these days, which would support a block size at least ten times the current maximum.And all of THAT is before even starting to think about possible optimizations (e.g. figure out how to mitigate the "insert malicious data" problem-- maybe Peter Todd's security bonds would be helpful-- and a shared DHT storing all valid transactions combined with bloom filters on connections could make it cheap for any one machine to be a fully validating node).Please, don't listen to all of the FUD being thrown around about raising the block size even before there is any solid proposal for what should be done. My reaction:  stop spreading FUD."small mining pools will go out of business" -- give me a break! My back-of-the-envelope calculations say that anybody willing to spend a few hundred dollars a year on a dedicated server with a high-bandwidth connection can support a MUCH, MUCH larger block size.The block size will be raised. Your video will just make a lot of people worried about nothing, in exactly the same way Luke-Jr's BIP17 proposal last year (and his hyperbolic rhetoric about BIP16) did nothing but cause a tempest in a teapot.
Let me guess, you think 9/11 was an inside job by the Bush administration and we never sent a man to the moon?This is exactly why I don't come here much any more, and exactly why the Foundation forums are real-name-only, member-only.  None of us have time to respond to all the tinfoil-hat-wearing conspiracy-mongering (I don't remember why "Bitcoin Foundation" was originally a legal entity in the midwest; something about an aborted previous attempt to get one started by... maybe Mt. Gox?  who cares? why does that matter? focus on the present and future, stop worrying about how things weren't done perfectly in the past exactly how you wanted them to happen).Sigh.  Ok, I'm going to go back to my default "don't feed the trolls" now, and actually get some work done. I'm allergic to that kind of bureaucracy. The agenda will probably be decided ten minutes before the meeting, and will probably be something like "Peter talks for ten minutes and answers questions for 20 minutes while everybody is eating. Then we all talk to each other about whatever we like."One day maybe the Foundation will be big and bloated, and will have lots of staff to prepare Official Agendas, solicit feedback from members months in advance, tabulate the responses, then hire a consultant to figure out how to increase the number of responses received, etc.I hope I'm not on the Board any more when that happens. Board meetings are board members only.  If you've ever been on the executive team of a company or non-profit I'm sure you can appreciate that if you want to actually get things done (as opposed to wanting to talk endlessly about things) then small, focused meetings are a necessary evil.The Bitcoin Foundation Members Only Lunch Forum is on the conference schedule. Last quarter's plan:  https://bitcoinfoundation.org/blog/?p=99What is next:  I dunno.  Foundation board will be meeting all day before the conference, and we'll all be talking to lots of people at the conference to figure out what the priorities should be going forward.As for excluding certain voices:  "okey dokey."  I listen a lot harder to people who are actually getting things done, and have learned to tune out trolls. Huh. What evidence do you have that the Foundation has been hurting the evolution of Bitcoin?Because it seems to me things have been going gangbusters since the Foundation was formed (with all the usual chaos and drama).Or, to be less polite to all the haters: we've all been working our asses off (especially Peter), to make Bitcoin a success. What have you anonymous cowards been doing besides spouting off about things you know NOTHING about? Meh.Lots of other ways that merchants could arrange to pay transaction fees, I don't think we need a hard fork to solve that problem.E.g. : child-pays-for-parent.Or an extension to the payment protocol so the merchant provides an already-signed SIGHASH_SINGLE / SIGHASH_ANYONECANPAY input to pay the fee that the client includes as the first input in the transaction. Probably more effective to ask if you can contribute to their campaign using Bitcoin.They like getting money. Thought it might be interesting for y'all to see the 'raw interview':Bitcoin is an open, international payment network. More and more businesses are choosing to accept bitcoins because it is an easy way to allow anybody, anywhere in the world, to pay for products or services-- even people from countries where credit cards and bank accounts might not be common.It is also very low-cost, because it was designed for the Internet.Individuals use it for a few different reasons.The earliest adopters started using bitcoins either because they like the idea (for political or personal reasons) of using a currency that isn't controlled by a government or corporation or just because it was "new and cool."Some people use it because they have no other choice; for example, more and more legal, online gaming sites use bitcoins to make it possible for players in countries that try to restrict onling gaming (like the US) to play.We're just starting to see individuals using bitcoin because it saves them money; merchants are starting to pass on some of the savings (much lower transaction fees, no "chargebacks") to customers who pay using bitcoin. People trust that it isn't going to disappear, because there is no central organization that can either go bankrupt or be forced to shut down by a government. Currencies are all about trust, and more people are beginning to trust this decentralized currency that is supported by everybody who uses it. I still tell people "only invest time or money into Bitcoin that you can afford to lose." I expect more drama and chaos and price fluctuations in the short-term.  The current price bubble was driven by lots of attention in the press here in the US and in Europe, and all of the attention was self-reinforcing: stories about Bitcoin's dramatic price rise got people interested, which drove the price higher, which triggered even more stories.I expect that will happen again in the next few years, perhaps in a different area of the world (maybe there will be a China-driven bitcoin bubble in a few years that will pop when the Chinese government decides to try to restrict bitcoin transaction across their Great Firewall).But in the long-term, I expect that to settle down, and the value of a bitcoin to become much more stable. Actually, the valuation isn't a big barrier to adoption. There are already services that help companies manage the currency exchange risk (you can peg your prices to dollars, your customers can pay the equivalent amount in bitcoins, and you get dollars deposited to your bank account), and as the financial service infrastructure for Bitcoin get more mature that will just get easier.Any important new technology grows by starting with successes in some niches where its advantages are overwhelming; ubiquitous technologies then manage to slowly grow out of those niches to take over markets where they have a marginal advantage (either in convenience or price).That is the pattern we're already seeing with Bitcoin, starting with niches where the advantages are too large to ignore (e.g. online gaming, international payments). It remains to be seen whether or not Bitcoin can grow out of those niches to become a ubiquitous form of payment. In theory, the value of a currency increases as more people use it. Since the potential market for Bitcoin is every person connected to the Internet, it could become more valuable than any national currency that is tied to one specific geographic region of the planet. http://knowledge.wharton.upenn.edu/article.cfm?articleid=3232 Mmm.  And I'm working hard to try to delegate that authority, so can y'all please just work it out? No, unless you take complete control over input selection and transaction creation using the raw transactions API.If you have multiple users sharing the same wallet, then reasonable ways of handling transaction fees are:Keep track of who owns which inputs and use the raw transactions API to charge users fees based on what the inputs look like.Just pay transaction fees for your users. If you work out how much that will cost you versus how much time you'll spend with a more complicated solution, you'll probably find this is the best solution. If you're using the 'accounts' feature, then the logic is:  Send the transaction, then get the transaction details and reimburse the transaction fee (if any) with a 'move' that transfers bitcoins from a transaction-fee-reimbursement account (which you finance in advance, and top-up when necessary) to the user's account.Or charge them a fixed fee that is enough to cover average costs (again, if using accounts you'd move bitcoins to/from the transaction fee account depending on whether a given transaction cost more or less than average).Otherwise, you'll have a situation where user A gets gazillions of tiny inputs credited to their account, and user B ends up paying to spend them. I think a diversity of views is good, as long as the people expressing their views are honest, trustworthy, and respectable. I still think Luke causes more trouble and strife than he is worth. And I wish people would stop implying he is part of the core development team. Howdy Adam!I'm going to quote myself, this is from an email I wrote yesterday to somebody else concerned about chip/mining centralization:In the very long run, mining will be dominated by your cost of electricity and your ability to put the excess heat generated to good use.I don't think it will matter what algorithm is used or even if the algorithm was changed every six months; if a general-purpose CPU was the only thing you could use for mining, you might see general-purpose CPUs designed to operate at thousands of degrees celsius being designed so that aluminum smelting plants can also mine bitcoins with all that electricity they use turning bauxite into aluminum.In the short run... I think there is zero chance that "we" will decide to change the hashing algorithm. See -blocknotify and -walletnotify command-line options in the latest code, which will run an arbitrary command when new blocks happen or transactions hit your wallet (and that arbitrary command can be "POST information to this URL..."). I think including a message that is NOT stored in the blockchain but is just broadcast across the network is a good idea. The receiver would only get the message if they were online and saw the transaction broadcast, but I think that would be fine (and perhaps services would spring up to deliver the extra transaction data associated with old transactions).First, though, I think the transaction memory pool needs to be re-implemented, and the transaction relaying rules need to be changed so that the entire size of the transaction (not just the part that will be stored in the block chain) is considered in the priority/fee calculations.And fixing the client so it calculates fees properly is higher priority... For the record:I think testing a gazillion pulls at once is madness, because if something doesn't work it can be incredibly difficult to figure out which of the gazillion changes made it break.  Assuming that just once change made it break and not some subtle interaction between two or three or six changes...If you want to help test, I think it would be much more helpful if you find a feature you care about, grab the binaries that the pull-tester creates, test thoroughly, and then report results in the pull request on github. Nah, I now think that's a dumb idea.Responding to gmaxwell:RE: burden of unpaid full nodes: for the immediately forseeable future, that burden is on the order of several hundred dollars a year to buy a moderately beefy VPS somewhere.I understand the "lets engineer for the far future" ... but, frankly, I think too much of that is dumb. Successful projects and products engineer for the next year or two, and re-engineer when they run into issues.Maybe the answer will be "validation pools" like we have mining pools today, where people cooperate to validate part of the chain (bloom filters, DHTs, mumble mumble....). Maybe hardware will just keep up.RE: race to the bottom on fees and PoW:sigh.  Mike explained how that is likely to be avoided. I'm 100% convinced that if users of the network want secure transactions they will find a way to pay for them, whether that is assurance contracts or becoming miners themselves. I think the big difference between the "bitcoin elites" and the existing financial system elites is the "bitcoin elites" are working really hard to distribute our power.We're getting there, but it will take time. I really hope in a year or two there will be at least three or four different bitcoin implementations all producing blocks, validating transactions, etc. And in ten years there will be a dozen or more.That is a natural progression; I was around when NCSA Mosaic was the one web browser and the NCSA server was the only web server, and there have been a couple cycles of certain browsers / web servers becoming dominant and then fading. I expect to see a similar evolution for Bitcoin infrastructure software. Okey dokey.If you want to be helpful, please write up a list of pros and cons for the various plans that have been proposed, including your own (last time I asked you, you waffled and didn't have any plan).I've been pretty busy dealing with the avalanche of press and working on the payment protocol. Exactly.DO NOT SELL TESTNET COINS. You'll just piss off the core developers, because we'll have to waste time re-launching a new testnet to reset the chain and make the coins worthless again.There a Fight Club "First Rule..." joke in there somewhere....
So the longer I think about the block size issue, the more I'm reminded of this Hayek quote:We can speculate all we want about what is going to happen in the future, but we don't really know.So, what should we do if we don't know? My default answer is "do the simplest thing that could possibly work, but make sure there is a Plan B just in case it doesn't work."In the case of the block size debate, what is the simplest thing that just might possibly work?That's easy!  Eliminate the block size limit as a network rule entirely, and trust that miners and merchants and users will reject blocks that are "obviously too big." Where what is "obviously too big" will change over time as technology changes.What is Plan B if just trusting miners/merchants/users to do the right thing doesn't work?Big-picture it is easy:  Schedule a soft-fork that imposes some network-rule-upper-limit, with whatever formula seems right to correct whatever problem crops up.Small-picture: hard to see what the "right" formula would be, but I think it will be much easier to define after we run into some actual practical problem rather than guessing where problems might crop up. I think there doesn't have to be One True Answer, and I'd like to see the different clients experiment with different ways of estimating fees.I like your idea, Jan-- go for it!I want Consumer Reports magazine to do an article in 15 years comparing bitcoin wallets and figuring out which one gives the fastest transactions for the lowest fees... You're assuming that miners are completely distinct from the people who want the network to be secure (users/merchants/exchanges/etc).That is a bad assumption. Nothing stops a merchant who wants more network security from either subsidizing miners (maybe in exchange for a promise to prioritize transactions to them) or mining themselves.This is already happening, not for reasons of security but for other reasons. Because dust outputs are more trouble than they're worth. They bloat wallets, cost more in fees to spend than they're worth (unless you go to ridiculous lengths to spend them), and are abused as a side-channel-in-the-blockchain-communication-mechanism.If I could go back in time, I would go back and try to convince Satoshi to make them non-standard to begin with.... Here's the thumbnail sketch on the code that I think needs to be written to handle fees properly:1). Memory-limit the memory pool-- the set of transactions waiting in memory eligible to be included in a block. Matt Corallo has been working on that.  The limit should be a small multiple of the median block size of the last few hundred blocks.2) Use the same algorithm/parameters/etc for adding transactions to the memory pool that we use to fill blocks.3) Only relay transactions that fit into your memory pool.  This is the DoS prevention, your transaction won't get relayed if your node doesn't think it will end up in a block soon.4) Estimate minimum transaction fee / priority needed to get into a block, based one:    a) At startup:  the transactions in the last few blocks    b) If you've been running long enough to "warm up" your memory pool:  transactions in the memory pool5) Expose the estimate in the GUI's "suggested transaction fee" dialog.All of that will give a floating fee that will change based on how many transactions, at what priorities/fees, are currently waiting to get into blocks.There is one more change I'd like to make that is independent; re-define "dust" based on the floating transaction fee (e.g. a dust output is any output with a value of less than 1/4 the minimum fee-per-kb required to get into one of the next 6 blocks).  And make any transactions with dust outputs non-standard, so they're not included in the memory pool or relayed. The only security risk with free bitcoin services is that they'll remember your IP address and associate it with the millibitcoins that they give you.If you're the conspiracy theory type, then here's one for you: a very good way for a Three Letter Agency to create a database that correlates bitcoin wallets to real people would be for them to run a free bitcoin service (along with whatever they're currently doing to correlate IP addresses with real people). r.willis is confused about the BIP process.It is not "Write a specification. Submit a BIP.  Argue for a while, revise the specification.  Finalize BIP, then everybody agrees to implement it."I know there are standardization processes that try to work that way, and they're generally miserable failures. You end up with bloated specifications and implementations that don't work with each other because everybody interprets the spec slightly differently.I like the IETF model, of working code and rough consensus. So, once the payment protocol is implemented and early adopters have had a chance to play with it, it will become a formal BIP.  Until then, as Mike said, I'll be tweaking https://gist.github.com/gavinandresen/4120476 as I run into issues. Nice!  We need a good Mac OSX developer, do you know C++?  Are you willing to learn Qt?My main machine is a Mac, but I'm not an expert OSX developer (I spend all my time in a Terminal window in emacs, pretending my Mac is a Unix machine). Wiki is out of date. Everybody running their node as a tor hidden service would work just fine as of a couple of releases ago. So... you complain about development not happening faster, and then you complain that I'm not spending all of my time here on the forums?"okey dokey" Transactions larger than 100K are non-standard now, so I doubt the big transaction was ever broadcast. Almost certainly the transaction belonged to the miner, and they paid the fees to themself. Sure.First, you need to make sure miners will accept bitcoins with the lower fee.  So lobby your favorite miner or mining pool to set the -mintxfee=  parameter to something lower than the default 0.0005 BTC-per-kilobyte; you can ask them if they will increase the size of the blocks they're creating and include more free transactions, too (those are settings they control).Then, if you're using Bitcoin-Qt, you can set the transaction fee in the Preferences/Options dialog.Right now, network peers won't relay low-priority transactions that include a fee of less than 0.0001 BTC, so that is as low as you should go. Fixing that is near the top of the (long) TODO list, but I really want to fix it correctly so we developers get out of the business of deciding what the transaction fees should be, and instead let the network decide.If you generate a small number of high-bitcoin-value transactions (e.g. you have more than 1 BTC in your wallet and make a few purchases a week) then you should probably leave the Pay transaction fee setting at zero; Bitcoin-Qt will send your transactions without a fee, which will be just fine. So....  move too fast and we maybe introduce a forking bug or a security vulnerability.Move too slow and maybe we get fired-- somebody faster at incorporating safe changes releases their own fork.For me, "move slow" is the right answer.But I would be completely happy contributing patches to somebody else running a fork who solves the "move fast but be safe" problem. Not rhetorical: it needs to be fixed, or your blockchain can easily be forked.Beware of Altchains that are abandoned or neglected by their developers (activity at https://github.com/litecoin-project/litecoin/commits/master doesn't look healthy to me... and now y'all are going to accuse me of spreading FUD, so I'll go away and shut up). Bitcoin is not a single product any more, so a "Download Now!" button doesn't make sense any more.Just like bittorrent or linux aren't single products. And if you visit bittorrent.org or linux.org... guess what?  No download button. Ummm.... speaking of the hardfork, has a version of Litecoin been released yet that fixes the problem? Straight Bitcoin isn't designed for really small transactions.  If you're sending less than something like $1 worth of bitcoins, you should expect to pay 10% or more in fees. More if you're trying to send $0.10 or less.There is no magic fairy wand we can wave and make Bitcoin suddenly great for gazillions of tiny transactions; plan your businesses accordingly. As transaction volume increases, there will be more competition for space in blocks and fees are likely to rise.And please avoid filling your customer's wallets with "dust" that they'll pay huge fees to spend; a payout should be at least a couple of cents, not a fraction of a penny. I think there is pretty good consensus among the core developers that sooner or later we'll make "dust" outputs non-standard, so they are not relayed or mined by default (details to be worked out, we need to implement a good algorithm for auto-adjusting the definition of "dust"). If you're on Linux or Mac, run contrib/tidy_datadir.sh if you want to get rid of old, not-used-any-more files in your data directory.It will safely remove the blkindex.dat and blk000?.dat files.If somebody wants to write an equivalent .bat file that does the same on Windows, that'd be fantastic!  I don't know hardly nuthin about Windows batch files.As deepceleron says, the blk000?.dat files are hardlinks, so even though it looks like they're taking up space they're not. And they're safe to delete (just don't delete anything in the blocks/ or chainstate/ folders). To be clear: the 'donor' was the EFF, and their only request was that the Bitcoins be given back to the bitcoin community. If you like, think of it as a bulk payment of transaction fees that the faucet would have paid if it had been operating over the last year instead of closed (due to lack of time for me to fight the scammers).Because it sent tiny transaction amounts, it paid almost as much in fees as it gave out... Somebody should exploit all the DoS bugs that have been fixed to put the dead altcoins out of their misery, starting with the BDB lock limit bug.Because if they keep scraping along, the worst thing that could happen would be for them to suddenly get popular-- because then attackers WILL swoop in and cause chaos.
After talking with a few groups of people, I decided a good use of Bitcoin Faucet funds would be compensating miners who had blocks that were orphaned in last week's Bit Chain Fork.This is a one-time thing-- don't expect orphaned blocks in the future to be compensated! It is just a coincidence that I haven't had time to fix the Faucet, and have a bunch of coins waiting to be given away.Transaction id paying the to the addresses in the coinbases of the orphaned blocks: c931f1aa9f0d211dca085342ec472e77b538b55980a2c7b0ff9fab9a20a9acd2 I think you're exactly right.FinCEN cares mostly about big-time money laundering and terrorist financing. If I was running a cash-for-bitcoins service in the US and started moving more than a few hundred bitcoins a month through my bank account, then I'd talk to a lawyer. If I was running an exchange, I would have already talked to a lawyer. If I was a US-based miner exchanging more than a few hundred freshly-made bitcoins for cash every month, then I would talk with a lawyer. If you hold other people's bitcoins... then I'd talk with a lawyer (even if you're not a money transmitter, there might be consumer protection or banking laws that might apply).Otherwise, I wouldn't worry. If I was a miner transferring my bitcoins to an exchange and selling them, then FinCEN won't come after me. FinCEN will get reports from the exchange, and that's what they really care about. The IRS might come after me if I don't report the income, but I think they'd charge me with tax evasion, not being an unlicensed money transmitter. I just used some bitcoins from the Bitcoin Faucet fund to compensate the p2pool miners who's block was orphaned in the Big Chain Fork.Transaction id 6521b0513f3077a983b82eb92cc95ecc24ad2a7ca3afdba082ef71ea8d25a868PS: this was a one-time thing, don't expect orphan blockss in the future to get paid for! Suggestion: instead of talking endlessly about possible attacks, try them out on the -testnet test network.That is what it is for.Oh:  except Sybil attacks, which just aren't very interesting on a network like testnet that has only a couple dozen peers on it. There are three stages to the rollout:1. Before 75% are producing block.version=2 blocks: no special checking2. Between 75 and 95% : block.version=2 blocks MUST have height in coinbase.  We are here.3. 95% or more:  all blocks MUST be block.version=2 and MUST have height in coinbase.  Should happen soon.Shell script to count block versions:Code:gavin$ for i in {225925..226925}; do ./bitcoind getblock $(./bitcoind getblockhash $i); done | grep version | sort | uniq -c 173     "version" : 1, 828     "version" : 2, The bottleneck for getting this pulled is testing.It needs a thorough test plan that tries to test edge cases where things might break, and then it needs people to carry out that test plan to make sure it is solid. "It works for me" isn't good enough for wallet-touching code.See https://github.com/bitcoin/QA  for a suggested process. No; the only 0.8 users who should upgrade are miners who are creating blocks themselves (mining pool operators, solo miners, or people using p2pool).Big merchants/services/exchanges who want to be as certain as possible they don't end up on the wrong side of a blockchain fork should also upgrade, although I think the risk of that happening if they keep running 0.8.0 is small. Last July, BIP 34 was accepted. It specifies a "soft fork":We are getting close to that threshold: 821 out of the latest 1000 blocks were version 2.If you are mining in a pool: there is a list of pools and what versions they are producing here. If your pool is producting version=1 blocks, you should urge your pool operator to upgrade or patch.If you are mining with p2pool or solo and using a very old version of bitcoind: you should upgrade, or you risk your blocks getting orphaned. Bitcoin-Qt/bitcoind version 0.8.1 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.1/This is a maintenance release that adds a new network rule to avoida chain-forking incompatibility with versions 0.7.2 and earlier.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you are upgrading from version 0.7.2 or earlier, the first time yourun 0.8.1 your blockchain files will be re-indexed, which will takeanywhere from 30 minutes to several hours, depending on the speed ofyour machine. More documentation is great, so yeah, if you want a formal spec, go for it.Here's a tricky question you can start with:Assume there is a fork consisting of max-block-size blocks. How deep a fork/re-organization MUST a conforming implementation handle?  6 blocks? 1000 blocks?  as-many-blocks-as-there-are-in-the-chain blocks?Does that imply that a confirming implementation MUST be running with a certain amount of memory, or MUST a conforming implementation be able to handle such a chain fork within a certain amount of time?.. and once you answer all that:  what if the network consists entirely of non-conforming implementations that take shortcuts and just assume that there will never be a re-org more than X blocks deep? Please stop the "Gavin's decision" meme, too:  I went with the in-the-moment consensus when it became clear that it was POSSIBLE to switch to the 0.7 fork.And as Melbustus said:  that was only possible because the split was close to 50/50.  If more miners had already upgraded to 0.8, an alert would have been sent to non-0.8 peers telling them to either upgrade or shutdown until we could find a workaround for the problem. No, that is not true.The only condition of my visit to the CIA was that I not use the fact that I visited there in any type of advertising.Well, that and to abide by their normal security while I was there:  no cell phone or other electronic devices allowed, no trying to wander off by myself unescorted.I am completely free to talk about what happened, and if you buy me a beer sometime I'd be happy to answer any questions you have.  Just not here, too many trolls and I've already spent too much time before and after the trip trying (and failing) to keep the conspiracy theories in check. The first part of the chain that got orphaned, starting at block 225,430, is here:  http://skypaint.com/bitcoin/fork08.datThe first three blocks in the 0.7-compatible chain starting at block 225,430 is:  http://skypaint.com/bitcoin/fork07.dat If Mr. Augustus found some documentation that I don't know about it, I genuinely want to know about it, because it will save me time. Right now I'm throwing blocks at an instrumented v0.7.2 bitcoind that tells me how many locks are taken, so I can be sure whatever fix we implement will always work. Ah, excellent, can you please send me the documentation that says exactly how many locks will be taken by each bdb operation?  I haven't been able to find that.  Thanks! I think you don't understand how mining works-- there is no such thing as a "faster" miner, just miners with more or less chance of creating the next block. I think this is exactly right.But I also think that choosing a larger-but-still-limited block size won't kill Bitcoin (but not raising the block size at all might-- a payment system with a hard seven-transactions-per-second limit is not Satoshi's vision). It is a problem if you send a transaction from one of the copies of the wallet while it is catching up with the blockchain. You can easily accidentally double-spend yourself, and end up with a transaction that will never confirm.Deterministic wallets don't solve that problem. Sigh.Ok, fine, so do a back-of-the-envelope for what THAT cost is.Big +1 to d'aniel for doing the work of actually calculating a number, that is very helpful. Why did you pick 0.0005 BTC ?  That is a mostly arbitrary number.I estimate a current-worst-case "orphan cost" of an average 250-byte transaction is 0.00008 BTC. See https://gist.github.com/gavinandresen/5044482 (more accurate analyses welcome, I don't pretend to have a monopoly on the "right" answer).That number will drop as CPUs get faster/cheaper, or bitcoin value rises. So you could argue that even though dust is not economical to spend today, in 20 years it will be.So I guess I'll rephrase my question again:  Rough, back-of-the-envelope: how much does it cost to keep a dust-like transaction output in the unspent outputs set for 20 years?If it is a lot, then we should set the "expected time when it will be economical to spend" to either "right now" or "very soon."If it is tiny, then we shouldn't worry so much about optimizing unspent txout size, and concentrate on other things.I have no idea what the answer is.
I agree.That is why I ask "what is the external cost, with reasonable assumptions."So I'll ask again: what is the cost-per-(pick-your-favorite-time-unit) to the network of an extra unspent transaction output? How much does it cost, if you assume reasonable trends for storage/electricity cost? +1 You may have heard me say "Bitcoin is an experiment" before...  well, we're finding out right now what happens as the experiment scales up.First:  I sent a message to the big mining pools, reminding them of the run-time options they can set to control the size of the blocks they create. I did not tell them what they should or shouldn't do, I think we need to move beyond centralized decision-making.I did send them a pointer to this very rough back-of-the-envelope estimate on the current marginal cost of transactions:  https://gist.github.com/gavinandresen/5044482(if anybody wants to do a better analysis, I'd love to read it).Second: block size is half of the equation. The other half is transaction fees and competition for getting included into blocks. All of the bitcoin clients need to do a better job of figuring out the 'right' transaction fee, and services that generate transactions will have to adjust the fees they pay (and are, already).Finally: in my opinion, there is rough consensus that the 1MB block size limit WILL be raised. It is just a question of when and how much / how quickly. I wouldn't say NO progress is being made, but there has been a long detour because we need a secure way of telling you WHO you are paying to make multisignature work securely. Otherwise we could have the most nifty, secure multisig system in the world that fails because you THINK you're paying 1kqHKEYYC8CQPxyV53nCju4Lk2ufpQqA2 but a crafty attacker makes you pay them at 1kqHLFyZDBDoPDYwSEtjv5CWka42uGqA2 instead.So I've been spending most of my time implementing "the payment protocol." I'll write more in a Foundation blog post on Friday.Payment protocol messages will be part of the information that will be sent between devices or people to make multisig transactions work. Yes, I definitely meant priority. Highest priority transactions (transferring lots of old coins) get included in blocks first under the default block-filling rules.And also notice that I said "most miners are..." There are at least a few big mining pools that have their own idiosyncratic ways of deciding which transactions get into blocks, including private deals with big exchanges/merchants/etc.Also note that because finding blocks is a random process the Bitcoin network "stalls" for an hour every three weeks or so, with no blocks found.My guess is that if an attacker tried to monopolize block space most of us wouldn't even notice. If you're really worried about it, then encourage some big mining pool(s) to have a completely different block-filling strategy ("randomly select from the memory pool" would be easy to implement). The default block-filling algorithm that most miners are running is:+ Fill up part of the block with the highest transactions, regardless of fees+ Then fill up the rest of the block with as many fee-paying transactions as possible, highest fee-per-kilobyte first.... so flooding the network with high-fee transactions won't "stall Bitcoin."  Well, except for people playing SatoshiDice or doing something else that results in lots of low-priority fee-paying transactions (and even there, they could always opt to pay a little more in transaction fees). A hard fork won't happen unless the vast super-majority of miners support it.E.g. from my "how to handle upgrades" gist https://gist.github.com/gavinandresen/2355445 RE: particular ideas if "we" decide the blocksize has to be increased:I think the first step is to come to rough consensus that, at some point, we WILL need a hardfork to increase the block size limit.If we can come to rough consensus on that, then we can figure out the safest way to accomplish that.I don't think we'll get consensus; retep and others will argue "we need to run into the hard limit to FORCE alternatives to be created first."I keep saying we should see what happens as we run into the soft blocksize limits.  To people on both sides of this debate:  what do you predict will happen?If what you predict will happen doesn't actually happen, will that make you re-evaluate your position?(I haven't spent enough time thinking about this problem to answer those questions, but that is how I'm going to think about it). Yes, I believe they would. So far, most miners and pools are VERY conservative; I think the idea that they will create huge blocks that have a significant risk of being rejected, just so they MIGHT get an advantage over marginal miners that can't process them fast enough, is loony.But I might be wrong.So I'd like to wait a little while, think deeply some more, and see how miners and merchants and users react with the system we've got as transaction volume increases. A couple people asked if they need to upgrade if they are running rc1:  no, I wouldn't bother.The only significant code change is better handling of the rare case of one of the leveldb database files being corrupted. If you're really curious, github will show you the differences between any two versions; here are the rc1 to 0.8.0 final release differences:  https://github.com/bitcoin/bitcoin/compare/v0.8.0rc1...v0.8.0 ... or not.  There's a difference between "unfixed vulnerabilities" and "half-baked design."I think big decisions that affect the fundamentals of the design should be discussed in the open (see the current Bitcoin debate over raising the block size limit). No, the hard limit has been 1 megabyte forever. But 500K was the largest block Satoshi's code could possibly build (I believe that that wasn't even possible in practice, because you'd have to spend all 21 million bitcoins in fees to fill it to 500K). A couple of minor clarifications:There has always been an artificial block size limit; Satoshi's code exponentially increased required transaction fees required to get into a block as the block filled up from 250K to an absolute-maximum 500K. There are almost certainly still miners running with that algorithm; their effective maximum block size is a little more than 250K.Also, solo/p2p miners and pool operators running a recent version of bitcoind can very easily change the maximum block size; it is a command-line / bitcoin.conf setting. They don't need to use different software. Bitcoin-Qt version 0.8.0 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.0/This is a major release designed to improve performance and handle theincreasing volume of transactions on the network.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).The first time you run after the upgrade a re-indexing process will bestarted that will take anywhere from 30 minutes to several hours,depending on the speed of your machine.Incompatible Changes--------------------This release no longer maintains a full index of historical transaction idsby default, so looking up an arbitrary transaction using the getrawtransactionRPC call will not work. If you need that functionality, you must run oncewith -txindex=1 -reindex=1 to rebuild block-chain indices (see below for moredetails).Improvements------------Mac and Windows binaries are signed with certificates owned by the BitcoinFoundation, to be compatible with the new security features in OSX 10.8 andWindows 8.LevelDB, a fast, open-source, non-relational database from Google, isnow used to store transaction and block indices.  LevelDB works much betteron machines with slow I/O and is faster in general. Berkeley DB is now onlyused for the wallet.dat file (public and private wallet keys and transactionsrelevant to you).Pieter Wuille implemented many optimizations to the way transactions areverified, so a running, synchronized node uses less working memory and doesmuch less I/O. He also implemented parallel signature checking, so if youhave a multi-CPU machine all CPUs will be used to verify transactions.New Features------------"Bloom filter" support in the network protocol for sending only relevant transactions tolightweight clients.contrib/verifysfbinaries is a shell-script to verify that the binary downloadsat sourceforge have not been tampered with. If you are able, you can help makeeverybody's downloads more secure by running this occasionally to check PGPsignatures against download file checksums.contrib/spendfrom is a python-language command-line utility that demonstrateshow to use the "raw transactions" JSON-RPC api to send coins received from particularaddresses (also known as "coin control").New/changed settings (command-line or bitcoin.conf file)--------------------------------------------------------dbcache : controls LevelDB memory usage.par : controls how many threads to use to validate transactions. Defaults to the numberof CPUs on your machine, use -par=1 to limit to a single CPU.txindex : maintains an extra index of old, spent transaction ids so they will be foundby the getrawtransaction JSON-RPC method.reindex : rebuild block and transaction indices from the downloaded block data.New JSON-RPC API Features-------------------------lockunspent / listlockunspent allow locking transaction outputs for a period of time sothey will not be spent by other processes that might be accessing the same wallet.addnode / getaddednodeinfo methods, to connect to specific peers without restarting.importprivkey now takes an optional boolean parameter (default true) to control whetheror not to rescan the blockchain for transactions after importing a new private key.Important Bug Fixes-------------------Privacy leak: the position of the "change" output in most transactions was not beingproperly randomized, making network analysis of the transaction graph to identifyusers' wallets easier. Zero-confirmation transaction vulnerability: accepting zero-confirmation transactions(transactions that have not yet been included in a block) from somebody you do nottrust is still not recommended, because there will always be ways for attackers todouble-spend zero-confirmation transactions. However, this release includes a bugfix that makes it a little bit more difficult for attackers to double-spend acertain type ("lockTime in the future") of zero-confirmation transaction.Dependency Changes------------------Qt 4.8.3 (compiling against older versions of Qt 4 should continue to work)Thanks to everybody who contributed to this release:----------------------------------------------------Alexander KjeldaasAndrey AlekseenkoArnav SinghChristian von RoquesEric LombrozoForrest VoightGavin AndresenGregory MaxwellJeff GarzikLuke DashjrMatt CoralloMike CassanoMike HearnPeter ToddPhilip KaufmannPieter WuilleRichard SchwabRobert BackhausRune K. SvendsenSergio Demian LernerWladimir J. van der Laanburger2defaultfanquakegrimd34thjustmoonredshark1802tucenaberxanatos I think casual users should avoid the Satoshi client. Gigabytes of blockchain data is not user-friendly, and we've done a lousy job of making it hard for users to lose their keys.I think the something like the blockchain.info web wallet or Electrum is a good choice for long-term storage; you keep control over your private keys, and are exposed to possible theft risk only when you make a transaction (because a hacked blockchain.info could feed you evil Javascript, or a hacked Electrum download server could feed you an evil executable).  The chances that you will be one of the first customers who make a transaction after they were hacked, before they took their site offline to recover from the hack, are pretty small if you are only making a couple of transactions per month.I'm also assuming that a casual user isn't storing thousands of bitcoins. I don't think we have great solutions for casual users with thousands of bitcoins yet (I consider paper wallets a fair solution, not a great one). The changes in the last year were "soft forks" -- forks that required all miners to upgrade (if they don't, their blocks are ignored), but that do not require merchants/users to upgrade.-------A couple of random, half-baked thoughts I had this morning:If you think that the block size should stay at 1 megabyte forever, then you're saying the network will never support more than 7 transactions per second, and each transaction will need to be for a fairly large number of bitcoins (otherwise transaction fees will eat up the value of the transaction).If transactions are all pretty big, why the heck do we have 8 decimal places for the transaction amount?Don't get me wrong, I still think the bitcoin network is the wrong solution for sub-US-penny payments. But I see no reason why it can't continue to work well for small-amount (between a US $1 and $0.01) payments.If there are a very limited number of transactions per day and billions of dollars worth of BTC being transacted (that's what we all want, yes?) then obviously each transaction must be large. So, again, why bother having 8 digits after the decimal point if each transaction is hundreds of bitcoins big?------Second half-baked thought:One reasonable concern is that if there is no "block size pressure" transaction fees will not be high enough to pay for sufficient mining.Here's an idea: Reject blocks larger than 1 megabyte that do not include a total reward (subsidy+fees) of at least 50 BTC per megabyte."But miners can just include a never broadcast, fee-only transactions to jack up the fees in the block!"Yes... but if their block gets orphaned then they'll lose those "fake fees" to another miner. I would guess that the incentive to try to push low-bandwidth/CPU miners out of the network would be overwhelmed by the disincentive of losing lots of BTC if you got orphaned. RE: lots of code to write if you can't keep up with transaction volume:  sure.  So?I really don't understand this logic.Yes, it is a fact of life that if you have a system where people are competing, the people who are less efficient will be driven out of business. So there will be fewer people in that business.You seem to be saying that we should subsidize inefficient miners by limiting the block size, therefore driving up fees and making users pay for their inefficiency.All in the name of vague worries about "too much centralization." Half-baked thoughts on the O(N) problem:So, we've got O(T) transactions that have to get verified.And, right now, we've got O(P) full nodes on the network that verify every single transaction.So, we get N verifications, where N = T*P.The observation is that if both T and P increase at the same rate, that formula is O(N^2).... and at this point your (and gmaxwell's) imagination seems to run out, and you throw up your hands and say "We Must Limit Either T or P."Really?If we have 20,000 full nodes on the network, do we really need every transaction to be verified 20,000 separate times?I think as T and P increase it'd be OK if full nodes with limited CPU power or bandwidth decide to only fetch and validate a random subset of transactions. So...  I start from "more transactions == more success"I strongly feel that we shouldn't aim for Bitcoin topping out as a "high power money" system that can process only 7 transactions per second.I agree with Stephen Pair-- THAT would be a highly centralized system.Oh, sure, mining might be decentralized.  But who cares if you either have to be a gazillionaire to participate directly on the network as an ordinary transaction-creating customer, or have to have your transactions processed via some centralized, trusted, off-the-chain transaction processing service?So, as I've said before:  we're running up against the artificial 250K block size limit now, I would like to see what happens. There are lots of moving pieces here, so I don't think ANYBODY really knows what will happen (maybe miners will collectively decide to keep the block size low, so they get more fees.  Maybe they will max it out to force out miners on slow networks.  Maybe they will keep it small so their blocks relay through slow connections faster (maybe there will be a significant fraction of mining power listening for new blocks behind tor, but blasting out new blocks not via tor)).I think we should put users first. What do users want? They want low transaction fees and fast confirmations. Lets design for that case, because THE USERS are who ultimately give Bitcoin value.
Why do people include transaction fees?Assuming the miner hasn't tweaked the reference code's parameters, the rules are:Create at most a 250,000 byte block:+ 27 kilobytes of space is set aside for the highest-priority transactions, regardless of fee.+ 223k of space left for fee-paying transactions.Transactions with a small number of inputs/outputs, transferring a large number of bitcoins, that weren't recently received are the highest priority and are included first.If you send a low-priority transaction without a fee you can end up waiting a very long time for it to get confirmed (and it may never be confirmed).Why do miners include free transactions?Either they're too lazy to change the default rules, or they believe that allowing free, high-priority transactions will help make Bitcoin more popular and will, therefore, increase the value of their coins.Why is there any incentive to pay fees at all?You'll notice that pretty much every block nowadays is bigger than 27k, so there IS competition for that free space. But if you've got 10 bitcoins that have been sitting in your wallet for a week or three, you'll still have no problem spending them without a fee (they'll have a much higher priority than somebody playing SatoshiDice 100 times a day). I hereby encourage everybody to use tor.But I think worrying about thugs getting your street address from your Internet service provider and then breaking into your house to try to coerce you into giving them your Bitcoins seems very unlikely. The windows setup.exe is signed, as is the Mac .app bundle. The executables inside them are not signed (I can't think of a good reason to sign them, it would not increase download security at all).You can also still check the download packages using the SHASUMS.asc file, which is signed with my gpg key.And if you are running Linux or Windows you could check all of the files in the installer against other core developer's keys.If the code signing certificate was revoked then we would go back to just using gpg keys. The code signing certificate is great because Windows and OSX know how to check it automatically when the download happens. The crash-on-exit bug could be this issue:  https://github.com/bitcoin/bitcoin/issues/2204We may have to live with it for the 0.8 release, and fix it in the next release, because there is a high risk that fixing it will cause more problems than it solves. Bitcoin version 0.8.0 release candidate 1 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.0/testThis is a major release designed to improve performance and handle theincreasing volume of transactions on the network.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesRelease-candidate 1 notes:The OSX binary reports its version as "0.8.0rc1-1-gba1d080-beta" due toissue https://github.com/bitcoin/bitcoin/issues/2285 . This will be fixedbefore the final 0.8.0 release.The Windows binaries could not be reproducibly built, due to issuehttps://github.com/bitcoin/bitcoin/issues/2288 . This will also be fixedbefore the final 0.8.0 release. The rc1 Windows binaries were builtby me (Gavin).How to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoin-qt (on Linux).The first time you run after the upgrade a re-indexing process will bestarted that will take anywhere from 30 minutes to several hours,depending on the speed of your machine. If you have enoughmemory, running with the -dbcache setting (e.g. -dbcache=1000 )may make re-indexing faster.Special notes for release candidate 1:--------------------------------------If you helped test pre-release versions, there are two changes that youshould be aware of:1. Subdirectories in the data directory changed names; to avoid re-indexingthe blockchain, rename:  mkdir $DATADIR/blocks && mv $DATADIR/blktree $DATADIR/blocks/index  mv $DATADIR/coins $DATADIR/chainstate2. The "undo file" format changed; if you see errors at startup during blockvalidation re-run with the -reindex flag to fix them.Incompatible Changes--------------------This release no longer maintains a full index of historical transaction idsby default, so looking up an arbitrary transaction using the getrawtransactionRPC call will not work. If you need that functionality, you must run oncewith -txindex=1 -reindex=1 to rebuild block-chain indices (see below for moredetails).Improvements------------Mac and Windows binaries are signed with certificates owned by the BitcoinFoundation, to be compatible with the new security features in OSX 10.8 andWindows 8.LevelDB, a fast, open-source, non-relational database from Google, isnow used to store transaction and block indices.  LevelDB works much betteron machines with slow I/O and is faster in general. Berkeley DB is now onlyused for the wallet.dat file (public and private wallet keys and transactionsrelevant to you).Pieter Wuille implemented many optimizations to the way transactions areverified, so a running, synchronized node uses much less memory and doesmuch less I/O. He also implemented parallel signature checking, so if youhave a multi-CPU machine all CPUs will be used to verify transactions.New Features------------"Bloom filter" support in the network protocol for sending only relevant transactions tolightweight clients.contrib/verifysfbinaries is a shell-script to verify that the binary downloadsat sourceforge have not been tampered with. If you are able, you can help makeeverybody's downloads more secure by running this occasionally to check PGPsignatures against download file checksums.contrib/spendfrom is a python-language command-line utility that demonstrateshow to use the "raw transactions" JSON-RPC api to send coins received from particularaddresses (also known as "coin control").New/changed settings (command-line or bitcoin.conf file)--------------------------------------------------------dbcache : now controls LevelDB memory usage. Running with (for example) -dbcache=1000will use a gigabyte of memory and might make the initial blockchain download faster.par : controls how many threads to use to validate transactions. Defaults to the numberof CPUs on your machine, use -par=1 to limit to a single CPU.txindex : maintains an extra index of old, spent transaction ids so they will be foundby the getrawtransaction JSON-RPC method.reindex : rebuild block and transaction indices from the downloaded block data.New JSON-RPC API Features-------------------------lockunspent / listlockunspent allow locking transaction outputs for a period of time sothey will not be spent by other processes that might be accessing the same wallet.addnode / getaddednodeinfo methods, to connect to specific peers without restarting.importprivkey now takes an optional boolean parameter (default true) to control whetheror not to rescan the blockchain for transactions after importing a new private key.Important Bug Fixes-------------------Privacy leak: the position of the "change" output in most transactions was not beingproperly randomized, making network analysis of the transaction graph to identifyusers' wallets easier. Zero-confirmation transaction vulnerability: accepting zero-confirmation transactions(transactions that have not yet been included in a block) from somebody you do nottrust is still not recommended, because there will always be ways for attackers todouble-spend zero-confirmation transactions. However, this release includes a bugfix that makes it a little bit more difficult for attackers to double-spend acertain type ("lockTime in the future") of zero-confirmation transaction.Dependency Changes------------------Qt 4.8.3 (compiling against older versions of Qt 4 should continue to work)Thanks to everybody who contributed to this release:----------------------------------------------------Alexander KjeldaasAndrey AlekseenkoArnav SinghChristian von RoquesEric LombrozoForrest VoightGavin AndresenGregory MaxwellJeff GarzikLuke DashjrMatt CoralloMike CassanoMike HearnPeter ToddPhilip KaufmannPieter WuilleRichard SchwabRobert BackhausRune K. SvendsenSergio Demian LernerWladimir J. van der Laanburger2defaultfanquakegrimd34thjustmoonredshark1802tucenaberxanatos The magic of public key crypto is that you can give somebody your public key, some data, and a signature, and they can be certain that:a) that particular signature could only have been created by somebody that has the private key that corresponds to the public keyb) the data hasn't been changed in any wayThey don't need to know the private key-- you keep it secret.The "hash over..." bit is the way digital signatures work-- you sign a hash of the data, and not the data itself, because the hash is much smaller.The "...simplified version of the transaction" bit is complicated. The data signed is the transaction minus all it's scriptSig signatures, plus (almost always) the previous transaction's scriptPubKey. See the OP_CHECKSIG page on the wiki for all the gory details. Got a fantastic idea for a project, but need some BTC to make it happen?Apply for a grant from the Bitcoin Foundation:  https://bitcoinfoundation.org/blog/?p=58Deadline is February 15'th.Good grant proposals are for things that are clearly a benefit to the whole Bitcoin ecosystem and that are the kind of "common good" thing that doesn't have a clear business plan.  (if you have an idea with a clear business plan then you should talk to an angel investor or venture capitalist to get some funding).Examples (I'm sure you can think of better):I'd love to see somebody run a free input-mixing service. A grant could cover server costs to run a server that takes connections over tor to coordinate mixes.Know any economists? A grant could pay to write some tools to extra bitcoin transaction data for an enterprising economist who might want to study the Bitcoin economy.There have been some very interesting research papers suggesting possible changes to core Bitcoin. A grant might pay for somebody to actually implement the ideas and demonstrate them on the -testnet. I'm of the opinion that bitcoind/Bitcoin-Qt shouldn't be pushed to the central/canonical repos until we hit version 1.0.Until then, I think we change too much too often (e.g. the blockchain format completely changed in the 0.8 release, and the wallet format will likely be changed before we hit version 1.0). The payment protocol (or a simple extension of it) is intended to be that more-flexible, standardized protocol.Excellent! I think this is exactly the right thing to do.There is still the question of what the default behavior should be. Here is a proposal:Ignore blocks that take your node longer than N seconds to verify.I'd propose that N be:  60 seconds if you are catching up with the blockchain.  5 seconds if you are all caught-up.  But allow miners/merchants/users to easily change those defaults.Rationale: we should use time-to-verify as the metric, because everything revolves around the 10-minutes-per-block constant.Time-to-verify has the nice property of scaling as hardware gets more powerful. Miners will want to create blocks that take a reasonable amount of time to propagate through the network and verify, and will have to weigh "add more transactions to blocks" versus "if I add too many, my block will be ignored by more than half the network."Time-to-verify also has the nice property of incentivizing miners to broadcast transactions instead of 'hoarding' them, because transactions that are broadcast before they are in a block make the block faster to verify (because of the signature cache). That is good for lots of reasons (early detection of potential double-spends and spreading out the verification work over time so there isn't a blizzard of CPU work that needs to be done every time a block is found, for example). Ummm, see this old forum thread, where Satoshi says: Yeah-- "democratic" is such a loaded word. Everybody loves democracy, so I didn't want to bash it.But democracy can be terrible if you're in the minority and the majority decides to trample on your rights.I probably should have just said "Bitcoin is a lot more democratic than the system we currently have, where a handful of unelected central bankers control our money." For the record:I'm on the "let there be no fixed maximum block size" side of the debate right now.I think we should let miners decide on the maximum size of blocks that they'll build on. I'd like to see somebody come up with a model for time-to-transmit-and-receive-and-validate-a-block versus increased-chance-that-block-will-be-an-orphan.Because that is the tradeoff that will keep miners from producing 1 Terabyte blocks (or, at least, would keep them from producing 1 Terabyte blocks right now-- if we have petabyte thumb-drives and Terabyte/second networks in 10 years maybe 1Terabyte blocks will be just fine).Right now, miners that use the reference implementation and don't change any settings will produce blocks no larger than 250Kbytes big.So we're finding out right now how miners collectively react to bumping up against a block size limit. I'd like to let that experiment run for at least a few months before arguing that we do or do not need to eliminate the 1MB hard limit, and start arguing about what the default rules for acceptable block size should be. Sergio:It would be more helpful if you either took a little bit more time and actually wrote a little bit of code to make sure the attack works, and started the conversation privately with "here's code that demonstrates a very expensive-to-verify transaction and a few suggestions on how you might fix it..."I created a simulation of TxPrep/TxAttack by adding them to src/test/data/script_valid.json and then running through the script_tests.cpp unit test in the debugger, and with the particular TxPrep you propose there is no problem with current code.Also, TxAttack is not standard with the latest code; see CTransaction::AreInputsStandard(), which checks the scriptPubKeys being spent.RE:  undocumented process of responsible disclosing :  good point.  Where would you expect to find the process documented?  We can fix that... Starting now! http://bitcoin.stackexchange.com/questions/5664/will-general-non-standard-transactions-ever-be-allowed Thanks Sergio!So:  if the attacker creates a block with a transaction that takes 3 minutes to verify, and then broadcasts it, it will take a very long time for it to propagate across the network (because peers verify blocks before relaying them).And since this attack requires non-standard transactions, mining a block is the only way an attacker will be able to pull off this attack. So I don't think this is a practical attack on the production network: by the time the 3-minute-to-verify block got to 50% of the network the other half of the network will probably have produced a block (sure, the attacker could try to Sybil the network and send its block to a super-majority of mining nodes, but I bet all of the big mining pools are hiding their block-creating and share-accepting nodes behind multiple "front-end bitcoinds" by now to mitigate DDoS attacks).Fixing the OP_*SIG opcodes so they "look before they hash" is a good idea. We're actually moving towards that; see fStrictEncodings and the IsCanonicalSignature/IsCanonicalPubKey in the latest script.cpp code. The intent is to eventually roll out a 'soft-fork' that requires signatures and public keys be well-formed and canonical.Also, a nit: using OP_0 for the scriptSig wouldn't work for this attack (see if (vchSig.empty()) return false; in CheckSig()). Okey dokey, first I think nobody should use an easy-to-memorize brainwallet for anything more than experimenting. I predict we'll start seeing very unhappy brainwallet users reporting huge losses sooner or later.Second: the 'sentinel wallet' idea is all about incentives.You need to put enough BTC in the sentinel wallet so it is economically rational for an attacker to "take the money and run" rather than spend time and money trying to crack a bigger brainwallet that might not even exist.Again, I don't think you should use a brainwallet, so I'm not motivated to do the math to figure out how many BTC you should put into the sentinel wallet so a ration attacker will just take it, but that is the way you should think about it. Run a testnet node and turn on CPU mining. We need more stable, long-running -testnet nodes. I don't think anybody knows. But you can find out:Send a token amount of bitcoin to two more brainwallets, made from each of the sentences.When somebody else either spends those bitcoins or sends more bitcoins to them, you know that your main brainwallet isn't safe any more.  (are the services that will send you an email when there is activity on a bitcoin address still around?)
I'd just point them to http://www.timemarker.org/ .... another random thought:  I wouldn't be surprised if you could get tricky with nonces to get any https-enabled web server to act as a free timestamping service, too... Is there a lot of demand for timestamping? Are people willing to pay for it?There are already free, centralized services that will timestamp arbitrary hashes for you. Besides the risk that they might go away (which you could mitigate by getting timstamps from several of them), is there any real advantage to using the blockchain?If I can already get timestamps for free, why would I bother to pay a transaction fee to get a blockchain timestamp?I'm often wrong, so feel free to ignore me, but blockchain timestamping seems to me like one of those gee-whiz ideas that appeals to us techies but isn't "enough better" than existing solutions to be interesting to non-techies. Because it is critical that YOUR passphrase be different from EVERYBODY ELSE'S passphrase.Adding your email address or driver's license number or some other certainly-unique-for-you information makes that work.That shifts the problem from "attacker is trying to guess EVERYBODY's passphrase" to "attacker happens to know that you have a bunch of BTC in a brainwallet and is trying to attack YOUR brainwallet, specifically."Nicely said.Again: we are really bad at thinking up good, unique passphrases. We share so much experience and culture that whatever you think of, somebody else will probably think of, too.  Or some attacker will think of something similar enough to crack your passphrase.And we are really bad at imaging what it means that an attacker might try a few hundred BILLION passphrases to try to crack everybody's brainwallet. Humans are pretty bad at being original. REALLY bad at being random. And we are terrible at comprehending huge numbers.So if you ask the average person to create a secure passphrase, they're very likely to create something that a "determined attacker" with a lot of computing power can crack.I think if people start to use quotes from obscure literary works as their brain wallets, then they're going to lose their bitcoins sooner or later. Attackers can try MILLIONS of passphrases per minute, to crack EVERY SINGLE brainwallet that has ever been created.So: if you absolutely, positively won't be dissuaded from using a brainwallet, here is my advice on how you might be able to come up with a secure passphrase:Think of two passphrases that you think you can remember. And think of a government-issued number that you can easily lookup or remember (like your driving license or social security number).Create a brainwallet passphrase that is:the first passphrase,the government id number,the second passphraseThen create a 'sentinel' brainwallet that is just the first passphrase, and send a small number of bitcoins to it. When those bitcoins get spent (or more bitcoins are sent to it by somebody else), you know that the first passphrase you chose isn't good enough any more.  Choose a more complicated passphrase and create a new 'sentinel' and real brainwallet, and move your old brainwallet there. The reference implementation patch is scheduled for the (real soon now!) 0.8 release:  https://github.com/bitcoin/bitcoin/pull/2223 No. It is perfectly possible for multiple people to provide inputs to a transaction, each signing their input but without knowledge of the other people's keys.That is extremely rare now, but that is exactly what you would do to implement a peer-to-peer coin-mixing service, which I suspect may be a very popular way of paying for things since it increases your privacy significantly. 20.11 It is very high on the priority list, yes. Miners already support it, but there are still a couple of steps to go before you can create a wallet split between Bitcoin-Qt running on your desktop computer and an app running on your iPhone. I think Dev&Tech == generic technical discussion, then sub-forums for discussion of development of the popular clients makes sense (including 'Reference Client (Bitcoin-Qt/bitcoind)' ).  And a catch-all for any not-yet-popular (or used-to-be-popular) clients. "sort of expensive" ?  Really expensive and getting more expensive all the time.  And absolutely impossible for a lightweight hardware or mobile-phone wallet, which I think a lot of people will use as their second-factor device. RE: what's my role in the core team:  I try to do whatever needs to get done, that isn't getting done.  Today I'm cross-compiling the 0.8 release and testing it on Windows, trying to track down a crash-at-exit issue and an excessive-memory-use issue that seems to only happen on Windows.When I'm not doing nitty-gritty things like that, I try to work on big, what-is-most-likely-to-make-Bitcoin-succeed problems.RE: why pay me a salary?  "why pay for the cow if you can get the milk for free?"I told myself (and my wife) a couple of years ago that I wasn't going to sink dollars into Bitcoin-- that I'd sink time into it, and that I'd EARN bitcoins by starting a bitcoin-related startup.Well, there's enough core development work to keep me busy full time. I wasn't very happy doing core development work AND trying to make ClearCoin happen; I'm happier when I can concentrate on one thing.  Besides, having my own startup introduces potential conflicts of interest (ClearCoin sparked conspiracy theories about why I push for multisig transactions so hard).RE: what if I get hit by a bus?Then the other core developers will carry on without me. I'm not indispensable.RE: Why should you join the Foundation?  What is in it for you, personally?That is a hard question, because you can "free ride" -- if we're successful making Bitcoin successful, everybody will benefit. Personally, I don't respect people with that kind of "I'm not going to do it because I'm sure somebody else will" attitude, and I think in the long run the people who take the risks and roll up their sleeves and do the work needed tend to win in the end.Really, the main benefit of joining the Foundation is it is an organization full of people who are rolling up their sleeves and doing the work. If you're smart, you'll realize that networking with those types of people is to your long-term benefit. I started working through a GUI design for secure multi-device wallets a couple months ago:  https://moqups.com/gavinandresen/no8mzUDB/p:afbbfb850But to be secure, I think we need the payment protocol first, because otherwise an attacker can simply replace the bitcoin address given to the first device and trick you into paying them. ... and because bitcoind's wallet code hasn't been optimized for massive wallets.  "patches welcome"(although I think the wallet code needs a complete rewrite, we've learned a lot over the last couple of years and need wallets that are much easier to back up and keep secure). But a transaction with a 0.005 BTC output triggers this rule:Code:// To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01... so you're back to paying 10kilobytes * 0.0005 BTC / kilobyte == 0.005 BTC to spend those 0.005 BTC.Yes, if you have a large-value, well-aged input then you can combine it with tiny transactions, have a single output greater than 0.01 BTC, and probably get into a block for free.If you want to prototype a smarter coin-selection algorithm, you might start with the 'spendfrom.py' code I wrote as an example of using the raw transactions API:  https://github.com/bitcoin/bitcoin/pull/2162 With the current transaction fee rules, inputs of less than about 0.00005 BTC will cost more to spend than they are worth.(somebody check my arithmetic, I'm good at dropping digits:  MIN_TX_FEE is 0.0005 BTC per kilobyte, an extra input is a signature+pubkey+a few extra bytes = 100 bytes, so minimum fee per input is about 0.00005 BTC)Wallet software should probably display micro-inputs as zero to the user (they really are worthless right now, since they cost more to spend than they are worth) and ignore them when computing the wallet balance or getting inputs to spend. Oops, sorry, update the github page, all the bounties are claimed.Thanks to everybody who tested, you were extremely helpful.What did you think about the bounty amounts:  too much?  too little?  just right? Let me google that for you.... ah, here's a nice chart:  http://dollardaze.org/blog/?post_idThere is about 5 trillion dollars in currency in the world.So 2.1 thousand trillion satoshis is PLENTY. Successful technology companies do not waste their time solving problems that they THINK they MIGHT have in 20 years.They don't even spend much time thinking about problems that they might have in four years.I don't spend any time worrying about the strength of 256-bit ECDSA or 160-bit RIPEMD, and I spend even less time worrying about the strength of those two combined. The only completely and utterly decentralized bitcoin-like system I can think of would have every person using it write and run their own code.On computers that they built themselves.Communicating over a wireless mesh network where each node in the mesh was controlled by a single person who wrote all the code and built all the hardware....
While we ponder this, if you are worried about this, there is a fairly straightforward workaround that will make you immune from this.Run two bitcoin daemons.  One that is a full peer in the network, but has an empty, never-used wallet.And another with a full wallet that connects to the full peer. You could even run them both on the same machine (you'll use double the CPU and disk space, unfortunately).RE: "I better alert people before they can be tracked" :Dan Kaminsky demonstrated that it is pretty easy to tie bitcoin addresses to IP addresses by watching the network last year. If you are worried about being tracked, you should be running bitcoin over Tor and connecting to only trusted nodes. We make no anonymity guarantees. correction: bitcoin-qt/bitcoind command-line arguments have a single-dash, so it would be  bitcoin-qt -serverSince you have to set a rpcuser/rpcpassword in the bitcoin.conf file for -server to work anyway, you might want to put "server=1" in the bitcoin.conf file instead of using the command-line argument... Dunno why github says 'authored 6 days ago', commit 2e922 was pushed yesterday and definitely has the changes (see lines 107-108 of spendfrom.py). Thanks for helping test!  Latest version fixes the p2sh issue.I had it 4-decimal-places because I personally don't care about less than 0.0001 BTC right now. It is 8 now, just because I know you won't be the last person to ask "why does it round."If there are python command-line-tool packaging experts, suggestions on how to package this better are welcome.  I thought all versions of jsonrpc had a ServiceProxy class, but I guess I'm wrong. I think you're right, 0.3.24 does not support -logtimestamps. If I recall correctly, it does log the time at startup; for this particular test, I'm mostly interested in how long the upgrade process takes, so the old version not supporting timestamps isn't a problem. There are three 0.5 BTC bounties available for people who will help us test the upgrade-to-release-0.8 code.I'm looking for:CLAIMED: Somebody running (or willing to install and sync-up) bitcoind/bitcoin-qt version 0.3.24(need to test upgrading from a very old version of Bitcoin)CLAIMED: Somebody running a version of Windows with their bitcoin data directory on a FAT32 filesystem(need to test upgrading on a very old filesystem)CLAIMED: Somebody running Windows XP with an NTFS filesystem(need to test upgrading on a very old operating system)Detailed instructions on how to test and then claim a bounty are here:  https://github.com/gavinandresen/QA/blob/master/HardLinksUpgrade.md Yes, please do a proof-of-concept on testnet.I suspect this code in CTransaction::GetMinFee() makes the attacks either slower or more expensive than you estimate because fees increase for transactions larger than 250Kbytes:Code:    // Raise the price as the block approaches full                                                                                                  if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)    {        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)            return MAX_MONEY;        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);    }I don't think these vulnerabilities are serious enough to warrant Official CVE Numbers, because I think if we create CVE numbers for every expensive-to-mount, easy-to-recover-from DoS vulnerability we will be denial-of-service-ing the attention span of users, and they might start ignoring warnings. If you've got easy_install (does OSX 10.6 comes with easy_install ?), then try:    easy_install jsonrpcOr grab jgarzik's version from github:   https://github.com/jgarzik/python-bitcoinrpc If you're interested in coin control, and you're comfortable with python and the command-line, then I could use your help.I've written a little utility called 'spendfrom.py' that uses the raw transactions JSON-RPC api to send coins received on particular addresses that I'd like to ship in the contrib/ directory.But since it touches the wallet it needs thorough testing.I've written a test plan; who is willing to run through the test plan with their -testnet wallet and then try to break it?Test plan:  https://github.com/gavinandresen/QA/blob/master/SpendFrom.mdCode:  https://github.com/gavinandresen/bitcoin-git/tree/spendfrom/contrib/spendfrom As was pointed out, getrawtransaction <txid> 1    will do the decode for you.If your JSON-RPC library supports it, you could also use a 'batch' request to get all of the inputs in one round-trip. See http://www.jsonrpc.org/specification#batch It wouldn't be hard to prototype a coin mixer using the raw transactions API and a centralized web service (accessible via Tor, if you're worried about it recording your IP address).If you want to do a really good job, though, you'll need:  + Lots of people participating and/or  + Lots of time so your mixes are spread out over timeThe 'lots of people' will take time, because the mixing code needs very high trust since it'll be spending your coins.The 'lots of time' might be a practical problem, because the mixer needs your wallet to be unlocked so it can sign mixing transactions.Somebody should create a working prototype and then for a Bitcoin Foundation grant to fund the web service for a year... So is there a banking term for an account that requires multiple authorizations for spending?I ain't never been a CFO or an accountant, so I don't know nuthin about that stuff... I completely agree that more documentation is better, as long as you don't fall into the trap of "if the documentation says it it MUST be true."Suggestions on how to make the wiki better welcome (there is a discussion elsewhere about banning certain people from the wiki because they have a history of starting edit wars, which I would support, and discussion on the Foundation forums about making the wiki infrastructure independend of Mt. Gox, which I also support). Or volunteers to move technical documentation from the wiki to someplace better also welcome. Because people like you noticed that it isn't quite right, but didn't bother to change it? RE: "multisig transactions" :I did some high-level multisig design work a couple of months ago:  https://gist.github.com/4039433and  https://moqups.com/gavinandresen/no8mzUDB/... and had these thoughts about terminology: Yes, those instructions should work, but build-osx.txt tells you how to build bitcoind.  See  https://github.com/bitcoin/bitcoin/blob/master/doc/readme-qt.rst... for very similar instructions on building Bitcoin-Qtreadme-qt.rst suggests downloading and installing the `Qt Mac OS X SDK` from the QT website, but you can also:  port install qt4-macIf something doesn't work, post here, or, even better, submit a patch for the documentation. theymos is correct; if all the inputs have a UINT_MAX sequence number then lockTime is ignored.Yes, they're supported by the network.No, there is no easy way to create such a transaction using the reference code.* Super-duper-bitcoin-ninjas like gmaxwell who edit raw transaction hex to set lock times / sequence numbers don't count. In my experience, developers are really good at either ignoring documentation or interpreting it in a way different than the way the author intended.And spec authors are really good at getting details wrong, no matter how careful they are. And they're really bad at keeping track of changes.That's why I spent a lot of time over the past year developing test cases and tools that you can run your code against instead of writing specs.I may just be cynical because I spent so much time in 1997 working on the ISO/IEC-14772-1 Official, Formal Standard. That is ascii for 'script' -- and was an unfortunate bug in somebody's software, if I recall correctly.Excellent! The first step to bitcoin development enlightenment is realizing that you are a part of the process... So... maybe https://en.bitcoin.it/wiki/Tonal_Bitcoin  needs some editing in the same spirit that he's editing other pages... (darn, nanotube protected it...)(ps to nanotube: that page should be deleted, in my humble opinion)
Seems to me account credentials are a kind of intangible property, and selling stolen property is illegal and shouldn't be allowed in the forums.I am not a lawyer, so that might not actually be true.  But it seems to me that's the way the law should be, and the right thing to do. How will you know if people tend to pick the same types of events, and, therefore, create big non-random clusters of choices that might be easily brute-forced?Taking an idea from https://gist.github.com/3840286....... you could store a small number of bitcoin at private key = SHA256(memory_key), store the bulk of bitcoin at scrypt(Name+PIN+memory_key), and tell users to choose a new memory key if the SHA256(memory_key) coins are either ever spent or if that key ever gets funds from somebody else.Because that means somebody else chose the same memory key. The bitcoind sendmany RPC call uses destination addresses as JSON Object keys, so you can't send to the same address multiple times in one transaction.If you REALLY want to do that... first, why do you want to do that? I suppose if you want to use the blockchain as a messaging system then sending 0.123+0.567+etc might be an inefficient way of sending a message... but please don't do that.Anyway, if you do REALLY want to do that, you'll have to write code to construct the transaction yourself. Then you could pass it to the signrawtransaction/sendrawtransaction RPC methods to broadcast it.  (you can't use createrawtransaction to create it, because it uses the same JSON syntax as sendmany for destination outputs). Planet Money has done some great podcasts on dollar coins. Start here:  http://www.npr.org/blogs/money/2012/04/20/151052399/cage-match-coin-vs-bill There is a longstanding issue that might be related:  https://github.com/bitcoin/bitcoin/issues/172 I sent ShadowOfHarbringer's some of my thoughts on this in this private message:I don't worry much right now about economically irrational, "I'm going to spend millions of dollars to disrupt the bitcoin network" attacks because I don't think anybody is going to spend millions of dollars to disrupt our tiny payment network. I have no idea what bitcoin payments will look like in 5-10 years; I expect all sorts of trust mechanisms and relationships to develop that are independent of the bitcoin network, and I suspect some of those will make 51% attacks irrelevant.And I have no idea what the mining landscape will look like in 5-10 years; if thousands of companies around the world are installing bitcoin mining hardware for free in every house built in cold climates (generate bitcoins and get a discount on your heating bill) then it may be completely inconceivable for even a government to amass enough hashing power to mount a 51% attack.So while I encourage y'all to keep thinking about it as an interesting theoretical problem, it is only slightly higher on my personal priority list than worrying about quantum computers breaking ECDSA. There are several smart people here who would tell you if your fix will work or not, if you listen to them.Peer review is not perfect, but is much better than assuming that you will always come up with the best solution. No fork required. The secure payment protocol stuff is all higher-level than the blockchain. Exactly.My priorities are:+ Network Security+ Network Scalability+ Network StabilityAfter those Big Three:+ Wallet SecurityUsability of the reference implementation is not on my priority list. I believe the vast majority of users will (if they aren't already) use bitcoin via a web-based service or an app on their mobile phone.RE: the bitcoin.org homepage:  I think replacing the links to Bitcoin-Qt on the hompage with just a link to the clients page is a good idea. Somebody should get the consensus to do that and submit a pull request. On one hand:  "Complexity is the enemy of security."  Several PKIs in parallel is more complex.On the other hand: "Security In Depth."  Several PKIs in parallel could be more secure. But I'd insist that ALL PKI authentications MUST be successful, otherwise you're just giving an attacker the ability to attack the least secure PKI. It would be a mistake to show users a dialog box:BUT: I think it is unlikely people will be willing deploy and keep secure multiple PKI systems, and I think the incremental security is small, so I think the right decision here is Keep It Simple, Stupid.For example, I re-ordered the fields of SignedPaymentRequest so the entire structure doesn't have to be in memory at once to be processed, which is a suggestion from somebody considering implementing the payment protocol on a very memory-constrained hardware device. There are real tradeoffs if we make this more complex. I'm liking the hack the more I think about it, too. Encoding a compressed public key (257 bits) in base32 would be 52 characters, which is comfortably less than the 63-character domain name limit.Anybody buying a multi-domain (not wildcard) certificate sometime soon? I'm curious to find out if CA's blink if you ask them to issue a certificate valid for something like BTC8df4rfkbmeopl49vvfgkjgtimb84k9gtredsxfr9fekspclen493.mydomain.com Standard disclaimer first:  I am often wrong.But I've got a nagging feeling that all of the pure Proof-Of-X (where X != Work) systems would set up a dynamic of "the rich and powerful get more rich and more powerful."The more coins you have, the more you get, as far as I can see in all of the proposed schemes (another disclaimer: I only vaguely pay attention to all of the Proof-of-X schemes, so feel free to tell me how I'm wrong). Seems to me that would end up being a destructive feedback loop, where your decentralized currency naturally gets more and more centralized over time. There are now lots of PCs for sale for Bitcoin at bitcoinstore.com. You don't HAVE to sell your bitcoins to get a PC. I'm feeling grumpy this morning, so my reaction is "good luck with that." Yes -- 0/1-confirmation double spends are certainly possible. A successful 2-confirmation double-spend would be more interesting. I would love to see if real-network experience matches the theoretical results from Meni's paper. No, that will be fixed in the 0.8 release.If you think the single-send-not-randomizing-the-change-address-bug gives you significantly less privacy... well, you're probably wrong, it is easy to cluster addresses if you have the right network analysis tools. But you can workaround the bug by adding an extra output to all of your transactions (add a new receiving address and then click the 'add recipient' button in on the Send Coins tab in Bitcoin-Qt and send some coins to yourself). I'm planning on renting a house near Cairns, Australia from June until December of next year.I'd love to be able to pay the deposit and rent in bitcoin.I think paying for international vacation rentals could be a "killer application" for Bitcoin. PGP links are on the bitcoin.org homepage; http://bitcoin.org/gavinandresen.asc  will get it.The source for the bitcoin.org homepage is at github, so you can get it from there, too:  https://github.com/bitcoin/bitcoin.org/blob/master/gavinandresen.ascIt is also stored at the MIT pgp keyserver under email 'gavinandresen@gmail.com':  http://pgp.mit.edu:11371/pks/lookup?search=gavinandresen%40gmail.com&op=index Bitcoin version 0.7.2 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.2This is a bug-fix minor release.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you were running on Linux with a version that might have been compiledwith a different version of Berkeley DB (for example, if you were using anUbuntu PPA version), then run the old version again with the -detachdbargument and shut it down; if you do not, then the new version will notbe able to read the database files and will exit with an error.Explanation of -detachdb (and the new "stop true" RPC command):The Berkeley DB database library stores data in both ".dat" and"log" files, so the database is always in a consistent state,even in case of power failure or other sudden shutdown. Theformat of the ".dat" files is portable between differentversions of Berkeley DB, but the "log" files are not-- even minorversion differences may have incompatible "log" files. The-detachdb option moves any pending changes from the "log" filesto the "blkindex.dat" file for maximum compatibility, but makesshutdown much slower. Note that the "wallet.dat" file is alwaysdetached, and versions prior to 0.6.0 detached all databasesat shutdown.Bug fixes---------* Prevent RPC 'move' from deadlocking. This was caused by trying to lock the  database twice.* Fix use-after-free problems in initialization and shutdown, the latter of  which caused Bitcoin-Qt to crash on Windows when exiting.* Correct library linking so building on Windows natively works.* Avoid a race condition and out-of-bounds read in block creation/mining code.* Improve platform compatibility quirks, including fix for 100% CPU utilization  on FreeBSD 9.* A few minor corrections to error handling, and updated translations.* OSX 10.5 supported again----------------------------------------------------Thanks to everybody who contributed to this release:AlexdansmithGavin AndresenGregory MaxwellJeff GarzikLuke DashjrPhilip KaufmannPieter WuilleWladimir J. van der Laangrimd34th What Mike said.Building a new PKI infrastructure is most definitely out of scope right now.But if somebody wants to spearhead an effort to get CAs to allow extra public keys in the certificates that they issue... that might be worthwhile.Then again, maybe not-- DNSSEC/DANE might make the CAs obsolete.
CAs will issue you multi-domain certificates for not a WHOLE lot more than a single-domain certificate, which suggests to me a possible short-term workaround/hack until DNSSEC/DANE is widely deployed.Get a certificate that is valid for these subdomains:   merchant.com   www.merchant.com   BaseBitcoinAddress.merchant.com  (e.g. 1gavinR2Y6RiHnEbf3sJBGbbKTc5t66do.merchant.com )(in X.509 speak: Subject Alternative Names)Payment requests from the merchant would include that certificate and the full public key (or script) that corresponds to 1baseBitcoinAddress.Bitcoin clients would have to notice that the merchant's SSL certificate included a bitcoin address as one of the top-level domains, and would need to reject any payment requests that didn't include the full public key/script (and would always pay to BaseBitcoinAddress*hash(payment_request) where '*" is whatever hierarchical deterministic wallet scheme we decide we like).Reasons not to do this or why it might not work:* It is a hack.* domain names are not case-sensitive (GOOGLE.com and google.com are the same); bitcoin addresses are.* The extra cost to the merchant for the multi-domain cert might not be worth the incremental security benefit; if they have good monitoring (which they should), then they should detect an attacker's intrusion within minutes and so their potential loss might be tiny.Edited, to add references to relevant standards:X.509 certificates for the Internet:http://www.rfc-editor.org/rfc/pdfrfc/rfc5280.txtSubdomain names must be less than 63 characters and start with a letter:http://www.rfc-editor.org/rfc/pdfrfc/rfc1034.txt Ay carumba, how did we not notice that for over two years?I introduced that bug with the 'sendmany' command two years ago (commit b9d1ed85). This is why programmers should not be trusted to test their own code (I probably carefully tested to make sure the change position looked random when I send to more than one destination, and never tested the degenerate send-to-one case; sigh). Disclaimer: I'm bad at predicting the future.Will governments create a crypto-currency to try to compete?The "network effect" is really important for money. Any form of money gains value as more people use it.It is possible that Bitcoin (or any future crypto-currency) will never be able to gain enough use to overcome big, existing currencies, that already enjoy huge network effects.But... the potential users for Bitcoin is greater than any national currency because Bitcoin doesn't care about arbitrary political borders. So maybe at some point in the future a distributed, borderless crypto-currency will have a bigger network effect, and will start to replace zlotny or euros or dollars.At that point, I don't think any one government would be able to compete. Other governments won't voluntarily give up the ability to control their own currency, so even if a government came out with their own crypto-currency how would they overcome the network effect and get people all over the world to use their newfangled solution?It is possible that there will be some type of worldwide government; a currency from THAT government could, I think, compete with a decentralized crypto-currency.I have no idea how likely any of this is.RE: consequences of the dollar not being the world's reserve currency any more: I'd take a look at the history of Britain. The Pound was the world's reserve currency for a long time, before being replaced by the dollar.  England seems to be doing OK, and I'm not aware of any radically huge consequences of the transition from Pounds to dollars. Wow, great paper!I like the idea of the "bill" (aka contract aka "PaymentRequest") determining the payment address, and the merchant's private bitcoin-signing key or keys being stored off their web server.I'll append some half-baked thoughts below on melding the current PaymentRequest proposal with your ideas.Using a Merkle tree to reveal (or not) parts of the bill is a nifty idea, but I think that is orthogonal to the payment protocol, and could be a generic way of encoding any document. I tend to agree with Mike, it feels like a complex solution to something that really isn't a problem right now (maybe if we ever have CyberCourts to adjudicate disputes between anonymous customers and merchants it will be useful).PS: I was amused by:Code:An implementation with bitcoin would require little effort.Writing the code should be fairly straightforward; getting everybody to agree to the dozens of details we'll need to work out will be more than a little effort.So in the PaymentRequest protocol, a SignedPaymentRequest contains a PaymentRequest that you know came from the merchant's web server (leveraging the SSL/TLS/PKI/X.509 certificate system that we all agree is the worst PKI system there is, except for all the other that have been tried):Code:SignedPaymentRequest  pki_type = "x509"  pki_data = ... certificate chain...  signature = ...  serialized_payment_request = ...PaymentRequest containing Outputs where payment will go...  etcAs your paper points out, if an attacker compromises the webserver then they can redirect bitcoins to their wallet.It would be nice if that was impossible, and your paper shows how to do that.  In the PaymentRequest scheme, one way of doing that might be:Code:SignedPaymentRequest  pki_type = "x509_homomorphic"  pki_data = ... certificate chain...  signature = ...  serialized_payment_request = ...PaymentRequest containing no Outputs...  etcThe merchant's certificate in the certificate chain would have to contain their base bitcoin public key (or as you point out in the paper, generalized to a "base script"). I think that could be done using an X.509 extended attribute (anybody know if certificate authorities will sign certificates that contain non-standard extensions?).The customer would hash the serialized_payment_request, combine it with the base key/script, and pay to that address/script.The TODO list for implementing the simpler "x509" payment requests is fairly long (help appreciated by the way, see https://github.com/gavinandresen/paymentrequest/blob/master/TODO.txt ); implementing "x509_homomorphic" would make it even longer. I think we need to implement the simpler protocol first, because I think small merchants will want to re-use their existing web server certificates instead of paying for a new "x509_homomorphic" certificate that contains their "bitcoin identity" public key. I think Jon has been pretty consistently on the "less regulation is better regulation" side of the debate. Given that the big criticism of the Bitcoin Foundation (and Mt. Gox) around here was that it is on the "more regulation" side of the fence, I find your comment kind of amusing.As for it being "a big pile of fail" :  I think reasonable people can disagree here.  I have no idea whether trying to work inside the existing system or working around the existing system is a better approach. You have your opinion, Jon has his, I think we'll be arguing about it for years to come; happily, there doesn't have to be One True Answer.  I just hope we don't spend all our time sniping at each other over the best One True Way to reach the goals that we all share. 12r6DPnX5TNK4PhnTiShmuK6o4jE8Yh28CReceived, rounded up to 3.11 BTC (because eleven is my favorite number) and sent:  https://blockchain.info/tx/e44db3d7cf05098bfe1a8961a8c805f3e8c94a55e7911699e37ae6227095121f RE: building the .app bundle:https://github.com/bitcoin/bitcoin/blob/master/contrib/macdeploy/macdeployqtplus... is python code with lots of useful stuff for building a nice .app (including making a pretty-looking .dmg).Lots of Qt-specific stuff, too, but it might be a good starting point. The main reason for this release is to fix a nasty bug in the RPC 'move' command that was introduced in 0.7.0.Bitcoin version 0.7.2rc2 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.2/testThis is a bug-fix minor release.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesHow to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you were running on Linux with a version that might have been compiledwith a different version of Berkeley DB (for example, if you were using anUbuntu PPA version), then run the old version again with the -detachdbargument and shut it down; if you do not, then the new version will notbe able to read the database files and will exit with an error.Explanation of -detachdb (and the new "stop true" RPC command):The Berkeley DB database library stores data in both ".dat" and"log" files, so the database is always in a consistent state,even in case of power failure or other sudden shutdown. Theformat of the ".dat" files is portable between differentversions of Berkeley DB, but the "log" files are not-- even minorversion differences may have incompatible "log" files. The-detachdb option moves any pending changes from the "log" filesto the "blkindex.dat" file for maximum compatibility, but makesshutdown much slower. Note that the "wallet.dat" file is alwaysdetached, and versions prior to 0.6.0 detached all databasesat shutdown.Bug fixes---------* Prevent RPC 'move' from deadlocking. This was caused by trying to lock the  database twice.* Fix use-after-free problems in initialization and shutdown, the latter of  which caused Bitcoin-Qt to crash on Windows when exiting.* Correct library linking so building on Windows natively works.* Avoid a race condition and out-of-bounds read in block creation/mining code.* Improve platform compatibility quirks, including fix for 100% CPU utilization  on FreeBSD 9.* A few minor corrections to error handling, and updated translations.* OSX 10.5 supported again----------------------------------------------------Thanks to everybody who contributed to this release:AlexdansmithGavin AndresenGregory MaxwellJeff GarzikLuke DashjrPhilip KaufmannPieter WuilleWladimir J. van der Laangrimd34th No, you probably won't get a response there, either."All BIPs should" ... is too rigid, in my humble opinion.If the person championing the BIP thinks that a link to a discussion thread helps clarify or convince, then they should include a link.  But I don't think a hard-and-fast rule is the right thing to do, we'll just waste time arguing over WHICH discussion thread or threads should be linked... Can you please let me know if this works on OSX 10.5:   https://s3.amazonaws.com/gavinandresen-bitcoin/bitcoin-0.7.2rc2-macosx.dmgI set up a new build environment on an old, 32-bit OSX 10.6 laptop, and I think I fixed the 10.5 compatibility issue.(some MacPorts maintainers don't seem to be terribly good at making sure their ports honor BOTH the -arch AND the -isysroot settings...) I would urge you to return a receipt with a memo that says:"your order will be shipped as soon as your payment has three confirmations."Explicitly telling your customers what they can expect to happen next is a great feature of the proposal, I think. You will be able to generate and send unsigned invoices that has no identity attached.But they are much less secure than signed invoices, because a "man in the middle" attacker could rewrite the Invoice so the bitcoins go to him.Or if you have a dispute with the merchant and all you have is an unsigned Invoice, the merchant can claim that "your machine must have been hacked, you sent the bitcoins to an address that isn't mine!" Yes, if they have an infinite amount of money to pay in transaction fees.I'm not sure why governments would want to give all of their money to miners, though. And buying up bitcoins to pay all those fees would just push up the price, so it would probably be counter-productive as a way of trying to ddos the network. I should talk with Valve?I'm not an expert in video game economics, and I haven't yet seen a strong argument for why a game company would give up control of their own in-game currencies for a currency that they do not (and cannot) control.If you've got a strong argument for why they should, then YOU should talk with Valve*. They're rational and profit-driven, so if it is in their best interest they should be willing to do it.*Cue a flood of armchair-game-economists posting their half-baked thoughts here... I don't think we'll know if it can work until it is tried; it does seem to me that the incentives point the wrong way (if my doctor tells me I have six months to live maybe I decide I deserve to run up my Ripple credit to the max....) but maybe I'm just cynical (maybe there will be an equal or greater number of people who decide to give away all their money through Ripple instead of leave it to their deadbeat children).Good luck to Joel and Jed and the rest of the Ripple team! For those of you not subscribed to bitcoin-development@lists.sourceforge.net :We've been having a productive discussion of a proposal for a simple payment protocol to get a much better user experience than is given by bitcoin addresses:  http://sourceforge.net/mailarchive/message.php?msg_id=30147926This is the next big "lets all agree to do things the same way" thing I think we should tackle. Latest pseudo-spec is: https://gist.github.com/4120476I'd prefer to keep the discussion on the mailing list (I think this forum is a great place for brainstorming, but I think the mailing list is a little better for getting consensus on all the nitty-gritty details of a proposal). You can use plain multisig if you like, they WERE added to IsStandard. listunspent output is designed to be read by machines, not people, and its output is designed to go directly into createrawtransaction.If you need all the human-friendly details of a transaction, use getrawtransaction <txid> 1I'm against adding "address" to the listunspent output, because most of the time it will be unused and sometimes it would just not appear at all (because not all scriptPubKeys are bitcoin addresses). You should only trust tags fetched via https, otherwise a man-in-the-middle could hijack the .json file and replace the address and signature.(and I think you'd want "tags" to be an Array of Objects...)RE: adding data to the blockchain: Did you see Stefan Thomas' nifty idea for using ECC math to tie a hash to a transaction without any blockchain bloat? See: https://en.bitcoin.it/wiki/Enabling_SSL_on_original_client_daemon
So... please don't take this the wrong way, but what's your prior experience creating and shipping high-quality software?I ask because re-implementing Bitcoin as a first "software-people-other-than-myself-are-going-to-use" project is a really bad idea, I don't see any list of previous work at the RocketHub page, and the 9,000 lines of code you've already written doesn't look like the work of somebody who has professional software development experience (e.g. no makefile/build system ...).Maybe you're a prodigy and will get it right the first time, but you're already at 'cbitcoin 2.0' because you weren't happy with how 'cbitcoin 1.0' was turning out. See the solidcoin/microcash saga for an example of how over-promising "1.0/2.0/3.0" releases destroys confidence.And maybe you CAN point to some other successful software you wrote and shipped when you were 17, in which case I'll shut up and leave you alone. Is that 0.00095 from a single input, or is it 95 .00001 inputs?0.00095 BTC is worth about one US cent. Are you sure it is worth your time to try to get that penny back? Good idea. Agreed, thanks Erik! I wonder if that is the smallest sha256 hash ever found for any purpose... +1 : most organizations won't appreciate getting random bitcoin donations, it is a headache for them to figure out how to handle them properly (and they will get pretty grumpy if they spend a couple hundred dollars worth of staff time to deal with less than that in bitcoin donations). See https://en.bitcoin.it/wiki/AlertsThere are three active alerts right now. Recent versions support JSON-2.0 "batch" queries, so you can combine multiple RPC calls into one batch and get a list of responses. Ummm........ yeah.Sorry, but tweaking and recompiling my macports boost to support OSX 10.5, which is not longer being supported by Apple (or Chrome or several other popular projects) just isn't very high on my TODO list.Figuring out why it used to work is even lower on my list.Perhaps you can convince people that you're trustworthy, and release a 10.5-compiled binary yourself. Yes, I believe I did. Because Foundation members posting on the forum may not want the entire world to know that they are Foundation members with a quick Google search-- there is a privacy issue.Somebody could sign up as a member and then try to screen-scrape and republish everything somewhere, so members should assume that whatever they say will eventually be public. And the membership might still decide that read-only for non-members is the right thing to do-- I agree that it could be a good way to attract new members, if the quality of conversation is high.In related news:  Foundation board members will be blogging regularly at https://bitcoinfoundation.org/blog/(RSS feed: https://bitcoinfoundation.org/blog/?feed=rss ) Does it run on the testnet blockchain? The relevant settings and their default values for recent versions of bitcoind are:Code:Maximum size, in bytes, of blocks you create:blockmaxsize=250000How many bytes of the block should be dedicated to high-priority transactions,                                                                                                 included regardless of the fees they pay                                                                                                                                 blockprioritysize=27000Minimum block size you want to create; block will be filled with free transactions                                                                                       until there are no more or the block reaches this size:                                                                                                                  blockminsize=0Fee-per-kilobyte amount (in BTC) considered the same as "free"                                                                                                                    Be careful setting this: if you set it to zero then                                                                                                                      a transaction spammer can cheaply fill blocks using                                                                                                                      1-satoshi-fee transactions. It should be set above the real                                                                                                              cost to you of processing a transaction.                                                                                                                                 mintxfee=0.0005So if you set blockprioritysize=0, you will only accept fee-paying transactions.If you only want to accept 500 or so transactions, set the blocksize to 500 * average transaction size (400 bytes or so) = 200000The rules for filling up the block are:First, take the highest priority transactions (regardless of fee) and fill up the block to blockprioritysize.  (if blockprioritysize is zero, then this step does not apply)Then, take the highest fee-per-kilobyte transactions and continue filling the block until either you run out of transactions with a fee-per-kilobyte greater than mintxfee or the block would be larger than blockmaxsize.Finally: the rules are likely to change again fairly soon so that groups of related transactions are considered together ("child pays for parent", so customers can send zero-fee transactions to merchants, who can create a child transaction with a fee when they need the transaction to be confirmed). dansmith:Here's a -g build:  http://skypaint.com/bitcoin/Bitcoin-Qt-mac-g.zipIf I recall correctly, one of the libraries it links with is incompatible with 10.5. See https://github.com/bitcoin/bitcoin/tree/master/contrib/pyminer  : The first thing your committee should do is come up with a better name.There is a reason the phrase "designed by committee" is one of the worst things you can say about a project.And if your committee can't agree on a better name... then you're doomed before you start. Thanks for helping test! Hmmm.... works for me.  See:  https://gist.github.com/3966071  for exactly what I did to create and then spend a 2-of-3 on the main network, with keys that are not in my wallet. Okey dokey.Reality is that the protocol IS defined by Satoshi's implementation.This isn't like HTML where the worst thing that happens if two implementations disagree about the spec you get different looking web pages.  Our worst case is much worse (if two popular implementations disagree then we potentially wind up with a blockchain split, and, essentially, two different currencies).We need help creating tests to make sure different implementations agree on the rules; as you re-implement the protocol please set aside some time to think about that and help! I think that is a good thought experiment:  If you replaced all uses of SHA256 in Bitcoin with MD5, what attacks would be possible? (please check my work, I am not an expert on hash collisions)Well, to generate a collision:Block hashing would be safe, for now; the block header that is hashed is only 80 bytes long, much less than the 128 bytes of wiggle room needed to find a collision.I believe an attacker could easily produce two different non-standard transactions that hashed to the same txid. That would be a disaster, they could split the blockchain and/or double-spend by broadcasting one version of the transaction to half the network and the other to the other half of the network.To split the chain the attacker would mine a block containing the 'poison' transaction hash, and then broadcast two versions of the same block, containing the two different-but-same-hash transactions. Half the network would think that block contains 't1', and half 't2'.  Everything would be just fine until the attacker spent the outputs of t1 and/or t2... then Bad Things would happen.Double-hashing doesn't help at all:  If HASH(t1) == HASH(t2)  then HASH(HASH(t1)) == HASH(HASH(t2))I do agree with everybody who points out that SHA256 isn't close to being broken. If it does ever start to get close, then I'm sure we could figure out a backwards-compatible fixes and phase them in (something like "a block's coinbase transaction must include a SHA3-based transaction merkle root", create a new version of OP_CHECKSIG that used SHA3, roll out a new alert system that used SHA3, etc).
If you receive income in any form, and your income-translated-into-dollars is above whatever the "must file" amount currently is, then yes, you must report it on your income taxes at the end of the year.Doesn't matter if your income is in the form of dollars or euros or bitcoins or diamonds.And I'm pretty sure Fincen would say that if you're receiving more than $10,000 worth of bitcoins from somebody then they want to know about it, just like they want to know if you're getting more than $10,000 worth of diamonds from somebody.  See the fincen.gov for the mind-numbing details. It should be pretty easy to use the raw transactions API to implement a "send all".You would do:  listunspent --> list of inputs  Then estimate a reasonable fee (this is the hardest bit, but listunspent tells you amount and #confirmations and you can estimate tx size based on number of inputs)  createrawtransaction/signrawtransaction/sendrawtransactionSomebody should write a little python tool we can ship in contrib/ Bitcoin version 0.7.1 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.1/This is a bug-fix minor release.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesProject source code is hosted at github; you can getsource-only tarballs/zipballs directly from there:  https://github.com/bitcoin/bitcoin/tarball/v0.7.1  # .tar.gz  https://github.com/bitcoin/bitcoin/zipball/v0.7.1  # .zipUbuntu Linux users can use the "Personal Package Archive" (PPA)maintained by Matt Corallo to automatically keep up-to-date.  Just type:  sudo apt-add-repository ppa:bitcoin/bitcoin  sudo apt-get updatein your terminal, then install the bitcoin-qt package:  sudo apt-get install bitcoin-qtKNOWN ISSUES------------Mac OSX 10.5 is no longer supported.How to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you were running on Linux with a version that might have been compiledwith a different version of Berkeley DB (for example, if you were using anUbuntu PPA version), then run the old version again with the -detachdbargument and shut it down; if you do not, then the new version will notbe able to read the database files and will exit with an error.Explanation of -detachdb (and the new "stop true" RPC command):The Berkeley DB database library stores data in both ".dat" and"log" files, so the database is always in a consistent state,even in case of power failure or other sudden shutdown. Theformat of the ".dat" files is portable between differentversions of Berkeley DB, but the "log" files are not-- even minorversion differences may have incompatible "log" files. The-detachdb option moves any pending changes from the "log" filesto the "blkindex.dat" file for maximum compatibility, but makesshutdown much slower. Note that the "wallet.dat" file is alwaysdetached, and versions prior to 0.6.0 detached all databasesat shutdown.New features------------* Added a boolean argument to the RPC 'stop' command, if true sets  -detachdb to create standalone database .dat files before shutting down.* -salvagewallet command-line option, which moves any existing wallet.dat  to wallet.{timestamp}.dat and then attempts to salvage public/private  keys and master encryption keys (if the wallet is encrypted) into  a new wallet.dat. This should only be used if your wallet becomes  corrupted, and is not intended to replace regular wallet backups.* Import $DataDir/bootstrap.dat automatically, if it exists.Dependency changes------------------* Qt 4.8.2 for Windows builds* openssl 1.0.1cBug fixes---------* Clicking on a bitcoin: URI on Windows should now launch Bitcoin-Qt properly.* When running -testnet, use RPC port 18332 by default.* Better detection and handling of corrupt wallet.dat and blkindex.dat files.  Previous versions would crash with a DB_RUNRECOVERY exception, this  version detects most problems and tells you how to recover if it  cannot recover itself.* Fixed an uninitialized variable bug that could cause transactions to  be reported out of order.* Fixed a bug that could cause occasional crashes on exit.* Warn the user that they need to create fresh wallet backups after they  encrypt their wallet.----------------------------------------------------Thanks to everybody who contributed to this release:Gavin AndresenJeff GarzikLuke DashjrMark FriedenbachMatt CoralloPhilip KaufmannPieter WuilleRune K. SvendsenVirgil DuprasWladimir J. van der Laanfanquakekjj2xanatos It is MIT licensed, anybody can mirror it anywhere they like. You don't need anybody's permission, just do it! You don't need the whole network to support transaction replacement to do that; just write some code that holds a time-locked transaction, has a way of replacing it with another time-locked transaction, and have it automatically broadcast the transaction onto the network if not replaced before the time-lock expires.It would be more convenient to have the whole network support transaction replacement, but I don't think it is reasonable for the whole network to remember everybody's dead-man-switch transactions. And even if they did, you'd run the risk that a miner eager to get an extra transaction fee would ignore a newer version of the transaction and mine the old transaction. RE: do I have gazillions of bitcoins:I've said before that I have "thousands of bitcoins, not tens or hundreds of thousands of bitcoins." I have mined a grand total of 250 bitcoins-- electricity here is not particularly cheap, and I'm a software kind of guy, not a hardware hacker. So it always made more sense for me to buy bitcoins rather than mining them.I would definitely be wealthier right now if I had been working as the CTO for a company for the last two years and had never heard of Bitcoin.RE: what work will I do:I will continue doing what I've been doing-- trying to focus on work that benefits all of Bitcoin and not one particular company. That is the kind of work that falls through the cracks-- why would one company pay for cross-implementation compatibility tests? Sure cross-implementation compatibility is really important for the stability of the Bitcoin network, but as long as the implementation THEY'RE using works properly then why would they spend extra to make life easier for other implementations?Or a company might fund the development of anti-denial-of-service techniques, but once they do, why would they want to share that with their competitors? Being more denial-of-service-resistant might give them a competitive advantage...TruCoin paid me a salary for a couple of months last year to do core development work (and paid Alex Waters to start doing Q/A for core development), but TruCoin ran into funding problems of their own and stopped paying us to concentrate on their own projects.Creating a Foundation is a proven, well-established way for projects to solve the free-rider problem of funding core development that benefits everybody. Over time, I hope to be working less on the reference implementation and more on "Chief Scientist" stuff, like organizing working groups to write best practices documents or work out agreements on changes that might be necessary to the core protocol to support more transactions, better privacy, advances in quantum computing, hiring or recruiting experts to do security reviews of proposed new stuff, etc.RE: voting:Great ideas! I think I'll be pushing to start with a good old-fashioned "send you a letter with a PIN number to your mailing address" as the first step to preventing voter fraud. We'll have to have a much more extensive discussion of voting procedures before it is time to vote.  I'll probably push to follow the lead of other successful organizations, and to do the Simplest Possible Thing That Will Work-- which might be hiring a disinterested high-reputation company who specializes in running elections for organizations. Nice! You should submit a pull request to put a version of this in the contrib/ directory; my only suggestion would be to make it take a version string as an argument (and maybe automatically look in the test/ subdirectory if it contains 'rc'). Right, and we don't accept "change the world" pull requests because the risks of introducing a catastrophic bug outweigh the benefits, and rewriting everything invalidates all of the careful code review that's been done over the past few years.However, we ARE moving towards better architecture as different parts of the code get worked on to support new features or improve scalability or fix bugs.  For an example of inversion-of-control done right, look for use of boost signals and slots; for example:Code:boost::signals2::signal<void (CWallet *wallet, const uint256 &hashTx, ChangeType status)> NotifyTransactionChanged; If I recall correctly, mybitcoin.com users got 49% of their coins back (I was one of the stupid people who trusted some bitcoins to them, by the way). Not yet. There is a pull request implementing bloom filters that should make that easy to implement.No. The reference implementation doesn't keep a master map of all addresses to unspent transaction outputs, and adding such an index for the small number of services that need to look up arbitrary addresses doesn't make sense.I'd suggest you -blocknotify and the getblock() RPC call to maintain your own index of address --> unspent txout. I slapped one up you can try:  http://skypaint.com/bitcoin/fauceturi.htmlI think typing bitcoin:1.....?label=... etc  into the browser address bar should work for testing, too. This will be a WONTFIX, unless somebody steps up to continue supporting OSX 10.5.I'll put a big note in the release notes that we're dropping OSX 10.5 support. There's no such thing as 'official.'I think the best term is "reference client." Huh?  There were none.  The blockchain bootstraps itself from the genesis block and peers on the network. Bitcoin version 0.7.1 release candidate 1 is now available from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.1/test/This is a bug-fix minor release.New features------------* Added a boolean argument to the RPC 'stop' command, if true sets  -detachdb to create standalone database .dat files before shutting down.* -salvagewallet command-line option, which moves any existing wallet.dat  to wallet.{timestamp}.dat and then attempts to salvage public/private  keys and master encryption keys (if the wallet is encrypted) into  a new wallet.dat. This should only be used if your wallet becomes  corrupted, and is not intended to replace regular wallet backups.* Import $DataDir/bootstrap.dat automatically, if it exists.Dependency changes------------------* Qt 4.8.2 for Windows builds* openssl 1.0.1cBug fixes---------* Clicking on a bitcoin: URI on Windows should now launch Bitcoin-Qt properly.* When running -testnet, use RPC port 18332 by default.* Better detection and handling of corrupt wallet.dat and blkindex.dat files.  Previous versions would crash with a DB_RUNRECOVERY exception, this  version detects most problems and tells you how to recover if it  cannot recover itself.* Fixed an uninitialized variable bug that could cause transactions to  be reported out of order.* Fixed a bug that could cause occasional crashes on exit.* Warn the user that they need to create fresh wallet backups after they  encrypt their wallet. ... so transfer 1,000 headers with different extranonces in one handshake.  Or don't handshake every time. Or modify the firmware that speaks whatever mining protocol you're sending at it to do the increment-extranonce-and-recompute-the-merkle-root-thing itself.All of this discussion is useless; even if you could convince us core developers that we need A HARD FORK RIGHT THIS VERY MINUTE! there is absolutely zero chance we could make that happen before the ASICS start shipping.So: plan accordingly. Actually, there is a small incentive to forward transactions:If you mine a block that contains a lot of transactions that have never been broadcast on the network, it will take your peers longer to verify that the signatures in the block are valid.*So it takes your block longer to propagate through the network, which makes it slightly more likely to lose a block race.* A couple of releases ago I implemented a signature cache, so if a node sees a transaction broadcast it doesn't have to re-check it when that transaction is part of a block. I'll outsource my thoughts:  http://skeptoid.com/episodes/4176 I really and truly hope you're, right, MPOE.But I would give 4-to-1 odds that the US justice system will disagree, and my advice to anybody thinking of raising funds via an unregulated IPO would be "don't do it unless you want to do it as a protest against our broken system and are willing to face the likely consequences."I'll cheer you from the sidelines, but I'm either not stupid enough or not brave enough to go up against the SEC. +1I still hope the Bitcoin world will be boring in 4 or 5 years, but I expect lots more chaos and drama until at least then. This is what innovation looks like-- lots of failures and a few spectacular successes.It is still WAY too early to tell what will be successful long-term.
No, that's the point:  you can take any validly signed bitcoin transactions, tweak the signature(s) in various ways, and create variations that are also validly signed but have a different txid. We've known that for a long time.You cannot change where the coins came from or where they go or any other information about the transaction that is covered by the signature(s).And the current reference bitcoin implementation will simply take the first variation it sees and consider it valid. Sergio is saying that if there are any merchants doing their own double-spend detection they should be aware of this issue. My daughter's review-- "wow, these are really good nuts!"Thanks D, we'll be ordering more! Okey doke.  I thought they had some firmware that knew how to talk over USB (or ethernet or whatever), too. I thought the consensus was that the mining devices just need a little extra software onboard to increment extranonce and recompute the merkle root.I don't know nuthin about hardware/firmware design, or the miner<->pool communication protocols, but it seems to me that should be pretty easy to accomplish (the device will need to know the full coinbase transaction, a pointer to where the extranonce is in that transaction, and a list of transaction hashes so it can recompute the merkle root). Transactions do not have an input address.They have one or more inputs, which may or may not correspond to one or more addresses.If you have a CScript, then you can call:Code:bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);What are you trying to do? If you held a pre-signed transaction that sends the funds back to you with a lockTime of 1 Jan 2013 that would work.Lets see... thinking out loud...Start by asking the exchange for a brand-new public key to use for their half of the 2-of-2 transaction. Call the send-coins-into-2-of-2 transaction "F" (for Fund).You create and sign that transaction, but don't broadcast it yet.Use it's transaction id to create a second, one-input-two-signature, lockTime=1/1/2013 transaction that refunds the coins to you.  Call that "R" (for Refund).Send R to the exchange and ask them to sign it using that brand-new public key they gave you. The exchange checks the lockTime and then returns R and the signature to you. You check the signature, and if it is good, broadcast F (and keep the half-signed R someplace safe).If 1/1/2013 rolls around and you want your coins back, you sign your half of R and broadcast it.I'd have to think a little harder than I want to right now about whether or not signing R knowing only txid==HASH(F) opens up the exchange to attacks. I can't think of any, but the exchange providing a signature when it doesn't know the details of exactly what it is signing makes me nervous.You could send the unsigned R and the signed-but-not-broadcast F to the exchange and trust that the exchange will not broadcast F unless they agree to sign R.I think holding on to pre-signed-but-not-broadcast-yet transactions is a technique "we" don't think about enough. 50 BTC (or whatever) deposit, tied up for a minimum of a year (don't want somebody putting down 1,000 BTC deposits the day before a vote, voting 20 times, then canceling their 20 sockpuppet memberships and getting their deposit back immediately) is an interesting idea.Call me paranoid, but I don't see many third parties who I would trust to not get hacked and to properly identify anonymous people. I don't see that third parties would have a strong incentive to do a good job at that. And delegating that piece of really core functionality feels like the wrong way to go to me.For the record: I think it would be great to come up with an easier way for people to remain anonymous but still be Foundation members. I say "easier" because I'd guess with enough effort you could use a (physical) mail forwarding service and an anonymous email service to sign up with a fake identity. I suppose the mail forwarding service is like an identity-checking service.RE: one vote per bitcoin: there seems to be some notion that Foundation member will be voting on things like "should a change to the core protocol be rolled out to support XYZ."Umm, no. Foundation members will be voting for (and lobbying) board members who will decide things like "should the bylaws be changed to allow anonymous memberships" or "how much Foundation budget should be dedicated to X and how much to Y." The number of bitcoins you own has nothing to do with those kinds of organizational decisions.Technical changes will happen as they have for the last couple of years-- get rough consensus in the developer community then convince miners and merchants and users to upgrade. No, no, no: to do it right, you "accidentally" slip a hint to a reporter a month before you launch....(to the humor-impaired:      ) So... if the membership agrees with your "bugs" then they'll get fixed.  Like I said, the vision is it will be a member-driven organization. And like I said, I find it is much more effective to start with something imperfect and improve it over time rather than try to get everything exactly right and make everybody completely happy at the start.My personal opinion on the "bugs":Name:  I like the name.  It can be changed if the membership decides on something better.Hosting company: could easily be changed; it likely will be. I highly doubt Cloudflare is a government honeypot for anything besides catching DDoS botnet operators.Identities/voting: Please see "Sybil Attack" for why we're requiring names, mailing addresses and emails. If you've got a magical way of identifying anonymous people please send me the source code, I could use it for the Bitcoin Faucet.Privacy policy: fair point, there should be a privacy policy on the website.US based: if Patrick (Foundation's lawyer) was Finnish we would probably be Finnish-based. That's the whole "perfect is the enemy of the good" thing (and I really don't want to have a month-long discussion about which legal jurisdiction is the least likely to declare Bitcoin Foundation illegal, which would be best for getting donors tax deductions, and whatever other arguments we could have).One of the things that I think will be fascinating to watch is how users and miners organize themselves (or not) to elect people to the Board. I'm not going to pretend that the current composition of the Board is perfect-- I have no idea if some arrangement would be better. But it seems to me before making a statement like "there should be more of X on the Board" we should either get some experience under our collective belts to see how things work OR find an example of a similar, successful organization that works. As DeathAndTaxes says, there is a weak vulnerability there for clients that are performing initial block download.It is weak because try-to-fill-up-disk attacks take a long time to pull off, the results are boring (you managed to fill 10 gigabytes of my terabyte hard drive? meh), recovery is pretty easy, and the attacker has to wait around for potential victims to connect to them.There are a bunch of optimizations to initial block download that could be done; the most obvious is fetching headers for the entire best blockchain starting at the best-block, then 'backfilling' block data in the background.  That would let a new user get up and running very quickly, and would get rid of the vulnerability. Jeff probably skims this sub forum for the same reasons I do-- entertainment, to keep my mind open to new ideas, and the chance that there will actually be some good ideas. If nobody steps up and volunteers to help with this, we'll have to drop support for OSX 10.5 in the next release. Right now?  What if we did that and it turned out the second public/private algo was broken first? ECDSA is a NIST standard that has been very well studied and has no known vulnerabilities.  There are much, much, much higher items on the development TODO list, like figuring out a nice GUI for multi-device transaction authorization.I did write up plans for migrating to a new algorithm here:  https://gist.github.com/2355445  (See the "using a quantum-resistant digital signature algorithm" example at the end). hazek, you're really annoying me.First, you edited my OP and broke all of the links changing .org to .com.Then you sent me a PM asking if it would be ok to move this thread to Service Discussion.  WTF?  If discussion of the Foundation isn't a good topic for the main Discussion forum what is?Now you spout off about 'Gavin this, Gavin that.'It isn't easy to piss me off, but, I'm sorry, you're really pissing me off. Bounties?  Really?  Point me to a successful security-critical open source project where bounties pay the rent.I haven't tried kickstarter-like fundraising?  http://blockchain.info/address/17XvU95PkpDqXAr8ieNpYzSdRDRJL55UQ8  is the address for the Bitcoin Testing Project, which has received a grand total of 72 BTC, which isn't nearly enough to pay a QA grunt, let alone a QA lead.You say "why change, Bitcoin has been working great for me!"It hasn't been working great for me; I'm frustrated by the lack of resources and all of the distractions I have to deal with as the unelected, un-asked-for de-facto leader of this amazing experiment. I'm excited about the Foundation, because it is bringing together dedicated, effective people who all want Bitcoin to succeed. Huh.That's a problem with BIP 20-- it doesn't say how the parameters are encoded.  I assumed they were encoded the same way as http URLs (application/x-www-form-encoded) because the bitcoin: scheme is very similar to the http scheme (where everything after the ? is x-www-form-encoded); are they not? Microsoft/authenticode assumes one trusted master key (I think? Can a binary be signed by multiple keys?)That is contrary to the no-central-authority idea, and it would be nice to avoid that.However, given that Apple and Microsoft are both going in the direction of "thou shalt be a registered developer to distribute software for our OS" a central signing process for at least the initial install seems inevitable.This is one of those "interact with existing systems that do not consider the possibility of radically decentralized solutions" hurdles that the Foundation can help jump; I expect the Foundation will soon be a registered Apple and Microsoft developer, and downloads will be signed with certificates owned by the Foundation.The alternative is downloads only geeks can use (because only geeks know how to turn off cert checks) or binaries signed by me personally. And I don't want to be a single point of failure; having an organization that will hopefully outlive me is a better solution.The best solution would be multi-signed binaries and a decentralized web of trust system, but we're not there yet. Thanks for all the positive, constructive feedback (those of you who gave positive, constructive feedback). I'm not going to address conspiracy theories, mostly because I'm not seeing most of them because of who I've got on my ignore list.The points people made here about the Foundation making Bitcoin MORE decentralized are, from my point of view, exactly right. To take one example, I don't want to be the centralized decision-maker who figures out who should or should not be on the bitcoin-press mailing list that is on the bitcoin.org homepage any more. To take another: if there is money for the development team, I don't want to decide how to split it up (I've got an obvious conflict of interest).RE: why Peter and why not anonymous members and why DC and why not a different process to start:Because I'm pragmatic.  I like to actually get things accomplished instead of endlessly talking about doing things. Everybody on the initial Board are people who get things done.My biggest fear is not that the Foundation will become some massively powerful entity controlling Bitcoin; my biggest fear is that the Foundation will turn into Yet Another Ineffective Bureaucracy, employing a few people who do nothing but put out meaningless press releases.RE: confirmation-of-payment emails:  that will be done soon.RE: bylaws:In the spirit of openness, the Foundation bylaws are on github:  https://github.com/pmlaw/The-Bitcoin-Foundation-Legal-Repo/tree/master/BylawsCreating forums or mailing lists where Foundation members can communicate is on the very short-term TODO list.Thanks again to everybody who has already joined, it is exciting to see people from all over the world get involved! Is there a good open source piece of code we can use to test to make sure we're generating good entropy?These bugs should be investigated and fixed (Sergio can you open issues on github?), but I'd like a test we could periodically run to make sure they stay fixed. Even better is if the code could monitor itself and let the user know if there's a problem with entropy generation. Y'all can stop speculating:  https://bitcointalk.org/index.php?topic=113400 I'm pleased to announce the launch of the Bitcoin Foundation:The Bitcoin Foundation is modeled on the Linux Foundation. I think Linux is a great "role model" for Bitcoin; it is a very successful open source project that really embraced the notion of "open," encouraging the use of the core technology for a wide range of applications.I hope that the Bitcoin Foundation will help do the same for Bitcoin.Of course, "the Foundation" won't do anything at all-- people get things done. I want the Bitcoin Foundation to be an open, member-driven organization, and hope that you or your organization will not only become a member but will help the Foundation accomplish its mission.Please visit the Foundation website for details, and please keep in mind that nothing is set in stone; the structure of the Foundation can be changed by a vote of its members, and exactly what the Foundation does will largely depend on who is willing to step up do the work to make things happen.To any of you feel like you should have been invited to be part of the group who defined the initial structure and purpose of the Foundation: I apologize. But in my experience the larger the group, the longer it takes to get things done, and it has been 11 months since I first posted about the possibility of forming a Foundation.In what will doubtless be an ineffective attempt to fend off the trolls, here are some answers to what I expect might be commonly asked questions:Q: Is this the infamous September Announcement?Yes.Q: How do we know you won't just take our bitcoins and run?We won't. The initial Foundation board members are all people with well established reputations using their real names.Q: How do we know you won't lose our bitcoins to hackers?We'll be using a cold wallet, with the private key securely backed up, for most of the Foundation's funds; in the near future I expect we'll be using a multisignature cold wallet, with keys controlled by multiple Board members to keep the funds even more secure.Q: Is this just a front for the CIA? What is the hidden agenda?No. And there is none.Q: The Foundation is a corporation, and corporations (especially US corporations) are evil.OK. So don't join-- go form your own non-corporate non-evil organization, or just ignore the Foundation and do whatever you think is right.Q: How, exactly, is the Foundation going to spend the money it gets?That depends on how many bitcoins it gets from memberships and donations. See Peter's "Letter from the Executive Director" for the current list of priorities, and see the Linux Foundation website for an idea of the types of things I hope the Bitcoin Foundation will be doing, assuming it has the funds.Finally, thanks to Peter Vessenes, Patrick Murck, Mark Karpeles, Charlie Shrem, Jon Matonis and Roger Ver who stepped up and did the work necessary to get this started.
I was just about to say the same thing; if there were multiple people all over the world downloading and checking the binaries against the PGP signatures that would be a wonderful thing, and would be much more robust against all the various attacks that might happen (DNS poisoning on some subset of the Internet, compromising one mirror, etc etc etc). Yes, I am an angel sent from God to deliver Justice to a world full of Sin!But I'm not behind the bitcoincard project. I did meet with them in Vienna, along with other bitcoin folks. See http://blog.bitinstant.com/blog/2012/6/8/bitcoincard-in-vienna-day-1-coffee-missing-atms-and-some-tes.html for info/pictures. Wanna bet? Yeah, where did I say that?Oops, edited, I forgot about my "don't feed the trolls" rule. +1And I'd say the same for anybody who has offered shares on GLBSE; I am not a lawyer, but you should talk to a lawyer about whether or not you might have broken some laws you had no idea existed, and if you did, what you should or shouldn't do about it. Update, 22 Sept:  Still looking for a fix for OSX 10.5 users. If you are running 10.5, you should not upgrade yet. No, these are Luke's pet branches, which I think are a bad idea because they divert development and testing efforts away from the latest release.The first real 'stable' release will be 1.0, and we're not there yet. Yes, go ahead and implement it.  Here's a thumbnail sketch of one way to start:+ Create a web service that lets anybody upload their email address and a list of public keys.+ Send the user an email whenever 'tainted' coins are sent to any of those public keys, telling them how tainted they are and where they came from.That's it.For extra credit, you could let users upload their wallet.dat files (private keys encrypted, I would hope) and auto-extract all the public keys in the wallet.  Heck, if you stored the private-key-encrypted wallet.dats you might be able to charge a little for both blacklist detection and wallet backup. I'm sure I could figure it out, but I don't have a copy of osx 10.5 to run, won't pirate it, and don't feel like spending $60 to pick up a copy on Ebay. I'd rather not spend the half a day it would take me to set up a development environment in a VM, too.... You'd need 15 words to represent a bitcoin address; more if you include a checksum (a very good idea, transpose two words without a checksum and you'd get a "black hole" address).Creating a secure payment protocol so I can tell people "send payment to gavinandresen@clearcoin.com" and be confident that I'll get the coins is very high on my priority list. We're getting reports that version 0.7.0 isn't working on OSX 10.5-- are there any Mac developers with a 10.5 machine who can help figure out what is wrong?The OSX builds are done on my OSX 10.6.8 machine, compiled against the 10.5 SDK in 32-bit mode (see http://gavintech.blogspot.com/2011/11/deploying-bitcoin-qt-on-osx.html ) for maximum compatibility. I'm not sure what changed between bitcoin versions 0.6.3 and 0.7.0 that would break compatibility... RE: listing bitcoind separately on the clients page:  good idea.  casascius, do you know (or are you willing to teach yourself) enough git to submit a pull request to the https://github.com/bitcoin/bitcoin.org  repository?I think we should remove the direct download links from the bitcoin.org (and wiki) homepage, too, and instead just link to the clients page. Sure, use multisig and store the keys on two different types of hardware (e.g. cell phone and computer). The block files (blk000N.dat) are not BDB files, they're a raw, binary, append-only list of serialized blocks, so -loadblock doesn't care about the version of libdb used. Yes, if by earlier you mean a few minutes earlier (it would have to have a 50+ BTC fee to make it worthwhile for miners to double-spend a transaction that already made it into the last block).Two zero-confirmation transactions essentially happen at the same time as far as the network is concerned; if there was a good way for everybody to agree that they happened in a particular order we wouldn't need the blockchain. I assume that miners will take the transactions that give them the greatest short-term profit; that may not be correct (there might be a lot of miners interested in the long-term health of Bitcoin), but I think it is the safest assumption. And I think if we design payment protocols around that assumption they will be more secure. Yes, mathematically approximately zilch.... unless the OpenSSL entropy-gathering code on your computer isn't working properly, so bitcoin's random-key-generating code doesn't work (we use OpenSSL to get good random numbers). That is a bigger worry, but happily lots of people have been reviewing that code for years. Bitcoin version 0.7.0 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/We recommend that everybody running prior versions of bitcoind/Bitcoin-Qtupgrade to this release, except for users running Mac OSX 10.5.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesProject source code is hosted at github; you can getsource-only tarballs/zipballs directly from there:  https://github.com/bitcoin/bitcoin/tarball/v0.7.0  # .tar.gz  https://github.com/bitcoin/bitcoin/zipball/v0.7.0  # .zipUbuntu Linux users can use the "Personal Package Archive" (PPA)maintained by Matt Corallo to automatically keep bitcoin up-to-date.  Just type  sudo apt-add-repository ppa:bitcoin/bitcoin  sudo apt-get updatein your terminal, then install the bitcoin-qt package:  sudo apt-get install bitcoin-qtHow to UpgradeIf you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy overCode:/Applications/Bitcoin-Qt (on Mac) or Code:bitcoind/bitcoin-qt (on Linux).If you were running on Linux with a version that might have been compiledwith a different version of Berkeley DB (for example, if you were using thePPA and are switching to the binary release), then run the old version againwith the -detachdb argument and shut it down; if you do not, then the newversion will not be able to read the database files and will exit with an error.Incompatible Changes* Replaced the 'getmemorypool' RPC command with 'getblocktemplate/submitblock'  and 'getrawmempool' commands.* Remove deprecated RPC 'getblocknumber'Bitcoin Improvement Proposals implementedBIP 22 - 'getblocktemplate', 'submitblock' RPCsBIP 34 - block version 2, height in coinbaseBIP 35 - 'mempool' message, extended 'getdata' message behaviorCore bitcoin handling and blockchain database* Reduced CPU usage, by eliminating some redundant hash calculations* Cache signature verifications, to eliminate redundant signature checks* Transactions with zero-value outputs are considered non-standard* Mining: when creating new blocks, sort 'paid' area by fee-per-kb* Database: better validation of on-disk stored data* Database: minor optimizations and reliability improvements* -loadblock=FILE will import an external block file* Additional DoS (denial-of-service) prevention measures* New blockchain checkpoint at block 193,000JSON-RPC API* Internal HTTP server is now thread-per-connection, rather than  a single-threaded queue that would stall on network I/O.* Internal HTTP server supports HTTP/1.1, pipelined requests and  connection keep-alive.* Support JSON-RPC 2.0 batches, to encapsulate multiple JSON-RPC requests  within a single HTTP request.* IPv6 support* Added raw transaction API.  See https://gist.github.com/2839617* Added 'getrawmempool', to list contents of TX memory pool* Added 'getpeerinfo', to list data about each connected network peer* Added 'listaddressgroupings' for better coin control* Rework getblock call.* Remove deprecated RPC 'getblocknumber'* Remove superceded RPC 'getmemorypool' (see BIP 22, above)* listtransactions output now displays "smart" times for transactions,  and 'blocktime' and 'timereceived' fields were addedP2P networking* IPv6 support* Tor hidden service support (see doc/Tor.txt)* Attempts to fix "stuck blockchain download" problems* Replace BDB database "addr.dat" with internally-managed "peers.dat"  file containing peer address data.* Lower default send buffer from 10MB to 1MB* proxy: SOCKS5 by default* Support connecting by hostnames passed to proxy* Add -seednode connections, and use this instead of DNS seeds when proxied* Added -externalip and -discover* Add -onlynet to connect only to a given network (IPv4, IPv6, or Tor)* Separate listening sockets, -bind=<addr>Qt GUI* Add UI RPC console / debug window* Re-Enable URI handling on Windows, add safety checks and tray-notifications* Harmonize the use of ellipsis ("...") to be used in menus, but not on buttons* Add 2 labels to the overviewpage that display Wallet and Transaction status (obsolete or current)* Extend the optionsdialog (e.g. language selection) and re-work it to a tabbed UI* Merge sign/verify message into a single window with tabbed UI* Ensure a changed bitcoin unit immediately updates all GUI elements that use units* Update QR Code dialog* Improve error reporting at startup* Fine-grained UI updates for a much smoother UI during block downloads* Remove autocorrection of 0/i in addresses in UI* Reorganize tray icon menu into more logical order* Persistently poll for balance change when number of blocks changed* Much better translations* Override progress bar design on platforms with segmented progress bars to assist with readability* Added 'immature balance' display on the overview page* (Windows only): enable ASLR and DEP for bitcoin-qt.exe* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)Internal codebase* Additional unit tests* Compile warning fixesMiscellaneous* Reopen debug.log upon SIGHUP* Bash programmable completion for bitcoind(1)* On supported OS's, each thread is given a useful nameThanks to everybody who contributed to this release:Chris MooreChristian von RoquesDavid Joel SchwartzDouglas HuffFordyGavin AndresenGiel van SchijndelGregory MaxwellJeff GarzikLuke DashjrMatt CoralloMichael FordMichael HendricksPeter ToddPhilip KaufmannPieter WuilleR E BroadleyRicardo M. CorreiaRune K. SvendsenScott EllisStephane GlonduWladimir J. van der Laancardpunchercoderrrfanquakegrimd34thsje397xanatosThanks to Sergio Lerner for reporting denial-of-service vulnerabilities fixed in this release. You request a transaction by hash (using an 'inv' message).You then get the transaction in a 'tx' message.  The hash isn't sent as part of that data, because you can reconstruct it by hashing the transaction data. If you're running Bitcoin-Qt on a Mac, what version of OSX are you running?I'm trying to get an idea of how many people are still running 10.5, because supporting that version of OSX is starting to become painful (it is almost 5 years old now...).And before somebody asks: yes, signing the Bitcoin-Qt app so it plays nicely with 10.8's "Gatekeeper" is near the top of the TODO list. Right now, there is a hard-coded limit of 1 megabyte per block.If we assume that limit never changes, that gives: 1MB per block * 6 blocks per hour * 24*365.25*200 = 10,519,200 MB... or 10.5 terabytes for the maximum size of the entire blockchain over the next 200 years (somebody check my math, I'm really good at dropping zeroes).I expect that in 200 years 10 terabytes of storage will cost a few pennies.Now whether or not that 1 megabyte per block limit should go away is hotly debated, and will be debated more and more as transaction volume increases.
Two-people-required-to-spend bitcoin addresses would be a great feature for blockchain.info.Coins would be sent to that address, then both address owners would have to agree to spend them (by signing transactions).The incoming coins do have to be fully spent, but it is easy to create transactions that send the change back into the "vault" (multisig address). Yeah, not Satoshi.  Satoshi has red hair and a big handlebar moustache. Is Decrits meant to be a decentralized solution?How is the coin minting queue managed? E.g. you say "Once enough minters have joined the queue..."  :  what if there is disagreement about which miners are in the queue or if there are "enough"? Release candidate 3 binaries are up; major differences from rc2 are:1) Fix the IPv6 RPC problem (you will get a warning in debug.log, that is expected)2) Updated translations------We could use more people "gitian building" releases; if you have a machine with at least 3 gig of memory and 20 gig of disk space, you can now help reproduce the builds using LXC running inside something like VirtualBox:  https://github.com/bitcoin/bitcoin/blob/master/contrib/gitian-descriptors/README#L57   BCDataStream.write takes binary data, so add a .decode('hex_codec') to the big long hex string:Code:test.write("0100000001da8d10a3b749dbda1658298d84512836c1bfb2bcbe7b61dcdd3e508bcb7e1477000000006c493046022100e041a6e5df8c8b44231b4fee02b34e2f12d553ab54dc434c1bf95dffb68e5f8d022100c74e5318b4c209397be7e1ea4f4ef783d036f5fbe894918e8e31c72e49f75fc30121034ecf9a2859c419500001e05710bec6673db9a8ea5faaf07497c9c996e1d28f81ffffffff0280324c35800000001976a914fc8e972d3f4c41b44a3ee71051aaf52f107ceb0f88ac005cb2ec220000001976a914847641ad2efb44d949070bf6e7b1c367c70f194388ac00000000".decode('hex_codec'))parse_Transaction(test){'lockTime': 0, 'version': 1, 'txIn': [{'sequence': 4294967295, 'prevout_hash': '\xda\x8d\x10\xa3\xb7I\xdb\xda\x16X)\x8d\x84Q(6\xc1\xbf\xb2\xbc\xbe{a\xdc\xdd>P\x8b\xcb~\x14w', 'scriptSig': 'I0F\x02!\x00\xe0A\xa6\xe5\xdf\x8c\x8bD#\x1bO\xee\x02\xb3N/\x12\xd5S\xabT\xdcCL\x1b\xf9]\xff\xb6\x8e_\x8d\x02!\x00\xc7NS\x18\xb4\xc2\t9{\xe7\xe1\xeaON\xf7\x83\xd06\xf5\xfb\xe8\x94\x91\x8e\x8e1\xc7.I\xf7_\xc3\x01!\x03N\xcf\x9a(Y\xc4\x19P\x00\x01\xe0W\x10\xbe\xc6g=\xb9\xa8\xea_\xaa\xf0t\x97\xc9\xc9\x96\xe1\xd2\x8f\x81', 'prevout_n': 0}], 'txOut': [{'value': 550650000000, 'scriptPubKey': 'v\xa9\x14\xfc\x8e\x97-?LA\xb4J>\xe7\x10Q\xaa\xf5/\x10|\xeb\x0f\x88\xac'}, {'value': 150000000000, 'scriptPubKey': 'v\xa9\x14\x84vA\xad.\xfbD\xd9I\x07\x0b\xf6\xe7\xb1\xc3g\xc7\x0f\x19C\x88\xac'}]} You would have probably found that a lot quicker running a testnet version.The testnet Faucet is giving away 500 play bitcoins at a time right now:  http://testnet.freebitcoins.appspot.com/ Productive discussion in IRC today:   http://bitcoinstats.com/irc/bitcoin-dev/logs/2012/09/10#l4463724Executive summary: Good idea, Stefan.  Lots of details to be worked out... Hoisted from the comments on pull request 1809:I think there are definitely use-cases for associating some immutable meta-data with a transaction. Example: a bitcoin client that gave a unique refund address for every outgoing transaction, and automatically groups refund transactions together with the original payment transactions.Somebody could create a service that associates data with transaction ids, but they need to do more work to make the data immutable... and it is not clear to me how you make that secure.I really want my refund address to be 'baked in' to the transaction that I sign, so if the transaction is accepted into the block chain I know there hasn't been some hacker somewhere who managed to rewrite the refund address so they get my coins.If I'm doing some type of smart contract with bitcoin transactions, I want the contract data baked in and covered by the transaction signature. And the person I'm transacting with would like to be sure I can't change the terms of the contract once the transaction is signed.It seems to me the simplest, most straightforward, and secure way to do that is with a limited-data OP_DROP transaction type. The data in the blockchain is (transaction+HASH(metadata)), and that is what is signed.  The actual metadata can be stored outside the blockchain and looked up (and verified) by hash (hand-wave, hand-wave, I have no idea how that happens, if there is more than one place that stores transaction metadata, etc).Any scheme that tries to move the HASH(metadata) outside the transaction signature recorded in the blockchain will, at the very least, be more complicated. And, therefore, very likely to be less secure.Am I missing some other simple, secure, decentralized, non-blockchain scheme for attaching metadata to transactions? Consensus is the RPC-doesn't-work-if-you-disable-IpV6 bug is serious enough to hold up the 0.7.0 final release.So the plan will be: get a fix for that bug and release/test a 0.7.0rc3. I just submitted a pull request to fix this:  https://github.com/bitcoin/bitcoin/pull/1818 debug.log might tell you why it is being rejected. Some reasons it might be rejected:+ You're re-using an input that has already been spent.+ Sum(outputs) is greater than Sum(inputs)+ signrawtransaction was unable to sign all of the inputs (it did not report "complete" : true )By the way: be EXTREMELY careful with the raw transactions API. You can easily forget to include a change output and create transactions with huge fees; test your code thoroughly on testnet before putting it into production. We need a payment protocol with non-repudiation built in.See https://gist.github.com/2217885 for a multisig version (the singlesig version is simpler, but the merchant <-> customer communication will be the same). Old coins are preferred over new coins because transaction spammers spend coins over-and-over again quickly to try to flood the network with transactions.Unintentional transaction spammers (like people playing SatoshiDice over and over) accidentally do the same thing, so their transactions are given low priority and can take a long time to get confirmed.Maybe think of it this way:+ Transaction fees are to pay miners to include your transactions.+ Transaction priority is used to "pay" for the network bandwith used by free transactions (note that any node relaying or listening for transactions pays the cost of every extra transaction). When I hear that, I hear "you should stop doing what you're doing for a year or two or three and re-implement the whole thing."Yeah... no.  As much as that would be a fun project, I don't think that is the job of the team working on the existing reference implementation. Keeping the existing software and network running as smoothly as possible is the highest priority.Another very high priority is working through issues that arise as alternative implementations happen (see the current thread in the development section about non-DER-encoded signatures for a good example).  An alternative implementation that has the kind of accounting that you want is a great idea-- go do it, fund it, or convince somebody else to do it.  I think genjix' libbitcoin has the "store the blockchain in a database" that you want (although last I heard he was running into performance issues with that approach). We should avoid saying "canonical" -- I just peeked at the ASN.1/BER/DER spec, and there's a "canonical" encoding that is different from the "distinguished" encoding:   http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf(international standards committees seem to be completely incapable of adhering to the Keep It Simple, Stupid principle). That would violate his users' privacy; maybe I don't want you (or the rest of the world) to know that I have a Gox account.You don't need accounts or registration, you just need a two-step process:1) User tells you their refund address2) You give the user a unique deposit address, and link the refund and deposit addresses in your database.To avoid creating a gazillion deposit addresses or bothering the user to give you a refund address every time, you might want to store the "user already got a deposit address" flag in a session cookie.  But if the user will remember the deposit address then even that isn't necessary. See http://dl.acm.org/citation.cfm?id=2335366 for recent research on passphrase usability; results do not look good. http://scholar.google.com/scholar?q=passphrase to see what other researchers have tried. Anybody else having success or failure running rc2 on Windows 7, please let us know... Fraud is telling people lies to get them to do something or making promises you know you can't keep.In my humble opinion, promising people "Risk-free" returns is fraud. Even US Treasury Bills are not "risk free." No. Absolutely not.
What stops an attacker from pre-generating tens or hundreds of thousands of alert messages (for tens or hundreds of thousands of their own transactions that the previously put into the chain) and then sending them to the network all at once?Goal would be to keep the network busy checking the alert signatures. First: I think it is extremely unlikely that somebody would spend a million dollars on an attack that takes months to pull off, doesn't benefit the attacker at all, is easy to fix, and that would be easy for the network to recover from.Good idea, and easy to do.I've got a half-finished "user-defined checkpoint" patch in my personal git tree, so users, merchants, and big mining pools can decide for themselves to add checkpoints on-the-fly (via an 'addcheckpoint' RPC command) to protect against this type of attack. Good point. I assume that miners will choose to mine the version of a transaction with the highest fee-per-kilobyte, since that will give them the best profit, but actually changing the code to implement that policy has been controversial when I've brought it up before.To fight transaction spam, I think the relaying logic will need to get smarter, too.  A large, expensive-to-verify double-spend should be way down on the "stuff that should be relayed when there is enough bandwidth" list.That's a different issue, and a new feature. I think the best way to implement that feature is "child pays for parent" (see https://github.com/bitcoin/bitcoin/pull/1647 for a proposed implementation), and then the user can broadcast a high-fee pay-to-self child transaction to get the parent accepted into a block. Bitcoin version 0.7.0 release candidate 3 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/test/Unless another critical bug is found, this should be the final 0.7.0 release.How to Upgrade--------------If you are running an older version, shut it down. Waituntil it has completely shut down (which might take a few minutes for olderversions), then run the installer (on Windows) or just copy over/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).If you were running on Linux with a version that might have been compiledwith a different version of Berkeley DB (for example, if you were using anUbuntu PPA version), then run the old version again with the -detachdbargument and shut it down; if you do not, then the new version will notbe able to read the database files and will exit with an error.Incompatible Changes--------------------* Replaced the 'getmemorypool' RPC command with 'getblocktemplate/submitblock'  and 'getrawmempool' commands.* Remove deprecated RPC 'getblocknumber'Bitcoin Improvement Proposals implemented-----------------------------------------BIP 22 - 'getblocktemplate', 'submitblock' RPCsBIP 34 - block version 2, height in coinbaseBIP 35 - 'mempool' message, extended 'getdata' message behaviorCore bitcoin handling and blockchain database---------------------------------------------* Reduced CPU usage, by eliminating some redundant hash calculations* Cache signature verifications, to eliminate redundant signature checks* Transactions with zero-value outputs are considered non-standard* Mining: when creating new blocks, sort 'paid' area by fee-per-kb* Database: better validation of on-disk stored data* Database: minor optimizations and reliability improvements* -loadblock=FILE will import an external block file* Additional DoS (denial-of-service) prevention measures* New blockchain checkpoint at block 193,000JSON-RPC API------------* Internal HTTP server is now thread-per-connection, rather than  a single-threaded queue that would stall on network I/O.* Internal HTTP server supports HTTP/1.1, pipelined requests and  connection keep-alive.* Support JSON-RPC 2.0 batches, to encapsulate multiple JSON-RPC requests  within a single HTTP request.* IPv6 support* Added raw transaction API.  See https://gist.github.com/2839617* Added 'getrawmempool', to list contents of TX memory pool* Added 'getpeerinfo', to list data about each connected network peer* Added 'listaddressgroupings' for better coin control* Rework gettransaction, getblock calls. 'gettransaction' responds for  non-wallet TXs now.* Remove deprecated RPC 'getblocknumber'* Remove superceded RPC 'getmemorypool' (see BIP 22, above)* listtransactions output now displays "smart" times for transactions,  and 'blocktime' and 'timereceived' fields were addedP2P networking--------------* IPv6 support* Tor hidden service support (see doc/Tor.txt)* Attempts to fix "stuck blockchain download" problems* Replace BDB database "addr.dat" with internally-managed "peers.dat"  file containing peer address data.* Lower default send buffer from 10MB to 1MB* proxy: SOCKS5 by default* Support connecting by hostnames passed to proxy* Add -seednode connections, and use this instead of DNS seeds when proxied* Added -externalip and -discover* Add -onlynet to connect only to a given network (IPv4, IPv6, or Tor)* Separate listening sockets, -bind=<addr>Qt GUI------* Add UI RPC console / debug window* Re-Enable URI handling on Windows, add safety checks and tray-notifications* Harmonize the use of ellipsis ("...") to be used in menus, but not on buttons* Add 2 labels to the overviewpage that display Wallet and Transaction status (obsolete or current)* Extend the optionsdialog (e.g. language selection) and re-work it to a tabbed UI* Merge sign/verify message into a single window with tabbed UI* Ensure a changed bitcoin unit immediately updates all GUI elements that use units* Update QR Code dialog* Improve error reporting at startup* Fine-grained UI updates for a much smoother UI during block downloads* Remove autocorrection of 0/i in addresses in UI* Reorganize tray icon menu into more logical order* Persistently poll for balance change when number of blocks changed* Much better translations* Override progress bar design on platforms with segmented progress bars to assist with readability* Added 'immature balance' display on the overview page* (Windows only): enable ASLR and DEP for bitcoin-qt.exe* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)Internal codebase-----------------* Additional unit tests* Compile warning fixesMiscellaneous-------------* Reopen debug.log upon SIGHUP* Bash programmable completion for bitcoind(1)* On supported OS's, each thread is given a useful name Right, you do have to remember them for at least a little while...  Replace "relay but don't remember" with "relay and forget as soon as possible." Sergio:Is a new type of message necessary?How about just making the transaction relay rules:1) If the transaction has inputs that conflict with one already in the best blockchain, drop it.2) If the transaction has inputs that conflict with another transaction in the memory pool, and it is the first such conflicting transaction, check the new transaction's signatures and if they're OK mark the memory pool transaction as "saw a double spend". Then relay the conflicting transaction (but don't otherwise remember it).Rule (1) is to prevent an attacker from taking a bunch of her old, already-in-the-blockchain outputs and trying to generate a "double spend alert storm" by sending bogus double-spend attempts for them.Rule (2) is to limit the amount of network traffic / signature checks an attacker can create to be twice what they can generate today (attackers can, and do, try to flood the network with transactions, but transaction fees and the free transaction relay policy keeps them in check).The GUI/RPC should definitely show attempted-double-spend memory pool (0-conf) transactions as "BEWARE".I think those rules will flood the network with the double-spend attempt, alerting merchants/users that something odd is happening. Without making it possible for an attacker to get the network flooded with gazillions of double-spend alert messages. "Hey, I've got this fantastic idea!""Really!  Tell me all about it!""We're going to blah blah blah.""Uhh... did you talk to a lawyer about that? That might be illegal.""Uhh... really? no.""And where will you get the money to do it?""Uhhh... haven't figured that out yet.""And if I want to participate, what should I do?""Uhh... I dunno, we don't really have a process for that yet..."I made the mistake of asking a reporter when her deadline was, because if it was far enough away I could tell her about the neat idea. I should have kept my mouth shut or sworn her to secrecy.Announcing a half-baked idea is counterproductive; you'll just get a gazillion questions that you can't answer, or, even worse, people will assume they know the answers and then be disappointed when it turns out the idea they thought they heard you describe isn't the same idea they thought they heard.Announcing a fully-baked idea and then modifying it based on what everybody thinks and how it works out in practice is the right way to do things, in my humble opinion. I've said that I think the download-and-install-software-on-your-PC is a mostly-dead way of using software, and that the vast majority of people using Bitcoin in a year or three will be using it via a web application or on their smart phone. That's half of the reason why I don't think improving the UI is a high priority right now (the other half is because I think solving wallet security and backup issues is critical).RE: 2112 and GAAP:  "patches welcome."  I don't know nuthin about GAAP, so if you're complaining that the reference implementation doesn't adhere to them then I'm not surprised. Feel free to fix that, or write a detailed proposal on what's wrong, why it'll cause problems, and how it ought to be fixed.RE: funding development: funding open source software projects is tricky; if done poorly you end up with a couple of paid developers and lots of disappointed unpaid former contributors who decide "I'm not gonna work if I'm not gonna get paid."That said... stay tuned, and I'll say more when I can. You're missing the point of Bitcoin if you feel left out. You can be as involved as you want to be, just go make something happen-- find something you think needs doing, recruit some people to help if you need help, and do it. Are you waiting for an invitation or permission from somebody? Yes, please don't create lots of unspendable scriptPubKeys. There are more prunable ways of embedding messages into transactions. And there are even better ways of associating messages with transactions, so only people involved with the transaction can read the message (if that's desired).In other words, lets figure out how to do this the right way. The way you're doing it now will stop working as soon as the network upgrades anyway (0-value outputs are nonstandard as of the 0.7 release). From "Operator Imprecision and Scaling of Shor's Algorithm" (2008):I don't see any published rebuttals in a quick Google Scholar search. Maybe there will be a breakthrough (or already has been... any QC wizards listening here?) in handling the fuzziness of quantum calculations as you scale up the number of qbits, but 256-bit ECDSA looks pretty darn secure to me right now. I'd like bitcointalk.org to be in the spirit of the Internet's original ".org" -- For Non-Commercial Use Only.But... it is hard to figure out what is Commercial Use and what isn't (e.g. some mining pools are non-profit, some for-profit, and I'm sure there are some in the fuzzy middle), which is why there really aren't any rules for .org any more. I'm leaning towards extending the 2nd argument, to give previous inputs and, if the previous inputs are P2SH, previous inputs scripts.Along with a new 'rawmultisigaddress' that is just like addmultisigaddress, but doesn't add the redemption script to the wallet but instead returns it.addmultisigaddress added the P2SH scripts to the wallet.RE: when can you expect a fix:It is too late to add new RPC features to the 0.7 release, so no fix until the next release. Bug. I never tested the combination of signing a pay-to-script-hash transaction with non-wallet private keys.I'm not 100% sure how to fix it, though. The problem is private keys, public keys, and P2SH scripts are all stored in a "keystore." When you give the third argument to signrawtransaction, it creates a keystore that contains just the private keys (and the corresponding public keys) that you give, and uses that to sign the transaction.There's currently no way to give it the P2SH script that corresponds to 34y6HmY6zTH51KTC9vd36HasNL4kLKcisC, but the transaction signing code needs that information.I think the right fix is to give signrawtransaction both the private key(s) and any P2SH information needed... I was sent a personal message by somebody saying that the burden of proof that something is a scam should be on the person accusing the scammer.  If they can't PROVE it, then they should shut up.I disagree. I think the burden of proof is on people "guaranteeing" high returns.Here's how I think of it:Imagine you see somebody claiming they have invented a perpetual motion machine.You claim bullshit, because that's against the laws of physics and all previous experience.Now they send you an email, saying "... before making such accusations you need to PROVE that it cannot work."Foolproof schemes to make high interest at low risk are the financial world's perpetual motion machines. They do not exist.Perpetual motion machines may not be scams; there are misguided people who really do believe that they've violated the laws of physics and will prove all of those pesky scientists wrong. I'm sure there are people who truly believe that they've invented foolproof methods of investing lots of money with no risk, too, but I'm equally sure they're delusional. Yeah, don't do that, you'll annoy some of us moderators.I think Micon is doing the moral thing, warning people of what he thinks are scams.I think they're scams, too. It is impossible to get risk-free 1.5% weekly interest, I don't care how good you are at "playing the market" or "choosing who to lend to." Does valgrind really not work on Mountain Lion?  Good reason for me not to upgrade... (runs great on Snow Leopard). Securities scares me because in the USA there are strict laws with even TALKING about securities.I know, I know, Congress is supposed to make no law abridging freedom of speech. I worry that won't stop the SEC from seizing the bitcointalk.org domain name for promoting unlicensed securities.I think a separate top-level domain for everything under the Marketplace heading would be the right thing to do. I agree with Micon. I'm embarrassed by 'Long Term Offers' and scared by 'Securities'. You address it by explaining where the bitcoins come from for the 'guaranteed' payouts.Credit cards make money by charging merchants a fee, charging interest on late payments, etc. And they mitigate their risk by running credit reports on borrowers.Legitimate lenders do something similar.So, I'll ask again: what is your business model?  How will you make the money to payback the people who are sending you X bitcoins and expecting to get X+Y back in a day?
How can Hunger Coin guarantee payback if you are lending the coins to people who may not pay YOU back?I'm sorry, but "Hunger Invest" and "Hunger Lending" still sound like Ponzi schemes to me. No, I don't understand.To whom are you lending the bitcoins you receive? Unless you can clearly explain, in small words that even I can understand, HOW you are getting the bitcoins to pay interest I'm going to assume that this is Yet Another Ponzi Scheme.I understand how SatoshiDice makes money, and I have no issues with them generating lots of transactions.If you were CHARGING interest then I would understand, and would have no issues with your service.So: how will HungerCoins make money?  And don't answer "I can't tell you or everybody else will do it," that is the Ponzi-operator's standard answer. Sweet! Please don't play this.If it gets popular, then it is just "use the blockchain to create a Ponzi scheme". It can scale up, using new transactions to pay a little more to older transactions made 2 or 3 blocks ago. That's is the essence of a Ponzi scheme.If you want to test something, use the testnet.  That is what it is for. mmm, no.To be valid JSON, arg[1] must be:Code:[{"txid":"eb63d5d53cd906b5cf75a014e1bcf1c0198ae58d378d45dbfa15045ac89a38ac","vout":0}]WTF is Windows doing with the arguments? Disclaimer: I don't do Windows.But according to a quick google search, caret is the Windows cmd.exe escape character, and [] and {} are NOT special characters to cmd.exe.So maybe this?Code:bitcoind.exe createrawtransaction [{^"txid^":^"eb63d5d53cd906b5cf75a014e1bcf1c0198ae58d378d45dbfa15045ac89a38ac^",^"vout^":0}] {^"1GMaxweLLbo8mdXvnnC19Wt2wigiYUKgEB^":23.35} Solo miners, miners using p2pol, and mining pool operators will eventually have to upgrade.RE: "Is there any web service to see the current ratio of v1 / v2?"I bet if you ask nicely blockchain.info will create a page. I expect it to take a long time (a year or more) before 95% of the hashing power has upgraded and is producing v2 blocks.The getblock RPC call will tell you a block's version number; if you're an old bash user like me then you can do something like:Code:last=$(./bitcoind getblockcount);for (( i=last-100; i <= last; i=i+1 )); do echo -n $i; ./bitcoind getblock $(./bitcoind getblockhash $i) | grep version; done... to see the version numbers of the last 100 blocks (I see 2 of 100 right now). Start here maybe:  https://github.com/gavinandresen/bitcointools/blob/master/deserialize.py#L262 Using bitcoind on a command-line?  What operating system?Something is stripping off the double-quotes from the "txid" and "vout" keys before it gets to bitcoind.  If you're using bash on linux, then put single quotes around the arguments.  Like this:Code:createrawtransaction '[{"txid":eb63d5d53cd906b5cf75a014e1bcf1c0198ae58d378d45dbfa15045ac89a38ac,"vout":0}]' '{"1FQvMNzFJRf2nFJbhri2pWEVMqTtdLSCmA":23.36129790}'I also corrected the second argument, the address is a string (strings in JSON are always "whatever") and the amount is decimal number-of-bitcoins. If you do it, I'd suggest implementing it as a proxy that sits in front of bitcoind.But before you do that, you should do some googling to see if somebody has already written a JSON-RPC-over-HTTP proxy that implements per-method access control. Bitcoin version 0.7.0 release candidate 1 binaries are now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/test/Please use the issue tracker at https://github.com/bitcoin/bitcoin/issues to report bugs.Notable changes:Security--------* Fixed denial-of-service attacks (disk and CPU exhaustion) related to the alert systemQt GUI------* Add UI RPC console / debug window* Re-Enable URI handling on Windows, add safety checks and tray-notifications* Add 2 labels to the overviewpage that display Wallet and Transaction status (obsolete or current)* Extend the optionsdialog (e.g. language selection) and re-work it to a tabbed UI* Merge sign/verify message into a single window with tabbed UI* Improve error reporting at startup* Fine-grained UI updates for a much smoother UI during block downloads* Reorganize tray icon menu into more logical order* Persistently poll for balance change when number of blocks changed* Much better translations* Added 'immature balance' display on the overview page* (Windows only): enable ASLR and DEP for bitcoin-qt.exe* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)Bitcoin Improvement Proposals implemented-----------------------------------------BIP 22 - 'getblocktemplate', 'submitblock' RPCsBIP 34 - block height in coinbaseBIP 35- 'mempool' message, extended 'getdata' message behaviorCore bitcoin handling and blockchain database---------------------------------------------* Reduced CPU usage, by eliminating some redundant hash calculations* Cache signature verifications, to eliminate redundant signature checks* Transactions with zero-value outputs are considered non-standard* Mining: when creating new blocks, sort 'paid' area by fee-per-kb* Database: better validation of on-disk stored data* Database: minor optimizations and reliability improvements* -loadblock=FILE will import an external block fileJSON-RPC API------------* Internal HTTP server is now thread-per-connection, rather than  a single-threaded queue that would stall on network I/O.* Internal HTTP server supports HTTP/1.1, pipelined requests and  connection keep-alive.* Support JSON-RPC 2.0 batches, to encapsulate multiple JSON-RPC requests  within a single HTTP request.* IPv6 support* Added raw transaction API.  See https://gist.github.com/2839617* Added 'getrawmempool', to list contents of TX memory pool* Added 'getpeerinfo', to list data about each connected network peer* Added 'listaddressgroupings' for better coin control* Rework gettransaction, getblock calls. 'gettransaction' responds for  non-wallet TXs now.* Remove deprecated RPC 'getblocknumber'* New blockchain checkpoint at block 193,000* listtransactions output now displays "smart" times for transactions,  and 'blocktime' and 'timereceived' fields were addedP2P networking--------------* IPv6 support* Tor hidden service support* Attempts to fix "stuck blockchain download" problems* Replace BDB database "addr.dat" with internally-managed "peers.dat"  file containing peer address data.* Lower default send buffer from 10MB to 1MB* proxy: SOCKS5 by default* Support connecting by hostnames passed to proxy (-proxydns)* Add -seednode connections, and use this for -dnsseed + -proxydns* Added -externalip and -discover* Add -onlynet to connect only to a given network (IPv4, IPv6, or Tor)* Separate listening sockets, -bind=<addr>Internal codebase-----------------* Additional unit tests* Compile warning fixesMiscellaneous-------------* Reopen debug.log upon SIGHUP* Bash programmable completion for bitcoind(1)* On supported OS's, each thread is given a useful nameThanks to everybody who contributed to this release:=======================================Chris MooreChristian von RoquesDavid Joel SchwartzDouglas HuffFordyGavin AndresenGiel van SchijndelGregory MaxwellJeff GarzikLuke DashjrMatt CoralloMichael FordMichael HendricksPeter ToddPhilip KaufmannPieter WuilleR E BroadleyRicardo M. CorreiaRune K. SvendsenScott EllisStephane GlonduWladimir J. van der Laancardpunchercoderrrfanquakegrimd34thsje397xanatosThanks to Sergio Lerner for reporting denial-of-service vulnerabilities fixed in this release. If I recall correctly, the first testnet-in-a-box node should have all the coins.  The second starts with a zero balance / empty wallet (send it coins from the first if you need to...). Right, that was one of the lessons learned from BIP16-- transactions redeeming non-standard inputs aught to be treated as non-standard. And they are, as of v0.6 (I think, I'm really good at forgetting when changes were introduced).If the merchant is using stock bitcoind, then the non-standard transaction won't show up in their wallet until it appears in a block with 1 confirmation, making the security downgrade non-existent (it becomes a variation on the Finney attack). The attacker will pay transaction fees to send those spammy inputs, and that has been a large enough disincentive that it hasn't happened.That said, SelectCoins aught to be improved; ideally, it should never include an input if the fee for adding that input is greater than that input's value.Or maybe it should just ignore inputs below the 'spam transaction' threshold for now, as being more trouble than they're worth. That's wrong; you wouldn't be able to send a new-style transaction to a merchant unless they'd already upgraded and were publishing new-style addresses.... which would actually just be BIP16 addresses, with the redemption script being something like  <ed25519_pubkey> OP_NOP1(I'm wrong about needing a new bitcoin address type).Obviously merchants wouldn't start doing that until a majority of miners were interpreting OP_NOP1 as OP_ED25519_VERIFY.http://gavintech.blogspot.com/2012/07/off-chain-transactions.html I don't think a new signature algorithm doesn't require a hard fork; redefine an OP_NOP as OP_CHECKSIGVERIFY2 that uses ed25519, create a new 'standard' transaction type that uses that new opcode, and a new bitcoin address type that corresponds to it, then start by rolling out miner support, etc. as sketched out here.That would probably be better than a hard fork; I'm not sure what the transition plan would look like for old transactions if OP_CHECKSIG was redefined to use the ed25519 curve.If the new transaction type was significantly cheaper, then cheaper transaction fees could incentivize people to upgrade their clients/wallets.I don't think now is the right time to do any of that, mostly because I wouldn't be surprised if some solution for instant "off the chain" payments is adopted instead, in which case perhaps sep256k1 transaction cost will be negligible. No, the main reason isn't anonymity the reason is so transferring bitcoins between accounts using 'move' doesn't require a blockchain transaction. EITHER: requiring that the wallet be unlocked for the settxfee RPC call to succeedOR: adding a new configuration option "-maxtxfee" (default: 0.01 maybe) that can't be set via RPC ...  seems reasonable to me.We've had an implicit assumption that if an attacker gets access to the RPC interface you're sunk, and while I think that's true (attacker could run a tight loop of "sendtoaddress" that will fail until the moment you unlock the wallet to send some bitcoins somewhere), I also think security in depth is a good idea.Can you open an issue on github please?RE: gui not telling you about the fee:Can you open a separate issue on github about that, too?  That's just a bug, in my humble opinion. RE: seeds with a lot of entropy:Every time I look at the academic literature on passwords/passphrases, I get more depressed about the feasibility of either giving users a secure passphrase that they will remember or getting a secure passphrase from them. I fear there will be a lot of lost coins if "brain wallets" get popular.E.g. this 2012 paper: http://dl.acm.org/citation.cfm?doid=2335356.2335366
Making transactions with non-DER-encoded (aka BER encoded) signatures non-standard has been on my TODO list for over a year now, but has never been the highest priority.  That's the first step to making non-DER-encoded signatures completely illegal.Note that if there is a core-dumping bug in OpenSSL's decoding code then it needs to get fixed in OpenSSL. Writing a BER decoder just for Bitcoin is a bad idea, it is much more likely our new code would have a crashing bug. From this very relevant article:  "Megan McArdle on Arbitrage and Why We Love Being Conned" +1I think I've said it before, but I'll say it again: I'll start to worry when there is a quantum computer that can factor 64-bit numbers faster than non-quantum computers. I bet that is at least 20 years away... Zooko Wilcox-O'Hearn also deserves recognition; he warned us that the method Bitcoin uses to compute the Merkle tree was possibly insecure (although at the time we couldn't see how to turn it into an exploit).This was a nasty bug; if Forrest hadn't found it and responsibly reported it, an attacker probably could have stopped most of the nodes on the network before we got patched code out. It is bugs like this that make me think that having several different implementations of the Bitcoin protocol is a good idea. See https://gist.github.com/2355445 .  Specifically, the section that starts "Example: re-define OP_NOP1 to be OP_Q_CHECKSIGVERIFY, using a quantum-resistant digital signature algorithm." Is bitcoin 2 coming out next month?No.Everybody knows eleven is my favorite number, so if there was going to be a major release of bitcoin it would be "Bitcoin 11".  But it ain't gonna happen. From an email I sent to somebody concerned about bitcoin usability just a couple of days ago:Making the reference Bitcoin application more usable isn't a high priority for me right now.The high priority is making it safe to use, even if your computer gets infected by malware. I WANT it to be hard and geeky to use so only geeks who are able to keep their computers secure run it.Also, the "download and run software on my computer" way of doing things is dying. The vast majority of ordinary users will be using Bitcoin on their smart-phones or through a web browser in the near future.... From the whitepaper:I'd have to think about it a lot harder than I'm willing to right now to be absolutely sure, but that seems like a mistake to me.If peers have to fetch inputs and compute coin age to determine whether or not a chain is longest then it seems like that could be leveraged into a denial-of-service attack. Because an attacker could do minimal proof-of-work (or proof-of-stake) but then broadcast a chain with JUST a little-less consumed coin age than the current best chain.Their chain will be rejected, but their peers will waste time figuring out that it should be rejected.Also note that Bitcoin does NOT use total proof-of-work-performed to determine the best chain; it uses total proof-of-work-target. That's deliberate; if it used proof-of-work-performed, then if you happened to get lucky and found an extremely small block hash you could hold on to it, build on top of it, and only announce your "more proof of work" chain when the network chain's work started to catch up with your secret chain. All right, all right, enough speculation.I'll be announcing http://bitundies.com/, where you will be able to buy high-quality Alpaca wool undergarments for bitcoin. Before I left for vacation, I submitted a pull request that makes the default policy for miners "more fees == more likely to get into a block."  That will be in the 0.7 release (the policy before was mostly "higher priority == more likely to get into a block"), and I've been encouraging the big mining pool operators to implement something similar if they have their own transaction-selection code.When I get back from vacation I plan on writing code to watch the transactions that do or do not make it into blocks to derive an estimate of the average miners' fee policy, and use that to recommend a reasonable fee to the user.Those changes will let fees float naturally-- users and miners will form a market and fees will rise or fall based on what users are willing to pay and what miners are willing to accept. I don't like the arbitrary, centralized setting of fees that we've had up until now. So while driving across Wyoming today my mind wandered to proof-of-stake.  And whether or not it would be possible to attack a proof-of-stake system by repeatedly sending expensive to verify but invalid proofs of stake.I think you could.Example: if the proof-of-stake involves creating a bunch of valid signatures using private keys that you own, then an attacker could buy or create a few thousand keys (e.g. buy 10,000 units of currency and then split them into 10,000 addresses) and submit a proof-of-stake where 9,999 signatures are valid and the last one is invalid.The proof-of-stake will fail, but it will cost the victims approximately the same CPU time to find that out as it takes the attacker to generate the signatures. If the attacker can repeatedly send the same proof-of-stake, and the victims don't cache the work of checking the signatures, then you've got the basis for a great denial-of-service attack.Proof-of-work doesn't suffer from this attack, because it is MUCH easier to validate proof-of-work (one hash operation) than to generate it. I haven't thought deeply about whether or not you could come up with a proof-of-stake that has the same "hard to generate, easy to validate" property. I suppose you could require that a proof-of-stake have a small, limited number of signatures-- requiring that stakeholders maintain a small number of large-balance addresses. That's bad for privacy and security, though.You could disconnect/ban peers that submit invalid proofs-of-stake; an attacker would have to mount a Sybil attack using lots of IP addresses to get around that. That might be a problem in an IPv6 world of essentially infinite IP addresses, though...A hybrid system that requires proof-of-work AND proof-of-stake might work.  You'd have to be careful to tie the proof-of-stake to the proof-of-work, though, otherwise an attacker might be able to re-use the same proof-of-work over and over.I'm curious: if you've been working on a proof-of-stake system, is this kind of attack the kind of thing you've already thought about and solved? I wrote up a step-by-step guide for secure two-person cold-storage escrow using the new 'raw transactions' api:  https://gist.github.com/3161162 +1+1 to Sergio's points, too.  Casascius: I think you need to think more like an attacker; if they can cheaply mount an attack, then they will. For the record:I've never met Zhou Tong, and wasn't involved in any with with Bitcoinica.I have met Tihan, Charlie and Patrick (Murck), and they are all responsible grown-ups who, like any of us, occasionally make mistakes. I think they're making a mistake getting stuck to the Bitcoinica tar-baby, but I think y'all should give them a little space because I think they're genuinely trying to help clean up this mess. Thoughts:We need better authorization and authentication for payments.  See https://gist.github.com/2217885  for my complete thoughts; the "are you paying who you think you are paying" process is relevant even if you're using a singlesig wallet. That's not quite right.The protocol supports it-- just take the output of an unconfirmed transaction (paying to you) and then broadcast a send-to-self transaction that uses it as input and has a big, juicy fee.I think the Eligius mining pool might even notice and confirm both transactions-- Luke DashJr has a pull request to change the reference implementation's transaction selection code to consider fees for sets of related transactions when deciding what to include in a block. Good question.In my humble opinion, the block size should not be arbitrarily limited as it is now (1MB is the limit; typical blocks these days are 30-250K big), but should 'float' -- miners should collectively decide how large a block they're willing to validate and build on top of.Obviously a miner wants to include as many fee-paying transactions in their blocks as possible, until the fee paid is less than their cost of validating and including the transaction (which is a small cost).But miners also don't want to spend a very long time validating other miners' blocks, so they have an incentive to ignore blocks that are outrageously big. If they were willing to build on a 10-gigabyte-big block that took ten minutes to download and signature check, then they're shooting themselves in the foot-- an evil miner could mine a huge block, and then get a head start on mining the next block while the rest of the network was busy validating it.BUT: moving to a floating maximum block size determined by miners will be really hard; it will require everybody-- merchants and miners and users-- to upgrade. It may never happen, because other ways of supporting very high transaction volumes might develop before then. I just sent this email to the biggest mining pool operators; I think creating a real market between users and miners to set transaction fees is a very high priority.After a lot of thinking, trying a few different implementations, and a couple days of testing I'm finally happy with a new scheme for selecting which transactions to include in created blocks.Patch for version 0.6.3:https://github.com/gavinandresen/bitcoin-git/commit/ed0531d8242c75c8c055ec5b4d134d42ea380158.patchThis is pull request #1590 and will very likely be part of the upcoming 0.7 release.Backported patch for version 0.3.24 if you're stuck on an old version of bitcoind:https://github.com/gavinandresen/bitcoin-git/commit/57df05e2cd48716ad2fa2e7379d61b980c65aade.patchThese add new command-line / bitcoin.conf options:Code:  -blockmaxsize=250000  -blockminsize=0  -blockprioritysize=27000  -mintxfee=0.0005The above settings are the default, and match the current default behavior. If you are using a stock bitcoind to create your blocks and apply the patch, the only difference you will see is a higher block reward, because the new code prefers transactions with higher fees to transactions with lower fees.The new options let you control your transaction acceptance policy without recompiling; here is what they do and how to use them:-blockmaxsize controls the maximum size of blocks created, in bytes. I know some pools are limiting the size of the blocks they create because they think larger blocks are more likely to be orphaned; this setting lets you do that easily. Reasonable values are between 50,000 and 250,000 bytes.-blockminsize lets you fill up any 'extra' space in blocks with free transactions, until the block is -blockminsize bytes big. You can use this to implement a policy of "Fill up the block with fee-paying transactions first, but if there aren't enough then include free transactions."  Reasonable values are 0 to blockmaxsize.-blockprioritysize is the primary way to support free transactions. This many bytes at the beginning of the block are set aside for the highest priority transactions, regardless of whether or not they pay a fee. Reasonable values are 0 to blockmaxsize.-mintxfee is the minimum fee, measured in bitcoins-per-1,000-bytes, for a transaction to be considered 'paid' instead of 'free.' It should ideally be a little larger than your real-world cost to process a transaction. Reasonable values are 0.0001 to 0.01  (setting this too low is dangerous; a transaction spammer can fill up your blocks with very-low-but-non-zero-fee transactions)So, putting it all together, here are some possible fee policies you might want to follow:CREATE SMALLER BLOCKSYou want to limit the size of the blocks you create so they propagate faster.Code:blockmaxsize=50000blockminsize=0blockprioritysize=10000mintxfee=0.0005PUNISH HIGH-FREQUENCY USERSYou want to mostly include transactions based on priority, to discourage SatoshiDice-like services where people are sending blizzards of low-value transactions. But you still want to pick up any large-transaction-fee transactions.Code:blockmaxsize=100000blockminsize=0blockprioritysize=50000mintxfee=0.01MAXIMUM FEESYou want to maximize your block reward, including as many fee-paying transactions as possible but avoiding all free transactions.Code:blockmaxsize=250000blockminsize=0blockprioritysize=0mintxfee=0.0001MAXIMUM FEES, ALLOW FREEYou want to maximize the fees you get, but allow some free transactions if transaction volume on the network is low.Code:blockmaxsize=250000blockminsize=50000blockprioritysize=0mintxfee=0.0001MAXIMUM COMPATIBILITY WITH EXISTING CLIENTSIf you want the best compatibility with Bitcoin-Qt and other existing clients, use the default values.Next on my TODO list: implement client-side code to figure out what the average miner's fee policy is by looking at how quickly transactions are being accepted into blocks, and recommend a reasonable fee to users on a per-transaction basis. For the voting problem:It would probably be best to give each voter a "yes" and "no" address that they are expected not to share with anybody else. They can then vote by sending the right number of bitcoins to one of those addresses.You can decide what happens if they send to both addresses.If you want the vote results to be public, then you can pre-publish before the vote a hash of the list of all addresses and voters. Then after the vote publish the list; everybody can make sure it hashes to the correct value, that it has the right list of voters, that it has twice as many addresses as voters, and each voter can check to make sure the addresses assigned to them are on the list.And the voters could then look at the transactions in the blockchain during the voting period, to those addresses to audit the vote.There's probably a complicated crypto protocol you could put on top to make the votes anonymous-but-verifiable, too -- so even the vote organizer doesn't know who voted for what. "We" thought of that (where "we" was actually Khalahan and Pieter and Gregory, if I recall correctly).The string "Bitcoin Signed Message:\n" is prepended to the message as salt, then that's SHA256-hashed twice, and the hash is what is signed/verified. Sign anything you like, it won't reveal information about your keys (unless your OpenSLL implementation has a broken random number generator and doesn't generate unique signing nonces).
That makes sense. If you think BCX will succeed and are immoral, then the way to profit at the exchange's expense is transfer a lot of LTC in to an exchange and sell them for BTC during the fork.If the attack is successful then the LTC deposit is rolled back and you can sell them again. Assuming there is somebody still willing to buy them.In any case, lots of buying before the attack then lots of selling while the fork is being created is the pattern I would expect to see. Of course, that is the same pattern as a plain pump-and-dump scheme... Yes-- bitcoind creates BIP16 multisig transactions (using BIP13 addresses). Because a BIP16 transaction doesn't reveal public keys until the first spend, if an attacker has only one of the public keys (and the multisig address has been funded but never spent) they won't be able to figure out that the key is helping to protect a large multisig-protected balance. Yes, but if Bob and Alice keep the 2-of-2 multisig address secret, then you, the rat, will have no idea that they key you managed to steal is one of the two keys needed to open the fridge.That's why I say that sending the change back into the same multisig address every time is somewhat bad for security...Yes, that was announced before (see the thread about the raw transactions api). In a wisdom-of-crowds system, the promise comes from faith that somebody in the future will still find bitcoins valuable, and be willing to give you something in return.True, it isn't a promise from one particular institution or person to redeem for one particular something else, so it doesn't fit your definition of 'backing.'  But I trust The Crowd more than I trust any one particular institution (especially institutions like governments, who have a long history of breaking promises).See my recent "Is store of value enough?" blog post for more thoughts along these lines. There's a prettier version of this here: https://gist.github.com/3161162Goal:Multi-person 'cold storage' wallet, using the upcoming 0.7-release 'raw transactions' JSON-RPC api (geek's multisig):Setup:Alice generate a public/private keypair. She prints them out and stores them somplace physically secure offsite as a backup. She secures the private key in a way she can easily access.Bob does the same, then Alice and Bob exchange public keys and both form a 2-of-2 multisig address using addmultisigaddress and verify that it's the same for both of them.0.1 BTC are sent to the multisig address, then Alice and Bob follow the spend procedure to make sure it works properly. If it does, the multisig address is fully funded as the secure 'cold' wallet. Public keys, multisig address, and funding/spending Transaction IDs and amounts are kept in a spreadsheet accessible to Bob and Alice (and potentially anybody else interested in auditing; Google Docs or DropBox or any other document-sharing solution works).To detect security breaches, Alice and Bob should send a token amount of bitcoin (say 1 BTC) to the public keys that they are using, and should never spend those coins. Both addresses should be monitored by both Alice and Bob, and if they see coins being spent they should assume that the corresponding private key has been compromised and transfer the multisignature coins to a new, secure multisig address with fresh keys generated on devices that have not been compromised.Spend:Alice selects enough unspent transactions to withdraw the amount she wants and cover fees. She updates the Google Doc document and marks the funding transactions as 'PENDING SPEND'.She calls createrawtransaction with those inputs and one or two outputs:Output to the address where the withdrawal is goingChange output, back to the multisig addressShe calls signrawtransaction, passing in her private key, and then send the half-signed transaction to Bob (via email or any other method).Bob calls decoderawtransaction and checks with Alice to make sure the transaction is OK (Bob and Alice either communicate in advance via phone or Bob calls Alice to verify the transaction details).Assuming all is OK, Bob calls signrawtransaction and then sendrawtransaction to broadcast to the network. He marks the PENDING SPEND inputs in the shared spreadsheet 'SPENT', and adds the change output (if any) to the spreadsheet as a new potential input for future spends.Variations/notes:Depending on the level of security felt to be necessary, securing the private keys might involve encrypting them with pgp and a passhprase and storing them encrypted on the computer or in the cloud. Or storing them in a LastPass secure note. Or storing them on a passphrase-protected IronKey USB stick. Alice and Bob don't necessarily have to follow the same procedure for securing their private keys.If Alice or Bob suffer any sort of security breach or some period of time goes by (1 year?), they should generate new keys and a new address and send all funds to the new address.If Alice and Bob do this more than twice, a little front-end tool that automated much of the process would be a worthwhile investment; that tool could be a prototype for adding complete multisig support to Bitcoin-Qt. Then again, it might just be easier to add support to Bitcoin-Qt in the first place.Extending this so any two of (Alice,Bob,Carol) can authorize a transaction out of the wallet is straightforward, and would prevent loss of funds if any one of them completely lost access to their private key. Or if even more security is needed then requiring all three authorize withdrawals is also straightforward.Sending the change back into the same multisig address is somewhat bad for both security (the public keys associated with the address are revealed at the first spend transaction) and privacy. This can also easily be extended to use two (or more) Hierarchical Deterministic Keys (see BIP 32), with a new multisig address generated for any change on every withdrawal.Alice and Bob might be one person, of course, using two different computers. What partial pre-image?  I assume the message being hashed is "Transfer THIS domain to THAT public key." (with probably a timestamp thrown in there that can't be too far ahead or behind current network time and, of course, a long nonce)I imagine the hash-for-hire services would just ask their clients for the public key; I know I wouldn't want a hash-for-hire service to have access to my site's private key, they could sell it out from under me!RE: a personal website or small domain being evicted: yep. You should offer to sell out for a couple bitcoins less than it will cost that big, evil corporation to find an eviction hash so at least you get compensated. There's very little difference between "legitimate little guy who's last name happens to be Ford" and "domain squatter." Good advice that I expect will be widely ignored: only invest in what you know.So-called high yield investments are (almost?) always dressed-up Ponzi schemes. If you "invest" in them then please lick your wounds quietly when they implode. And if you're one of the lucky few who make money on them, don't expect me to admire your investing wisdom, any more than I'd admire the number-picking brilliance of a lottery winner. That's a really great idea!I think that's a type of all-pay auction; I wonder what an economist who's an expert on auctions would think.... Gentle reminder to the other bitcoin developers: it is generally best not to feed trolls.  Use the ignore button. I am not a lawyer, but I believe the answer depends on how bitcoins are classified by the Securities and Exchange Commission.If they're a currency then insider trading rules don't apply. But last time I looked the legal definition of 'currency' in the U.S. was the money issued by a recognized government.  The only insiders for a currency are the people who issue it (I bet there are strict rules on trading of any kind by Treasury or Federal Reserve employees who have inside knowledge).If Bitcoin gets classified as a commodity, then I'm not sure what rules apply. If an employee at Apple knows that the next generation iPad is going to use a lot of unobtanium, buys a bunch on the unobtanium exchange, then sells after the announcement for a profit are they guilty of insider trading?  Probably...If Bitcoin gets classified as a security, then I'm pretty sure insider trading rules would apply.As always, if you're an employee at, oh, I dunno, Walmart and you know that Walmart will start accepting Bitcoin next March (I can dream, can't I?) and are tempted to buy a bunch of coin now I'd suggest you talk to a lawyer first. That sounds more complicated than it needs to be.If you can assume some mixers are honest and won't disclose what they added to the mix, then just do a series of pair-wise mixes.E.g.A and B communicate securely and create a transaction that has 2 inputs and 2 outputs, all of the same amount of bitcoins (A and B might need to send-to-selves to get the right sized outputs).  The output order is randomized. They each sign their input (after checking to make sure their output goes to them).A could then repeat with C, then D and, assuming B, C, and D aren't all actually the same person recording his IP address and the mixes, would have a coins linked to the wallets of A/B/C/D.  I believe after a few mixing steps a simple clustering analysis would think everybody who participated in the mix is sharing one big wallet (but I know very little about that stuff, and I wouldn't be surprised to find out there are more sophisticated clustering techniques that look at transaction times and overall transaction ordering that might be able to see through the fog and figure out who is who).If all the other participants in the mixes are actually the same person (Sybil attack) then I believe no matter WHAT algorithm you use you're sunk.My intuition is that if you can make the pairwise-mixing case work, then involving more than 2 people at once might be a useful optimization.  But you should start with the 2-person case and prove it is secure before getting more complicated. I asked FINCEN about de-centralized virtual currencies a few weeks ago; here's what I got:  http://dl.dropbox.com/u/38065353/FincenFOIA.pdfOnly the first page is interesting.  Reading between the lines, it looks like they're thinking about us. You'll be able to run as a 'hidden service' that is advertised to other nodes running on the Tor network and get incoming Tor connections in the next release.See https://github.com/bitcoin/bitcoin/blob/master/doc/Tor.txt  for details (send thanks to Pieter Wuille for doing the work).RE: hard drive space:  Pieter has been busy optimizing HD usage, too ("ultraprune"), but that work isn't finished yet. Yes. It was pulled into what will become the 0.7 release a while ago.Documentation is now on the wiki:  https://en.bitcoin.it/wiki/Raw_TransactionsI decided not to abbreviate "transaction" -- none of the other RPC calls use abbreviations. And the features have been tweaked a little bit.There are some nice unintended-but-useful things you can do with it-- as documented on the wiki page:Re-broadcast a transactionIf you want to re-broadcast a transaction right away, you can use the getrawtransaction and sendrawtransaction API calls to do that. As a bash shell-script one-liner it would be:Code:sendrawtransaction $(getrawtransaction $TXID)(note that Bitcoin-Qt/bitcoind automatically re-transmit wallet transactions periodically until they are accepted into a block).Validate a transaction without broadcasting itIf you have a raw transaction and want to make sure all of it's signatures are correct, you can use the signrawtransaction API call. Pass in the hex-encoded raw transaction, any inputs that bitcoind doesn't yet know about, and an empty array of private keys to use to sign the transaction. Passing an empty array of private keys will prevent signrawtransaction from doing any signing; if it returns "complete":1 then all of the existing signatures are valid and there are no signatures missing. Starting with OWASP is good advice.But if you are holding other people's bitcoins, just securing the app is not enough. You need people who have experience securing money telling you how to create processes to make sure you're not the victim of embezzlement, that you are complying with legal requirements, keeping adequate records, keeping customers' funds separate from the funds used to pay expenses, that regular audits are done to detect problems early, and so on.+1 My bank must be weird, they let me withdraw more than X and let me carry a negative balance for a little while (a service they charge for).With the accounts feature, if you have an account containing X bitcoins there are two ways to overdraw it:1. Using the move command. Negative balances have a lot of use-cases, and last time I checked accountants know how to deal with negative account balances.2. Using the sendfrom command, if a transaction fee is required then the fee is charged to the "sendfrom" account and may take it negative.Are you sometimes using "sendtoaddress" and sometimes "sendfrom" ? Or are you using both the GUI (designed for a single user's wallet) and the RPC?  If you want to use the accounts feature, don't do that, always use "sendfrom".Better accounting for transaction fees is a valid complaint, always deducting the fee from the "sendfrom" account can be annoying. It doesn't violate accounting principles, though; if you want the transaction fee to be paid from some other account, then you just sendfrom() and then move() to adjust account balances.If you really want to find something about the accounts feature to complain about, then you should complain that it doesn't scale. What do you mean "send from A" ?  Are A and B accounts or bitcoin addresses?The reference client does not send coins "from" an address; when you send coins they are chosen from any of the available inputs in your wallet.If you receive 50 BTC to an address associated with an empty account "A", then move those 50 bitcoins to account "B", then make the RPC call:  sendfrom "A" <to_address> 50... you will get an error "Account has insuficient funds"I have no idea what 2112 is talking about RE: accountants having trouble figuring out how the accounts feature operates.  It is very much like separate accounts at a bank, where dollars and coins flow in, are credited to accounts, and then flow back out (debiting accounts).  If I take a bag of cash to the bank and have it deposited into my account, I don't expect to get exactly the same bills and coins out the next time I make a withdrawal, and I shouldn't be surprised if the bank uses those coins and bills for withdrawals from other accounts. Sure-- I've always liked the BitTorrent/W3C model because it is less centralized (lots of different implementations of the protocol, as opposed to a project like Perl, where essentially everybody runs the same code).  I consider Satoshi's code the "reference" client, though, not "proof-of-concept", since there is no formal specification.(I've written a formal specification, and I think having a working reference implementation is better than An Officially Blessed Pile of Paper). The upcoming 0.7 release will support running as a hidden service, and supports hidden services finding each other via the p2p and dnsseed peer-finding mechanisms; see   https://github.com/bitcoin/bitcoin/blob/master/doc/Tor.txt  for information.
Relevant recent IRC discussion: http://bitcoinstats.com/irc/bitcoin-dev/logs/2012/07/11/6#l3981048Bottom line: I think transaction replacement is important, but if we just enable it as-is then I think we open up the entire network to an easy DoS attack.And I think the incentives for miners aren't right. I think the rule for what version of a transaction will be included in blocks has to be something like "the one that pays miners most OR the one that pays miners first (if there are several with the same fee)."So I think a scheme where transaction fees are increased, or lock times are decreased, with every transaction replacement is the right way to go. Mmm.  That's why if I were King I'd fast forward to a couple years from now when there were several mature bitcoin clients and bitcoin.org would not list any directly at all (see w3c.org for an example, you won't find a "Download a Web Browser Now!" link).But I'm not King and unlike the Web there aren't a bunch of mature, well-funded bitcoin clients to choose from yet. Yes, he ruffled a bunch of feathers by unilaterally changing bitcoin.org instead of submitting a pull request that could be tweaked and argued about.You can see the discussion here:  http://sourceforge.net/mailarchive/forum.php?thread_name=4FFBF1DF.8070203%40justmoon.de&forum_name=bitcoin-development RE: 101 or 103 unused keys in the keypool:  That's normal.  Here's the sequence of events that causes it:+ You do something that requests a new key from the keypool. Several things do that (including the 'getinfo' RPC call -- it requests a key from the keypool so it can report the keypoololdest time).+ The keypool automatically adds new keys so there are always at least 100 (by default)+ The something you did returns the key back to the keypool, so now there are 100+1I tend to have 104 keys in my keypools, because I do a lot of 4-core CPU mining on testnet-in-a-box setups, and the 4 miner threads each grab a keypool key that is released when bitcoind quits.RE: better backup:  good idea. However, the keypool might not survive for much longer; they're likely to be replaced by Hierarchical Deterministic Wallets (see https://en.bitcoin.it/wiki/BIP_0032 ). Yes.As Pieter said, they don't count towards your wallet balance because you don't have ALL of the private keys in your wallet.It is not clear which wallet those 1-of-2 coins belong to, since neither has exclusive control over them. So the code is conservative and doesn't add them to your balance unless you have ALL of the private keys.The 0.7 release will have a set of RPC calls to create and sign transactions that spend from multisig inputs: see https://gist.github.com/2839617 In case you don't subscribe to the bitcoin-development mailing list, we've been talking about a new BIP:"Bitcoin blocks and transactions are versioned binary structures. Both currently use version 1. This BIP introduces an upgrade path for versioned transactions and blocks. A unique value is added to newly produced coinbase transactions, and blocks are updated to version 2."Full BIP: https://en.bitcoin.it/wiki/BIP_0034Mailing list discussion:  http://sourceforge.net/mailarchive/message.php?msg_id=29505990Pull request that implements BIP 34: https://github.com/bitcoin/bitcoin/pull/1526BIP16 "Lessons learned" : https://gist.github.com/2355445I'd like to keep most discussion on the bitcoin-development mailing and not here on the forums, although I do plan on posting to one of the mining boards to warn solo miners and pool operators that they will eventually need to upgrade (I expect it will take at least a year and probably two or more for 95% of hashing power to upgrade, which is the proposed timeframe for full BIP 34 support). Depending on what you're doing, you should support BIP 13: https://en.bitcoin.it/wiki/BIP_0013Also see: https://en.bitcoin.it/wiki/Base58Check_encoding  for pseudo-code. Pieter is exactly right. The current code is extremely conservative with multisig addresses, only counting them as yours if the wallet contains all the private keys.Loosening that to considering them yours if you have enough keys to spend might happen, although I am worried that might cause vulnerabilities for applications that make the implicit assumption that if they have the key necessary to spend that means nobody else can possibly spend those coins after 6 confirmations. If it is a 1of2 multisig that wouldn't be true. I think Bitcoin is already perfectly capable of scaling up.  Here's one half-baked idea for how to do it:  http://gavintech.blogspot.com/2012/07/off-chain-transactions.html  (pasted below to save you a click):The problem: is there a safe and secure way to make Bitcoin transactions without relying on the block-chain but, instead, relying on some semi-trusted third-party?If there is, then Bitcoin is more easily scalable; most transactions could happen off the block chain, with in-the-block-chain transactions happening every once in a while to "settle up" off-chain transactions.So here is the half-baked idea:Use multisignature transactions to split the ownership of some bitcoin value between a customer (lets call her Alice) and a transaction service (lets call it "Joe's UltraTransactions" -- Ultra for short).Alice deposits 100 bitcoins into her Ultra wallet, and what actually happens behind the scenes is Alice's software generates a new keypair, gets a public key from Ultra, and coins are sent into a 2-of-2 transaction.Alice withdrawing the bitcoins (getting them out of the UltraTransaction system) is the boring case-- she'd generate a transaction, sign her half, then ask Ultra to sign the other half (and there would be some sort of authentication check-- maybe Ultra sends Alice an SMS to approve the withdrawal).Now Alice wants to pay Bob 10BTC, who also happens to be an UltraTransaction customer. This is where things could get interesting.Instead of generating a block-chain transaction, Alice could just give Bob her private key. Both Alice and Bob would sign a message with the private key saying "Alice is sending 10 bitcoins to Bob; she's given him the private key that she generated."  Bob would send the message to Ultra, which would send Alice an SMS to make sure she approves, and then any withdrawal involving those 10 bitcoins associated with that private key would require Bob's authorization instead of Alice's.Alice would still know the private key, but won't be able to spend what is now Bob's money (Ultra would only let her send/withdraw 90 of the 100 bitcoin tied up with that private key).Ultra is only semi-trusted; it never has the private key, so can't spend the coins without either Alice or Bob's aproval. Joe can't decide to run off with everybody's coins when the Ultra wallet is worth a few million dollars.Alice and Bob do have to trust that Ultra keeps track of who owns what accurately, and that Ultra will be around to sign it's half of the transaction when they want to withdraw some coin. And Bob has to trust that Alice did generate the private key, didn't share it with Ultra, and isn't actually Joe trying to trick him.That's quite a lot of trust required, but the ability to instantly transfer value between Ultra customers with zero Bitcoin-block-chain transaction fees might outweigh the risks. And there are probably variations on this idea that would minimize trust in Ultra (maybe there's a semi-trusted service that Ultra pays to keep offline, "use-only-if-we-go-out-of-business" backups of their private keys).And it scales beautifully; one UltraTransaction server cluster could easily handle hundreds or thousands of transactions per second, and you could imagine companies popping up all over the world, handling most transactions outside the blockchain. {full public key} OP_CHECKSIG is a valid, standard transaction type, redeemed by providing just {signature}. Several people have asked me privately via email what I think of Butterfly Labs and ASIC mining in general, so:What do I think of ASICs hitting the "mining scene" ?meh.It shows that Bitcoin is considered stable enough for a company to invest a LOT of money on design and production on it, which is very good. ASICs were bound to happen if Bitcoin survived long enough.The long-term outlook for mining is "mining will happen with very specialized hardware, in places where either electricity is free or generating lots of heat is a benefit and not a cost"  (and probably both; I still think Iceland will be a big mining hot-spot eventually).I'm not worried about Butterfly Labs deciding to take over the blockchain with their superior hashpower. They'd be idiots to do something like try to mount a 51% attack-- they don't want to kill Bitcoin, they want it to get more successful so they sell more hardware.And if they are successful they will very quickly have competitors.Full disclosure:  I spent some of my bitcoins to pre-order their USB coffee-warmer doo-hickey.  It gets cold here in the winter. See "Batch Mode" in the JSON 2.0 spec: http://www.jsonrpc.org/specificationYes, you can request information about many unrelated transactions in one call. I first heard about Bitcoin from this article:  http://www.infoworld.com/d/open-source/open-source-innovation-the-cutting-edge-582?page=0,2 Excellent point. I use python, which just works with different types in arrays, and C++/json_spirit, which also just works, but I can that other languages would be painful.I'll go through the raw transactions API and will replace any "Array of different types" with "Array of Objects". Sounds kind of like youtipit, which is shutting down:  http://blog.youtipit.org/?p=379 More discussions in IRC today prompted further tweaks to this API:"get any transaction, even transactions that aren't in your wallet" functionality will be moved from gettransaction to a new 'getrawtransaction' API call, for two reasons:1. It doesn't 'feel' right to mix the high-level info with the nitty-gritty low-level detail.2. We think there's a potential for security vulnerabilities if there are existing services that assume that 'gettransaction txid' returns an error for any transaction not in the wallet (as it does in all previous releases).So the new plan is to put the new functionality in a new RPC call:getrawtransaction <txid> [verbose=0]   :  If verbose=0, returns a JSON string that is the hex-encoded, serialized transaction. That is the "machine readable, as concise as possible" use case.  If verbose=1, returns a JSON object with all the nitty-gritty details, to cover all the other use cases.Also, Jeff already has a pull request for JSON-2.0 "batch" functionality, so if you need information about all transactions in a block or all of a transaction's parent transactions you can get it with one RPC round-trip. Rereading my original post, I should make clear: the people I really have issues with are the people who think it is more fun to try to destroy something than to help build it.  My comment about "I wish people would find more constructive things to do with their time" was not meant to be aimed not at AlternaCoin creators.I agree that there are some benefits to the alternate chains existing; I just wonder if the costs of all the duplicate infrastructure (exchanges and pools and faucets and...) is worth the benefits.RE: privately disclosing exploits to AlternaCoin developers: well, to be frank, I have no idea if most AlternaCoin developers can be trusted with sensitive exploit information or even who is currently supporting which chain. The danger would be somebody emailing me claiming to be the lead developer for FooCoin, I tell them about the vulnerability, and then they turn out to NOT be the lead FooCoin developer but an attacker.  Or I tell FooCoin about the vulnerability and they decide to use it to launch an attack on their arch-enemy, BarCoin.It is all drama and heartburn that I'd really rather not have (again, costs and benefits....) 1. Make sure the SHA256SUMS.asc file hasn't been modified:Code:$ gpg --verify SHA256SUMS.ascgpg: Signature made Mon Jun 25 10:57:21 2012 EDT using RSA key ID 1FC730C1gpg: Good signature from "Gavin Andresen (CODE SIGNING KEY) <gavinandresen@gmail.com>"2. See what file you SHOULD have downloaded:Code:$ grep macosx.dmg SHA256SUMS.asc 3de1490d1390e5a085b4bc2217430b3caadd203780a7bfe8751e8d1930f087cc  bitcoin-0.6.3-macosx.dmg3. Make sure the file you downloaded is exactly the same:Code:$ shasum -a 256 bitcoin-0.6.3-macosx.dmg 3de1490d1390e5a085b4bc2217430b3caadd203780a7bfe8751e8d1930f087cc  bitcoin-0.6.3-macosx.dmg Bitcoin version 0.6.3 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.3/This is a bug-fix release, with no new features.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesCHANGE SUMMARY==============Fixed a serious denial-of-service attack that could cause thebitcoin process to become unresponsive. Thanks to Sergio Lernerfor finding and responsibly reporting the problem. (CVE-2012-3789)Optimized the process of checking transaction signatures, tospeed up processing of new block messages and make propagatingblocks across the network faster.Fixed an obscure bug that could cause the bitcoin process to getstuck on an invalid block-chain, if the invalid chain washundreds of blocks long.Bitcoin-Qt no longer automatically selects the first addressin the address book (Issue #1384).Fixed minimize-to-dock behavior of Bitcon-Qt on the Mac.Added a block checkpoint at block 185,333 to speed up initialblockchain download.Thanks to everybody who contributed to this release:====================================================Chris MooreChristian von RoquesFordyGavin AndresenJeff GarzikLuke DashjrMatt CoralloMichael HendricksPeter ToddPhilip KaufmannPieter WuilleR E BroadleySergio LernerWladimir J. van der Laan Determining the "right" fees is a separate issue; see https://gist.github.com/2961409  for my current thinking.The raw transaction API will let you create and try to send a transaction with as much or little fees as you like, but if you try to send a 20 kilobyte transaction with zero fees you shouldn't be surprised if nobody relays or mines it.If you use the raw transaction API then you're responsible for saying exactly where all of the outputs go.  If you create a raw transaction with a 50 BTC input and a 2 BTC output then that is a no-change, 48 BTC fee transaction.  If you don't intend the 48 BTC to go to miners, then you need to specify where the change goes by adding another output.I suppose the RPC calls could have limits to try to keep you from shooting yourself in the foot, but anybody using the raw transaction API should be doing a lot of testing with worthless testnet coins and I'd rather not start playing the "lets write lots of code to try to prevent RPC-users from being dumb" game.
When I tell people I work on Bitcoin full-time, a somewhat common reaction is "Really?  I thought Bitcoin was finished, what do you work on?"I spend half my development time working on new stuff (or testing new stuff that other people have submitted), but the other half I spend trying to anticipate problems or reacting to problems that are reported. That work tends to be unseen, partly because we want to keep problems quiet while we fix them and partly because quietly anticipating/fixing problems minimizes the 'lulz' that attackers might enjoy if every single-node-DoS attack caused us to run around like chickens with our heads cut off.Anyway, good developers are hard to find, and one of the reasons I'm not thrilled by all of the AlternaCoins is because I'd rather a good developer help make Bitcoin better rather than spend their time with the busy-work of cross-porting the latest Bitcoin fixes to some other codebase. I would guess that some of the developers of the alternative chains underestimated the amount of work it takes to nurture them and keep them healthy. Maybe that will change when Bitcoin is truly mature and has dealt with another year or two or six of attacks and scaling issues...I truly don't mean this to sound like a threat, but I think some of the blockchains that have been chugging along running on an ancient forked version of the Bitcoin codebase will be attacked; pretty soon we'll be fully disclosing the denial-of-service bugs that prompted the 0.6.2/0.6.3 releases, and it is highly likely somebody will decide to play with exploit code on a vulnerable chain.I wish people would find more constructive things to do with their time, but I wish I could fly and never get old like Peter Pan, too. See the raw transaction API I've been working on, and please help try to break it-- it needs more testing.The main motivation is to move forward with multisignature transactions, but it also lets you have complete control over the source(s) for a transaction. My work on the 'raw transaction' API has me thinking hard about the gettransaction/getblock RPC calls. I want it to be easy for the information returned by those calls to be used by the new createrawtx/etc API calls.So:  in version 0.6.3 and earlier, gettransaction would only return information about transactions in your wallet, and would not return all of the information about the transaction.A month or two ago Pieter and Luke wrote code to modify gettransaction/getblock to return information about any transaction in the blockchain and a new 'decompositions' Object argument was added to those RPC calls that would let you specify 5 different ways to get information about transaction inputs and outputs (no/hash/hex/asm/obj).  So you might do:Code:gettransaction 0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098 '{"script":hex}'I think 5 different ways of getting (or not getting if you specify 'no') the information is 4 too many, so I'm modifying the code as follows:getblock doesn't change from version 0.6; it returns a list of transaction id's in a "tx" Array.gettransaction gets an extra boolean argument that defaults to 0 (false).  If non-zero is passed, then it is verbose and outputs information about the transaction inputs and outputs in all the different formats (same as what decomposition "obj" does).for compatibility with the 'raw transaction' API calls, gettransaction always return the full serialized-hex-encoded transaction data as a new "rawtx" field.The thinking is either RPC users will want minimal information quickly, or will want full information and won't care much if they get extra information. If you want full information as quickly as possible, then you should write code to decode the "rawtx" array yourself.This does mean getting full information for every transaction in a block means more than one RPC call, but Jeff has a pull request for JSON-2.0 "batch" calls, so getting full information about every transaction in a block will be just two RPC round-trips (one getblock, then one batch with a bunch of gettransaction calls in it).And to be clear: these changes are meant to be 100% backwards-compatible with getblock/gettransaction in version 0.6.3 and earlier.  We're talking about extra arguments and extra information in the returned JSON objects.Example output for a complicated multisignature testnet transaction:Short, in-wallet transaction:Code:$ ./bitcoind -testnet gettransaction 4ec492788efb3c9e4e23972f095bd575217288c9f6b8237922145aeff8dae8d5{    "rawtx" : "0100000001c6660657eb258f9e58d246d767f5aaa15980d4d26ee496e7e24fabf72f2cc3440000000048473044022026b2e3d408a7848ad18b35042163c0efb358c456c6006a0cd13c077ec213aeab02202115a38de465e0c927f858cbb83fca45bddb0e469524667e39fd0c54ab5007d701ffffffff0100f2052a0100000017a914b6cb85e6fa58b2bff3da23074eb0f1a0ddb23e1f8700000000",    "amount" : -50.00000000,    "fee" : 0.00000000,    "confirmations" : 2,    "blockhash" : "0000000003abdd41db27190bb4f19e36497f647d1ea586ef543c44f7ccd40015",    "blockindex" : 1,    "txid" : "4ec492788efb3c9e4e23972f095bd575217288c9f6b8237922145aeff8dae8d5",    "time" : 1339001503,    "details" : [        {            "account" : "",            "address" : "2N9uknE7Zy9M3cPxWvkHu9HQiArL3pnbcUF",            "category" : "send",            "amount" : -50.00000000,            "fee" : 0.00000000        }    ]}Verbose:Code:$ ./bitcoind -testnet gettransaction 4ec492788efb3c9e4e23972f095bd575217288c9f6b8237922145aeff8dae8d5 1{    "rawtx" : "0100000001c6660657eb258f9e58d246d767f5aaa15980d4d26ee496e7e24fabf72f2cc3440000000048473044022026b2e3d408a7848ad18b35042163c0efb358c456c6006a0cd13c077ec213aeab02202115a38de465e0c927f858cbb83fca45bddb0e469524667e39fd0c54ab5007d701ffffffff0100f2052a0100000017a914b6cb85e6fa58b2bff3da23074eb0f1a0ddb23e1f8700000000",    "version" : 1,    "locktime" : 0,    "vin" : [        {            "prevout" : {                "hash" : "44c32c2ff7ab4fe2e796e46ed2d48059a1aaf567d746d2589e8f25eb570666c6",                "n" : 0            },            "scriptSig" : {                "asm" : "3044022026b2e3d408a7848ad18b35042163c0efb358c456c6006a0cd13c077ec213aeab02202115a38de465e0c927f858cbb83fca45bddb0e469524667e39fd0c54ab5007d701",                "hex" : "473044022026b2e3d408a7848ad18b35042163c0efb358c456c6006a0cd13c077ec213aeab02202115a38de465e0c927f858cbb83fca45bddb0e469524667e39fd0c54ab5007d701",                "type" : "pubkey",                "addresses" : [                    "n4DUWe93vkdfAiSVDaMP3okaU7upK2wtrr"                ]            },            "sequence" : 4294967295        }    ],    "vout" : [        {            "value" : 50.00000000,            "scriptPubKey" : {                "asm" : "OP_HASH160 b6cb85e6fa58b2bff3da23074eb0f1a0ddb23e1f OP_EQUAL",                "hex" : "a914b6cb85e6fa58b2bff3da23074eb0f1a0ddb23e1f87",                "reqSigs" : 1,                "type" : "scripthash",                "addresses" : [                    "2N9uknE7Zy9M3cPxWvkHu9HQiArL3pnbcUF"                ]            }        }    ],    "amount" : -50.00000000,    "fee" : 0.00000000,    "confirmations" : 2,    "blockhash" : "0000000003abdd41db27190bb4f19e36497f647d1ea586ef543c44f7ccd40015",    "blockindex" : 1,    "txid" : "4ec492788efb3c9e4e23972f095bd575217288c9f6b8237922145aeff8dae8d5",    "time" : 1339001503,    "details" : [        {            "account" : "",            "address" : "2N9uknE7Zy9M3cPxWvkHu9HQiArL3pnbcUF",            "category" : "send",            "amount" : -50.00000000,            "fee" : 0.00000000        }    ]}The only feature that bothers me is reporting 'addresses/type' for transaction inputs. It bothers me for two reasons:1) It is expensive to fetch that data, because it means finding the previous transaction in the blockchain and fetching it from disk. It violates the principle that "a feature shouldn't cost you anything if you're not using it."2) If "we" implement spent-input pruning (Pieter has some fantastic early results) that data might not exist.I think it would be better to remove the 'addresses/type' information from gettransaction output, so gettransaction never has to lookup previous transactions.If you care about the previous transaction, then you would have to call gettransaction again, using vin.prevout.hash to look them up (and, again, using the JSON-2.0 'batch' feature to lookup all the prior transactions in one RPC roundtrip).If/when transaction pruning happens then the semantics are clear: that gettransaction would return an error if the prior transaction was pruned. I think "1 2 3 4" is bad.  4 is more than 1, so a level 4 vulnerability is worse, right?I still like critical/serious/other.  More gradations than that and I think we'll just waste time arguing over "is this a level 3 vulnerability?  level 4?  ok, let's make it a pi vulnerability (3.1415...)" Anybody know where I can buy an "I am a Space Lizard" T-shirt for bitcoin? I usually answer with:Why do screwdrivers have value? What backs the value of a screwdriver?Because they're useful and it takes effort to create them.Bitcoin has value for the same reasons. In the 0.6.3 thread Graet asks a good question:  what's do we mean by "critical" versus "serious" vulnerability?Here's what those terms mean to me.  All examples are hypothetical:A critical vulnerability is one that will have disastrous consequences if it is exploited. Examples might be a remote code exploit, a bug that somebody could use to take down the entire bitcoin network, or a bug that could be exploited to steal your entire wallet.A serious vulnerability is one that will have serious consequences if it is exploited.  Examples might be a bug that can be triggered by network traffic and will cause the software to stop working or a bug that could be exploited to misdirect your next bitcoin transaction so it goes to an attacker instead of the intended recipient.The 0.6.3 denial-of-service problem I consider "serious" -- an attacker who figures out exactly what the vulnerability is (we haven't disclosed that yet) can make bitcoind or Bitcoin-Qt stop processing transactions.Then there are run-of-the-mill vulnerabilities; things like Sybil attacks that require an attacker to round up hundreds or thousands of machines, or denial-of-service attacks that require that the attacker be able to send the victim gigabytes of network traffic. Dealing with these often doesn't even merit a mention in the release notes, because they affect so few people and require an attacker willing to spend a fair bit of money and/or effort just to be annoying. I'll buy my grandma a terabyte drive for Christmas.No, seriously, a better startup experience is part of "easy to use" -- waiting hours for the blockchain to sync sucks. The things on my "good enough to be called 1.0" list are:+ easy enough for my grandma to use+ secure enough that it'd be hard for my grandma to lose her bitcoins, even if her computer is infected by 11 bitcoin-stealing trojans and then catches fire and explodes.+ past the December block-reward-drops-to-25 Before you copy the blk* files, you must run with the -detachdb option and make sure you shutdown bitcoin and wait for it to exit completely.  With 0.6.2, we change the default from "take a long time to shut down, but leave standalone .dat files" to "shutdown quickly, but leave .dat files that are tied to the database/log.* files".Too many ordinary users were quitting bitcoin and then immediately powering off their systems, leaving the database in a bad state. We're releasing 0.6.3 to fix two important issues (a serious potential denial-of-service attack, and to improve new-block propagation times for blocks containing lots of transactions).If you can, please help do some sanity testing-- shutdown bitcoin, then download, install, and run 0.6.3 and let us know "works nicely for me running on 64-bit Ubuntu 10.04" by posting a quick reply to this thread.Release notes:Bitcoin version 0.6.3rc1 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.3/test/This is a bug-fix release, with no new features.CHANGE SUMMARY==============Fixed a serious denial-of-service attack that could cause thebitcoin process to become unresponsive. Thanks to Sergio Lernerfor finding and responsibly reporting the problem. (CVE-2012-3789)Optimized the process of checking transaction signatures, tospeed up processing of new block messages and make propagatingblocks across the network faster.Fixed an obscure bug that could cause the bitcoin process to getstuck on an invalid block-chain, if the invalid chain washundreds of blocks long.Bitcoin-Qt no longer automatically selects the first addressin the address book (Issue #1384).Fixed minimize-to-dock behavior of Bitcon-Qt on the Mac.Added a block checkpoint at block 185,333 to speed up initialblockchain download.Thanks to everybody who contributed to this release:====================================================Chris MooreChristian von RoquesFordyGavin AndresenJeff GarzikLuke DashjrMatt CoralloMichael HendricksPeter ToddPhilip KaufmannPieter WuilleR E BroadleySergio LernerWladimir J. van der Laan Chain proof-of-work is calculated based on the hash target, so if you get another block at the same height there is no benefit to keeping the one with "the smaller hash".Maybe if you receive a second block solution, keeping the block that removes the most transactions from the memory pool would be the right "good for the entire ecosystem" policy.  That way even if small blocks propagate slightly faster that might be offset if a larger, slower block was found.  (but making new-block-flooding independent of the size of the block is an even better solution, and that shouldn't be too hard to implement)Creating a semi-trusted backbone of connections to other pools/miners so your new blocks propagate quickly is a good idea. The RPC and GUI won't let you spend 0-confirmation transactions unless they are 'change' outputs from yourself.If you REALLY want to shoot yourself in the foot, I've got a pull request for the 0.7 release that adds 'raw transaction' RPC commands that will let you do all sorts of dangerous things, including counting your chickens before they've hatched spending unconfirmed-from-somewhere-else inputs. I gathered data on transaction first-confirmation times this weekend: https://docs.google.com/open?id=0B74FtkFP4j73TXZUY05kSFVzN00Each line in the file (except the first one) represents one transaction. Each column is:Number of seconds the transaction spent in the memory pool.Size, in bytes, of the transaction.Fees attached to the transaction (in satoshis).Priority (floating-point number) of the transaction when it first entered the memory pool.  Priority 0.0 transactions have inputs that aren't yet confirmed.Last column is "1" if the transaction exited the memory pool normally, by being included in the a block, or "0" if the transaction was still in the memory pool when I shut down bitcoind.--------------I haven't really analyzed it yet (feel free to help if you're a data geek); I plan on testing some algorithms for suggesting a reasonable fee if you want your transaction to get confirmed quickly, and suggesting an estimate of how long you'll have to wait if you don't attach any fee at all.But it look like 35% of transactions this past weekend got into a block within 10 minutes, and 87% got into a block within one hour. Luke is guessing it is SatoshiDice, it might just be a run of bad luck.Or it might be a side effect of Eligius accepting non-standard transactions.Does Eligius include transactions that have not been transmitted/relayed to the rest of the network?  If so, it might be a side effect of that (and if that isn't a side effect now, it might be in the future if Eligius blocks take longer to verify as other nodes need to fetch transaction inputs from disk, instead of already having them in cache memory like transactions that ARE transmitted/relayed). The 0.7 release will include an optimization that should help a lot (transaction signature cache -- prior releases checked signatures when the transaction was first seen, and then checked again when a new block was received, it makes processing new blocks much faster). This is why I think the so-called "stable" backports are a bad idea. I want people to spend time finding and fixing bugs in 0.6.2, and I want people to realize that the core developers are not supporting older releases. Cross-posting from the bitcoin-development list:I submitted a pull request yesterday that implements low-level "raw" transaction, and am looking for feedback on the API and help with trying to test/break it.Design doc:  https://gist.github.com/2839617Pull request: https://github.com/bitcoin/bitcoin/pull/1456Test plan: https://secure.bettermeans.com/projects/4180/wiki/Raw_Transaction_RPC_Test_PlanPlaying around with this API on the command line I'm pretty happy with the level of abstraction and the way it interacts with existing RPC commands; for example, "createrawtx" is just like "sendmany" in the way outputs are specified.The signrawtx method is the key new method; it takes a raw transaction, signs as many inputs as it can, and returns the same raw transaction with signatures. Typical usage would be:Funds are sitting in a multisignature transaction output, and it is time to gather signatures and spend them.Assumption: you know the multisignature transaction's [txid, outputNumber, amount].Create a raw transaction to spend, using createrawtx.Use signrawtx to add your signatures (after unlocking the wallet, if necessary).Give the transaction to the other person(s) to sign.You or they submit the transaction to the network using sendrawtx.I don't imagine anybody but very-early-adopters or ultra-geeks will do this by calling these RPC methods at a command-line. They are really intended for people writing services on top of bitcoind. The service should be careful to include an appropriate transaction fee, or the sendrawtx method is likely to fail.I've been asked a couple of times: why doesn't signrawtx handle the BIP 0010 (https://en.bitcoin.it/wiki/BIP_0010) transaction format?I considered parsing/writing BIP 10 format for raw transactions, but decided that reading/writing BIP 10 format should happen at a higher level and not in the low-level RPC calls. So 'raw transactions' are simply hex-encoded into JSON strings, and encoding/decoding them is just a couple of lines of already-written-and-debugged code.------Here is the help output and example use for all the new RPC calls:listunspent [minconf=1] [maxconf=999999]Returns array of unspent transaction outputswith between minconf and maxconf (inclusive) confirmations.Returns an array of 4-element arrays, each of which is:[transaction id, output, amount, confirmations]E.g:  listunspent 1 2Returns:[    [        "2881b33a8c0bbdb45b0a65b36aa6611a05201e316ea3ad718762d48ef9588fb3",        0,        40.00000000,        2    ],    [        "894a0fc535c7b49f434ceb633d8555ea24c8f9775144efb42da85b853280bcd7",        0,        50.00000000,        1    ]]getrawtx <txid>Returns hexadecimal-encoded, serialized transaction datafor <txid>. Returns an error if <txid> is unknown.E.g.: getrawtx fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233Returns:01000000016d40da062b6a0edcaf643b6e25b943baf103941589d287e39d6f425d84ae8b1c00000 0004847304402203fb648ff8381d8961e66ef61ab88afe52826a5179b8a7312742c8d93785ca563 02204240ea12de1211fffab49686f13ca0e78011d1985765be6e6aa8e747852f897d01ffffffff0 100f2052a0100000017a914f96e358e80e8b3660256b211a23ce3377d2f9cb18700000000createrawtx [["txid",n],...] {address:amount,...}Create a transaction spending given inputs(array of (hex transaction id, output number) pairs),sending to given address(es).Returns the same information as gettransaction, plus anextra "rawtx" key with the hex-encoded transaction.Note that the transaction's inputs are not signed, andit is not stored in the wallet or transmitted to the network.E.g.: createrawtx '[ ["fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233",0] ]' '{"mqYmZSQQuAWNQcdwBrDwmtTXg2TLNz748L":50}'Returns:{    "version" : 1,    "locktime" : 0,    "size" : 85,    "vin" : [        {            "prevout" : {                "hash" : "fce46ea2448820f7bb8091b5f5e3fd75b7b267e60b9a22af88a9eeabfb084233",                "n" : 0            },            "scriptSig" : "",            "sequence" : 4294967295        }    ],    "vout" : [        {            "value" : 50.00000000,            "scriptPubKey" : "OP_DUP OP_HASH160 6e0920fc26383dc7e6101bc417cf87169d0cedbd OP_EQUALVERIFY OP_CHECKSIG"        }    ],    "rawtx" : "0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc00000 00000ffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd 88ac00000000"}signrawtx <hex string> [<prevtx1>,<prevtx2>...]Sign inputs for raw transaction (serialized, hex-encoded).Second argument is an array of raw previous transactions thatthis transaction depends on but are not yet in the blockchain.Returns json object with keys:  rawtx : raw transaction with signature(s) (hex-encoded string)  complete : 1 if transaction has a complete set of signature (0 if not)E.g.: signrawtx "0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc00000 00000ffffffff0100f2052a010000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd 88ac00000000" '["01000000016d40da062b6a0edcaf643b6e25b943baf103941589d287e39d6f425d84ae8b1c00000 0004847304402203fb648ff8381d8961e66ef61ab88afe52826a5179b8a7312742c8d93785ca563 02204240ea12de1211fffab49686f13ca0e78011d1985765be6e6aa8e747852f897d01ffffffff0 100f2052a0100000017a914f96e358e80e8b3660256b211a23ce3377d2f9cb18700000000"]'Returns:{    "rawtx" : "0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc00000 0009100473044022007f3ba1b8bdc156f2340ef1222eb287c3f5481a8078a8dad43aa09fd289ba1 9002201cc72e97406d546dc918159978dc78aee8215a6418375956665ee44e6eacc115014752210 2894ca6e7a6483d0f8fa6110c77c431035e8d462e3a932255d9dda65e8fada55c2103c556ef01e8 9a07ee9ba61581658fa007bf442232daed8b465c47c278550d3dab52aeffffffff0100f2052a010 000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000",    "complete" : false}sendrawtx <hex string>Submits raw transaction (serialized, hex-encoded) to local node and network.E.g.: sendrawtx 0100000001334208fbabeea988af229a0be667b2b775fde3f5b59180bbf7208844a26ee4fc00000 0009100473044022007f3ba1b8bdc156f2340ef1222eb287c3f5481a8078a8dad43aa09fd289ba1 9002201cc72e97406d546dc918159978dc78aee8215a6418375956665ee44e6eacc115014752210 2894ca6e7a6483d0f8fa6110c77c431035e8d462e3a932255d9dda65e8fada55c2103c556ef01e8 9a07ee9ba61581658fa007bf442232daed8b465c47c278550d3dab52aeffffffff0100f2052a010 000001976a9146e0920fc26383dc7e6101bc417cf87169d0cedbd88ac00000000Returns:error: {"code":-22,"message":"TX rejected"}(Rejected because it doesn't have all required signatures, if it was accepted it would return the transaction id) Relevant discussion here:  http://crypto.stackexchange.com/questions/779/hashing-or-encrypting-twice-to-increase-security You're a crazy-man.  Crazy in a good way... ever do any APL programming?
Once upon a time bitcoin.org called Bitcoin "anonymous" but that was a mistake, and for at least two years "we" (core developers) have tried to be careful to say that, at best, Bitcoin is pseudanonymous.I tell reporters that Bitcoin is more private than using any other online payment method, but less private than cash (unless you know a lot about how it works under the covers and jump through several hoops to keep your identity secret). Where did you read that bitcoin is supposed to be anonymous? You just poked one of my pet peeves: the Y-axis on your Euro chart doesn't start at zero, so you're exaggerating it's volatility. No, I don't have a prototype.The hardware is real and very cool, but they've got a lot of work to do on software and user interface and manufacturing process and marketing and distribution and.... .  Expect the design to change before you can actually buy one. And like all really innovative projects (and to quote the MythBusters) "Failure is always an option."Answering detailed questions about exactly how it works right now would be a waste of time, because I think before it ships most of the answers will be different. The meeting in Vienna was for bitcoincard to get early feedback on whether or not they're headed in a good direction.RE: why would you want a bitcoincard versus just using your cellphone:  I personally think you'll want both; I'm trying to convince them that the bitcoincard could be a perfect "second device" for multisignature transactions. Cell phone viruses and trojans and malware will be the next big wave of security vulnerabilities. I've been switching back and forth between writing a spec for it ( https://gist.github.com/2839617 ), implementing it ( https://github.com/gavinandresen/bitcoin-git/tree/signrawtx ), writing up a test plan ( https://secure.bettermeans.com/projects/4180/wiki/Raw_Transaction_RPC_Test_Plan ) and testing.My goal is to get all that done by the end of this week and have it in the 0.7 release.  But lots of things could make it take longer. I actually created and spent some "input from wallet a", "input from wallet b" private testnet transactions earlier this week (I'm working on some lower-level RPC commands for bitcoind -- see https://gist.github.com/2839617  for the half-baked spec).Somebody could build a transaction-combining service on top of those low-level RPC commands, although I suspect to be really resistant to sophisticated network analysis doing "one or more inputs from A in,  one or more from B in, ApayToSomebody Achange BpayToSomebodyElse Bchange out" won't help much.  There is a lot of prior work on "mix networks" and maintaining anonymity, and the only thing I know about it is that it is a hard problem to get right. RE: the 100/120 difference:Check my work, but I think this is the scenario where it would matter and cause headaches:You generate a block 100 blocks before a difficulty adjustment.Then you spend the coinbase exactly 100 blocks later, in a block in the next difficulty period. And, let's say, whoever you send the bitcoins to spends that transaction again immediately.Now imagine a really wacky scenario where you're reorganized onto a shorter-but-has-more-difficulty block chain.  That could happen if you were disconnected from the main bitcoin network for a while.Your coinbase-spend transaction and any transactions that depend on it can't be included in the main chain because they're immature, so they get dropped from everybody's memory pool as "trying to spend an immature coinbase."  I'm not sure what then happens; I think you'd eventually retransmit them and get them into the main chain, but that could take a while. Yes... but having peers with a completely different block chain from you connect is a good way to shake out obscure bugs.  Like Bitcoin-Qt's "how many blocks are in the valid chain" code getting fooled... Bitcoin-Qt ?  Sounds like a bug in the "estimate how many blocks there are based on what your peers tell you" bug. Signatures are BER-encoded data structures, and can be an arbitrary number of bytes (if they're DER-encoded, which is the strict subset of BER encoding, then they're 70-something bytes).Public keys are either 33 or 65 bytes (not counting the "push the next N bytes onto the stack" CSCript opcode).I've got to say you make me nervous; you seem to be following a "make it work for a couple of test cases then move on" style of development, which is a bad way to create a secure, robust codebase.PS: I sympathize with you RE: OpenSSL's lack of documentation.... I just got stuck-- looks like somebody is serving up the testnet2 blockchain to testnet3 nodes that connect to them (that's what is causing the 'nBits below minimum work' message).Re-running to connect to a real testnet3 node is getting me the correct blockchain (with 6,905 blocks). I think consolidating everything under one domain is dangerous and against the decentralized nature of the Bitcoin project. I'd love to see somebody resurrect the Visual C++ makefile and build instructions (and let us know if we've accidentally added and gcc-specific code), so Windows developers didn't have to spin up a VM and cross-compile everything.As to why your builds are different:  no idea, but you can look at the file-by-file checksums in the bitcoin-build.assert file to see exactly what is different. I should lie and say I'm feeling extra generous to miners this morning and wanted to give them an imaginary 50 BTC fee... How would you use a 'getaddressbalance'?  What are you trying to do?Start with an empty wallet.  I send you 100 BTC to address 'foo'. Then you send somebody else 1 BTC.Internally, a new change address with 49 (edit: 99) bitcoins is created, so getaddressbalance 'foo' would return zero. Would that ever be the right answer? I love you guys, and hope you're being wildly successful... but:Plugging in "Deposit $200, get $192" for a cash deposit and then finding out I'll actually have to bring $204.95 or $201.58 because of an extra third-party processing fee feels like bait-and-switch to me. Don't you know in advance how much the payment processors will charge?  Does it vary based on location or something? Ummm....When you run something like:  Code:bitcoind getinfo... bitcoind creates a network connection to localhost:rpcport and talks to the running bitcoind process via the JSON-RPC protocol.So it doesn't matter what user the Code:bitcoind getinfo process is running as, what matters is securing access to the JSON-RPC network port, keeping the rpcpassword a secret, and preventing attackers from getting in and copying wallet.dat. Once.(it is actually once every couple of months, but that's a secret and might change so don't tell anybody that) Sipa has been busy implementing IPv6 support and much better support for running bitcoin as a Tor hidden service. Both of those should help make the network more robust and resistant to attack. If a lot of people decide to run only inside Tor then it will look like even fewer nodes are listening, though. Use one of the send commands to send to the multisig address several times and you will create several multisig transactions.addmultisigaddress does not create a transaction, it just creates a place for future transactions to go. 
There will be 2.1 quadrillion satoshis.There are approximately 770 trillion pennies in the US M2 money supply.We've got a VERY VERY long way to go before bitcoins are as popular as dollars, and there are much higher priority things to work on right now than adding more divisibility for a problem that is pretty likely to never actually be a problem. etotheipi:Sorry, I was responding to the original proposal, not yours, I should have made that clear.Better protocol support for lightweight clients is a Good Idea. And in two years maybe anybody who can afford to buy an asic-mining-space-heater for their house can mine.  And in ten years maybe new houses will come pre-equipped with asic-mining-baseboard-electric-heaters.Or maybe not.  Nobody knows what is going to happen, which is why I keep repeating BITCOIN IS AN EXPERIMENT IN PROGRESS.  If you can't handle uncertainty and the very real possibility that the experiment will fail, then don't get involved (but don't come back whining that you missed out if the experiment turns out to be a huge success).No, I don't think it is a problem, any more than the relatively small number of "backbone" routers are a problem for the Internet. The bitcoin network is evolving in roughly the direction I expected it would (lots of lightweight clients connecting to a smaller number of heavyweight "backbone" nodes).All of the incentives are for merchants, exchanges, and big mining pools to accept lots of connections, relay only valid transactions and blocks, and be as DoS-resistant as they can afford. Merchants and exchanges want transactions to be validated quickly, the big mining pools want their payouts to be processed quickly and want their blocks propagated quickly, and they all want to be reliable.  The big exchanges and mining pools have ALREADY implemented DDoS countermeasures because they have ALREADY been attacked. And the network keeps chugging away, processing transactions.... Chaining not-yet-signed transactions is impossible because transaction inputs are identified by the previous transaction's hash, and the transaction's hash includes everything about the transaction, including the signatures.A multisignature transaction taking funds from #1 and paying them to #4 that requires signatures from #1, #2, and #3 should accomplish the same thing, though. So code up a prototype:+ Implement code that computes and publishes 'balance blocks' and 'balance block hashes'. Convince a couple people with extra download bandwidth to run it.+ Modify one of the bitcoin implementations to download the latest 'balance block' from some trusted place at startup, and use it if transactions/blocks can't be found in the traditional block database.+ Extra credit/paranoia : query a couple of trusted places for the balance block hash, and make sure it matches the hash you got.+ OR: randomly spot-check the balance block by requesting blocks in the traditional way, and make sure the balance block doesn't list any outputs as unspent that are actually spent.You don't want bitcoin address balances, there are no addresses way down deep inside. You need to know which transaction outputs have not yet been spent, and the value of those outputs.I'm not excited about this proposal, because I think it is solving a problem that doesn't need solving yet, and my priorities for bitcoin continue to be wallet security and network stability, not making it quicker for newbie solo miners to get a full blockchain so they can start validating transactions/blocks. The format is a list of pairs, where the first item is the scriptSig required to spend and the second is the scriptPubKey. The third item is ignored (useful for comments).script_valid.json contains only valid scriptSig/scriptPubKey pairs.script_invalid.json contains only invalid scriptSig/scriptPubKey pairs.valid/invalid are defined by the rules of transaction validation, and the unit test actually constructs transactions and runs the verification routine on them to make sure that they succeed or fail, as expected. Your unit tests look like they'll miss lots of edge cases.I've been working on cross-implementation unit tests for Script, and am actually working on more tests today (and am working on a testnet reset that will embed the "should validate" tests into the testnet block chain).JSON format tests are here:  https://github.com/bitcoin/bitcoin/tree/master/src/test/data(read by https://github.com/bitcoin/bitcoin/blob/master/src/test/script_tests.cpp ) Works in a Terminal on my Mac, returns:... which validates as:I don't know enough about Windows CLI quoting rules to get ["...","...","..."] passed un-modified to bitcoind.exe.   No. Bitcoin connections are TCP, so you can't forge the IP address.I've also implemented denial-of-service checks that automatically ban misbehaving peers to make network disruption attacks more difficult. Trying to anticipate future DoS attacks is hidden engineering work that you will never notice if we get it right. The Bitcoin Faucet's wallet was stolen a couple of months ago:  http://gavintech.blogspot.com/2012/03/bitcoin-faucet-hacked.html Gather (or generate) 3 bitcoin addresses, on whichever machines will be participating, using getnewaddress or getaccountaddress  RPC commands (or copy and paste from the GUI).Get their public keys using the validateaddress RPC command 3 times.Then create a 2-of-3 multisig address using addmultisigaddress; e.g.addmultisigaddress returns the multisignature address. Be a little careful, the public keys are raw hexadecimal and don't contain checksums like bitcoin addresses do.You can then send funds into that 2-of-3 transaction using the normal sendtoaddress/sendmany RPC commands, or the GUI (or anything that's been updated to recognize multisig addresses).That will create a multi signature transaction.If you want to then SPEND the funds sent in that 2-of-3 transaction... that isn't implemented yet (well, if bitcoin has all 3 private keys in it's wallet then the funds will show up in the wallet's total balance and it may be selected to be spent like any other funds received by the wallet). "We" need to implement RPC calls to implement BIP 10 or something like it. What Pieter said. BIPs are intended to make it easier for different implementations of Bitcoin to inter-operate with each other. The existing network protocol is just one piece of that. Bitcoind doesn't run on ppc-- and minimum supported osx version is 10.5.And Armory depends on bitcoind, right? We have been quietly notifying the largest exchanges, merchant service providers and mining pools about this issue, and waited until they upgraded or patched their code to go public with this:-----BEGIN PGP SIGNED MESSAGE-----Hash: SHA512CVE-2012-2459: Critical VulnerabilityA denial-of-service vulnerability that affects all versions ofbitcoind and Bitcoin-Qt has been reported and fixed. An attackercould isolate a victim's node and cause the creation of blockchainforks.Because this bug could be exploited to severely disrupt the Bitcoinnetwork we consider this a critical vulnerability, and encourageeverybody to upgrade to the latest version: 0.6.2.Backports for older releases (0.5.5 and 0.4.6) are also available ifyou cannot upgrade to version 0.6.2.Full technical details are being withheld to give people theopportunity to upgrade.Thanks to Forrest Voight for discovering and reporting the vulnerability.Questions that might be frequently asked:How would I know if I am the victim of this attack?Your bitcoin process would stop processing blocks and would have adifferent block count from the rest of the network (you can see thecurrent block count at websites like blockexplorer.com orblockchain.info).  Eventually it would display the message:"WARNING: Displayed transactions may not be correct!  You may need toupgrade, or other nodes may need to upgrade."(note that this message is displayed whenever your bitcoin processdetects that the rest of the network seems to have a differentblock count, which can happen for several reasons unrelated tothis vulnerability).Could this bug be used to steal my wallet?No.Could this bug be used to install malware on my system?No.-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)iQIcBAEBCgAGBQJPsTpaAAoJECnZ7msfxzDB76cQALBqcEb40dQOtopbsk7vHDuLFL4xd56B1/s3idyHGeCuwJX5bgxGD9b3svayXhDiLo9O+5E3sxsLY1HehTXnU8KVBGpIQ7I+XLDcmarGYrDLMNMDLFOp/1hTipi08X3cr6oHNdYOxGbdtqCQR8xxtdfhMmo07ReYYWamlF+QbwoXIJQOEka2UVeWWgmk1C+WW1phI3P3Of5EvWvkmOurZsY1zew7G3sk0Lu8glxSt8qq1SKlDXOaSqTBPxs+2FtgkUplNrAIyufu0vCTsnC44oiendJD6XZAaG6cYr3adGQKmUjRR+oyZarMtBdDHBvYHkrQI4uQclL1aS7DhkLtH8kpfBRHdqmbBJpmpWOcs+OZeaQCzrArKihuVVZqP4HYbHgGHLV3Ls1bebyWm5eLZH6ZC5l3B4Hz/lp50gJpVsIZI291l3KWfoBW2qGyQv51U4uByLU8tPzgr5bdyo6YCo4NXQZHveNInMDI8jSimGyHg7WNm0YjkSAM8PEIJhQuL+RaHKgN/ghLPR+1K1YZnMjqBPdJZVDpP2bgClyj6P+UkhAplEoenxZUsjyRmcs9EWjHZo3UUI9MLZW96vkR0WlvUBgq0/jSNQ6s3U3YwKM8CDFJ4OB7Mu1Ln6sn+Tu5sl3xtPyapARA5K67FYSpvqVXGNIME8aiNjICQmtIFiuX=9L8G-----END PGP SIGNATURE----- I'm definitely not in the "speculators are evil" camp.  Speculation for the right reasons (hedging risk, for example) is a very good thing.I personally think speculation for the thrill of gambling is not a good thing, but I'm also not in the "Every Bad Thing (where I get to decide what Bad and Good is) Should Be Illegal" camp. If you want to gamble you should be free to do so; I think it is stupid that we let rich people on Wall Street gamble with other people's money and yet have laws that make it illegal for not-so-rich people to gamble with their own money.From his post, Tong thought about Bitcoinica and decided that he could be more effective at making the world a better place by working on something else that is more obviously positive-sum. Good for him! It seems I touched a nerve when I said that getting better at playing a zero-sum game isn't a good way to make the world a better place.I was thinking of day-traders at the time; people who don't care what asset they're buying and selling but just try to buy low and sell high to make a profit. Or high-frequency traders who try to be just a tiny bit faster executing transactions to take advantage of tiny inefficiencies in markets.Probably I don't have a deep enough understanding of the value of liquidity in asset markets or a deep enough appreciation for their role in creating market prices, but it seems to me the world would get along just fine without them spending all their time and effort competing against each other.I wasn't thinking of competition in general as being a zero-sum game, because in general it is not.  Competition drives efficiency, and efficiency (creating more by using less) is what makes the world a better place -- assuming that the thing you're making more efficient has a positive effect on the world.  Competing to build the most efficient bomb or assault rifle is not a world-improving activity.To bring it back to Bitcoin: competition between Bitcoin miners is a zero-sum game for the miners, but if you think that Bitcoin will make the world a better place (I do) then the competition to be more efficient at mining is a net positive for the world as a whole. Good luck-- I share your view that coming up with better ways of playing zero-sum games is not the way to make the world a better place. Do you get different answers for 'getbalance'  versus 'getbalance "*"' ?There is a longstanding issue with they way unconfirmed transactions are counted that might be the source of your problem:  https://github.com/bitcoin/bitcoin/issues/172 Pieter fixed the "100% usage on OSX bug" and I created and uploaded a fixed version 0.6.2.2 especially for the Mac.RE: upgrading:  the best upgrade practice is to:1) Backup your wallet someplace safe (if you're running an 0.6 release then use the Backup Wallet menu item).2) Shutdown. Make sure Bitcoin isn't still in your system tray-- don't just close the window, shut it down.3) Wait a minute or two (it can take older versions a minute or two to completely shut down)4) Install and run the new version. Over 50 BTC in donations with no fundraising effort-- thanks everyone who has donated so far! 
Because when I was a young child a Portuguese family lived across the street from me and their oldest child bullied me mercilessly, making fun of my haircut and my funny Australian accent.(KIDDING!  JUST KIDDING!)Somebody to do translation quality assurance is a great idea. Want to volunteer? Yeah, but you're probably a geek and think cute cat videos have too little actual information, too.The video gets a +1 from me; effective marketing appeals to emotion, not intellect. Bitcoin version 0.6.2 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.2/This is a bug-fix and code-cleanup release, with no major new features.Please report bugs using the github issue tracker at:  https://github.com/bitcoin/bitcoin/issuesNOTABLE CHANGES===============Much faster shutdowns. However, the blkindex.dat file is no longerportable to different data directories by default. If you need aportable blkindex.dat file then run with the new -detachdb=1 optionor the "Detach databases at shutdown" GUI preference.Fixed https://github.com/bitcoin/bitcoin/issues/1065, a bug thatcould cause long-running nodes to crash.Mac and Windows binaries are compiled against OpenSSL 1.0.1b (Linuxbinaries are dynamically linked to the version of OpenSSL on the system).CHANGE SUMMARY==============Use 'git shortlog --no-merges v0.6.0..' for a summary of this release.Source codebase changes:- Many source code cleanups and warnings fixes.  Close to building with -Wall- Locking overhaul, and several minor locking fixes- Several source code portability fixes, e.g. FreeBSDJSON-RPC interface changes:- addmultisigaddress enabled for mainnet (previously only enabled for testnet)Network protocol changes:- protocol version 60001- added nonce value to "ping" message (BIP 31)- added new "pong" message (BIP 31)Backend storage changes:- Less redundant database flushing, especially during initial block download- Shutdown improvements (see above)Qt user interface:- minor URI handling improvements- progressbar improvements- error handling improvements (show message box rather than console exception,  etc.)- by popular request, make 4th bar of connection icon greenThanks to everybody who contributed to this release:Chris MooreDwayne C. LitzenbergerGavin AndresenJeff GarzikLuke DashjrMatt CoralloPhilip KaufmannPieter WuilleR E BroadleyTimothy RedaelliWladimir J. van der Laancardpuncherfreewilgraingertsje397 On restart, you should be able to ask bitcoind for the top-of-chain block (using getblockcount/getblockhash/getblock).If it's not in your database, then add it.  Then look at the previous block hash, and if it's not in your database ask bitcoind for it (and so on).To be extra safe, after you're all done ask bitcoind for the top-of-chain block again to see if there was a block re-org while you were catching up. See https://en.bitcoin.it/wiki/Public_relations We'll announce a 0.6.2 later today, which is just 0.6.1 plus a last-minute bugfix for a crashing bug (I was THIS CLOSE to formally announcing 0.6.1 when Pieter found and fixed the bug...). @luke-jr : I don't want to start an argument, but I still think we don't have enough testing resources to support 4 releases. I think we need to establish good QA for the main Bitcoin-Qt/bitcoind release before we worry about next-test or so-called-"stable" releases.That's a good discussion for the Testing Project team to have, though, once it gets up and running a little more.I'd also like the Testing Project to not get pigeonholed into "QA testing for Bitcoin-Qt/bitcoind", but to tackle cross-implementation compatibility (which I think is the next big, critical issue). I'd still like to see several somebodies who know a lot more about networking than I do work on transmitting Bitcoin traffic over different networks (along with bridge nodes to shuffle traffic between the network we have now and the new networks).I'd sleep easier if I knew that an as-yet-undiscovered bug in the network protocol we have now couldn't bring the entire system down. I'm confident we'd quickly fix whatever the problem is and I'm sure it would be back up and running within 24 hours, but it would be better if big merchants and miners and services could run two or more completely different bitcoin-network-stacks so they're less likely to be taken down by DoS attacks, bugs, or ISPs deploying deep packet inspection to try to block Bitcoin traffic. +1I still expect it to be a long and very bumpy road, but as long as the system keeps chugging away reliably processing transactions I think it will, overall, in the long run, gain more and more trust. Miners won't switch to a 51% chain if it means they can't cash out the coins they're creating!The attack we're talking about is "51% attacker refuses to include anybody else's transactions in their blocks."  And newly generated coins are useless to miners if they can't get transactions that spend them into the block chain.... I said:I like decentralized approaches, because failures are less catastrophic and because I think smaller, focused organizations are more effective than big, try-to-be-everything-to-everybody organizations.So I'm happy that the Cryptocurrency Legal Advocacy Group is working on legal issues, starting with figuring out what the issues are.And I'm happy that LoveBitcoins have been starting PR/Marketing efforts for Bitcoin.Today I created the Bitcoin Testing Project to tackle some infrastructure needs that I think are being ignored (rigorous quality assurance / testing):   https://bitcointalk.org/index.php?topic=80019.0 I setup the wallet this afternoon, the donation address was:  (defunct address, don't send coins...) I've been procrastinating creating a "Bitcoin Testing Project" to fund testing work, and I was actually thinking a few days ago that vulnerability bounties would fit in nicely as one of the things a Bitcoin Testing organization would tackle.I decided to stop procrastinating today; see my announcement here for a Bitcoin Testing Project:   https://bitcointalk.org/index.php?topic=80019.0 Testing changes to Bitcoin-Qt continues to be a chronic problem, and as alternative implementations of Bitcoin start to mature testing to make sure that they interoperate correctly and don't harm the network will become a big problem.Therefore, I'm creating a decentralized, transparent organization using the BetterMeans system. I'll need help from people willing to be fundraisers, testers, project managers, toolmakers, troll-catchers, etc.I'll create and hold a secure wallet that will be used for donations (at least until the project gets mature enough to turn over that responsibility to somebody else), but we'll use the BetterMeans "Credits" system so that everybody working on the project collaboratively decides who gets what, and what the priorities aught to be.So: it is easy to talk about stuff like this, who's willing to help make it happen?  Send me an email at gavinandresen@gmail.com if this sounds like a project you'd like to help with, describing what you think the highest priorities for the project aught to be, how you could contribute, how much time you could contribute per week, and any relevant prior experience. See doc/build-osx.txt in the source tree for how to build bitcoind on osx.See doc/readme-qt.rst  for how to build Bitcoin-Qt. That's a BIP 16 transaction:  see https://en.bitcoin.it/wiki/BIP_0016 I think this is The Idea That Will Not Die.Bottom line: ain't gonna happen, everybody who created or purchased bitcoin over the last three years did so with the expectation the they would last forever, not that they would have some arbitrary 5-year expiration date. Yes, the "from" account-- I think bitlane wants the "to" account... So you create a 'send' transaction:Code:sendtoaddress msK1Hu7N27XTcuXd5MqWuyhW3YEGxHgVPe 11 "Testing" "One, two, three"a9e19baabc3929f0940805e69370d4aefa981cbe9cb8f5ea9184f5f6909a8544... and you've associated msK1Hu7N27XTcuXd5MqWuyhW3YEGxHgVPe with the label "2_address":Code:setaccount "msK1Hu7N27XTcuXd5MqWuyhW3YEGxHgVPe" "2_address"listtransactions looks like this:Code:{        "account" : "",        "address" : "msK1Hu7N27XTcuXd5MqWuyhW3YEGxHgVPe",        "category" : "send",        "amount" : -11.00000000,        "fee" : 0.00000000,        "confirmations" : 0,        "txid" : "a9e19baabc3929f0940805e69370d4aefa981cbe9cb8f5ea9184f5f6909a8544",        "time" : 1336073201,        "comment" : "Testing",        "to" : "One, two, three"    }... because "send" transactions always report a negative amount (you're sending coins) and the account that they're being sent from.If you want to know the account/label associated with the address that you're sending to, do this:Code:getaccount msK1Hu7N27XTcuXd5MqWuyhW3YEGxHgVPe2_address... or you could use the [comment]/[comment-to] params to the sendtoaddress/sendfrom/sendmany commands if you want the "to-account" to show up in listtransactions. I think it is a waste of time to maintain so many old versions.But it's Luke's time to waste...
Interesting.If I understand correctly, if an address has a greater-than-average amount of currency then it will get interest.Paid for by all the accounts with a less-than-average amount of currency.So there's an incentive for everybody to (try to) be above the average. That seems like a recipe for a lot of disappointed people, especially since a graph of size-of-account will have a long tail with of lots of little accounts.Making a half-thought-out-prediction, I'd say the end result would likely be one big centralized account controlled by the largest exchange with over 50% of the currency in it, because there would be a natural incentive to store your money in the biggest account so you get the most interest... Bitcoin version 0.6.1rc2 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.1/test/This is a bug-fix and code-cleanup release, with no major new features.NOTABLE CHANGES===============Much faster shutdowns. However, the blkindex.dat file is no longerportable to different data directories by default. If you need aportable blkindex.dat file then run with the new -detachdb=1 optionor the "Detach databases at shutdown" GUI preference.Mac and Windows binaries are compiled against OpenSSL 1.0.1b (Linuxbinaries are dynamically linked to the version of OpenSSL on the system).CHANGE SUMMARY==============Use 'git shortlog --no-merges v0.6.0..' for a summary of this release.Source codebase changes:- Many source code cleanups and warnings fixes.  Close to building with -Wall- Locking overhaul, and several minor locking fixes- Several source code portability fixes, e.g. FreeBSDJSON-RPC interface changes:- addmultisigaddress enabled for mainnet (previously only enabled for testnet)Network protocol changes:- protocol version 60001- added nonce value to "ping" message (BIP 31)- added new "pong" message (BIP 31)Backend storage changes:- Less redundant database flushing, especially during initial block download- Shutdown improvements (see above)Qt user interface:- minor URI handling improvements- progressbar improvements- error handling improvements (show message box rather than console exception,  etc.)- by popular request, make 4th bar of connection icon greenThanks to everybody who contributed to this release:Chris MooreDwayne C. LitzenbergerGavin AndresenJeff GarzikLuke DashjrMatt CoralloPhilip KaufmannPieter WuilleR E BroadleyTimothy RedaelliWladimir J. van der Laancardpuncherfreewilgraingertsje397 Network effect.More developers are working on Bitcoin, there are more interesting projects, more useful tools, more documentation at places like bitcoin.stackexchange.com, etc. And that all builds on itself. Yes. And yes. If a 51% attacker stopped including all broadcast transactions in blocks "we" would quickly figure out a rule or rules to reject their blocks.Something like "ignore a longer chain orphaning the current best chain if the sum(priorities of transactions included in new chain) is much less than sum(priorities of transactions in the part of the current best chain that would be orphaned)" would mean a 51% attacker would have to have both lots of hashing power AND lots of old, high-priority bitcoins to keep up a transaction-denial-of-service attack. And they'd pretty quickly run out of old, high-priority bitcoins and would be forced to either include other people's transactions or have their chain rejected.I'm tempted to code that up and run some tests on a testnet-in-a-box, but there are much higher priority things on my TODO list; I don't think a 51% attack is likely. You'd spend a lot of time and money on an attack that "we" would neuter within a day or two. I blogged about the CoinLab deal (the post wanders off into bigger-picture economics thoughts at the end):  http://gavinthink.blogspot.com/2012/04/coinlab-and-bitcoin.html I have a -noprivacy patch that I use for the Faucet that accomplishes what you want, sending any change back to the funding address.It isn't part of the core code because it doesn't play nicely with other features (accounts and listtransactions, for example). See https://github.com/gavinandresen/bitcoin-git/tree/noprivacy  There's one selling for about 2 BTC (equivalent) here: http://cheshirehorse.com/Buggy-Whip-P6374.aspxI wonder how that compares to the inflation-adjusted buggy-whip price in 1900... I pinky-swear on a stack of bibles I haven't heard a peep from Satoshi.Whatever he/she/they have been busy doing, I guess he/she/they're still busy doing it. Or maybe doobadoo is Satoshi and is trying to misdirect us.... Of course fungibility is important.But fungibility isn't all-or-nothing, and, in my humble opinion, it isn't all-important. Refusing to accept dollar bills or bitcoins that you believe were obtained illegally makes them less fungible, but so what?  It's the right thing to do. Cross-posted from the Alternative Clients sub-forum, since it looks like the alternative client folks are more interested in adding new features than figuring out exactly how the features we already have work:Better testing, both for the Satoshi code and across different implementations, is right at the top of my priority list. So I wrote some code to make it easier to exercise edge cases in Script evaluation:  https://github.com/bitcoin/bitcoin/pull/1121/filesThe unit tests are data-driven by two files: script_valid.json  contains pairs of (scriptSig,scriptPubKey) that, when used in a transaction, should evaluate to true. script_invalid.json  contains pairs that are invalid for some reason.I'm looking for help to expand those to cover all the quirky edge cases that might trip up alternative "fully validating" implementations (excluding OP_CHECKSIG/OP_CHECKMULTISIG, I'm still thinking about how best to write test cases for those). If you can help, please jump in and write some more. Assuming you've got the bitcoin source tree cloned the process for adding new tests is easy:1. Edit src/test/data/script*.json2. From the src/ directory run:   make -f makefile.unix test_bitcoin3. Run the unit tests with:  ./test_bitcoinOr if you've already got Script test cases in some other human-readable form please point me to them.I'm planning on resetting the testnet with a new genesis block and a chain that contains all of the valid tests as spent transactions (and a checkpoint so all those nice test cases aren't overwritten).It would be really nifty to have a 'bad chain' node running; -connect to it and it would send you otherwise-valid blocks that contained one or more of the invalid transactions from script_invalid.json. Does that sound like a project any of you would like to tackle? I agree with Andrew. Building a website that handles money is a terrible first project. We should have, but "we" didn't think of that in time.I've been working on a "how to do it better next time" document:  https://gist.github.com/2355445 Better testing, both for the Satoshi code and across different implementations, is right at the top of my priority list. So I wrote some code to make it easier to exercise edge cases in Script evaluation:  https://github.com/bitcoin/bitcoin/pull/1121/filesThe unit tests are data-driven by two files: script_valid.json  contains pairs of (scriptSig,scriptPubKey) that, when used in a transaction, should evaluate to true. script_invalid.json  contains pairs that are invalid for some reason.I'm looking for help to expand those to cover all the quirky edge cases that might trip up alternative "fully validating" implementations (excluding OP_CHECKSIG/OP_CHECKMULTISIG, I'm still thinking about how best to write test cases for those). If you can help, please jump in and write some more. Assuming you've got the bitcoin source tree cloned the process for adding new tests is easy:1. Edit src/test/data/script*.json2. From the src/ directory run:   make -f makefile.unix test_bitcoin3. Run the unit tests with:  ./test_bitcoinOr if you've already got Script test cases in some other human-readable form please point me to them.I'm planning on resetting the testnet with a new genesis block and a chain that contains all of the valid tests as spent transactions (and a checkpoint so all those nice test cases aren't overwritten).It would be really nifty to have a 'bad chain' node running; -connect to it and it would send you otherwise-valid blocks that contained one or more of the invalid transactions from script_invalid.json. Does that sound like a project any of you would like to tackle? Good question. They're the Mint, so I bet they'll handle that the same way they handle somebody showing up at a bank with a bunch of counterfeit $100 bills: they'll ask you where you got them, and either throw you in jail (if they don't like your story) or tell you to be more careful about who you deal with and maybe direct you to some technology to help detect counterfeits in the future. But they won't let you deposit them or trade your bad money for good. RE: $100 per-transaction, $500 balance limit:That makes perfect sense; they probably figured out about how much it will cost to hack a MintChip to get it's private key (dissolve case in acid, put it under an electron microscope, attach electrodes at exactly the right spots, etc...). Do a little calculation involving the cost of hacking one chip, the number of times you can double-spend before you're likely to get caught and the maximum amount per transaction and I bet they figure it doesn't pay.Especially if online transactions "phone home" to detect double-spends.  If you have to physically walk to 500 different not-online merchants to get away with $50,000 worth of double-spends that's just like counterfeiting $100 bills, and that's an attack Mints have been pretty successfully dealing with for hundreds of years.RE: anonymity: the anonymity model is similar to Bitcoin. Each physical MintChip is like a Bitcoin keypair, if you can easily buy/load a bunch of them anonymously then it will be hard for Them to track your purchases.If MintChip fails I bet it is not due to hacking or lack of anonymity, but just due to the inconvenience of needing Yet Another Physical Doohickey. Paper money fits nicely into the wallet I already have, I don't want Yet Another Dongle on my keychain, and I bet before the end of the year either Apple will finally approve a Bitcoin app or there will be a nifty HTML5-based web wallet I can use on my iPhone... Or maybe you should wait 60 blocks before considering a half-a-million-dollar transaction final if you think there is any possibility of a mining cabal trying to do this.All of this reminds me, I need to clean up my user-defined-checkpoints code for the 0.7 release, so a cabal of merchants and exchanges can get together and decide they will "lock in" an agreed-upon blockchain after 6 (or 60 or whatever) confirmations. I think that would go a long way towards infrastructure for injecting real-world knowledge about who is trustworthy into the block-chain. Split from the press hits topic:The only "skeleton key" I have is the private key for alert messages, that lets me sign messages that are broadcast and then displayed in the client (see https://en.bitcoin.it/wiki/Alerts for details, and the alerts that have been sent).MAYBE he is saying that the core developers could slip in a change to the source code without anybody else noticing... but we've worked hard to make that impossible (with things like the gitian reproducible build system so people can verify that we are creating executables from the source code that anybody can look at).Smells like plain-old FUD to me. The Bitcoin ecosystem consists of more that just miners, and even if miners decided to try to form a cabal to increase inflation merchants, users, and exchanges could all veto their block-chain by simply refusing to recognize it.I think the policy of which transactions to keep in the memory pool is fundamentally different, because miners can do whatever they like and there's not a whole lot merchants/users/exchanges or other miners can do about it. There's no way to enforce a "first broadcast version of a transaction must be mined" rule, if there was then we wouldn't need the block chain at all.As for re-writing the blockchain if an after-the-fact, large-fee double-spend is broadcast:  I think that's covered by this case:Or, in other words, you'd need to be pretty sure that you've got a majority of miners who will cooperate with you to rewrite the block chain. The longer the chain, the harder that will be (because it becomes increasingly likely that one of your co-conspirators mined one of the blocks you want to overwrite). Some of the big mining pool operators are already going their own way, experimenting with new types of transactions (e.g. deepbit and eligius), so I suspect the answer to your question "Can 'we' please hold off..." is "No."Discussions like this one are how I start to understand parts of the protocol like nLockTime and transaction replacement better.As for BIP 16 draining effort away from making the standard client scale:  I've been saying for a year that my top priorities are network stability and wallet security. Making the standard client scale is, in my opinion, a lower priority; I don't want a super-scalable client with a 4-minute blockchain initial block sync time if it is vulnerable to the user clicking one wrong link and getting infected by a trojan wallet stealer.
As I told Matthew when I spoke with him a couple of weeks ago, I also think this is a fantastic idea and plan on helping the CLAG however I can. Legal and regulatory uncertainty is perhaps the biggest barrier for companies who might be thinking of launching projects involving Bitcoin, and having a reliable source of up-to-date accurate information about the issues will be incredibly valuable.Hopefully in a couple of years the CLAG's biggest problem will be figuring out what it's role should be as similar groups, inspired by the CLAG, spring up all over the world to tackle the unique legal issues in each country. In the long run, I think we have to assume that miners will do what is most profitable, and design escrow/payment protocols around that assumption.Replacing non-final transactions in the memory pool potentially opens up a whole bucket of worms, but I think the short-term challenge is to figure out if we should change the rules we have now. If we do (I think we should), then I think it would be a mistake to do anything other than "create rules that will maximize miner profits."  Because if we do something else, then sooner or later I believe there will be a "miners special" version of the code that has miner-friendly rules.If you agree with me that the default rules in the client should maximize miners' profits, then it seems to me there's one simple rule change we should make:If you've got two otherwise equivalent transactions that spend the same input(s), keep the one with the most fees.Right now, the rule is "keep the first one you see."The bag of worms comes into play if you've got two transactions that spend the same input(s) that, for example, look like this:Transaction 1:  final transaction (can go into a block RIGHT NOW) that has a fee of 0.005 BTCTransaction 2:  transaction that won't be final for 3 days that has a fee of 0.1 BTCShould a miner put Transaction 1 into the block they're mining and take the smaller fee now, or not include it, hoping that nobody else mines Transaction 1 in the next 3 days so maybe they can mine Transaction 2 and get the bigger fee?I'm not an expert in game theory, but I believe the winning strategy in the above situation, assuming everybody knows about both transactions, is to mine Transaction 1 right away (any economists reading who know a lot more about game theory than I do?).That suggests the rules for transactions that spend the same inputs aught to be:1. If you have two free transactions, keep the first one you see.2. If you have a free and a fee-paying transaction, always keep the fee-paying one.3. If you have two final, fee-paying transactions, keep/mine/relay the one with the higher fee.4. If one or both of the transactions is non-final, keep/relay the one that will become final first. Thanks, that should be very helpful.  I opened issue #1065 https://github.com/bitcoin/bitcoin/issues/1065 Write up a proposal, start experimenting on testnet, recruit people to think really hard about how whether or not what you're proposing could be abused to compromise security or could make a denial-of-service attack easier...I'm against changes that might make Bitcoin a tiny bit better, but if you've got a well-thought-out proposal for how to make Bitcoin much better in some way then I'll help you argue for it. +1Personally, I consider the coin creation function (50 BTC every 10 minutes, halving every 4 years) and rules for whether or not you can spend the coins you have (if, and only if, you can satisfy the scriptPubKey by creating an ECDSA signature then you can spend them) sacrosanct. Them's the rules of Bitcoin, change them and it ain't Bitcoin any more.Extending Bitcoin to new and wonderful types of transactions is fine, and, actually, I believe Therilith could build most of what he wants on top of Bitcoin using pre-signed fee-only non-final transactions with a lockTime 10 years in the future.Convincing people to agree to do that would be another thing all together... Yes, if Bob puts in a deposit it adds a step internally.I think for this to have a reasonable user-interface Alice and Bob's bitcoin clients will need to communicate in real time.My inclination is to add JSON-RPC methods to bitcoin-qt/bitcoind to support this, and not build it into bitcoin-qt's GUI (or at least not right away). I'm imagining Armory or little "let's make a deal" 2-party-escrow-apps that... Do The Right Thing.Random UI thoughts:Alice could be asked "How much do you trust Bob?"  and "How much do you think Bob trusts you?"  If an answer is "not at all" then propose an escrow that requires a substantial deposit.  If the answer is "a lot" then maybe no deposit is required. It'd be way spiffy cool if it was automagically tied into the #bitcoin-otc web of trust sytem...(... more random thoughts: would IRC as the communication mechanism under the covers be a good or bad idea?  might be a convenient way to prototype...)I'm imagining Bob gets the details of the proposed escrow and can either agree or disagree (maybe with a message to let Alice know what he WOULD agree to). Well, if DISPUTE is a fee-only transaction then miners have a VERY strong incentive to drop LAZY_ALICE and mine DISPUTE instead. I don't think we'd have trouble asking miners to support a code change that is something like:etotheipi, I've been thinking about your comment "I don't like the asymmetry" ... LAZY_ALICE and DISPUTE are, I think, symmetric-- Alice holds DISPUTE in case Bob doesn't hold up his end of the bargain, Bob holds LAZY_ALICE in case she doesn't.  I proposed that DISPUTE have an earlier lockTime than LAZY_ALICE, but maybe that's not necessary. If Alice really doesn't trust Bob, then I think the whole scheme also works if Bob puts a "good faith security deposit" of bitcoins into the mix.The complexity of all this (5 possible transactions, different states the escrow can be in, initial communication to initiate the escrow) makes me nervous. Even just figuring out how Alice and Bob's clients talk to each to setup the escrow isn't obvious. Is anybody else seeing anything like what jetmine is seeing?  Anybody else running CentOS 5.6?  Did you compile from source or are you using the binaries we compiled?My 0.6 nodes running on Ubuntu 11 have been rock solid.The "CBlock::ReadFromDisk() : OpenBlockFile failed" is very odd, that should never happen.  You aren't running with a -datadir on a network drive or something are you?RE: filling addr.dat:  that is one of the denial-of-service attacks fixed by the 0.6 release. https://gist.github.com/830ca16758fb9ad496d7   : I created it as a 'private' gist because it is only half-baked.RE: lockTime and the memory pool:Note:  I'm using an "Alice pays Bob" scenario as described in the above gist:If neither party is cheating, then the pre-signed DISPUTE  should NOT get broadcast until there really is a dispute. Instead, Alice and Bob's clients hold on to it.So it is not in any miner's memory pools, and if there is no dispute nobody besides the two people involved in the transaction ever know about it.Of course we have to assume that people WILL try to cheat, so the question becomes: what if Alice or Bob broadcasts DISPUTE prematurely?  Would anything bad happen?I believe the answer is no, assuming Bob waits for transactions to be confirmed.  If DISPUTE is in "everybody's" memory pool, then any other transaction involving the escrowed funds will just be ignored. Even if Bob's client didn't see the DISPUTE broadcast (maybe he was offline) but later saw the SUCCESS transaction broadcast from Alice, SUCCESS would never be confirmed.On the other hand, if not "everybody" has the DISPUTE transaction in their memory pool and Alice broadcasts SUCCESS, then it will likely be picked up by a miner and confirmed.  Once it is in a block, the conflicting DISPUTE transaction gets dropped from everybody's memory pool as a failed double-spend.  Given the churn in the nodes connected to the network, I expect this would actually be the most common case.If Bob's client does see DISPUTE broadcast, it should probably let Bob know that Alice is unhappy and has disputed the transaction.DISPUTE (which will be given a non-final sequence number) cannot get into a block until after lockTime.All of the above is based on my best understanding of how the Satoshi code works right now; prototyping and experimenting on the testnet would be a good next step to make sure it actually behaves the way I think. If I'm reading their specs correctly, if A manages to break the chip she could generate duplicate transactions for the full value stored on the chip to B and C and D (and E and F and...).But she wouldn't be able to double-spend the same funds to B, because B's chip is able to detect that attempted double-spend.Eventually, I assume the Mint would figure out that the same funds were spent at B and C and D and... etc, just like the Mint eventually figures out when a lot of counterfeit paper notes are being spent in a particular area. And I imagine they'd deal with it the same way, interviewing merchants to ask them if they have a record of who made a transaction at a particular time, etc.And assuming B/C/D/... did nothing wrong I bet the Mint honors all of the the A -> B/C/D/... transactions, so B/C/D/... don't lose any money. The Mint eats the loss (it just shows up as inflation in the money supply, so really EVERYBODY pays for the fraud), and if the problem gets large enough they declare version 1.0 of their chips obsolete and come out with a New and More Secure version.It all looks pretty nifty to me, I hope it is a big success; it could be a great way to buy Bitcoins (non-reversible, cash-like...). All righty... you're the first person I've heard that from.Please file bug reports on the github issue tracker. Include enough information so we can reproduce the problem (what platform? what seems to cause the problem? etc) and it might get fixed.I say "might" because if you're serving up a big mining pool running bitcoind on Windows... well, none of the current core developers work on Windows. I think it is really important that the bitcoins involved in failed escrows not be destroyed, but EVENTUALLY make their way back into the economy.So I'd really like to see network and client support for having both people pre-sign and hold on to a transaction with a far-in-the-future lockTime (maybe as a fee-only transaction). Nope, sorry, have higher priority things to do. Upgrade to 0.6. Multisignature adoption has to follow a multi-step process:1. A majority of miners have to put multisignature transactions into blocks so they get confirmed.2. A significant fraction of everybody else has to relay multisignature transactions so they reliably get to the miners (preferably more than 50%).3. Depending on what you're using multisig FOR (escrow? secure wallets?), more technical infrastructure will need to be built.4. After all of the above is done... y'all will be able to reliably use multisignature transactions.April 1'st was the first step and we're doing pretty well with the second step, version 0.6 has a lot of support on the network already.  In fact, it is going so well I think we should turn on the 'addmultisigaddress' JSON-RPC method so people can start creating and experimenting with multisig with the 0.6.1 release. Summarizing a discussion from #bitcoin-dev this morning:The merge window for pull requests for a 0.6.1 release is now open.This will be a bug-fix and code-cleanup only release, with the goal to have Release Candidate 1 binaries available for testing in three weeks: April 23'rd.  We want this to be a quick release cycle so we can start pulling new features for a 0.7 release in a month or so.The major issues I would like to get resolved: # 1024 Correct passphrase crashed the client # 1012 bitcoin-qt slow to shut down after recent commitsThere are currently 189 open issues in our bug tracker; lets try to get that down to under 100.I know this will frustrate some of you who think development is happening at a snail's pace; feel free to pull and test new features (IPv6 support and coin control) that are important to you. Adequate testing is still our biggest issue, if you want your favorite feature to get into bitcoin core faster please spend some time helping test other people's favorite features. About 20 minutes until the deadline... I expect to hear some very loud complaining about "I wasted a bunch of time generating orphan blocks why didn't you WARN me!" in the next few days. This is not an elaborate April Fool's joke. Yes, you should insist that customers give you a refund/cash-out address BEFORE you give them the funding address. I don't know nuthin about pricing risk, which is why I tell all of my relatives I have absolutely no idea whether or not they should buy Bitcoins.But: it seems to me you're assuming that the entire $5 current price of Bitcoin is pure speculation, and ignoring that they ARE functioning as money in some fledgling markets. And don't you have to factor in time value of money into the calculation?  I'll pay a lot more for bitcoin today if I think there's a 30% chance it will be worth $600 in a year than if I think there is a 30% chance in 100 years.You're also assuming that the velocity of bitcoin will be approximately equal to the velocity of traditional currencies. I could image it being much higher (less friction in transactions, so more transactions) or much lower (maybe bitcoin will be used mostly as a long-term store of value, with infrequent transactions; what is the velocity of an gram of gold compared to dollars?). What is your definition of "truly mainstream" ?If 1% of the world uses Bitcoin for 1% of their transactions, then I'd still consider it a huge success. I think there's a good chance that happens, but that doesn't fit my definition of 'mainstream.'I think there is small possibility Bitcoin proper is used by a majority of people in some country somewhere in the world use it at least once a week to pay for things. I'd consider that mainstream success.I think there's a tiny possibility Bitcoin will eventually become as popular as the dollar.But I'm not very good at predicting the future, so you might want to consult you local fortune teller.
When the maintainer (Matt) has a little time.No, not yet. Anybody know if there's a web page that will do the verification?  (would be easy to create one...)Yes. Bitcoin version 0.6.0 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/This release includes more than 20 language localizations.More translations are welcome; join theproject at Transifex to help:  https://www.transifex.net/projects/p/bitcoin/Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesProject source code is hosted at github; we are no longerdistributing .tar.gz files here, you can get themdirectly from github: https://github.com/bitcoin/bitcoin/tarball/v0.6.0  # .tar.gz https://github.com/bitcoin/bitcoin/zipball/v0.6.0  # .zipFor Ubuntu users, there is a ppa maintained by Matt Corallo whichyou can add to your system so that it will automatically keepbitcoin up-to-date.  Just type sudo apt-add-repository ppa:bitcoin/bitcoinin your terminal, then install the bitcoin-qt package.KNOWN ISSUES------------Shutting down while synchronizing with the network(downloading the blockchain) can take more than a minute,because database writes are queued to speed up downloadtime.NEW FEATURES SINCE BITCOIN VERSION 0.5--------------------------------------Initial network synchronization should be much faster(one or two hours on a typical machine instead of ten or morehours).Backup Wallet menu option.Bitcoin-Qt can display and save QR codes for sendingand receiving addresses.New context menu on addresses to copy/edit/delete them.New Sign Message dialog that allows you to prove that youown a bitcoin address by creating a digitalsignature.New wallets created with this version willuse 33-byte 'compressed' public keys instead of65-byte public keys, resulting in smallertransactions and less traffic on the bitcoinnetwork. The shorter keys are already supportedby the network but wallet.dat files containingshort keys are not compatible with earlierversions of Bitcoin-Qt/bitcoind.New command-line argument -blocknotify=<command>that will spawn a shell process to run <command> when a new block is accepted.New command-line argument -splash=0 to disableBitcoin-Qt's initial splash screenvalidateaddress JSON-RPC api command output includestwo new fields for addresses in the wallet: pubkey : hexadecimal public key iscompressed : true if pubkey is a short 33-byte keyNew JSON-RPC api commands for dumping/importingprivate keys from the wallet (dumprivkey, importprivkey).New JSON-RPC api command for getting information aboutblocks (getblock, getblockhash).New JSON-RPC api command (getmininginfo) for gettingextra information related to mining. The getinfoJSON-RPC command no longer includes mining-relatedinformation (generate/genproclimit/hashespersec).NOTABLE CHANGES---------------BIP30 implemented (security fix for an attack involvingduplicate "coinbase transactions").The -nolisten, -noupnp and -nodnsseed command-lineoptions were renamed to -listen, -upnp and -dnsseed,with a default value of 1. The old names are stillsupported for compatibility (so specifying -nolistenis automatically interpreted as -listen=0; everyboolean argument can now be specified as either-foo or -nofoo).The -noirc command-line options was renamed to-irc, with a default value of 0. Run -irc=1 toget the old behavior.Three fill-up-available-memory denial-of-serviceattacks were fixed.NOT YET IMPLEMENTED FEATURES----------------------------Support for clicking on bitcoin: URIs andopening/launching Bitcoin-Qt is available only on Linux,and only if you configure your desktop to launchBitcoin-Qt. All platforms support dragging and droppingbitcoin: URIs onto the Bitcoin-Qt window to startpayment.PRELIMINARY SUPPORT FOR MULTISIGNATURE TRANSACTIONS---------------------------------------------------This release has preliminary support for multisignaturetransactions-- transactions that require authorizationfrom more than one person or device before theywill be accepted by the bitcoin network.Prior to this release, multisignature transactionswere considered 'non-standard' and were ignored;with this release multisignature transactions areconsidered standard and will start to be relayedand accepted into blocks.It is expected that future releases of Bitcoin-Qtwill support the creation of multisignature transactions,once enough of the network has upgraded so relayingand validating them is robust.For this release, creation and testing of multisignaturetransactions is limited to the bitcoin test network usingthe "addmultisigaddress" JSON-RPC api call.Short multisignature address support is included in thisrelease, as specified in BIP 13 and BIP 16.Thanks to everybody who contributed to this release:Alex BAlistair BuxtonChris MooreClark GaebelDaniel FolkinshteynDylan NoblesmithForrest VoightGavin AndresenGregory MaxwellJanne PulkkinenJoel KaartinenLars RasmussonLuke DashjrMatt CoralloMichael FordMichael HendricksNick BosmaNils SchneiderPhilip KaufmannPierre ProncheryPieter WuilleRune K SvendsenWladimir J. van der Laancoderrrp2ksje397Special thanks to Sergio Lerner and Matt Corallo for bringingpotential denial-of-service attacks to our attention. Thanks for the help sanity testing, I've repackaged the rc6 bits as version 0.6.0. We updated the translations and fixed two serious-enough-to-be-showstopper bugs, and 0.6 release candidate 6 is available at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/The two bugs (both caused by changes between release candidates 4 and 5, of course!) were:1. Creating over a gigabyte of transaction logs during initial blockchain download. You should now see both a fast download and no more than 120MB of log files created.2. A few people upgrading from previous releases couldn't get past the 'loading addr.dat' phase of startup.I hope to repackage this as the final 0.6.0 release tomorrow; if you can help sanity test, please do! My point was ANY scheme you come up with will eventually come down to "Does this transaction input have a high enough percentage of 'badness' for me to say no, I won't take it."Whatever percentage you choose, the bad guys will very likely figure out ways to make their transactions just barely pass your purity test.Which is why I mostly think starting down that road is probably a bad idea.On the other hand... "security theatre" can be good public relations.  Make the bad guys jump through two hoops and then feel good about how tough you are on crime.... If 'tainted coin tracing' is ever implemented, it would be pretty easy to extend the idea to 'tainted mined coins'.Mine 75 BTC (50 plus 25 in 'melted, tainted coins') and it'd be considered 33% tainted. We might re-spin the release with just updated translations.There is one serious issue affecting a few people (https://bitcointalk.org/index.php?topic=74447.0) but because it is a one-time problem when you upgrade from an older release and has a pretty simple workaround (remove your addr.dat file and re-run), we may release with it as a Known Issue.If there are any Berkeley DB database experts reading this we could use your help figuring out what the heck is going on... You mean like:https://bitcointalk.org/index.php?topic=34562.0  orhttps://bitcointalk.org/index.php?topic=19080.80  orhttp://gavinthink.blogspot.com/2011/06/why-arent-bitcoin-wallets-encrypted.html  orhttps://bitcointalk.org/index.php?topic=2574.0It has been a while since I wrote a "State of Bitcoin Development" update (too busy...), but wallet security was my second priority, behind network stability, the last time I did one. It is still right at the top of my priority list. Ummm...You know when you choose "About Bitcoin-Qt" and it says "Version 0.something BETA" ?When we've got an implementation that is safe and secure (both from hackers and from accidental loss) out of the box that will change to say "Bitcoin Version 1.something".Unfortunately, I don't know how to launch Bitcoin in an alternate universe where it will be attacked by highly motivated black-hats and then bring back the battle-tested source code to this universe to be launched as a perfectly secure Version One.So, to repeat myself:  Bitcoin is experimental software. Do not invest time or money in it that you cannot afford to lose. Here's the thinking:Joe Random User finds out about bitcoin, and decides "what the heck, I'll check it out."They run it.  First thing it does is ask him for a passphrase, with tons of "DO NOT FORGET YOUR PASSPHRASE" and/or "CHOOSE A LONG PASSPHRASE" warnings.  What does he do?  Many users will either:1. Type "passphrase".or2. Bang on the keyboard to create a long, random passphrase: "b;lkaj425[09234kjvfda,nvfd;nkj34toht4"He gets a little coin from the Faucet, writes me an email asking when they will arrive (because he hasn't yet downloaded the entire blockchain and didn't bother to read the information about that on the Faucet's "Sent!" page), and then shuts down the client.Time passes.  Eventually the Faucet coins show up.He decides Bitcoin really doesn't suck as much as he first thought, so he decides to buy some Bitcoin on Mt. Gox.Time passes while Dwolla verifies his bank account and stuff.Then he buys Bitcoin, and manages to send them and see them show up in his running Bitcoin.Yay!Time passes.  He decides he wants to spend the Bitcoin, and now he has to enter the passphrase that he set a week or three ago.  But back then, wallet security wasn't at all important to him.  He didn't have an Bitcoins to keep secure.So either he forgot that his passphrase is "passphrase" or he remembers that he typed a bunch or random letters just so he could get past that annoying "enter passphrase" dialog box so he could just try the damn thing.In short: wallet encryption is not the default because the right time to enter a passphrase to encrypt the wallet is when you KNOW that the wallet is valuable, and will take the steps necessary to protect it. Barring any last-minute showstopper issues, the plan is for release candidate 5 to become the official 0.6.0 release on Wednesday.So please help look for last-minute showstopper issues:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/The major changes from release candidate 4:Much faster writing of blkindex.dat during initial blockchain download (by modifying the default bdb environment cache settings)A new policy for wallet.dat upgrades: use the old format unless the user either uses a feature that requires an upgrade (encrypts the wallet) or explicitly requests that the wallet be upgraded using the new -upgradewallet option. New wallets will use new features (for 0.6, the only new wallet feature is compressed public keys).bugfix introduced in rc4 for an assertion failure that could occur during blockchain reorganizationsNew code for managing the addr.dat file that prevents an attacker from filling it with bogus entries. Start with this stickied thread. That statement is incorrect.There are two ways you might waste time hashing:1) Put a bad BIP16 transaction in your block2) Building on top of a bad block produced by somebody elseSo even if you don't include anybody else's transactions in your blocks you will still almost certainly waste some time hashing by building on top of invalid blocks produced and announced by some other lazy miner running an old version of bitcoind. That's source code for the kernel, right?I removed the old binary releases from SourceForge because it was getting annoying to find things like testnet-in-a-box in that very long list, and also getting hard to see what the latest release was. And with our gitian reproducible build process, the windows/linux binaries for recent releases are deterministically reproducible from the source code.See https://github.com/bitcoin/bitcoin/tags  for the history back to the 0.1.5 release.  Uploading 0.1 to github is a good idea, maybe somebody who knows more about git than I do can suggest the best way to do that. See this thread for BIP16-compatible-backported release candidates:  https://bitcointalk.org/index.php?topic=72069.0A final 0.6 release candidate will be out very soon, the last issues are being resolved now.Again: if you don't upgrade and are a solo miner, pool operator, or p2pool user you will almost certainly waste time hashing bad blocks after April 1. I pulled #964 for 0.6 this morning.I had played with database settings several months ago and saw no speedup because there was another bug causing a bottleneck.  That bug was fixed a while ago, but nobody thought to try tweaking the db settings again until a few days ago.Pieter and Greg did all the hard work of doing a lot of benchmarking to figure out which settings actually matter.PS: the database settings are run-time configurable for any version of bitcoin; berkeley db reads a file called 'DB_CONFIG' (if it exists) in the "database environment" directory (aka -datadir). I'm posting this to both this and the Mining Pools subforum:To all pool operators, solo miners and p2pool miners; I have an announcement.As everyone well remembers, we are upgrading the block-validity rule of Bitcoin to support short multisignature addresses. We realize that upgrading the code that you've been using for a long time is at least inconvenient and, for some of you, even painful or scary. But in the case of BIP30, which went into effect with the appropriately safe network support on March 15, it was necessary and in the case of this announcement the long-term benefits will far outweigh the short-term costs of this transition.Therefore I'd like to announce that support for BIP16 has acquired a majority of mining support needed to prevent a potential permanent fork and will be activated on April 1st as previously planned.This chart shows support over the last week: http://blockchain.info/P2SH.  Support is well over 70%.So if you are a pool operator, solo miner, or p2pool miner you need to upgrade your Bitcoin-Qt/bitcoind before April 1st. Running a version of bitcoind earlier than 0.6 release candidate 3 past this date means running the risk of potentially wasting your hashing power mining invalid blocks since earlier versions will accept invalid spends of BIP16 transactions into their memory pools and will put them into blocks considered invalid by the majority.p2pool users will also need to upgrade to the latest version of p2pool.If you are a miner connecting to a mining pool, you can ignore this message.For non-miners: version 0.6 also contains several important bug and denial-of-service fixes, so if you can, upgrade. Backports of the BIP16 code to earlier releases are available if you are running a patched bitcoind. Patched binaries of older releases will be available soon. To all pool operators, solo miners and p2pool miners; I have an announcement.As everyone well remembers, we are upgrading the block-validity rule of Bitcoin to support short multisignature addresses. We realize that upgrading the code that you've been using for a long time is at least inconvenient and, for some of you, even painful or scary. But in the case of BIP30, which went into effect with the appropriately safe network support on March 15, it was necessary and in the case of this announcement the long-term benefits will far outweigh the short-term costs of this transition.Therefore I'd like to announce that support for BIP16 has acquired a majority of mining support needed to prevent a potential permanent fork and will be activated on April 1st as previously planned.This chart shows support over the last week: http://blockchain.info/P2SH.  Support is well over 70%.So if you are a pool operator, solo miner, or p2pool miner you need to upgrade your Bitcoin-Qt/bitcoind before April 1st. Running a version of bitcoind earlier than 0.6 release candidate 3 past this date means running the risk of potentially wasting your hashing power mining invalid blocks since earlier versions will accept invalid spends of BIP16 transactions into their memory pools and will put them into blocks considered invalid by the majority.p2pool users will also need to upgrade to the latest version of p2pool.If you are a miner connecting to a mining pool, you can ignore this message.For non-miners: version 0.6 also contains several important bug and denial-of-service fixes, so if you can, upgrade. Backports of the BIP16 code to earlier releases are available if you are running a patched bitcoind. Patched binaries of older releases will be available soon. Great!  Pull requests to fix compiling-on-platform-X problems are always welcome (assuming they don't also break compiling on platform-Y). Yes.
Not relaying "smelly" blocks is a very interesting idea.It doesn't have to be a binary relay/don't relay... you could immediately relay good blocks but wait a while before relaying bad blocks, and make the length of time you wait to relay based on how bad you think they are (maximum of maybe 10 minutes before you relay).But... not relaying new blocks immediately might just encourage the bad guys to try to connect directly to as many nodes as possible, and that could be bad for network health. Full disclosure blog post is at:  http://gavintech.blogspot.com/2012/03/full-disclosure-bitcoin-qt-on-windows.htmlExecutive summary: we were compiling Windows binaries with the wrong flags. Check your math-- to get 51% you'll need to dedicate six times as much hardware to hashing as it takes to get 15%:The formula for what fraction of existing hashing power you need add to get X% of the network is:Code:H = X / (1-X)To get 15%, you need to add 17.6%.  E.g. if existing hashing power is 100, then you add 17.6 more and your fraction is (17.6/117.6) = 0.15.To get 51%, you need to add 104%.  E.g. if existing hashing power is 100, then you add 104, then your fraction is (104/204) = 0.51.104 is six times as much as 17.6. I started experimenting with user-defined checkpoints (-checkpoint=height,hash multiarg, and 'addcheckpoint <height> <hash>' RPC call) but stopped when higher priority issues came up.It seems to me that type of low-level mechanism is the right way to go; checkpointing is a good low-level way of identifying which chain you think is "the" chain. And making it command-line/RPC configurable means we don't all have to agree on One True Way of deciding what the right blockchain aught to be; cunicula can write some code that implements proof-of-stake and then tie it into bitcoin/bitcoind using -blocknotify.  etotheipi can write some code that scans the blockchain for well-known miner signatures (or asks miners directly if they produced a new block), etc.If your argument is "But Gavin, if core Bitcoin doesn't support One True Way of doing I'll never be able to convince miners to do it my way!" then I'd say you need to better express to them how the benefits of your proposal outweigh the costs. How are signatures created when the phone or computer needs to spend some coins?I'm told it IS possible to break a single ECDSA key in half and then have a complete signature generated without either device ever knowing the entire key, but, if I recall correctly, the solution involves several communication round trips between the devices and some very sophisticated cryptography.  The multikey solution is much simpler.If I'm wrong, then great! The single ECDSA key solution will get adopted for wallet security and multisigs will only be used for escrow.RE: makku's question "How do you identify transactions that belong to you in the first place?"I think it is wrong to think of coins involved in a multiparty multisignature transaction as "belonging to you."  They don't belong to you-- you have to agree and cooperate with other keyholder(s) for the transaction to be spent.You are involved in the transaction, but you need some extra information that isn't in the blockchain to know how you are involved (are you an arbitrator? a person getting paid?  a person paying somebody? something else?). We'll release full detail tomorrow (Monday) at 16:00 GMT, after essentially the entire world has had a chance to go into work Monday morning, see the alert message, and shutdown/upgrade. -----BEGIN PGP SIGNED MESSAGE-----Hash: SHA1A potential security vulnerability has been discovered in the Windowsversion of Bitcoin-Qt. If you are running Bitcoin-Qt versions 0.5through 0.6 on Windows you should shut it down and upgrade to eitherversion 0.5.3.1 or 0.6rc4 NOW.The command-line bitcoin daemon (bitcoind), Mac and Linux versions ofBitcoin-Qt, and versions prior to 0.5 are not affected.Due to the nature of the vulnerability, we believe it would be verydifficult for an attacker to do anything more than crash theBitcoin-Qt process. However, because there is a possibility of such acrash causing remote code execution we consider this a critical issue.Binaries are available at SourceForge:https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.3/If you have questions, feel free to drop by the #bitcoin-dev channelon FreeNode IRC.- --Gavin AndresenGregory MaxwellMatt CoralloNils SchneiderWladimir J. van der Laan-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)Comment: Using GnuPG with Mozilla - http://enigmail.mozdev.org/iEYEARECAAYFAk9j12IACgkQdYgkL74406iIyQCfbxFTO3yD4Q2bHDjPlDuJn3Mj9GAAn3mV+ggo+5q1Ujd0A5zwpFYojkE2=g1Ad-----END PGP SIGNATURE----- I agree. https://sourceforge.net/projects/bitcoin/files/Bitcoin/blockchain/... has a fairly recent copy of the blockchain. Testnet is healthier now, although you'll need to run latest 'git HEAD' to be on the right chain. Thanks to everybody who threw some hashing power at it to outrun the bad, old-rules chains. Stay tuned:  the testnet is a mess right now. Another genesis block reset might be needed to fix it, there have been several blockchain-splitting changes and there are several different versions of the blockchain competing (with/without the difficulty change, with/without the duplicate coinbase change, and with/without BIP16 support).In the meantime, testing with a testnet-in-a-box or private testnet is a good way to go:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ There have already been several "transaction spam" attacks; as already pointed out, transaction fees keep them from being a big problem.The code also limits the number of free transactions that are relayed across the network, so you can't flood the network with transactions that will never get mined.Smarter denial-of-service attack prevention code has been a major unseen feature of the last couple Bitcoin releases. Yes, fixed in rc2. Bitcoin doesn't install Growl-- something else must have in the past.PS: there is an open bug in the 0.6 release that it is not compatible with some versions of Growl; if that isn't resolved Growl notifications might be completely disabled. PS: The 'accounts' feature doesn't scale well past a dozen or two accounts each with a few hundred transactions. It could (need to add some indices to the database so looking up transactions by account and/or time is quick), but doing that work hasn't been a high development priority. You should be able to build your GL on top of the accounts feature of bitcoind.The 'validateaddress' RPC call will tell you the account associated with an address and whether or not it is an address that belongs to you or is external.Combined with the 'sendfrom' and 'setaccount' RPC calls, you should be able to create a proper general-ledger-type application where all transactions have well-defined "from" and "to" accounts.Example of one way to do it using my testnet-in-a-box setup:1. Create a couple of accounts:Code: ./bitcoind -testnet getaccountaddress "cash"# ... send some coin to the "cash" account from ... somewhere ..../bitcoind -testnet setaccount mzDfbJCELPQzHMjJ6ZLFRUxT51FdKezbEZ "hosting_expenses"# the mzDfb... address would come from my web hosting company, of course2. Now pay for web hosting out of "cash"Code:./bitcoind -testnet sendfrom "cash" mzDfbJCELPQzHMjJ6ZLFRUxT51FdKezbEZ 103. All the information about the transaction (from and to accounts) is available, but you'll need 2 RPC calls to get it:Code:$ ./bitcoind -testnet listtransactions "cash" 1[    {        "account" : "cash",        "address" : "mzDfbJCELPQzHMjJ6ZLFRUxT51FdKezbEZ",        "category" : "send",        "amount" : -10.00000000,        "fee" : 0.00000000,        "confirmations" : 0,        "txid" : "53a681fd7f6b2cb542d69cb72d18ca780d42df63fcc00cf46b19499ab75540b3",        "time" : 1331050826    }]$ ./bitcoind -testnet validateaddress mzDfbJCELPQzHMjJ6ZLFRUxT51FdKezbEZ{    "isvalid" : true,    "address" : "mzDfbJCELPQzHMjJ6ZLFRUxT51FdKezbEZ",    "ismine" : false,    "account" : "hosting_expenses"}The GUI has no notion of a "sendfrom account", so any coins send from the GUI won't play nicely with whatever system you create using the RPC interface. The expectation is the vast majority of GUI users won't go to the trouble of creating a general ledger system to keep track of where their bitcoins are coming from and going to. That is always a risk, which is why next to the downloads there is a gpg-signed SHASUMS.asc file.To check the integrity of the download you should:+ Check the signature on the SHASUMS.asc file:Code:$ gpg --verify SHASUMS.asc gpg: Signature made Wed Feb 29 20:51:40 2012 EST using RSA key ID 1FC730C1gpg: Good signature from "Gavin Andresen (CODE SIGNING KEY) <gavinandresen@gmail.com>"+ Make sure the checksum for the downloaded file matches the checksum in the SHASUMS.asc file:Code:$ shasum bitcoin-0.6.0rc2-macosx.dmg7ab035250ad32a95adf12f2bf8751df9adae0ad4  bitcoin-0.6.0rc2-macosx.dmg$ grep macosx SHASUMS.asc 7ab035250ad32a95adf12f2bf8751df9adae0ad4  bitcoin-0.6.0rc2-macosx.dmg I was thinking of a kind of replay attack:+ Control the TPM's view of the world (e.g. make it seem like it is Jan 1, 2010)+ Get the TPM to sign a small transaction, shut it down.+ Increment time, get it to sign another transaction+ Repeat.Replace "time" with "blockchain" and you've got the same problem: can the TPM know that it's view of the external world is correct?  If it sends a nonce (to prevent replay attacks) to some external service that adds a timestamp and signs it with a public key known to the TPM code... then we're back to using two different servers. Great ideas, Mike. I think the "use two servers" approach will happen first (you typically want at least two servers anyway just for backup and redundancy), but trusted code running in a TPM could be an extremely powerful and cost-effective building block for much more secure solutions.RE:That seems like the hardest problem.Does the TPM have access to a guaranteed-to-be-unhackable time source? If it does, then a policy like "do not approve more than X bitcoins worth of transactions in timeperiod Y" should work well enough to prevent more than petty theft, assuming you've got some other way of watching the blockchain for unauthorized transactions and shutting down the compromised machine or using an emergency offline backup key to move the funds to a non-compromised wallet. RE: tx replacement:Somebody aught to start experimenting with transaction replacement with testnet-in-a-box.Put together a test plan, modify the code and try to break it.Assuming it all works, submit a pull request to enable transaction replacement on testnet (with a pointer to your test plan and results of testing, please).Then we can start trying to break transaction replacement on testnet; again, assuming no bugs/hacks/issues turn up after "enough" testing, and if there's general consensus that the benefits outweigh the risks, it could be rolled out to the production network.We just pulled a DoS fix involving filling up memory with orphan transactions; one concern with transaction replacement is DoS (could I fill up the memory pool by spamming "will be replaced" transactions?)
Those 0.002 bitcoins cannot be redeemed, because there is no input that will make that script valid (because there are no OP_ENDIF opcodes in there to match the OP_IFDUP/OP_IF opcodes). If you're using multisig to secure your wallet, then I think backup could be "free" ; all the involved multisig keys could be derived predictably from singlesig keys that you'll already need to backup. Disaster recovery from a lost wallet would mean importing all the backed up singlesig keys, then deriving (say) the first 1000 multisig ScriptSigs that would have been derived from those keys and scanning the blockchain for transactions involving those (and, hand-wave, hand-wave, doing something smart to derive more than 1000 in case it looks like more than 1000 were used).  (or, in other words: what kjj said)If you're using multisig for escrow involving other people... then the escrow transaction has to be recorded and backed up, including all the keys involved.  In that case I'm pretty sure you'll want to record and backup other information about the escrow-- like "100 BTC escrow to my cousin Bob; release them if he's still not smoking on June 1."Backup should be part of the user experience design for the escrow function; for example, I think a lot of escrows will an associated date, so the client should store the escrow transaction id AND the public keys involved in the escrow AND a "remind me to do something on June 1" AND (maybe) a link to my Address Book entry for Bob so I can call him on June 1. For me, I think the best way to backup that kind of escrow information would be for the client to send me an email containing all of that stuff in a standardized mini-file-format; I'll let gmail archive it and that would be my emergency backup.So, emergency recovery of a lost wallet would then be:1. Recover all private keys from paper backup (or whatever the singlesig backup solution is).2. Re-import all escrows that involve other people from email archive.RE: Bytecoin and "OR BACKUP_KEY" :  In either the OP_EVAL or the BIP16 case you need a new type of 'standard' transaction (and bitcoin address) to make that work. Nice!  Thank you very much for looking deeply into this; it looks like the inter-process-communication doo-hickey bitcoin uses to handle bitcoin: URLs was left behind when you blue-screened, and that's making startup fail the next time around. The dreaded DB_RUNRECOVERY...  that's usually caused by running an older version of BDB (0.6 is compiled against BDB 4.8) on a datadir written with a newer version of BDB.Recovery isn't hard; just delete the .bitcoin/database/log.000* file(s) and any .bitcoin/__db*.log files.  Were you previously running a self-compiled version of Bitcoin?From http://subversion.apache.org/faq.html#divining-bdb-version  :Code:cd ~/.bitcoin/databaseod -j12 -N8 -tx4 log.000*... will show what version of BDB the log files were written with. FYI:The Bitcoin Faucet bitcoind's are both running on a Linode VPS, which was mysteriously restarted 14 hours ago.  The 5 bitcoins in the main-net Faucet's wallet were stolen, also; I'll shutdown the Faucet website, do NOT donate any coins to the Faucet donation address, it is controlled by the thief.Transaction ID:  14350f6f2bda8f4220f5b5e11022ab126a4b178e5c4fca38c6e0deb242c40c5f... if you want to start watching where the coins end up. Windows, Linux and Mac binaries for 0.6rc2 are up at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/Please use github to report bugs:  https://github.com/bitcoin/bitcoin/issuesNote that there were a few "release candidate 1 doesn't work on Windows" bug reports that, as far as I know, have not been fixed. We need some good Qt-on-Windows developers to help out, none of the current core developers use Windows as our primary development platform.A lot of bug-fixing happened between release candidate 1 and release candidate 2, but we did also sneak in one major new feature that was long overdue:  a Backup Wallet menu entry.Be aware: the 0.6 release will create wallet.dat files that will not work with older releases, so you should back-up your wallet before running in case you need to revert back to an older release. 0.6 doesn't mark the wallet as backwards-incompatible until a new 'compressed' keypool key is added, so until you do something that generates a new key the wallet will stay compatible. Compressed keys will benefit everybody by using less network bandwidth, allowing more transactions to fit into each block, and making the blockchain smaller than it would otherwise be.Even a little time testing helps a lot; if you do can do some testing please reply in this thread with a message like "Bitcoin-Qt and bitcoind both worked nicely for me on my OS 10.6.8 Mac, running on -testnet." From the arimaa whitepaper:Right-- good luck with that! Any system that relies on Wise, Efficient and Effective Bureaucracies to decide hard questions like "are these 400 accounts really one scammer trying to get more than their fair share" are doomed to fail if they ever get large enough to attract the attention of scammers.If you have a really good automated way of telling the scammers from real people that doesn't require them sending in a DNA sample or body part, please let me know. I could use a good solution for the Bitcoin Faucet. This would replace the existing JSON-RPC getmemorypool command?Code:getmemorypool [data]If [data] is not specified, returns data needed to construct a block to work on:  "version" : block version  "previousblockhash" : hash of current highest block  "transactions" : contents of non-coinbase transactions that should be included in the next block  "coinbasevalue" : maximum allowable input to coinbase transaction, including the generation award and transaction fees  "coinbaseflags" : data that should be included in coinbase so support for new features can be judged  "time" : timestamp appropriate for next block  "mintime" : minimum timestamp appropriate for next block  "curtime" : current timestamp  "bits" : compressed target of next blockIf [data] is specified, tries to solve the block and returns true if it was successful.And a meta-question: are there any other implementations that will be supporting external mining via JSON-RPC soon? There's no reason to go through the whole BIP process to make a change or improvement to one implementation. Do you have to talk about those three projects?How about Bitcoin-Charity.com or CoinWorker.com for projects that aren't so potentially controversial? https://github.com/gavinandresen/bitcoin-git/tree/fuzzer... but it is pretty narrowly targeted at stress-testing the transaction validity code.Last year at the NYC conference I mentioned that I would really like to see somebody who knows a lot more about network simulation than I do develop tools to help test proposed protocol changes, simulate Sybil or DoS attacks, etc.I'd still really like to see that... eleuthria is right.The bad-for-not-upgraded-miners scenario is:+ Somebody gets a valid BIP16 transaction into the chain.+ They then spend that transaction by broadcasting a 'standard', non-BIP16 transaction, BUT they create a signature for the BIP16 part that old miners consider valid, new miners consider invalid.+ The old miners will add that 'poisonous' transaction to their memory pool and if they include it in the blocks they mine then those blocks will be rejected by most of the network.makomk pointed out a while ago that I hadn't noticed that old miners will accept spends of half-valid BIP16 transactions, because the old code doesn't check to see if a transaction is spending a non-standard input. He's right; one of the changes in the 0.6 release is an AreInputsStandard() method, to make upgrading smoother next time.Executive summary:  if you are a p2pool or solo miner you should upgrade before the switchover date (April 1, if all goes well)  or there is a good chance you'll produce nothing but orphan blocks.  I welcome suggestions on how to effectively get that message out to the community. Reposting from the bitcoin-development mailing list:Mining support for BIP 16 is still under 50%, and won't possibly be over 50% by March 1.  Which means we need a new evaluation/switchover date:Re-evaluate support: March 15'thTarget switchover: April 1If you're already supporting BIP16, restart bitcoind with the argument:  -paytoscripthashtime=1333238400... to delay switchover until April 1.Hopefully this will be the last delay; Tycho has told me that the deepbit pool will support BIP16 as soon as he's able to merge and test the changes, which will put support at well over 55%.If you are a solo or p2pool miner you are strongly encouraged to upgrade bitcoind/Bitcoin-Qt in the next month; if you don't, you risk creating orphan blocks that the rest of the network will reject (and that risk will rapidly become greater over time as BIP16 transactions start to appear in the main block chain and get relayed across the network). In my humble opinion, this kind of trash talk against BIP 16 is bad for Bitcoin.The poll in this thread says the community prefers BIP 16.The chart on the bitcoin wiki says the core developers prefer BIP 16.And the actions of the big mining pools and independent miners says that they overwhelmingly prefer BIP 16.Luke, I'd be delighted to add Eligius to the list of pools that are supporting BIP 16 in my signature. I think you might be conflating two costs:Cost #1 is the cost to get a bunch of domain transactions accepted.I believe pent's proposal is based on additional difficulty, which will be independent of the bitcoin price.In other words, if bitcoin difficulty is 100, then maybe you need to solve a difficulty 110 block to get your additional DIANNA data accepted by the other DIANNA nodes who are maintaining the key:value database.If bitcoin difficulty rises to 1 million, then you need to solve a difficulty 1-million-and-ten block to get your data accepted.The additional difficulty factor should be set by the DIANNA nodes based on their ability to process/store data. More thinking is needed about what that function looks like (it reminds me of the bitcoin fee algorithm; it's trying to solve a similar problem, preventing spam/abuse but allowing as many transactions as possible for the lowest possible price).Then there's a completely separate Cost #2, which will be higher than cost #1, that is the payment that miners (aka registrars) will charge to handle domain transactions (and do the work of bundling them up, creating some sort of summary hash, and getting that hash into the bitcoin block chain).  That's just a free market.(I'm completely ignoring Cost #3, which is the "what if I want to purchase an existing domain" price, and is whatever the owner is willing to sell it for.) YesYes, you could do it that way, re-using Bitcoin's Script system for signatures.  I suppose it might be useful to require m-of-n signatures for a domain to be transferred to somebody else.  I wouldn't make them full-fledged Transactions, though (multiple "inputs" to a domain renewal or transfer doesn't really make sense, for example).Yes, I think that's right, although I was imagining that the DIANNA and bitcoin difficulties would be kept separate and not combined. Combining them is probably a better idea (if you find any blocks that satisfy the bitcoin difficulty but not the DIANNA+bitcoin difficulty you can still announce them on the bitcoin network and get the block reward).RE: what is the incentive for maintaining the DHT:  the registrars/mining pools would, I think, be the primary maintainers of the DHT and their incentive to maintaining it is the registration fees that they charge.I haven't thought deeply about possible attacks; if a DHT is used then you have to defend against Sybil attacks (you must have some way of checking to make sure the data you get from the DHT is valid, e.g. have the DHT nodes return a Merkle branch down to the data they're returning that you can verify hashes to the correct Merkle root). I should have made it clear:  I imagine there will be an arbitrary number of registrars. They will compete to provide the best service (fastest updates of the DNS database, lowest prices, etc).If you were willing to do the proof-of-work and insert your own updates into the bitcoin block chain then you could be your own registrar (I assume most people won't be willing to setup the necessary software, run it, etc. just to register a couple of domain names). I really like your idea of scaling up difficulty based on the number of domain operations in a block to prevent the key:value database from growing arbitrarily big.It seems to me that should be enough to make domain operation pricing correct; I don't see why there needs to be a block reward or fees, I assume the registrars will charge whatever they need to charge to make a profit, and I would strongly encourage you to avoid making the DNS system yet-another-currency.  I'd like to use dollars or euros or bitcoins (preferably bitcoins) to pay for my domain names, please.I imagine a system something like:+ I give some money to a registrar, and ask them to register/renew/transfer 'gavinandresen.dianna'+ The registrar makes sure the register/renew/transfer operation is valid+ The registrar bundles up a bunch of register/renew/transfer operations and then asks/pays a Bitcoin miner to merge-mine that hash to securely timestamp those changes+ After they're timestamped, the registrar asks that all of those record changes be inserted into a shared distributed hash table, providing the DIANNA proof-of-work and the bitcoin block hash.+ The nodes maintaining the shared DHT make sure the records have the right DIANNA proof-of-work, that the bitcoin block is valid, and that the changes aren't over-ridden by a later bitcoin block, and then update the records. I've got a "noprivacy" branch of bitcoin that I use for the Faucet:  https://github.com/gavinandresen/bitcoin-git/tree/noprivacyInstead of creating a new address for change, it uses one of the input's addresses.It works nicely if your entire bitcoin balance is one "account", but will fail if you're using the accounts feature to keep track of separate balances (which is why it will probably never be a mainline feature). Meeting summary posted to the bitcoin-development mailing list (link)IRC logs here. This doesn't affect Bitcoin at all, because the ECDSA algorithm that Bitcoin uses does not use pairs of prime numbers to do it's thing.
Tomorrow at 21:00 UTC on #bitcoin-dev I'd like to talk about:Status of BIP 16 support (progress towards 50% hashing power).Protocol change: checksum in version messages coming up Feb. 20.Duplicate coinbase issue (and requiring block height in the coinbase as a solution). I've got about $12 USD in my TradeHill account:  Jered, please keep it, you deserve it, I know how hard you've worked and how hard a fight it is to interface with our designed-in-the-1960's-duct-tape-and-bailing-wire rats-nest-of-regulations banking/finance system. If you've got a great business model and funding for a much better bitcoin client, more power to you!If you're planning on defacing one of the web servers that I haven't been keeping up-to-date (because I'm busy doing Bitcoin-related things) or hacking my gmail account to prove that I'm not The World's Best Security Expert... then I'll save you the trouble:I am not the World's Best Security Expert.I am not the World's Best Programmer.I am not a cryptographer.I am not an expert on finance or banking or monetary systems.I am not an expert on leading open source projects.And I hope someday I get replaced as the technical lead for this project. I'm sure there are lots of people better qualified than me, I'm just doing the best I can to try to help make Bitcoin a success. I hope they find and prosecute the bastards; DDoSing somebody because you disagree with them is never OK.In fact, I think there is never a situation where DDoSing is OK, even if you're trying to accomplish something good (philosophical discussions about ends justifying the means should move to off-topic...) Don't panic.roconnor has been experimenting with spending "duplicate coinbase transactions" on the testnet.  Block explorer is confused, and isn't seeing the 50 bitcoins generated to that address in testnet block 45,442 (because the generation transaction has the same ID as the generation transaction in block 45,333).Expect code changes before the 0.6 release is final to discourage and eventually prohibit accepting blocks with duplicate coinbase transactions; although we can't see a way to exploit this weirdness to cheat anybody (it is easy to cheat yourself out of bitcoins using duplicate coinbase transactions that cannot be spent), it's definitely not a good thing. You are the Quality Assurance department.  A test plan is an excellent idea, could you write one up and post it on the wiki and ask for volunteers to help test?I don't know, the GUI for multisignature transactions hasn't been designed yet. But I imagine it will be simpler to always produce P2SH transactions, just as the client always produces OP_HASH160 transactions and has no option to produce plain OP_CHECKSIG transactions.I assume that both forms will be supported for multisig payments into your wallet (but detailed discussion on how to support multisig in the GUI should happen somewhere other than this thread). Yes, thanks for reminding me:  I just uploaded gitian signatures for the win32 and linux 0.6rc1 builds to:  https://github.com/bitcoin/gitian.sigsThe win32 build was not deterministic, though.  There's a pull request to fix that.The OSX binary is not gitian-built. Re-posted from the bitcoin-development mailing list:I'd like version 0.6 to get lots of review, "soak time" and testing, soplease download and run release candidate 1 from: http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.6.0/test/You can review the code changes using github's compare feature: https://github.com/bitcoin/bitcoin/compare/v0.5.2...v0.6.0rc1Please report bugs using the github issue tracker.Release notes:NEW FEATURES SINCE BITCOIN VERSION 0.5--------------------------------------Bitcoin-Qt can display and save QR codes for sendingand receiving addresses.New context menu on addresses to copy/edit/delete them.New Sign Message dialog that allows you to prove that youown a bitcoin address by creating a digitalsignature.Wallets created with this version of bitcoin willuse 33-byte 'compressed' public keys instead of65-byte public keys, resulting in smallertransactions and less traffic on the bitcoinnetwork. The shorter keys are completelycompatible with older versions.New command-line argument -blocknotify=<command>that will spawn a shell process to run <command>when a new block is accepted.validateaddress JSON-RPC api command output includestwo new fields for addresses in the wallet: pubkey : hexadecimal public key iscompressed : true if pubkey is a short 33-byte keyNew JSON-RPC api commands for dumping/importingprivate keys from the wallet (dumprivkey, importprivkey).New JSON-RPC api command for getting information aboutblocks (getblock, getblockhash).New JSON-RPC api command for getting extra informationrelated to mining (getmininginfo).NOTABLE CHANGES---------------The -nolisten, -noupnp and -nodnsseed command-lineoptions were renamed to -listen, -upnp and -dnsseed,with a default value of 1. The old names are stillsupported for compatibility (so specifying -nolistenis automatically interpreted as -listen=0; everyboolean argument can now be specified as either-foo or -nofoo).The -noirc command-line options was renamed to-irc, with a default value of 0. Run -irc=1 toget the old behavior.PRELIMINARY SUPPORT FOR MULTISIGNATURE TRANSACTIONS---------------------------------------------------This release has preliminary support for multisignaturetransactions-- transactions that require authorizationfrom more than one person or device before theywill be accepted by the bitcoin network.Prior to this release, multisignature transactionswere considered 'non-standard' and were ignored;with this release multisignature transactions areconsidered standard and will start to be relayedand accepted into blocks.It is expected that future releases of Bitcoin-Qtwill support the creation of multisignature transactions,once enough of the network has upgraded so relayingand validating them is robust.For this release, creation and testing of multisignaturetransactions is limited to the bitcoin test network usingthe "addmultisigaddress" JSON-RPC api call.Short multisignature address support is included in thisrelease, as specified in BIP 16. Run with -bip16=0 toturn off support for BIP 16. But what if somebody hacked into your server and modified the code that decides which addresses get paid out?If they were smart, they'd shave just a little bit from everybody's payout and insert a payout to themselves... I imagine it could take quite a while before anybody noticed. I used my Phone-a-Friend and Ask the Audience, and I'm locking in BIP 16 as my Final Answer (follow the link if you don't get the stale pop culture reference). Good idea. Who wants to volunteer to do the fundraising and organize this, and let me know how I can help? No, bitcoind is solid as a rock, both with and without the BIP 16 patches applied. RE: lightweight versus heavyweight clients:First: lightweight clients (like Multibit) that don't store the entire blockchain must rely on the rest of the network to confirm that transactions are valid.  They can't check for themselves (this is true today, and BIP 16 doesn't change that at all).Full clients do check, but it is still not safe for them to accept 0- or 1-confirmation transactions; an attacker might be sending them an attempted double-spend (and the network might be still be trying to figure out which 'side' of the double-spend will win).  That is also true today."Backwards compatibility" means that all valid transactions created by the new software will be accepted as valid transactions by the old software.But, after BIP 16 is supported by a majority of the network, there could exist transactions that the old software considers valid but the new software rejects as invalid.So... does BIP 16 make things riskier for people running old software?  Yes, a tiny bit, in the very particular case of 1-confirmation transactions. And that particular attack requires that the attacker manage to mine a block that they know will be found invalid (which is expensive). Again, if you get bitcoins from somebody you do not trust then you should wait until they have 3 or more (6 if you want to be extremely safe) confirmations before considering the payment final.If you want all the technical details of why BIP 16 does NOT increase the risk for 0-confirmation transactions but does for 1-confirmation transactions... ask me another day (it has to do with how the old software recognizes "Standard" transactions and won't even show you transactions it doesn't recognize). They just keep running the code they've been running.   It will reject the 'bad' blockchain being produced by 95% of the miners, and accept the 'good' chain being produced by the other 5%. No, bad idea, two chains cannot peacefully coexist for more than a few dozen blocks, they would eventually make a complete mess out of users' wallets. No, you don't have to upgrade your client to receive coins from somebody using a BIP 16 multisignature wallet. I apologize for the shouting, it's been a hard couple of weeks.  And thanks for the support.Very quickly, the problem with any chain split is double spends.  An attacker can spend his bitcoins twice, once using CHECKSIGEX and some script instead of a public key.  They can wait for the coins to confirm on the "new" chain, and then they can spend the coins again, using CHECKSIG, on the old chain.The result would be massive confusion and chaos as those "old" users slowly upgraded and then found their wallets had NEGATIVE balances after the upgrade. OK, it has been a couple of days and the general consensus seems to be a 'rolling' two-week window, with no "below 20%" rule.I don't think there is any need for a two-week email discussion period among those familiar with the guts of Bitcoin, we've already spent months discussing the options and the consensus for BIP 16 is clear (see the tally here).It is time to call it settled and move on to bigger and better things, like what protocol to use when a client needs to gather signatures (REST? JSON? http? https? something else?). STOP IT.  JUST STOP IT.BIP 16 has overwhelming support, it will be the solution.Casascius:  please read BIP 0001 for the process to get assigned a BIP number.  The process is not "create a page on the wiki."As for the proposal itself:  No.You are proposing a non-backwards-compatible change, which would mean a "hard" blockchain split. Everybody agrees that is a bad idea. The confusion and potential for hacks if a significant fraction of bitcoin users were on a separate chain is massive; you gloss over all of that in your proposal. I moved Casascius' proposal ("BIP 22") to the Dev&Tech forum, I will respond there.
FYI: I pulled:  https://github.com/bitcoin/bitcoin/pull/686... which will likely result in a testnet blockchain split on February 15'th. I hadn't pulled before because I was busy with other things. The testnet faucet bitcoind will be updated in the next day or two.See this thread for the design discussion. Yes, exactly. At some point you have to say "enough is enough, I'm not going to let this person derail the project any more going forward."I'm saying that point is right now; see the unproductive, one-sided argument about BIP 20 versus BIP 21 on the bitcoin-development mailing list that is re-hashing a wiki editing war that "the rest of us" just gave up on a year ago for the latest example. You understand wrong.BIP 16 recognizes a certain pattern of bytes, and says "If you see those bytes, then the script will be provided by the person who has the coins instead of the sender (the sender just provides a secure hash of that script)."The script that is provided is then used EXACTLY as if it was a "normal" sender-provides-the-script transaction.BIP16 is the most conservative possible solution to the problem we want to solve. RE: debating ideas rather than people:  I've tried very hard to do that.I said last year when I reluctantly agreed to function as the lead core bitcoin developer that I have zero experience leading open source projects.  But I try to do my due-diligence and learn from the experience of other successful projects.The "aha" moment for me yesterday is the point in the video that I linked to, where the advice is to evaluate whether or not somebody causing issues for a project (whether intentional or not) is a net positive or negative to the project, and if they're "more trouble than they're worth" get them out of the project.This isn't about BIP 16 versus BIP 17, this is about one person draining the rest of the development team with nagging, idealogical rigidity, and holy wars against "impure" ideas.I try very hard to consider that maybe I'm wrong, but I think the evidence is clear.You might also argue that the subversion people take the wrong approach, in which case please send me a link to some other open source project that has dealt with the issue in a different/better way.I thought carefully about where to start this, and decided I might as well start it in the most public bitcoin discussion forum, because I think if I started it anywhere else it would eventually just appear here as "There's a Secret Conspiracy Started By Gavin To Oust A Valued Developer!" bittenbob:You replied 3 minutes after I posted.  You obviously didn't watch the video link I posted.At that link, two experienced subversion (another successful open source project) developers talk about what to do if somebody in your open source community makes it impossible to have unity and agreement.You say "we need to get back to unity" -- I agree.  That is why Luke must go. Thanks to midnightmagic who directed me to this very helpful video about identifying and then dealing with "poisonous people" in open source software projects:  http://youtu.be/ZSFDm3UYkeEAdvice on disinfecting:  http://youtu.be/ZSFDm3UYkeE?t=34m22sWatch the whole thing for examples of "poisonous person" behavior, like repeatedly flooding mailing lists/forums with their opinion or comments, not listening to the opinion of others, or making sweeping "the world will end if..." statements about the project.I'll be blunt:  I think Luke Dashjr fits the definition of a poisonous person, and I think Bitcoin would be better without him. At the very least, we wouldn't be creating two BIPs for every technical issue, one for Luke and one for the rest of us (see BIP 16/17, and now we have BIP 20/21, too). For context: makomk is the creator of CoiledCoin, a bitcoin alternative:  https://bitcointalk.org/index.php?topic=56675And RE: creating bots:  I created a BIP-17-stealing bot because it was really easy (took about 10 minutes of hacking).  A BIP-16-stealing bot would be a lot harder (because it would have to 'lie in wait' until the sender was redeeming the coins, and then race to relay/mine a 'stealing' version of the transaction before the rest of the network mined the original). Transaction sent: 2d3006cf1e16cb9f4097894fdaa0739c66d38eb9e0356be3fd8daf63810cf375I wrote some code that found all blocks with "/P2SH/" in their coinbase that did not include transaction fees in the block reward. I extracted the block reward payment address (or addresses, if it was a p2pool block) and reimbursed those addresses.If the amount would be less than 0.0011 bitcoins, then I rounded the amount awarded up to 0.0011.  Just because eleven is my favorite number (well, and because I like the idea of rewarding p2pool users, I think p2pool is neat). I've started a discussion on BIP 16/17 support moving forward (including trying to improve the testing process) here:  https://bitcointalk.org/index.php?topic=61922.0(please reply there so the discussion stays mostly in one place) I've started a discussion on BIP 16/17 support moving forward (including trying to improve the testing process) here:  https://bitcointalk.org/index.php?topic=61922.0 RE: rushing:I'm starting a discussion on how not to rush here:  https://bitcointalk.org/index.php?topic=61922.0 BIP 16 (or 17) will not meet their initial "go/no-go" deadlines.  You can see the state of support here: http://blockchain.info/P2SHThat's OK, that's why the deadlines were structured the way they are; in the past, Satoshi made changes like this by simply changing the code and then expecting everybody to upgrade. This is the first time we've used a more open, community-driven process.So, since we'll miss the deadline, the question is:  what next?  To focus discussion, here are two straw-man proposals that y'all can agree or disagree with; I'll go along with whatever consensus arises over the next couple of days:On the subject of testing... I've created a wiki page to record QA (quality assurance) testing that has been done on BIP 16.  If you can help test, or have been testing/deploying, then please add to this page:  https://en.bitcoin.it/wiki/BIP_0016_QAAs always, (on-topic) discussion, feedback, etc. is very welcome. If we can, I'd like to move past the "we dont' need to do ANYTHING" arguments, there is clearly rough consensus (with notable exceptions) that a short-bitcoin-address solution is needed. Yes, that's the use-case I care most about -- you have control over all of your keys, you just put them in multiple places so if you lose control of (say) your computer you don't lose your bitcoins.But there are other use-cases, like you agreeing to let the government control half the keys, so the government can "guarantee" the transactions, etc.  I can imagine the PR campaign: "It is just like Federal Deposit Insurance (FDIC), only for Bitcoin!"I don't think that will ever happen, though. I know I wouldn't trust the government to keep the keys to my money safe and secure, I don't think most people would, either. More likely is most people will trust banks to hold half the keys, and the governments will then regulate the banks like they do today to get information about who is paying who for what.... So far, I think the pace of technological change has outrun governments' ability to figure out how to use it to exert control.Maybe governments will get more nimble, but I'm going to continue betting that entrepreneurs and individuals will continue to widen the gap between the new freedoms that technology enables and what the law allows.RE: multisignature transaction dangers:  I'm completely convinced the (large, practical) benefits far outweigh the (small, theoretical) risks that it'll be abused by some repressive government(s). So the SolidCoin folks have been creating 1-post locked threads announcing stuff.Putting aside how you feel about SolidCoin, I wonder what other people think about that practice in general.  It seems to me to go against the purpose of "Forums" -- seems to me the whole point is discussion.  If you don't want discussion, then buy an ad or publish information on your website.Seems to me locking threads should be a last resort instead of "I'll just lock every thread I make to keep out the trolls."I'm going to lock this thread now because I think some people will disagree with me.(KIDDING, JUST KIDDING) It is completely artificial urgency, so a decision is reached and implemented in a reasonable amount of time.When I set the deadline, I had no idea Luke would:  a) Decide that a bugfix 0.5.2 release was a good idea. I thought the minor bugfixes weren't worth taking the time to make a release but arguing with Luke is like arguing with a brick wall, so I went "meh, whatever."  b) Propose BIP 17 and go on a war against BIP 16.Both of those distracted from implementation and testing of BIP 16.But what's past is past, the question is what do do from here; I'm planning on starting that discussion in the Dev&Tech forum tomorrow.PS: RE: risk:  the risks of either proposal to the overall health of the bitcoin network are small. The fees were 0 all the time, that was the bug. You know how I say "I make mistakes, don't trust me" ...A bug in my code is dropping transaction fees from the block reward. Simple to fix, and obvious in hindsight; I will be personally reimbursing everybody who got bit by this bug by finding the blocks affected by this, figuring out what transaction fees the creators SHOULD have received, and sending that number of bitcoins to the block-award address.Backports and the main git HEAD tree have been patched with the fix.On a higher level:There is obviously not going to be 50+% blockchain support for BIP 16 on Tuesday; I'm going to start conversations on how to move forward.And there has obviously not been enough testing of the BIP 16 code. Getting people to thoroughly test things BEFORE code makes it into the main tree has been a chronic problem, I'd appreciate ideas on how to avoid this kind of annoying, time-wasting "it's ready"/"oops, found a bug"/"it's fixed"/"wait, no, somebody found another bug" thing in the future. I've been unsuccessful finding the kind of QA (quality assurance) person who can both do the QA and do the fundraising necessary so they get paid. Yes, you will confuse the GUI if you send coins to 'change' addresses.My advice would be "don't do that."Thanks very much for helping to test, though, it is very appreciated! Just FYI: I contacted the top ten mining pools (as listed in the stickied threads in the Mining Pools subforum) directly via email way back in October, copied the email to them in the Mining Pools forum, and kept them 'in the loop' on all of this.I probably should have posted all of my followup emails to them in the Mining Pools forum, also; as I said, I'm terrible at that kind of "keep track of who you've told what and make sure you've got 'buy-in' from X Y and Z" thing.I think my only really major blunder was being too stubborn about inserting some wording into BIP 16 that Luke wanted inserted; I let my emotions cloud my judgement.
A few of the big mining pools have started supporting BIP 16, and I feel pretty confident that they've shaken out any major bugs.If you'd like to jump on the bandwagon, backported code for BIP 16 is available at:  https://github.com/gavinandresen/bitcoin-git/... in the "p2sh_backport" and "p2sh_backport_vinced" branches.Backports are available for all releases from bitcoin version 0.3.19 forward; for example if you're running code forked from the 0.3.24 release you would:Code:git checkout -b bip16  # Create a branch for the changes, just in casegit fetch --tags git://github.com/gavinandresen/bitcoin-git.git p2sh_backportgit tag -l 'bip16*'  # List the backports availablegit merge bip16_v0.3.24_1The "vinced_mergedmine" tags are for if you are using Vince's 'getauxwork' patch/branch for merged mining (based on bitcoin version 0.3.24).If you're running latest&greatest or are willing to upgrade to the latest&greatest, BIP 16 support is already in https://github.com/bitcoin/bitcoin/Finally, if you do decide to support BIP 16, upgrade your code, and start mining with it, let me know and I'll be happy to thank you publicly in my signature  (offer good until I run into the 300-characters-in-the-signature forum limit). (channelling my inner CoinHunter):It is SIMPLE ECONOMICS, people!price = function(supply,demand)So to create more demand, just fix the price and the supply!  Easy-peasy!(ok, done, back to reality) <begin troll>No it is not!  BIP 17 is bad for the network and will give you herpes!<end troll> Testing is actually one of the reasons I don't like BIP 17; it is harder to test, because it is much easier to steal BIP-17 transactions if the network hasn't yet upgraded (Luke has had to test BIP 17 on the main network instead of testnet because I wrote a BIP-17-stealing robot and ran it on testnet).I've spent the last couple of days running "transaction fuzzing" tests against both the new BIP 16 code and old clients; so far it has turned up no problems. "Fuzzing" means throwing lots and lots of random inputs at a program and making sure it deals with them properly; it is another good way of finding the "what do you know, we didn't think of that..." bugs.The fuzzing tool is here:  https://github.com/gavinandresen/bitcoin-git/tree/fuzzerAlso RE: ghastly exploits:Satoshi himself made changes to the way the scripting language works after a series of 'ghastly exploits' were discovered back in 2010 after the first slashdotting. I'm so stubbornly against BIP 17 because it basically reverts one of the changes he made (separating execution of scriptSig and scriptPubKey-- take that discussion to another thread in Dev&Tech if you want to argue more about it, please). Yes, BIPs are based on PIPs and BEPs (for Python and BitTorrent).  See BIP 0001 for the process. We all learn from our mistakes.Would you be willing to write an "informational BIP" describing how to do a rollout right in the future?I'm terrible at that kind of "first we'll need to get buy-in from groups X, Y, and Z by doing A, B, and C, then each of those groups will elect representatives who will have three days to agree to a schedule, which will be announced blah blah blah blah" LOL!  I gotta stop shaving and start working on that nifty 'stash ! I apologize for coming across as harsh, it has been a hard couple of weeks.And the reason it has been a hard couple of weeks is because I'm working really hard to try to get support for multisignature wallets... which would have prevented your loss (assuming you were using a multisignature-protected wallet).The hacker would have been able to ask your bitcoind to send him your coins, but you would have got a confirmation on your cell phone (or SMS or email with a one-time-PIN or whatever) and realize immediately that you'd been hacked.Or, in other words:  I've been working really hard trying to get a solution for the bigger problem of insecure computers, because I really do care about the "flock." I apologize-- I did not mean to attack you, I thought I stated nothing but facts. I am also sorry I didn't speak up about some of the things that were said about you earlier in this thread (e.g. suggesting an attack on your pool is NOT cool) but I don't have time to read every forum post as soon as it is posted... Did you read BIP 16?So there is no manipulation allowed AT ALL.A maximum of 1,000 "naked" OP_CHECKMULTISIG operations are allowed in the scriptSigs and scriptPubKeys of transactions in any given block.We had a block earlier this month with 1,8000 scriptSigs, so I think we are uncomfortably close to that limit.BIP 16 "hides" the CHECKMULTISIGS in the serialized script, so more of them are allowed.At the very least BIP 17 is harder to test-- Luke had to test on the main network because I was naughty and wrote and ran a BIP-17-transaction-stealing bot (sorry, I couldn't resist).I have zero commercial interest; I am not being paid by anybody for anything right now. Like this one? Let me count the ways:1. You must explicitly choose a username and password; you must have enough tech know-how to find your bitcoin.conf directory or run with -rpcpasswrod= options.2. If you choose a short password, then every failed access attempt DOES trigger a timeout.3. You must explicitly tell bitcoin to listen for connections from IP addresses other than localhost, using the rpcallowip= option.4. You must open a hole in your firewall that lets any arbitrary IP address through to your rpcport.I'm sorry you lost 75 bitcoins, but you really made a LOT of mistakes. Adding more layers of protection to the RPC interface isn't high on the development priority list, but if anybody wants to volunteer to keep track of number of failed RPC authentication attempts over time then be my guest and write a patch. Just be sure it isn't vulnerable to denial-of-service attacks by people deliberately generating failed login attempts. I just had a great discussion with a developer who urged me to write a "big picture" technical post about BIP 16.  So:First, I think a good design approach is to be clear about what you are trying to accomplish and think about what the ideal solution, if there were no constraints like backwards compatibility, would look like.The big picture goal has always been:  short, multisignature bitcoin addresses (BIP 13).The ideal solution would be to split scriptSig/scriptPubKey into three parts:signatures, redemption script, and redemption script hash.The sender would just provide the script hash, the receiver would provide the script and signatures to sign them over to somebody else.Ideally, the redemption script hash would be include a version or 'hash type' byte, so in the future if RIPEMD160(SHA256()) was ever considered insecure a smooth upgrade could happen.That's the ideal solution. I think all bitcoin transactions should have been done that way from the start, but it is what it is. Now we have to compromise, because one of the design constraints is backwards compatibility-- we are not going to replace scriptSig/scriptPubKey with something else and require everybody to upgrade all at once.OP_EVAL tried to do too much, in my opinion.  It enabled all sorts of nifty things, but we made the mistake of losing sight of what we were trying to accomplish.BIP 16, in my view, meets the goal and (importantly!) does nothing more.  I think of it as implementing the ideal three-way split in as simple and safe way as possible:signatures:   all the items except the last pushed onto the stack by the scriptSigredemption script:  the last item pushed onto the stack by the scriptSigredemption script hash:  the scriptPubKeyIt is pretty darn close to what I think would be the ideal solution. It even has a byte at the beginning of the redemption script hash that specifies what hash type to use (OP_HASH160) !That's all why I like BIP16 better than OP_EVAL.  I've written quite a lot here on the details of why I prefer BIP 16 to BIP 17, but, fundamentally, I believe that BIP 16 is a more conservative solution that is less likely to have an "darn, I didn't see that coming" bug. I want to try to clear up two misconceptions:1. The original implementation of OP_EVAL was not "exploitable", but it did have bugs.  2. The Feb. 1 deadline was explicitly designed to be a "soft" deadline; here is what BIP 16 says about it: I believe that without a deadline nothing would get done.We could talk and argue and discuss for six months trying to find the perfect solution, and there would still be people saying that we need another six months to argue and discuss some more.In fact, us developers HAVE been discussing and arguing about this for over six months now; this whole thing started with an impromptu brainstorming session at the first Bitcoin Conference in New York.As for this upgrade being "secretive" : huh? It certainly isn't/wasn't a secret among the developers, and until the developers came to rough consensus (and I believe there IS rough consensus, despite what Luke claims) I didn't think non-developers would be interested in the technical details.From some of the reactions in this thread, I think I was right-- most people don't care whether we use nails or screws or glue to build a better wallet.RE: rumors that I'm doing this for some personal reason:  100% untrue. I want a solution because it will make Bitcoin better sooner. Bitcoin addresses today correspond to one public key in your wallet. Signatures enter the picture when you spend the bitcoins sent to an address; your private key is used to generate the right digital signature, proving that you actually have that key.BIP 16/17 will enable bitcoin addresses that are associated with more than one public key. Your wallet will know both public keys, but will only know ONE of the private keys needed to spend the bitcoins (your phone or a "wallet protection service" will keep the other private key safe).So when sending coins, your wallet will provide one signature for the private key that it knows, the other required signature must come from whatever device is holding the other private key.The public keys aren't just strung together in a row, but are combined using a secure hashing algorithm (the same algorithm that is used to associate public keys with the bitcoin addresses we're all using today). I suppose I could have posted to the general Bitcoin Talk, but I didn't think that kind of low-level "plumbing" would be of general interest, any more than the average bitcoin user would care or notice a bunch of other low-level "plumbing" changes that are being made (I've got a patch pending that a certain-somebody doesn't like because it tightens up the definition of a "standard" transaction; I expect that if I pull that patch he'll start screaming that I'm wrecking future network flexibility all because I'm a big old worry-wart).I did post to the Mining/Pools forum a couple of months ago looking for feedback because miners/pool operators are the people who are "voting" on the original proposal:  https://bitcointalk.org/index.php?topic=50707.msg604435#msg604435 So you might have rumblings about changes to the network:  OP_EVAL and BIP 16 and BIP 17 and multisig and P2SH, and you wonder what the heck is going on.Here's my view; I'll try not to get too technical.First, the feature:I want more secure wallets. There's unanimous agreement among developers that the easiest, fastest way to get there is with "multi-signature transactions" -- bitcoins that require approval from more than one person or device to spend.For example, a future version of Bitcoin-Qt might know how to talk to an app running on your mobile phone. When you send bitcoins, it would provide one signature, but it would have to ask your phone for approval and the other signature.  That way even if your computer gets compromised by malware your bitcoins absolutely positively cannot be stolen, since the best the malware could do would be to ask your phone to approve the "Send the bad guys bitcoins" transaction.The bitcoin network protocol already mostly support multi-signature transactions, although they're considered "non-standard" right now.  Part of what is going in is making them standard.  That's not controversial.What is causing all the discussion is how to support sending coins into one of these new, spiffy, secure wallets.  There is rough consensus that the best way to do that right now is with a new type of bitcoin address; I say "rough consensus" because in a perfect world some people think that there wouldn't be bitcoin addresses visible to users at all.  And I say "right now" because we don't live in a perfect world, and there are no proposals for how, exactly, to replace bitcoin addresses with something better.Part of the controversy is whether really long bitcoin addresses would work-- would it be OK if the new bitcoin addresses were really long and looked something like this:  57HrrfEw6ZgRS58dygiHhfN7vVhaPaBE7HrrfEw6ZgRS58dygiHhfN7vVhaPaBiTE7vVhaPaBE7Hr(or possibly even longer)I've argued no: past 70 or so characters it becomes a lot harder to copy and paste, a lot harder to scan an address with your eyes to see if you're paying who you think you're paying, harder to create a readable QR code, harder to upgrade website or database code that deals with bitcoin addresses, etc. There is rough consensus that very-long addresses are not workable.So: there are three proposals on how to support short multisignature addresses-- BIP 12, 16, and 17.I withdrew BIP 12 (also known as "OP_EVAL") because I try to be extremely conservative when it comes to changes to core Bitcoin, and I think BIP 16 is a safer way to go.Luke Dashjr liked OP_EVAL, really doesn't like BIP 16, and came up with BIP 17, which solves the same problem in a different way. I still like BIP 16 best, because I think it is the most conservative, safest solution. The number of people who understand the guts of Bitcoin well enough to have an informed opinion about which is better is pretty darn small, but I think the controversy is really about how conservative we aught to be.All of the BIP 12/16/17 stuff is mostly engineers arguing over whether it is better to use a nail, a screw, or glue to put two pieces of wood together. Any of the solutions would work, and ordinary users wouldn't notice any difference; you'll still (eventually) get spiffy, more secure wallets.(don't take the analogy too far, in this case using a nail AND a screw AND some glue to be extra safe isn't an option).How dangerous is all this?  Is the bitcoin network in danger of falling apart one of these BIPs is adopted?The worst-case scenario for all of this stuff (including the non-controversial support of multisignature transactions as "standard") is that some bug will slip by, and an attacker will figure out a way of getting all the nodes running the new software to crash or misbehave. I'm working hard to prevent that from happening-- I've been writing "unit tests" and "fuzzing tools" and have been getting other developers to look really hard at the code.  I strongly believe that the new feature is worth the (small) risk, and that even in the worst-case scenario the consequences are not catastrophic (we'd just fix the bug and come out with a new release; everybody still running old code would continue to confirm transactions and create blocks while the early adopters were busy downloading and installing the fixed software).The bitcoin network is NOT in danger of falling apart if any of these are adopted; they are all backwards-compatible, so old software will continue to work exactly as before.Some footnotes (and sorry for making this so long):I concentrated on multisignature transactions for secure wallets, but they're useful for several other things, including escrow transactions and "emergency offline backup keys" for wallet backups.I've set an arbitrary deadline of February 1'st for deciding whether or not to "turn on" the new short-multisignature-bitcoin-address-support feature, mostly because deadlines are the only way I know to actually get people to pay attention. If you read the BIPs, those deadlines are designed to be flexible, so if there is NOT a majority of support or "we" think that not enough time has gone by or enough testing has been done they can (and will) be slipped.Right now, it looks like one person/pool (Tycho/deepbit) has enough hashing power to veto any change. I believe Tycho liked, and planned to support, the original OP_EVAL proposal, but doesn't like/support either BIP 16 or BIP 17 (he does like/support BIP 11, the multisignature-as-standard-transactions part of all this), so unless he changes his mind or there is a mass exodus from his pool short, multisignature bitcoin addresses will have to wait. Decentralized systems often settle into some kind of "power law distribution."For example, there's no central authority determining how large cities all over the world should be, and yet if you plot the size of cities you'll see that there are a few REALLY big ones, a bunch of medium sized ones, and a gazillion small ones.Plot the size of the bitcoin mining pools and I think you'll see the same thing.If there were no mining pools, then plot the hashing power of individual miners and I bet you'd see the same thing... (ArtForz used to be a significant fraction of mining power all by himself, for example)I worry a lot more about incentives than I do size; if the "naturally big" players have the right incentives, then they're not bad for the network. So far, I think the incentives are working nicely. For example, people HAVE tried to knock out the big mining pools and exchanges using denial-of-service attacks, and the big mining pools and exchanges have (as far as I can tell) worked to fix that problem themselves.PS: p2pool built into a bitcoin client is something I'd fully support, I think a lot of people would like a one-button "get a trickle of bit-pennies" option. Please explain to me how ANY of the proposals (the original OP_EVAL, BIP 16, and BIP 17) are any different in the "what if we change our minds and want to remove support" case?Removing support for BIP 17 would be harder than removing support for BIP 16, because if the network doesn't support it all BIP 17 transactions can be stolen as soon as they're broadcast.Imagine there are a bunch of un-redeemed BIP 17 transactions in the block chain and support for BIP 17 goes away.  Every single one of them could be immediately redeemed by anybody.The situation is better with BIP 16, because of the "half validation" done by old nodes.  Admittedly not a lot better, but it is the "belt and suspenders" nature of BIP 16 that makes me prefer it.
I've been very clear about my top development priorities:1. Network stability: DoS threats, scaling-up issues, etc.2. Wallet security/backup.I see everything else as lower priority; I want users to be confident that their bitcoins can't get stolen even if they slip up and open an attachment in Outlook that the aughtn't have opened before I want a downloads-the-entire-blockchain-in-10-seconds client with all sorts of other bells and whistles. Huh?  GIT HEAD bitcoind supports import private key functionality:Code:importprivkey <bitcoinprivkey> {label}Whether or not that's ever supported by the GUI is a different issue, and there I think we SHOULD be more concerned about people using the GUI shooting themselves in their feet. No, it really isn't.Here's a possible future implementation of IsStandard():Code:boolIsStandard(){    return true;}I like the idea of a future IsStandard() that allows more transaction types, but only if they're under some (sane) resource limits. That's non-trivial to implement; it seems to me that a conscious decision by the miners/pools to support or not support is less work and safer.Luke proposed something similar earlier, though; I'm surprised his patches don't implement it.I like whoever proposed that the string in the coinbase refer to the BIP, in the future that's the way it should be done.RE: schedules:Deadlines, as we've just seen, have a way of focusing attention.  OP_EVAL got, essentially, zero review/testing (aside from my own) until a month before the deadline.It seems to me one-to-two months is about the right amount of time to get thorough review and testing of this type of backwards-compatible change. Longer deadlines just mean people get busy working on other things and ignore the issue. So I'm trying to figure out why I'm so annoyed at I'm-sure-you-can-guess-who.And I think I've figured it out-- I think it is because I feel like I bend over backwards to be completely honest and open about potential flaws or problems with my ideas, and I'm completely honest and open about the fact that I'm human and I make mistakes.And it seems like that's being leveraged to create fear, uncertainty and doubt. I say something like "there is a small risk that...", but I NEVER EVER hear even a hint that the "other side's" proposal might be anything but perfect.Maybe I'm just too naive, and aught to get with the program and say that everything I do comes perfect, straight from God. People do tend to suffer from The Wise Leader Fallacy; maybe I should stop fighting against human nature and be more of a politician.Ok, enough venting. Yes.I'd love so see a bitcoin client with p2pool-technology built in; bring back the "generate coins" option!But... that will take a while. If I was a pool operator, though, I'd be thinking about other bitcoin-related businesses where I could use my expertise (the pool operators deserve a lot of credit, they've had to deal with DOS attacks, keeping their wallets safe, servicing hundreds or thousands of customers banging on their servers constantly, etc). Yes. Old solo mining clients will produce perfectly valid blocks, unless they've been hacked to mine "non-standard" transactions.There is a small risk that somebody ELSE will produce an invalid block, old solo mining clients will think it is valid, and will try to mine on top of it.  But that's a small risk because we'll wait until a super-majority of the network supports p2sh before starting to reject any p2sh transactions.So worst case scenario would be:+ Somebody with a hacked bitcoind mines a block containing a valid-under-old-rules, invalid-under-new p2sh transaction.+ Old miners try to build on it, but the majority of the network rejects it (there's a short block-chain split).If an attacker could target just the p2sh-supporting nodes and denial-of-service enough of them to get p2sh support below 50%, then there could be a longer block-chain split. If you do the math, that's not as easy as it sounds (if p2sh support is at 80%, you'd have to knock out 60% of the supporting nodes-- 20% of the original network would support, 20% wouldn't...).Don't do that, please. "Voting" with your coinbase should mean you actually do the extra validation required by p2sh, otherwise you're saying you support a feature when you really don't. I try not to respond to trolls, but....Quit spreading FUD. If you think BIP 16 is terrible, please give a rational reason, beyond "It is a special case," which I have repeatedly responded to. BIP 16 explicitly states:"Validation fails if there are any operations other than "push data" operations in the scriptSig."Let me try again for why I think it is a bad idea to put anything besides "push data" in the scriptSig:Bitcoin version 0.1 evaluated transactions by doing this:Code:Evaluate(scriptSig + OP_CODESEPARATOR + scriptPubKey)That turned out to be a bad idea, because one person controls what is in the scriptPubKey and another the scriptSig.Part of the fix was to change evaluation to:Code:stack = Evaluate(scriptSig)Evaluate(scriptPubKey, stack)That gives a potential attacker much less ability to leverage some bug or flaw in the scripting system.Little known fact of bitcoin as it exists right now: you can insert extra "push data" opcodes at the beginning of the scriptsigs of transactions that don't belong to you, relay them, and the modified transaction (with a different transaction id!) may be mined.Are you volunteering to make that happen? After working really hard for over four months now to get a backwards-compatible change done I'm not about to suggest an "entire network must upgrade" change... By the way... if there is no fully-functional reference implementation yet, you really shouldn't be putting "CHV" in your coinbases yet. The string in the coinbase really aught to mean "this code is all ready to support this feature,"  because full support from a majority of hashing power is what we want to measure.Imagine you're an early adopter.  You ask people to send you money into your spiffy new ultra-secure wallet.With BIP 16, transactions TO you will take longer to get into a block because not everybody is supporting the new feature.But transactions FROM you will look like regular transactions, so the people you are paying won't have to wait.That is not a big difference, but it is an advantage of the BIP 16 approach.No, they are not evaluated in the same way.  The bit of code in bitcoin transaction validation that makes me nervous is:Code:    txTmp.vin[nIn].scriptSig = scriptCode;... in SignatureHash(), which is called from the CHECKSIG opcodes.  scriptCode is the scriptPubKey from the previous (funding) transaction, txTmp is the transaction being funded.This is the "Copy the scriptPubKey into the scriptSig before computing the hash that is signed" part of what OP_CHECKSIG does.I like BIP 16 better than OP_EVAL/BIP 17 because BIP 16 does two complete validations, once with the scriptPubKey set to HASH160 <hash> OP_EQUAL and then once again with the scriptPubKey set to (for example) <pubkey> OP_CHECKSIG.BIP 16 essentially says "If we see a P2SH transaction, validate it, then treat it is a normal, standard transaction and validate it again."BIP 17 will run OP_CHECKSIGs when it is executing the scriptSig part of the transaction, which is a completely different context from where they are executed for the standard transactions we have now.Again, I can't see a way to exploit that but it makes me very nervous. If you don't want to change you can just ignore the new feature(s). There is zero risk with the proposed changes for anybody running old, un-hacked versions of bitcoin.(if you are solo mining and hacked your version of bitcoin to accept 'non-standard' transactions then you could shoot yourself in your foot, but even that is unlikely). Nobody has written a Korean translation.  If/when somebody does (join https://www.transifex.net/projects/p/bitcoin/ if you want to help) you'd get the Korean translation.An option to change the language in the GUI is a great idea.  Somebody should do that.... We need more Windows developers, by the way; if you know a lot about developing in C++ on Windows and want to (for example) create a Visual Studio project or resurrect makefile.vc or fix the build instructions if they're not right that'd be spiffy. I haven't seen discussion of BIP 17 anywhere besides IRC, so I thought I'd start one.I'll start by saying that I'm trying hard to put aside my biases and dispassionately evaluating the proposal on its merits (I'll just say that I'm not happy with the way BIP 17 came to be, but it is what it is).Quick executive summary of BIP 17:A new opcode is proposed, OP_CODEHASHVERIFY, that replaces OP_NOP2.It is used in a new "standard" scriptPubKey that looks like:Code:<hash> OP_CODEHASHVERIFY OP_POP... which is redeemed using a scriptSig like (for example, a 2-of-2 CHECKMULTISIG):Code:OP_0 <signature> OP_CODESEPARATOR 2 <pubkey1> <pubkey2> 2 OP_CHECKMULTISIGOP_CODEHASHVERIFY is defined to take the hash of everything in the scriptSig from the last OP_CODESEPARATOR and compare it to the top item on the stack. If the hashes match, then it is a no-op, otherwise script validation fails. (see the spec for all the details for what happens if there is no CODESEPARATOR or a CODEHASHVERIFY is put in the scriptSig)BIP 17 is an alternative to BIP 16, which has a scriptPubKey:Code:OP_HASH160 <hash> OP_EQUAL... which is redeemed with:Code:OP_0 <signature> OP_PUSHDATA(2 <pubkey1> <pubkey2> 2 OP_CHECKMULTISIG)I see the appeal of BIP 17 -- the redeeming opcodes aren't "hidden" as serialized bytes, they're right there in the scriptSig. That feels less like a hack.However, there are a couple of practical reasons I like BIP 16 better:Old clients and miners count each OP_CHECKMULTISIG in a scriptSig or scriptPubKey as 20 "signature operations (sigops)."  And there is a maximum of 20,000 sigops per block.  That means a maximum of 1,000 BIP-17-style multisig inputs per block.  BIP 16 "hides" the CHECKMULTISIGs from old clients, and (for example) counts a 2-of-2 CHECKMULTISIG as 2 sigops instead of 20. Increasing the MAX_SIGOPS limit would require a 'hard' blockchain split; BIP 16 gives 5-10 times more room for transaction growth than BIP 17 before bumping into block limits.With BIP 17, both transaction outputs and inputs fail the old IsStandard() check, so old clients and miners will refuse to relay or mine both transactions that send coins into a multisignature transaction and transactions that spend multisignature transactions.  BIP 16 scriptSigs look like standard scriptSigs to old clients and miners. The practical effect is as long as less than 100% of the network is upgraded it will take longer for BIP 17 transactions to get confirmed compared to BIP 16 transactions.Old clients and miners will immediately accept ANY scriptSig for BIP 17 transactions as valid. That makes me nervous; if anybody messes up and sends coins into a BIP 17 transaction before 50% of hashing power supports it anybody can claim that output. An advantage of BIP 16 is the "half-validation" of transactions; old clients and miners will check the hash in the scriptPubKey.I also have some theoretical, "just makes me feel uncomfortable" reasons for disliking BIP 17:OP_CHECKSIG feels like it was originally designed to be in the scriptPubKey-- "scriptSig is for signatures." Although I can't see any way to exploit an OP_CHECKSIG that appears in the scriptSig instead of the scriptPubKey, I'm much less confident that I might have missed something.  I'm much more confident that BIP 16 will do exactly what I think it will (because it is much more constrained, and executes the CHECKSIG exactly as if it appeared directly in the scriptPubKey).Changing from the scriptSig being just "push data onto the stack" to "do the bulk of verification" also makes me nervous, especially since nodes that relay transactions can add whatever they like to the beginning of the scriptSig before relaying the transaction. Again, I can't think of any way of leveraging that into an exploit, but the added complexity of code in the scriptSig and requiring OP_CODESEPARATORs in the right place makes me nervous.I've never liked OP_CODESEPARATOR-- it is not like the other opcodes, the way it isn't affected at all by OP_IF and the way it 'steps out' and causes the raw bytes of the transaction to be hashed.  Nobody has been able to figure out how to use it, and the best guess is it is like your appendix:  maybe useful in the past, but not useful now.  Safer to get rid of it entirely, in my opinion. Once transactions are validated and buried "deep enough" in the blockchain you can forget their inputs, because the inputs are only needed for validation.... although SOMEBODY on the network should remember them, in case I-don't-trust-anybody nodes want to validate the entire blockchain. Good idea. Somebody should do that. Just the bitcoind node. Yes, the next step is to get miners and clients to recognize a new 'standard' transaction type that does multisig.  BIP 11 describes them, they're already supported in git HEAD and by the p2sh code, and old miners and clients will recognize and validate blocks that contain OP_CHECKMULTISIG transactions. I did some work today that should be useful to stress-test transaction handling for alternative bitcoin implementations:  https://github.com/gavinandresen/bitcoin-git/tree/fuzzerFrom its README.md:Hacked version of Bitcoin that adds a "relayfuzzed" command. Note: this only works on the testnet.USING THIS CODEFirst, create one or more transactions using the send* RPC commands, and remember their transaction IDs. This version of bitcoin is modified so 'original' wallet transactions are not announced to the network.Then, you can generate as many "fuzzed" variations as you like using the relayfuzzed command, which takes a transaction ID and an integer to seed a random number generator.Example usage from a bash prompt:Code:# Run two bitcoind's that talk to each other:alias bc1="./bitcoind -datadir=testnet-box/1"alias bc2="./bitcoind -datadir=testnet-box/2"bc1 -daemonbc2 -daemon# Now fuzz a send-to-self:TXID=$(bc1 -testnet sendtoaddress $(bc1 getnewaddress) 0.01)for i in {1..100}; do bc1 relayfuzzed $TXID $i; doneThe result should be a long list of fuzzed transaction ids, almost all of which are actually bad, invalid transactions. And a lot of "ConnectInputs failed" in testnet-box/2/testnet/debug.logTHINGS TO BE AWARE OFYou will trigger the denial-of-service-prevention code using this. If you are running a "testnet-in-a-box" setup (see https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/) then you don't have to worry, nodes running on localhost don't disconnect each other for bad behavior. Otherwise, you can run bitcoind with -banscore=999999 to avoid being disconnected.Running the code being tested under Valgrind or Purify or another memory-corruption detection tool is a good idea.Types of "high-level" fuzzing done:Insert random opcodes at the front of the transactions's scriptSig(s)Types of "low-level" fuzzing done:Change bit in one of the transaction's bytesDelete one or more bytesInsert one or more random bytesTODO:Generate mostly-random scriptSig/scriptPubkey pairs that validate, and generate pairs/chains of valid transactions that spend them. So what happens if I put two OP_P2SH's in a scriptPubKey?  What happens if I put one in a scriptSig? What if I put it inside an OP_IF ... OP_ENDIF ?I think you're really just suggesting that the "magic" scriptPubKey be 24 bytes big instead of 23, and start with one of the NOP opcodes-- yes? In which case there is going to be a special case code path anyway.
Yes, of course. I did most of my testing on 'testnet-in-a-box' nodes, but spent a day producing P2SH blocks and transactions on testnet; see, for example this transaction that spends a P2SH transaction:  http://blockexplorer.com/testnet/tx/cff697a07fa21780b2553c6e86bf956cb42838b0e9b226da2c6b3cd7754da736Today I created a smart 'transaction fuzzer', and tomorrow I'll be creating and running stress-tests for the new p2sh and multisignature code to try to catch anything code review and unit tests might have missed. notme is exactly right; the change is backwards-compatible, pool users don't have to do anything.Pools and solo miners should upgrade, or they run a (very small) risk that they'll waste time hashing a block that can't be valid.The risk is very small because it requires that somebody mine a block containing a /P2SH/ transaction that is valid-under-the-old-rules, invalid-under-the-new. That won't happen by accident, somebody malicious will have to create such a transaction and then find a miner who is willing to put that non-standard transaction in their block (and is willing to create a block they know the network will reject).They would spend a lot of time (and therefore money) on an attack that would do nothing but slow down transaction confirmations a tiny bit and maybe trip up some random, unlucky mining pool or solo miner who didn't bother upgrading.Gory details if you're not already bored:Old miners and clients will ignore all /P2SH/ transactions; they won't relay them to other nodes and won't put them in blocks they mine, because they're non-standard.  So an attacker can't broadcast an invalid /P2SH/ transaction and hope it gets included in a block; they'll have to mine a block themself, or partner with a big solo miner or pool who is willing to produce bad blocks.If an attacker DID manage to create a block with a timestamp after the switchover date and a bad /P2SH/ transaction in it, then some percentage of the network will try to build on that bad block.  Lets say 70% of hashing power supports /P2SH/.  That would mean only 70% of the network was working on a good block-chain, and the result would be transactions taking, on average, about 14 minutes to confirm instead of the usual 10 minutes.In other words: they'd give up a $300 block reward and manage to just give the network a tiny little hiccup. Is this open source? The code is written and committed to the master branch, backports are available for every bitcoin release since 0.3.19, and I'm as confident as I can be there are no major bugs or "gotchas" hiding in the pay-to-script-hash code. Several of the big mining pools have been testing it and will start deploying it on the main network."This stuff" IS programmed in a way so it is only activated on the main network after an agreed-upon time.There are still two weeks until we look and see how much support it has, and almost a month before /P2SH/ transactions are fully validated on the main network. You want to wait 30,000 more blocks?  More than 7 months? That's a darn good way to get everybody to ignore the issue for 6 months and then restart this debate from square one with 1 month to go and a whole fresh set of people who think they're being helpful suggesting using OP_ADD to combine private keys because they don't realize we thought about and discarded that idea 4 months ago. No, that's not a realistic attack.For an attacker to feed you a malicious block chain, they would have to be able to produce malicious blocks that have CORRECT proof-of-work. I don't think it is realistic to think that any attacker would throw lots of hash power onto a malicious block chain just so they can feed a bad block chain to somebody who connects to them.Especially since that somebody would discover that their version of the block chain was incorrect within about 10 minutes, as soon as they got a new block message.The bugfix was a "belt and suspenders" change to limit the potential damage from somebody who already had more than 50% of hashing power. All righty, I mostly stepped away from the keyboard for a couple of days and I'm less frustrated and angry.So first, I want to apologize to Luke for calling his CODEHASHCHECK code "a joke." I was frustrated that after weeks of discussion and gathering consensus around /P2SH/ he and piuk (and a couple others) decide it would be a good idea to propose slightly-different-but-not-obviously-better alternatives.I still think Luke went about this the wrong way; for example, I think I would have been happy to accept a patch that made supporting /P2SH/ optional if he had presented it rationally instead of posting "ALERT! GAVIN IS HIJACKING BITCOIN! ACTION NEEDED!" I'd still be happy to accept a patch turning on/off the "put /P2SH/ in the coinbase" (assuming the general consensus is that is a good idea), but that's a discussion that should happen in the Dev/Tech forum.In fact, most of the discussion in this thread on the merits of various proposals belongs in the Dev/Tech forum, and most of the concerns expressed here in this thread have already been discussed over the last several months. piuk:  please read BIP 0001, it describes the process for getting BIP numbers assigned. RE: Why OP_CODEHASHVERIFY is bad:First, it requires that you concatenate the scriptSig and the scriptPubKey and execute them as on Script.Bitcoin used to validate scripts that way, but ArtForz discovered a bug in July of 2010 (the OP_RETURN bug) that allowed anybody to spend anybody else's bitcoins.  It by far Bitcoin's biggest bug and Satoshi's biggest brain-fart.Part of the fix was to make executing the scriptSig completely independent of executing the scriptPubKey (see commit 7f7f07 in the tree if you're really interested).Is there some other subtle bug involving the interaction of OP_CODESEPARATOR, OP_CHECKSIG, OP_IF and the proposed OP_CODEHASHVERIFY lurking? I don't know, and I'm not about to risk all of Bitcoin to find out.Second, Luke obviously isn't very familiar with all the details of transaction validation, or he would know that a scriptPubKey needs to leave a true value on the stack or validation fails.  So either OP_CODEHASHVERIFY both verifies AND leaves a true value on the stack (in which case it is inconsistent with the other VERIFY opcodes that consumer their operands) or it should be OP_CODEHASHEQUAL.Third, the whole reason OP_EVAL caused controversy and was withdrawn is because adding a new opcode is more risky than adding a little extra validation logic.  OP_CODEHASHVERIFY is almost as risky as OP_EVAL.Fourth, the code Luke posted is a joke. He doesn't modify VerifyScript to combine the scriptSig and scriptPubKey, so there is no way for the code hash to get communicated between the scriptSig and the scriptPubKey.  I think he is just trying to do whatever he can to cause trouble and confusion.strikethrough added:  I read through his code again and his code is a joke for a different reason than I thought at first glance (I missed the vchLastScript nonsense). Here's my motivation for /P2SH/ or something like it:I want to stop playing whack-a-mole with wallet stealing viruses and trojans, and I think requiring more than one private key to sign away your bitcoins is the critical feature needed to do that. Keep one set of keys on your computer, another set of keys on your cell phone, teach each to talk to the other before sending out bitcoins and you're safe (as long as a virus or trojan doesn't infect BOTH your cell phone and your computer at the same time).The bitcoin protocol already supports that, but the bitcoin network, the bitcoin software, and the bitcoin addresses that we're all using now don't support multisignature transactions.OP_EVAL and /P2SH/ and Luke's OP_CODEHASHCHECK are all slightly different ways of implementing multisignature transactions that are as short as the bitcoin addresses we're using today.RE: the timeframe:I'm pushing this hard because I'm tired of hearing that users lost their bitcoins to trojans and viruses, and getting there is a multi-step process that will take a lot longer than I'd like:1. First a majority of miners have to validate, accept and mine the new transaction types. (that's the Feb 15 date)2. Second we have to convince enough people to upgrade so that they are relayed around the network and not dropped3. Finally, we can release software with wallets that use the new feature.I'm losing patience because this process started in October, over three months ago, and certain people seem determined to do whatever they can to derail it-- if I was more conspiracy-theory-minded I would think somebody was purposely trying to keep bitcoin less secure than it can be. roconnor brought up legitimate complaints with OP_EVAL that were discussed and addressed with /P2SH/, but I can't respond to every half-baked scheme that is supposedly "better" or I will spend all of my time explaining why something like CODEHASHCHECK is a bad idea and have no time left over to making Bitcoin better. Luke, you try my patience.I'm going to step away from the code for a few days to calm down before I do something stupid because my patience is wearing thin. I just pulled p2sh into master, replacing the OP_EVAL code that I pulled last month before the controversy erupted.If you think it is a bad idea, then don't use it.  Hopefully it will inspire you to prove that I'm an idiot and completely wrong about people continuing to use 30-something-character "bitcoin addresses" for the next year or three. I don't think they make the two-person-escrow case you describe any simpler; use a plain CHECKMULTISIG for that case.I think they might make third-party escrow easier; the escrow agent would get public keys from all the participants and then give the buyer a short script hash to send the funds into escrow, instead of giving them three separate public keys. If all the key gathering negotiation happens automatically (as it should) then it doesn't really matter, but I suspect that it will take a while to get a secure, convenient, well-supported multiparty transaction negotiation protocol defined and implemented. So I bet pay-to-script-hashes for escrow transactions will get copied and pasted (or put into emailed or SMS-ed URLs) for at least a year or two.But the use case I REALLY care about is the secure, multiple-signatures-required-to-spend wallet. Script hashes are the same length as existing bitcoin addresses, so it should be much easier for services that can already send to bitcoin addresses to be modified to send to multisignature script hashes (if they use bitcoind to validate addresses then they will just need to update bitcoind; otherwise it is a trivial change to their bitcoin-address-validation routine to recognize the new pay-to-script-hash format). What percentage support by February 15'th would make you comfortable?  As I said, if it is 55% from Feb 1 to Feb 15'th (or, worse, if it varies a lot in that time) then I think we'll need to re-assess. I expect to get well over 70% support starting Feb 1.I'd rather use some common sense rather than spend days arguing about exactly what percentage aught to be specified in the BIP, or how many standard deviations of variance are acceptable between Feb 1 and 15. No, not "something else", it is "if you see this very-specific sequence of bytes in the scriptPubKey then do this ADDITIONAL validation."As for saying something in BIP 16 about obsoleting scriptPubKey :  no.  Although I think in the future we'll move towards all transactions being pay-to-script-hash, I think it is dumb to put anything like "we think this is what is going to happen in the future" into standards documents.Can we keep the big picture in mind?  The reason I'm pushing so hard for "send bitcoins to a multisignature-protected-address" functionality is so users stop losing their bitcoins to malware infecting their computers and smartphones and to scammers.We can spend more months arguing over trivia, but I would much rather we spent the time thinking hard about, and building, great wallet and escrow solutions that solve Bitcoin's biggest technical problems. Right........Also, the worst case scenario isn't very scary-- worst case is the less-than-50%-of-miners who did the switch find themselves on the short end of a blockchain split, so they lose revenue (and transactions take longer to confirm because the network is working on two different chains).That would motivate them to either quickly recruit more hashing power or quickly switch back to the old rules. If we manage to get 55% or better on Feb 1, then for the next two week's I'll be sending out the message "Upgrade or you might be on the short end of a blockchain split come Feb 15" -- and I expect the result to be a large majority of miners supporting P2SH by the Feb 15'th switchover date. If we're still at 55% on Feb 7'th then I'll be worried, too, and might advise miners to push the hard switchover date a couple of weeks (if they're using the patches I'm creating then it is a command-line argument to bitcoind).The real danger is for the 45% -- after Feb 15 (assuming the switchover happens) all it takes is for one old miner who is including non-standard transactions in their blocks to create a block containing a transaction that is invalid under the new rules.  They announce the block, and any miners who haven't upgraded would happily build on it, only to waste some hashing power because the 55% majority will sooner or later reject their chain.However, I don't think anybody will accidentally mine a block spending an 'invalid under the new rules transaction' in it (the number of people mining non-standard transactions seems to be very small), and it seems unlikely an attacker would waste time solving one or more blocks that they knew were going to be rejected by a majority of the network. Are you communicating via JSON-RPC or by command-line (bitcoind sendmany ....) ?There shouldn't be any limits if you're talking directly via JSON-RPC, but if you're calling it via the command-line then sh and bash and whatever Windows uses to launch processes all have length limits. Why do you assume that?A pool operator will have hardware capable of validating X transactions per second.  Right now, with low transaction volume, X is much bigger than current transaction volume, no matter what kind of hardware the pool operator is using.If we assume Bitcoin is successful, eventually the number of transactions to be processed will be bigger than X.The pool operator will have an incentive to sort transactions by the fee minus how expensive they are to process, and drop transactions that cost too much.   (or maybe implement some more complicated strategy like Mike's assurance contracts-- I have no idea how it will evolve).Miners have an incentive to lie about transaction fees to clients-- they want higher fees, so even though they might accept 0.001BTC for a transaction they might tell clients that the fee is 0.005BTC.Clients should be able to get a pretty good idea of what transaction fees are needed (if any) to get a transaction into the block chain just by watching 'tx' and 'block' messages and seeing what miners are actually doing, instead of trusting miners to tell the truth about what they are doing. What do I personally think?  I think it was mean, and luke-jr shouldn't have done it.But if your system has a requirement "everybody will play nice" then your system is broken. You have to assume that people will try to break what you build (and also have to assume that nobody is perfect so you'll have to have a way of fixing your system when you find out it is broken).So my heart feels sorry for CoiledCoin; my head thinks it is possible Luke-Jr did all the altchains a favor by demonstrating a problem that needs to be solved. And I'll re-iterate what I say in my "Be Safe" post:  only invest money or time in altcoins (or Bitcoin, for that matter) that you can afford to lose. My prediction for 2012:Peer-to-peer pool technology will mature (will get easier to install and run), and p2pool's will be more than 25% of bitcoin hashing power by the end of the year.
I love that idea!  Point your camera at the product, confirm payment, and you're done.RE: changing prices:  I wonder if you could make little QR-code-capable LCD or e-ink displays cheap enough to put 20 of them in a vending machine.It'd also be a great opportunity for practical jokes, like making the machine vend... oh, I dunno, NerdsTM along with their popcorn. Because we don't have infinite programming resources, and we've been busy working on low-level stuff that will lead to solutions that will fix the "my hard drive crashed" and also the "my computer got infected by malware" and "my house burned down along with my computer and all of my USB thumbdrives" disaster scenarios. I hate to inject gloom and doom into a fun topic like vanity bitcoin addresses... but y'all should be aware that one of my longer-term goals for the Bitcoin system is to make bitcoin addresses disappear. I hope Bitcoin software 10 years from now tells users "You're about to pay 11 micro-Bitcoins to Amazon.com" and not "2mRwtf8blahblahblah". And I'm not alone, I know Mike Hearn feels strongly about making bitcoin addresses go away for ordinary users.If you do spent lots of time creating The World's Best system for mining vanity bitcoin addresses, please don't be upset or surprised if you find it is obsolete when "Bitcoin 2017 Turbo++ Enhanced Edition" is released. The consensus from Tuesday's IRC meeting is to replace OP_EVAL with "pay-to-script-hash" -- a simpler, safer-but-less-powerful alternative for creating bitcoin addresses for multisignature and future more-complex transactions.So please read the BIP: https://en.bitcoin.it/wiki/BIP_0016And the source: https://github.com/gavinandresen/bitcoin-git/tree/pay_to_script_hashImportant dates:Feb 1 deadline to try to get 50+% of hashing power to express support.Feb 15: "full validation" pay-to-script-hash switchover date (assuming success on Feb 1)  Just thinking out loud...... but vanity addresses using 1-of-2 multisignature transactions and BIP 13's new bitcoin address format could be orders of magnitude easier to generate.You'd start with a normal keypair.And simply compute the hash of the public key and another, arbitrary, "I don't have the private key but I don't care" public key (in an "OP_1 <public_key> <don't care public key> OP_2 OP_CHECKMULTISIG" transaction type).You'd always spend the funds sent to the vanity address using pk1.No expensive ECDSA addition or multiplication required, just lots of SHA256/RIPEMD160 hashing and base58 encoding and string comparing.-----------Widespread use of the new pay-to-script address format will have to wait until "everybody" upgrades to support it, though. And it does make transactions larger (2 public keys instead of 1) than the find-the-right-private-key solution. Newer versions do this already. Don't be sad-- it hasn't been wasted at all. Most of the work was making multisignature transactions work properly, the OP_EVAL part was a small amount of code (which becomes an even smaller amount of code under the new PayToScriptHash scheme, which is one of the reasons I like it).And re: new cycle of coding/testing/etc taking 3 more months:  I'm going to propose slipping the schedule by two weeks, which means a "network is fully validating the new transaction types" of Feb 15 instead of Feb 1. Ok, here are three:Authorities gather enough circumstantial evidence to get a warrant.  They raid the guy's house/office, and find a wallet on an unencrypted hard disk with private keys corresponding to "B".  That should be enough evidence to convict.Or the guy thinks he's being clever by breaking up his 10,000 BTC into 50 BTC chunks and slowly, over time, transfers them to new wallets C, then D.  Then deletes B and C.But he doesn't realize that the graph of transactions he is creating would be IMPOSSIBLE to happen by chance if wallets B and C belonged to innocent bystanders (what are the chances that, say, 10,000 stolen bitcoins were broken up into a bunch of pieces and then just happened to end up later in the SAME wallet?)Or somebody with lots of connections to the bitcoin network is figuring out (with pretty good precision) what IP address each transaction is coming from. The guy doesn't use a proxy to hide his IP address, and the transactions from A->B->C->D all appear to come from IP addresses allow assigned by the same Internet Service Provider in the guy's town. The authorities subpoena the ISP and find out the guy was assigned those IP addresses when the transactions hit the network.----All of the above is why I say it is hard to be anonymous when using Bitcoin, and I'd urge you not to do anything with bitcoins that would prompt The Authorities to bother getting subpoenas/warrants to try to figure out who you are. https://bitcointalk.org/index.php?topic=34028.msg656908#msg656908 Good Idea.  How are you creating the files?What language are you writing in?  Anybody want to volunteer to write a Satoshi-bitcoin unit tester in C++ that parses ThePiachu's format? Or do you already have code that runs them? Committing a gazillion Script unit test cases to src/test/scriptTests/ sounds like a very good idea to me. Wallet.dat files don't get corrupted very often; blkindex.dat or addr.dat corruption is much more common (which makes sense, they are much larger and changes all the time as new blocks are added/indexed).A lot of reported "database corruption" has been Berkeley DB log file incompatibility (the .dat files are compatible between 4.* releases and across operating systems; I know the log files are NOT compatible from 4.7 to 4.8, I think they're cross-OS compatible too but could be wrong about that).The Satoshi bitcoin code could certainly do a better job of helping users recover from any/all of the above, although I personally think that development time would be better spent on the "what if my computer catches fire" scenario-- can we make it really easy for users to securely backup and restore their wallets off-site? The Bitcoin price ($4) was the NPR Planet Money podcast's indicator for their Tuesday, Dec 27 episode:  http://www.npr.org/blogs/money/2011/12/27/144323325/the-friday-podcast-the-rest-of-the-story The client doesn't support multisignature transactions yet. You can do 2-of-3 (overseer holds 2, so can always spend, you hold 1) instead to accomplish the same thing. I suppose having the overseer put transactions in the block-chain that everybody can see might make you and the people you're paying trust them more... TrundleNet (no reason)Transactinator (T13 for short)Eleventy (because eleven is my favorite number) Disclaimer:  I'm a Tor newbie and networking stuff isn't my strong suit, you probably know more about it than I do.But: I fixed a Tor-related bug for version 0.6 a few days ago.  In particular, I moved all of the "turn this on or turn this off if running over Tor" to one spot (in the init.cpp file) and reworked the code so that you can override all of those decisions via command-line or bitcoin.conf switches (e.g. specify -nolisten=0 to set nolisten to false so you DO listen even if running a port 9050 proxy). Yes.  That would be a "1 of 2 signatures required" multisignature transaction.That you can't do. If the coins were stolen, the thief can just sign them away.I suppose you could do a "2 of 2 signatures required" and then have the overseer only approve transactions that were ALSO 2-of-2 required (where 1 was the overseer's signature).  A thief could take your coins away, but wouldn't be able to spend them without the overseer's OK.  The overseer wouldn't be able to take them back, though.More complicated schemes are probably possible if you want to trust the overseer completely... but if you and the person you are paying trust the overseer completely then why bother using bitcoin transactions at all?  Just hold accounts at the overseer and they can transfer balances or reverse transactions as they like.... I've been working hard to make sure there will be no blockchain split, and I've convinced myself I've thought through all the "old/new client sending transactions to an old/new miner" cases.The only case where an old miner could be split off the network is if they are mining non-standard transactions (which means they've modified their mining code) and do not upgrade. If you are in that situation, then you should either stop adding transactions containing OP_NOP1 into your miner's memory pool or upgrade to interpret OP_NOP1 as OP_EVAL.But I've said it before and I'll say it again:  don't trust me. I make mistakes. Two serious bugs in my OP_EVAL/multisignature code have been found (and fixed) in the last week.  Version 0.6 will have at least a month of release candidate testing.I still firmly believe the benefits of the new 0.6 features far outweigh the risks.  Please help minimize the risks; review code if you can, run release candidate on the testnet and try to break them, read the BIPS and try to think of ways bad people might use them to do bad things. Review the contingency plans and think about how they could be improved or if you could help when (when, not if) vulnerabilities are found. makomk reported a remote vulnerability that I pulled into the master bitcoin/bitcoin tree on December 20. If you are running git-HEAD code on the production network you should pull the latest code to get the bug fixed.This affects only anybody who has pulled and compiled their own bitcoind/bitcoin-qt from the source tree in the last 5 days.Gory details:I made a mistake.  I refactored the ConnectInputs() function into two pieces (FetchInputs() and ConnectInputs()), and should have duplicated a check in ConnectInputs for an out-of-range previous-transaction-output in the FetchInputs() method.  The result was a new method I wrote to help prevent a possible OP_EVAL-related denial-of-service attack (AreInputsStandard()) could crash with an out-of-bounds memory access if given an invalid transaction.The bug-fix puts a check in FetchInputs and an assertion in AreInputsStandard. This does not affect the back-ported "mining only" code I wrote that some miners and pools have started using.The good news is this was found and reported before binaries with the vulnerability were released; the bad news is this was not found before the code was pulled and could have made it into the next release if makomk had not been testing some unrelated code.Before releasing 0.6, I would like to have an "intelligent, bitcoin-specific fuzzing tool" that automatically finds this type of bug that we can run before every release. If anybody already has one, please speak up! Yes.The times the blocks are announced also matters; if my node suddenly sees a longer 10-block chain it has never seen before, then either it is a 51% attack or the network was split and just came back together.If the network was split 10 blocks ago then I should see that those 10 blocks took twice as long to create as expected.Rating blocks is a neat idea; I can think of several potential criteria, there are probably more we could come up with:Did I first see the block announcement long after the block's timestamp?Does it look like it is part of a network split?  (two chains that are both producing blocks more slowly than usual)Are they part of a sub-chain with a 'normal' distribution of blocks from the well-known mining pools? (an attacker's chain won't have blocks from ANY of the mining pools)Does it contain any double-spends that conflict with alternate chains I know about?Do the transactions in it look 'normal'?  (reasonable number of transactions, reasonable amounts)Somebody should simulate some 51% attacks and network splits and try out various detection algorithms.And maybe see if it would be practical to have a checkpoint lock-in rule of something like "auto-checkpoint any AAA-rated block once it is 4-deep in the best chain". I don't think that should be built-in to bitcoind, but a little side program that monitored the block chain and the pools and told bitcoind to add a checkpoint once an hour or so would be pretty spiffy...
I was working on user-defined checkpoints today-- command-line/bitcoin.conf (and maybe a RPC call) that just says "Add this block hash at this height as a checkpoint."You and your 10 trusted friends could then run a little program that coordinated automatic lock-ins whenever you like... https://github.com/bitcoin/bitcoin/pull/727 :This is designed to work nicely with 'gettransaction' and new 'blockhash' information returned in listtransactions; it is modified from the 'getblock' that was in my monitorreceived patch.getblockhash <index>Returns hash of block in best-block-chain at <index>.e.g. getblockhash 0 returns 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f(genesis block hash)getblock <hash>Returns details of a block with given block-hash.e.g. ./bitcoind getblock $(./bitcoind getblockhash 0) returns the genesis block:Code:{  "hash" : "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",  "blockcount" : 0,  "version" : 1,  "merkleroot" : "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b",  "time" : 1231006505,  "nonce" : 2083236893,  "difficulty" : 1.00000000,  "tx" : [    "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"  ],  "hashnext" : "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048"} bitcoin/bitcoin is the 0.6 treeI haven't done a code review of the anon-ish coin control, so I don't know if it will mess up 0.6 testing; it might interfere with the multisignature transaction changes.The github issues tracker is the best to report any bugs you find, for general "it sucks" or "I love it" or "can you make this new RPC command to this" the best place is either IRC chat or right here. So...I've been mostly quiet about the alternative block chains, but I have to say I'm a little disappointed.I had hoped that they would be full of interesting experiments with different transaction types or smart contracts or different fee-setting algorithms or maybe some innovative scheme for instant transactions.Instead, it seems like you've been too busy dealing with low hashrates and transaction-spam attacks, and have been spending all of your time re-inventing a lot of infrastructure (exchanges and block explorers and mining pool software and etc.).I'm curious to hear what other people think:  will altchain innovation pick up in 2012?  Am I irrationally biased and just not seeing the awesome power of (insert-your-favorite-altchain-feature-here)?I think there's an interesting dynamic, where the larger and more popular an altchain gets, the harder it is to do things like schedule a block-chain splitting-change (because you have to get all your exchanges and mining pools and etc. to upgrade). I wonder if that means the experimentation will only happen with brand-new blockchains, and if a blockchain will only really take off it the inventor manages to "get it 99% right" the very first time... Run them inside a virtual machine that you don't use anything else for and you're almost certainly safe. OP_EVAL, and OP_EVAL-bitcoin-address support were pulled into the master git branch two days ago; the plan is still to evaluate miner support on January 15, and if a majority of miners are supporting it (looks like that won't be a problem), to roll out version 0.6 with the low-level support fully enabled.And Luke-Jr is correct: sending coins into an OP_EVAL transaction is perfectly safe, but until February 1 it will be unsafe to spend them. BIP 11/12/13 support is Core functionality only for 0.6-- the network needs to support the new transaction types BEFORE users start using them. Use: contrib/wallettools/walletunlock.pyand contrib/wallettools/walletchangepass.py The coinbase must be between 2 and 100 bytes long and must be valid when deserialized as a "CScript", but may contain arbitrary data.Block 158479 looks like it is doing merged mining.The '07456c6967697573' at the start is the string 'Eligius'.The stuff in the middle looks like hashes for other block chains.And the '074f505f4556414c' at the endis is the string 'OP_EVAL'. No, I bet nobody knows if or how TD F 90-22.1 applies to Bitcoin.I am not a lawyer, but I bet the IRS would say that you should report any funds greater than $10,000 held by non-US bitcoin exchanges or wallet services.I don't know what the IRS would say about Bitcoins held on a server that you control but that happens to be located outside the US, or if it would matter if they were also held on your computer or printed out and stored in a safe deposit box somewhere in Kentucky. Reposting from email to bitcoin-development mailing list:I've been busy pulling patches into git HEAD for a Bitcoin version 0.6, with the goal of having a Release Candidate 1 out in a couple of weeks.So if you've done all your Christmas shopping and have time to help test, code review, etc. now would be the time.Major changes pulled so far:Implement BIP 11/12/13:  "Standard" multisignature transactions  "Standard" OP_EVAL transactions  OP_EVAL bitcoin addressesImplement BIP 14 (separate protocol from client version)Private key import/export (RPC commands, not GUI)New DNS seeds If I thought that downloading and installing software onto your computer is the way to go then I'd be helping make it better.I don't. I think 90-something-percent of future Bitcoin users will be using it on an iPad or mobile phone or on their computer in a web browser.I'm sorry you think 0.5 is worse than 0.4, but you're in the (vocal) minority. Nobody stepped up to support the 0.4 wxWidgets-based GUI, and we've got several people working on the 0.5 Qt-based GUI, so I'm confident switching was the right decision. The standard answer is if the river is owned, then the owner(s) of the river will have the right incentives to keep it unpolluted.  See, for example: http://www.cato.org/pubs/journal/cj1n2-6.htmlIf you care about clean rivers, then buy them (or donate money to an organization that buys them; the Nature Conservancy is one of my favorite charities).It is the Chinese government's river, not the free market's, why are they tolerating all the pollution?Global Warming and air pollution is a stickier problem because nobody owns the climate or the air we breathe, and nobody CAN own them. Personally, I think we do actually need good government for some things, which is why I describe myself as "mostly libertarian".And if I were King, I think I'd implement the Cato Institute's suggestion and give all of our National Parks and public wilderness to private environmental organizations to take care of (or sell, if they decided they could put the money to better use for something else). My reaction to Ben Laurie's papers:Incentives matter.Yes, it is true that we cannot be absolutely, positively safe against a 51% attack unless we are absolutely certain 50% or more of the world's entire computing resources are dedicated to Bitcoin mining.So what?The natural incentive for somebody with lots of hashing power is to profit by playing by the rules, NOT to cheat.And if you assume that your attacker is Rich and Powerful but Economically Irrational, then any alternative system that you propose will almost certainly be at least as vulnerable as Bitcoin. Create a system that requires 500 semi-trusted "mintettes" that all agree on a transaction log and then imagine 251 Special Agents infiltrating and corrupting the organizations that run those mintettes.Increase the number to 40,000 mintettes to make it harder... and you've just re-invented Bitcoin. RE: documentation about key encryption:See the comment at the top of crypter.h:Code:Private key encryption is done based on a CMasterKey,                                                                                                   which holds a salt and random encryption key.                                                                                                                                                                                                                                                                   CMasterKeys are encrypted using AES-256-CBC using a key                                                                                                 derived using derivation method nDerivationMethod                                                                                                       (0 == EVP_sha512()) and derivation iterations nDeriveIterations.                                                                                        vchOtherDerivationParameters is provided for alternative algorithms                                                                                     which may require more parameters (such as scrypt).                                                                                                                                                                                                                                                             Wallet Private Keys are then encrypted using AES-256-CBC                                                                                                with the double-sha256 of the public key as the IV, and the                                                                                             master key's key as the encryption key (see keystore.[ch]).                                                                                             The way I think of it:  Take the passphrase and salt and SHA512-hash them nDerivationIterations times.  That gets you an encryption key and initialization vector.Use those to AES-256-decrypt the encrypted_key master key.Now you can AES-256-decrypt the private keys, using the master key as the key and the (double-sha256-hash) PUBLIC part of the keypair as the initialization vector.The "SHA-512-hash them a bunch of times" is actually done by the OpenSSL EVP_BytesToKey routine-- documentation for that is here: http://www.openssl.org/docs/crypto/EVP_BytesToKey.html wallet.datwallet.dat.rewrite SHOULD be automatically removed as part of the upgrade-to-0.5 process; I don't know why it isn't in some cases-- and, frankly, I would much rather spend time getting really, truly secure wallet solutions working.RE: bitcoin version 0.4 starting up on your machine:You should run the old bitcoin, un-check the "start on windows system startup", then exit.Then remove it using the Add/Remove Programs control panel doo-hickey (did that move again in Vista?).  You should see both "bitcoin" (the old 0.4) and "bitcoin-qt" (the new 0.5).... all of which is, I know, annoying and painful.  Again, frankly, I'm more interested in spending time on the very-highest-priority issues rather than making every beta release upgrade completely smooth in all cases. https://github.com/laanwj Yes, those are both my PGP keys. I generated a new, stronger key yesterday (1FC7...) that I intend to use for code signing for the next release. I thought I'd changed the gavinandresen.asc file on bitcoin.org to contain both keys, but it looks like I didn't (or pgp/gpg doesn't allow more than one key in the .asc file; I was disappointed to learn that gpg doesn't support putting multiple signatures in an .asc file...) Bitcoin version 0.5.1 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.1/This is a bugfix-only release.This release includes 13 translations, including 5 new translations:Italian, Hungarian, Ukranian, Portuguese (Brazilian) and Simplified Chinese.More translations are welcome; join the project at Transifex if you can help:  https://www.transifex.net/projects/p/bitcoin/Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesProject source code is hosted at github; we are no longerdistributing .tar.gz files here, you can get themdirectly from github: https://github.com/bitcoin/bitcoin/tarball/v0.5.1  # .tar.gz https://github.com/bitcoin/bitcoin/zipball/v0.5.1  # .zipFor Ubuntu users, there is a new ppa maintained by Matt Corallo whichyou can add to your system so that it will automatically keepbitcoin up-to-date.  Just type sudo apt-add-repository ppa:bitcoin/bitcoinin your terminal, then install the bitcoin-qt package.BUG FIXES---------Re-enable SSL support for the JSON-RPC interface (it was unintentionallydisabled for the 0.5.0 release binaries).The code that finds peers via "dns seeds" no longer stops bitcoin startupif one of the dns seed machines is down.Tooltips on the transaction list view were rendering incorrectly (as black boxesor with a transparent background).Prevent a denial-of-service attack involving flooding a bitcoin node withorphan blocks.The wallet passphrase dialog now warns you if the caps lock key was pressed.Improved searching in addresses and labels in bitcoin-qt.===============================Thanks to everybody who contributed code or helped test this release:Alex BClark GaebelDylan NoblesmithGavin AndresenLuke DashjrMatt CoralloMichael HendricksNick BosmaNils SchneiderWladimir J. van der Laan Ok.  So who controls the private keys?
... and that's exactly why I discourage people from doing things like that. It is too easy for two "copies" of a wallet to get out-of-sync.You have to be a geek and muck around with copying the wallet.dat file from one place to another to get into trouble, and that is by design. I have no problem at all with geeky tools that let you do dangerous things (like PyWallet).The JSON-RPC interface is trickier, because adding dangerous functionality there might encourage web services to do not-so-smart things like sending private keys over unencrypted/unprotected channels ("Email the private key as a Christmas gift" works great for a while, and then the bad guys start looking for privkeys in traffic they're sniffing and spend them before your Dad can....)  I only half-paid-attention to all the previous deterministic wallet discussions, but isn't it pretty simple?Start with a random private key and a random nonce.ECC multiply the key by SHA256(nonce+n) to get the n'th derived key.(I think you could even get away with using the private key as the nonce) (and, of course, I defer to the expertise of people who know way more about ECC crypto than I do)It seems to me these issues will be the same no matter what solution is implemented.I think the next step is starting to prototype and standardize a protocol for communicating with WPS or escrow services to request new public keys, get keys signed, etc.Supporting deterministic wallet schemes at the same time makes sense, in my humble opinion.I imagine an API call that is something like "I'm customer gavin@acm.org.  Please use whatever private key you're storing for me and this 256-bit number to derive a new public key, and send it back to me."(details to be worked out, but note that the WPS wouldn't necessarily have to store that new keypair if the "Please sign" request included the same (gavin@acm.org,256-bit-number) ....)As long as the API is consistent, I don't think the details of the deterministic wallet matter.I don't see the difference: if the WPS becomes unavailable, then either solution requires that the "C" key be transferred from paper (or wherever) to the online client. I spent some time today looking again at the state of quantum computing: I'm still not worried.The D-Wave system is not a general-purpose quantum computer; it is pretty specialized for solving certain problems (I'm reasonably certain cracking ECDSA encryption is not one of the problems it would be good at, but I am definitely NOT a quantum crypto expert).Skimming the research, it looks like you'd need a specially-constructed quantum computer with 515 qbits and over 100million quantum gates, running more than 16 million quantum operations to crack Bitcoin's 256-bit ECDSA private keys using Shor's algorithm.There's was a good reality-check article in the New York Times just last week:   http://www.nytimes.com/2011/12/06/science/scott-aaronson-quantum-computing-promises-new-insights.htmlI've said it before:  I'll start to worry when quantum computers can factor 64-bit numbers. The current import patch needs work to be of practical use to web services-- it does a scan of the entire blockchain to find transactions to the newly imported key (and keeps the wallet locked that entire time).  For any sweep/import solution to be useful for more than once-in-a-blue-moon use, an index of pubkeys to transactions involving those keys should be kept.It seems to me the "sweep now, and re-sweep every once-in-a-while" functionality would work nicely for web services. Can you describe a use case that wouldn't work? I like "sweep" -- it has very clear semantics that I think users will understand:  "Take all the funds that were sent THERE, and send them to me RIGHT NOW."Automatic sweep-every-once-in-a-while functionality would be fine, as long as it was coded properly (sweeps should only be done if you have the full block-chain, not if you're busy catching up, and shouldn't be done immediately to avoid a flurry of accidental double-spends if you have several wallets setup to sweep the same key(s)).I don't like "import" -- it has muddy semantics that I think users will not understand.  "You kind-of-sort-of own the funds that were sent THERE, unless somebody else happens to have a copy of THERE that you may or may not know about."Import is bad because it can lead to a situation like: Start up bitcoin, see you have 1 BTC in your wallet (sent to an imported private key in block 111,000) So you send half of it to your friend to pay for lunch. ... bitcoin chugs away, and it turns out that 1BTC was spent already, in block 190,000. User is all "wtf??? where did my BTC go???"If you're an uber-geek and know what you're doing, then you should use geeky, dangerous tools like PyWallet to do what you want to do. So what happens when two users import the same private key into their wallets? (or you accidently or on-purpose import the same private key into two of your wallets?)You can say "Don't Do That", but if they CAN do that, then they WILL. ... if you're sending a transaction, then its timestamp should be the time it is sent.And coinbase transactions should be assigned the block timestamp.I think. It is odd that different machines may assign the same transaction different timestamps... I'll be uploading Release Candidate 2 binaries this afternoon, with two bug fixes from RC1 (text was being truncated in the wallet passphrase dialog box, and previous versions of bitcoin-qt did not display "alert" messages). These bytes at the end of the coinbase:  074f505f4556414c... are the 7-character string "OP_EVAL" (07 is the length, 4f is the letter O, etc).There are no OP_EVAL transactions in that block; it isn't safe to send OP_EVAL transactions until after a majority of miners support it.I believe Eligius is the only pool supporting OP_EVAL right now; Tycho of DeepBit has finished integrating the backport and has said he'll start supporting it after more testing, before the end of this month. Last I heard slush was also working on supporting it. Please help sanity test version 0.5.1 release candidate 1.Why a version 0.5.1 ?  To fix the bugs listed below before starting on 0.6 release candidate testing.After doing some testnet testing to make sure it works properly, I plan on using the "alert" system built in to the client to warn 0.4 users that if they have an encrypted wallet they need to upgrade to be secure.Bitcoin version 0.5.1 release candidate 1 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.1/test/This is a bugfix-only release.This release includes 13 translations, including 5 new translations:Italian, Hungarian, Ukranian, Portuguese (Brazilian) and Simplified Chinese.More translations are welcome; join the project at Transifex if you can help:  https://www.transifex.net/projects/p/bitcoin/Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesProject source code is hosted at github; we are no longerdistributing .tar.gz files here, you can get themdirectly from github: https://github.com/bitcoin/bitcoin/tarball/v0.5.1  # .tar.gz https://github.com/bitcoin/bitcoin/zipball/v0.5.1  # .zipFor Ubuntu users, there is a new ppa maintained by Matt Corallo whichyou can add to your system so that it will automatically keepbitcoin up-to-date.  Just type sudo apt-add-repository ppa:bitcoin/bitcoinin your terminal, then install the bitcoin-qt package.BUG FIXES---------Re-enable SSL support for the JSON-RPC interface (it was unintentionallydisabled for the 0.5.0 release binaries).The code that finds peers via "dns seeds" no longer stops bitcoin startupif one of the dns seed machines is down.Tooltips on the transaction list view were rendering incorrectly (as black boxesor with a transparent background).Prevent a denial-of-service attack involving flooding a bitcoin node withorphan blocks.The wallet passphrase dialog now warns you if the caps lock key was pressed.Improved searching in addresses and labels in bitcoin-qt.===============================Thanks to everybody who contributed code or helped test this release:Alex BClark GaebelDylan NoblesmithGavin AndresenLuke DashjrMatt CoralloMichael HendricksNick BosmaNils SchneiderWladimir J. van der Laan Here's how to figure it out from the Satoshi client code:The IMPLEMENT_SERIALIZE macro is used to both store transactions on disk and to serialize them into a byte-array that can be hashed.For class CTransaction, that looks like:Code:    IMPLEMENT_SERIALIZE    (        READWRITE(this->nVersion);        nVersion = this->nVersion;        READWRITE(vin);        READWRITE(vout);        READWRITE(nLockTime);    )READWRITE is a wrapper that is overloaded to Do The Right Thing for all the types bitcoin deals with; for complex types like CTxOut, IMPLEMENT_SERIALIZE is (essentially) called recursively.Expand out all of the types and, assuming I didn't screw up (always an iffy assumption), it looks like a CTransaction is serialized as:Code:nVersionvin.size  (vectors are serialized as a compressed count immediately followed by their contents) vin[].prevout    (vin->prevout->hash followed immediately by vin->prevout->n, as 36 bytes) vin[].scriptSig   (CScripts are serialized as a vector of bytes) vin[].nSequence ... repeated for each vinvout.size vout[].nValue vout[].scriptPubKey ... repeated for each voutnLockTimeString all those bytes together, SHA256 them twice, and you should get the transaction hash for the merkle chain. Can we come up with a scheme that uses 2-of-3 that solves the problem?Key 1 is the Wallet Protection Service Key. Your wallet only knows the public half of that key.Create two random keys, Key 2 and Key 3, offline.  Save them, they're needed for backup.Transfer the private part of Key 2 and just the public half of Key 3 to the online wallet.The wallet can generate the 2-of-3 required bitcoin payment address (it has all 3 public keys), but can only sign for Key 2.Normally, it will ask the wallet protection service to sign for Key 1.If the WPS goes out of business, the private key for Key3 can be imported and the wallet will be able to spend without the WPS.If the online wallet gets lost AND the WPS goes out of business, then Key2 and Key3 can be restored from the offline backup.If you care about privacy and want to make it harder for people to track your transactions, then you could implement a deterministic key scheme on top of all of that-- start with keys 1, 2 and 3 and ECC multiply them by some random number to get derived keys. The random number would need to be stored with the backup, in the online wallet, and sent to the wallet protection service, but that's OK because you need the random number plus 2 of the 3 secret keys to spend the coins. ... or, even worse, invalidate competing proof-of-stakes.I might like proof-of-stake schemes better if somebody has a good plan for how to get them started-- you've got a genesis block, so the creator starts with 100% stake.Now what, exactly, happens to create block number 2 for proof-of-stake systems? +1 So netrin:I asked before and I'll ask again, I'm genuinely curious:Are there password-cracking algorithms that attempt passwords from lowest-entropy-to-highest-entropy?Is it even theoretically possible to sort passwords by "entropy" ?  (seems like a hard thing to easily measure; password "a.b..c...d....e.....f" has low entropy, but would any password-cracking algorithm try it before 6 random characters?) Neat idea!I don't get the economics of it, though-- how do I convince the network to run/check the calculations I want the MerkleWeb to run rather than somebody else's?  And does anything prevent me from asking the MerkleWeb to do some useless busy-work that is just designed to chew up computing resources? Who decides what gets run on the Turing machine, when? Sure-- it has to be possible, there is no guarantee that you'll see blocks announced on the network in order. An orphan block may just be one that you can't connect to the main chain yet because you haven't seen it's parent yet (maybe you're downloading blocks and haven't got them all yet, or maybe a miner got lucky and only needed eleven hashes to build on a block and you see her block before the parent because of network delays). The misbehaving client creates orphan blocks with very low proof-of-work; the unlucky miner creates orphan blocks with valid proof-of-work.The misbehaving client gets away with their misbehavior by either anchoring their bogus blocks deep in the chain, when blocks had very easy proof-of-work.Or giving them a bogus "previous block hash" so they're not anchored anywhere in the chain at all. https://github.com/bitcoin/bitcoin/pull/686Testnet difficulty calculation changes, to take effect Jan 1 2012Allow mining of min-difficulty blocks if 20 minutes have gone by without mining a regular-difficulty block.Normal rules apply every 2016 blocks, though, so there may be a very-slow-to-confirm block at the difficulty-adjustment blocks (once per month, assuming testnet is in it's normal "difficulty too high for number of people mining it" state).This will almost certainly cause a testnet blockchain split after Jan 1. After pulling I'll update the Testnet Faucet, I'll ask theymos if he can update the testnet block explorer bitcoind.I didn't implement any "shun blocks from the future" or "prefer blocks with more memory-pool transactions", I want to see how well the simplest-thing-that-might-possibly-work solution works first. Eligius is the first pool to support OP_EVAL-- thanks Luke-Jr !  Block 155974 is the first "I support OP_EVAL" block in the chain.The pull request for the next version of bitcoin is ready to go:  https://github.com/bitcoin/bitcoin/pull/669... and there are backports of just the changes relevant to mining available at these git branches:  https://github.com/gavinandresen/bitcoin-git/tree/v0.3.23_op_eval  https://github.com/gavinandresen/bitcoin-git/tree/v0.3.24_op_eval  https://github.com/gavinandresen/bitcoin-git/tree/v0.4.1_op_eval
The advice here is very relevant:  http://producingoss.com/en/money.html Why the change:  because it is twice as fast to compile just 32-bit, a 32-bit-only executable is smaller and faster to download, and there is no advantage to running 64-bit (bitcoin doesn't need more than 4 gigabytes of memory, there are no performance-critical routines that would be faster running 64-bit, etc).If there's a good reason to compile 64-bit, or if we ever drop support for 32-bit Macs then a 64-bit version would make sense. BIP 12 says:  "If there are any OP_EVALs in the deserialized script they are also executed, but recursion is limited to a depth of 2."I waffled on whether to propose any recursion at all, but I think just a touch of recursion will be safe and very useful.And I wasn't clear, because I'm just thinking out loud:  I meant take two big 256-bit random numbers (call them n1 and n2) and then produce three keypairs, where the private keys are n1, n2, and n1*n2.  Thinking a little further, a 2-of-2 with that key arrangement gives a kind of "a and b OR c" ...  but if c knows both n1 and n2 then the n1*n2 is redundant....Anyway, my point was that with some cleverness I think lots of things become possible with just what is proposed with BIP 11, and I'd like to give people time to explore what can be done and figure out how to make this stuff easy to use before thinking about even more complicated transaction types. Yes, it ignores the block.Pulling out just the detect-too-low-difficulty-blocks parts wouldn't be terribly hard. (A-and-B)-or-C will wait for another BIP; there are some nifty (and generalizable) ways of doing that by using OP_EVAL recursively that have the added benefit of keeping never-used public keys out of the blockchain.(1,1) is silly but standard according to BIP 11.  It is just a slightly larger version of the standard <sig> <pubkey> OP_CHECKSIG form used by most coinbase transactions.I think (1,2)....(3,3) combined with all the things that can be done with deterministic keys or "I only have part of the private key" or other tricks will enable plenty of innovative solutions.Just thinking off the top of my head: what interesting things could you do if you create 3 keys, where the private key for the third is the product of the first and second?  If you make them a 2-of-3-to-redeem, is that the same as an (a and b) OR c transaction? I think the version on the bitcoin wiki ( https://en.bitcoin.it/wiki/BIP_0011 ) is a little more up-to-date, but you should check with genjix, he's the BIP-meister.Pull request for BIPS 11 12 and 13 is here:  https://github.com/bitcoin/bitcoin/pull/669Unless I hear objections, I'll probably pull it tomorrow. How:CNode::Misbehaving(int howmuch) is called when code detects that a peer is doing something out-of-the-ordinary.  In this case, if a peer sends you a block that can't possibly be in the best chain, Misbehaving(100) is called.When a Node accumulates a misbehavior score greater than or equal to "-banscore" (default 100), their connection is dropped and their IP address is banned from reconnecting for "-bantime" seconds (default 24 hours).When are they un-banned:After -bantime seconds. But the list of banned IP addresses is stored in memory, so if you shutdown and restart bitcoin everybody is un-banned.There is no way to see the list of currently banned nodes, but you will see "Disconnected n.n.n.n for misbehavior" and "connection from n.n.n.n dropped (banned)" in the debug.log. Interesting idea!Thinking out loud...  There Doesn't Have To Be One Way To Do It.  Piuk (or somebody) should hack together a client or miner that uses a ledger system; it could refuse to relay or include any transactions with inputs smaller than 0.001 BTC, so it only needed a truncated ledger to create new blocks (if it is a miner, maybe it connects to a trusted 'traditional' bitcoin node to make sure it only builds on valid blocks which might contain tiny inputs). I don't know nuthin about merged mining-- anybody have objections to Luke-Jr's pull?My only concern is: will this be a "used by exactly one person (the Eligius pool)" feature? Neat idea! Umm, they seemed to be doing OK overall when I was there a couple of years ago, despite the horrible drought, terrible floods, and Hurricane Yasi.I'm all for doing things to keep people from dying and suffering. Rereading the IPCC report, the big killers/dangers will be an increase in malaria and other diseases in poor countries.It seems to me policies that make the poor countries richer (free trade, open immigration, stable political institutions and rule of law) is the best way to tackle those problems.Or to put it another way: The US will probably spend years arguing over whether or not a carbon tax (or cap and trade or whatever) is a good idea (I'm watching to see what happens with Australia's carbon tax with great interest, by the way). Maybe we'll eventually pass one and reduce our carbon emissions.I predict that will just move carbon-intensive industries somewhere else in the world, and carbon emissions will continue to rise.I think it would be better to spend the time arguing over what we could do to help make poor countries rich. Or argue for open borders so poor people in places that are getting flooded (don't buy real estate in Bangladesh...) have a place to go.Or, if you REALLY think rising CO2 levels will be a catastrophe, then rich countries or individuals should create solar-powered CO2 scrubbers and spend money installing gazillions of them in the desert.  Because betting on the whole world coming together and agreeing to do something is about a million times less likely than getting everybody on this forum to agree on... well, pretty much anything.Don't buy real estate in Florida.  New York will be mostly OK ("The average elevation of Manhattan is reported to be 29 meters (97 feet"); I can't find a mean elevation for LA, but city hall is 300 feet above sea level so unless you buy beachfront property you'll be OK.With global warming, we're talking changes that happen over a hundred or three (or more) years. I may be wrong (I often am), but I'd be the big worry 100 years from now will not be global warming, but something else.  Maybe running out of Unobtanium for our flying cars.... Maybe it is because I am married to a geologist, but I tend to look at a longer timescale. When the dinosaurs were around CO2 concentrations were up around 3000ppm.I'm not saying there will be no effects of global warming-- I am claiming that we, and mother nature, will adapt.We could argue about whether it would be less expensive or better to change our behavior now rather than just adapt later-- last I looked, adapting by (for example) moving inland and abandoning low- lying cities and countries was estimated to be cheaper than spending money to reduce CO2 emissions. How far back in history do you have to go to find a time when the Earth couldn't support human life?If I recall correctly, CO2 concentrations were pretty darn high when the dinosaurs where walking around. There were no people around then, but I don't see any reason why we couldn't live in a much warmer, wetter world.You got it backwards. The dinosaurs came after the mass extinction of other species.Which is kind of my point: if there IS a mass extinction event, then that sucks for the species that go extinct. But new species will arise that are well-adapted to the new climate. And we humans are a pretty darn adaptable species... So go implement it and see how well it works.Create a little HTTP-based protocol with, oh, three methods:You send a block height or block hash, you get back a ledger hash.You send a ledger hash, you get back the full ledger or an "I have no idea what you're talking about, that's not a valid ledger hash".You send two ledger hashes, you get back the changes from one to the other or an "I have no idea what you're talking about, one of those isn't a valid ledger hash".Then you just need to convince a bunch of semi-trustworthy people to run "ledger servers." And maybe have some mechanism for reporting when a ledger server has a bug or 'goes rogue' and reports a ledger hash that is different from everybody else.Oh, and you might need to solve the incentive problem of "why would I run a ledger server if I'm not paid for it" (and maybe write a bunch of denial-of-service-prevention code in case some jerk with a botnet decides to ask for 10,000 full ledgers from 10,000 different IP addresses).  I didn't read through the whole "what is the Libertarian solution to Global Warming" thread, so excuse me if I'm saying what somebody else has said.And I'm not a climate scientist (although I am married to a geologist who is a professor in the same department as Ray Bradley and several other world-class climate scientists), so I can't assess the scientific literature and pick apart various estimates of CO2 sensitivity or urban heat island effects on weather stations or ...But it seems to me pretty clear that there is a clear consensus among scientists that Global Warming is happening and we're almost certainly the cause.So the question for me becomes:  how big a deal is it, for both people and our environment?According to the climate scientists, we've been warming for 100 years now, and nobody seemed to notice.I know there are worries that there will be a 'climate tipping point' -- that warming will shut down the gulf stream or make the Greenland Ice Sheet fall into the ocean all at once or ocean chemistry changes will make all that methane down there suddenly bubble up to the surface. I'd be very interested in evidence that any of those things have ever happened in the past (because on a geological time scale the Earth's climate has varied a LOT).And I'm certain warming will be bad for some species-- maybe polar bears will go extinct. Then again, a warmer environment will be good for some species, and I recently read an interesting article about new species arising to fill empty ecological niches much more quickly than biologists expected (I dont' remember the details, but they were seeing new species arise over a period of decades instead of centuries or millenia). I think we all (biologists included) have a bias towards species that already exist, and have trouble having faith in Nature's ability to adapt.So given that the world was a MUCH warmer place back when the dinosaurs were roaming around, and given that most people most places in the world didn't even notice an almost 1° C rise in temperature over the last century, I just don't think it will be a global catastrophe.Which is a good thing, because I don't think the kind of global agreement that would be required to reduce carbon emissions has any realistic chance of happening-- the incentives for a country or region to cheat (and burn lots of cheap fossil fuels) are just too great. You can remove the addr.dat file and run with the -noirc and -nodnsseed options to experiment right now.I fixed the bootstrap-from-hard-coded seed node code a couple of months ago, so use a recent version of bitcoin to see it working properly. https://bitcointalk.org/index.php?topic=41718.0 No.See: https://en.bitcoin.it/wiki/ScriptOpcodes 1-75 push data onto the stack. It is high on my list because I think most miners (and pools) would be happy to include many more free transactions than the current rules allow, and if there is another price spike or somebody rich decides it would be fun to make the block chain a couple of gigabytes bigger it is much easier to react if the fees are not hard-coded.The rough plan is: + Give miners more "knobs" to set fee policy-- let them specify (via command-line switch and maybe bitcoind RPC command) how much (if any) space to set aside in blocks for free transactions, how much to charge per-kilobyte and/or per-ECDSA-signature-validation, and what the priority/size/number-of-signatures thresholds are for considering a transaction for inclusion in the free space. + As Meni says, teach clients to look at the recent blockchain history and, for a given transaction, estimate how much of a fee will be required to get it into a block reasonably quickly. Maybe a "createtransaction" RPC call that locks coins for a certain amount of time and returns the how-long-to-confirm estimate along with "commit/aborttransaction" calls....  + Figure out a reasonable UI for fees. Maybe:  calculate the probability sending the transaction with 0 fee will get into the next, oh, 3 blocks, and if it is greater than, oh, 90% then just send it without a fee.  Otherwise, let the user decide between paying a fee that will get it included (with 90% probability) in the next 3 blocks or letting them know how long it might take if they pay no fee.Lots of details to be worked out... The setup.exe is a "NSIS installer" -- I think this will work (but I haven't tried it):Code:bitcoin-0.5.0-win32-setup.exe /S
0.3.15 is pretty old, and the way you're spending from a copy of the wallet is, I suspect, confusing it.  Pieter updated the wallet code to handle transactions with partially spent outputs a while back.Try upgrading to version 0.4.1 or 0.5 and running -rescan and see if your missing bitcoins reappear. Ummm, yes.It seems to me miners will have an incentive to lie about the transaction ledger, and put fake ledger hashes in their blocks. Either so their transactions might be considered 'unspent' by unsuspecting nodes that trust them, or so that other miners that don't have the full block chain create invalid blocks (eliminate the competition!)And I don't see a proposal that everybody check the ledger and reject blocks that contain invalid ledger hashes.I also don't see what the ledger hash accomplishes.  If you're going to trust some other node's version of unspent-transaction-reality, then you could just ask "send me the ledger state before (or after) the block with THIS block hash".But if you're going to trust one or more nodes anyway... then it seems to me sending an ever-increasing-in-size ledger is a bad way to get scalable. If size-of-full-blockchain becomes a problem before the mining pools and big exchanges/merchants/transactions processors all have transaction processing clusters with a terabyte of ram and petabyte hard drive array then I think extending the protocol to make it easy to request all transactions involved in a given Merkle branch will probably be the way to go.But before then I expect the bitcoin network will look very different from the way it looks today, and I expect there will be several different solutions for how to scale up. If (when!) Bitcoin gets that successful, there will be serious money hiring the same smart people who figured out how to scale up PayPal and Visa. How did you build Berkeley DB?  Something like this in the MSYS shell:  sh ./dist/configure -enable-cxx -enable-mingw... should do the trick (see this thread, for example).I'm no longer develop on Windows, but I had to be very careful to make sure bdb/boost/miniupnpc/openssl/Qt were all compiled with the same compiler and compatible options (e.g. -arch i386 versus -arch x86_64) to successfully compile bitcoind and Bitcoin-Qt on my Mac. I give you a transaction that sends you 11 bitcoins... but I tell you "you better put that in the blockchain in the next 120 blocks, or I'll broadcast another transaction that sends the inputs somewhere else so the transaction to you will be seen as a double-spend."I'd need a bitcoin client that let me do that, and you'd need one that could take a transaction in some format and then let you decide whether or not to broadcast it for inclusion in the block chain, or told you "sorry, too late, inputs already spent", but that all should work today. As Mike said, help on "initial headers-only download" would be much appreciated.Work-in-progress is here:  https://github.com/bitcoin/bitcoin/tree/blockheaders... and my notes on issues that have to be worked out are here:  https://gist.github.com/1059233As for scalability in general:  it looks to me like CPU time to validate transactions will be the bottleneck before bandwidth or disk space, so I don't see a strong reason to switching to a 'ledger' or 'balance sheet' method. Effective optimization/scalability is all about identifying and eliminating bottlenecks.  I can't see how OP_CODESEPARATOR can be used, either. I'm tempted to suggest that any transactions using it be 'discouraged' (have miners refuse to build on blocks that contain transactions using it).Transaction hashes might be another, separate discussion topic-- I've been thinking that the way transaction hashes are calculated/used could be improved, although I don't think it is a critical design flaw but in the category of "stuff we can live with but that maybe could have been done better". Try running with the -nolisten -noirc flags, see if that works around the problem (and please let me know if it does/doesn't).I'm not sure any of the current core developers regularly use TOR; getting somebody who does to contribute patches and review code for regressions is a good idea. Yes, who cares if you get extra testnet coins?But... if somebody wanted to be annoying, they'd pre-generate as long a min-difficulty coinbase-only-transaction chain as the block timestamp rules allowed, and constantly broadcast those blocks.  Just to prevent transactions from getting confirmed.To prevent that...Testnet could prefer to build on blocks with more transactions from the memory pool over blocks with fewer transactions from the memory pool (that's not a bad rule for main net, either; might be worth considering if it works well for testnet). The rule now is "build on first valid block seen".And "discourage" (refuse to directly build on or relay) blocks with timestamps in the future. Good, accurate article.I'm still not Satoshi, though. Yes.Any opinions on whether to do a hard reset (new genesis block with the new rules) or a split ("new rules apply to blocks with timestamps after XYZ") ?RE: scaling down difficulty:  good idea if we were thinking of implementing something like this for the main network.  But I'd want to give everybody lots of time to think long and hard about potential hacks/exploits/unintended consequences if this was being considered for the main network-- sudden drops in hashing power is NOT a problem for the main network, so I don't think it is worth considering now. Why?  What problem would that solve? In the spirit of "do the simplest possible thing that works..."  I think I see a very simple thing that will work.The simple additional rule for the testnet:If current_block_timestamp - previous_block_timestamp > 20 minutes:  block difficulty = minimum difficultyAnd that's it.If mining is proceeding normally and most blocks are produced in less than 20 minutes, then the rules are exactly the same as the main network.But if somebody has driven difficulty way up, then the new rule acts as a safety valve, ensuring that new blocks are created at least once every 20-something minutes or so.  After a month of "safety valve blocks" the difficulty would be calculated as normal, and would get cut in (approximately) half.This does make the testnet block chain more susceptible to forks -- somebody with a bunch of hashing power can pretty easily invalidate a long chain of 20-minute, min-difficulty blocks if they want to. And there is likely to be a flurry min-difficulty blocks produced/announced every 20 minutes. But that could be considered a feature (test your block-chain-reorganization code!). I updated the .zip and .tar.gz and SHASUMS.asc a few hours ago, because the .zip and the .tar.gz were expanding to a "bitcoin-rc7" directory.Be sure you run bitcoin-qt.exe, not the old bitcoin.exe. Yes.I'm testing patches against the last two versions of Bitcoin (0.3.23 and 0.4.1) for BIPs 11 and 12 right now to make it as easy as possible for miners to support them.  Review or help testing is very welcome:  https://github.com/gavinandresen/bitcoin-git/tree/v0.3.23_op_eval  https://github.com/gavinandresen/bitcoin-git/tree/v0.4.1_op_eval Yes, I forgot to rename the folder.Uploading a fixed 0.5.0 linux.tar.gz and win32.zip now (and SHASUMS.asc), will do the same for 0.4.1. Mmm... perfect software...You notice how we aren't at Bitcoin version 1.0 yet?  That the version is "0.5 BETA" ?If you NEED it to be perfect then you're going to be waiting forever, because no software is ever perfect.The criteria for a new 0.something release is "Is there general agreement that it is better than the last release."There is general agreement that the new GUI is better; the huge problem with the old GUI is we have no wxWidgets GUI programmers willing to support the old GUI. There are several people contributing patches to the new Qt GUI.I've said it before but I'll say it again:  Bitcoin is still a high-risk, high-potential-reward experiment, and you shouldn't invest time or money that you can't afford to lose. We're working hard to make it better, but we're not perfect. The download directory contains them in a file called SHASUMS.asc:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/SHASUMS.asc/download... which I'll reproduce here just because it is easy:Code:-----BEGIN PGP SIGNED MESSAGE-----Hash: SHA1d80b811852744aaa23bc7eddd23cdac4d56bb50f  bitcoin-0.5.0-linux.tar.gz86b0de71d601176ba49a84da59baf37ec3b561ec  bitcoin-0.5.0-macosx.dmg4649a78d3a55843b7ced690694b9b241a26f4d93  bitcoin-0.5.0-win32-setup.exe97ef546d923e75f309a19f8a52b07affc0942948  bitcoin-0.5.0-win32.zip-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)iEYEARECAAYFAk7Kdy8ACgkQdYgkL74406g2ogCgiMfivGR4xJOacx/DnYfIiBO0tlgAmwRYs7eKIgz1v3t1tj1I3NrrBfij=SFwh-----END PGP SIGNATURE----- Yes, it aught to work (for bitcoind, at least-- I haven't tested with bitcoin-qt).  getinfo will tell you if it is working (look at "hashespersec").You might want to run a testnet-in-a-box, it is 60 time easier to generate blocks on it:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ http://testnet.freebitcoins.appspot.com/  has 11,000 testnet coins available. Bitcoin version 0.5.0 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/The major change for this release is a completely new graphical interface that uses the Qt user interface toolkit.This release include German, Spanish, Spanish-Castilian, Norwegian and Dutch translations. More translations are welcome; join the project at Transifex if you can help:  https://www.transifex.net/projects/p/bitcoin/Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issuesFor Ubuntu users, there is a new ppa maintained by Matt Corallo which you can add to your system so that it will automatically keep bitcoin up-to-date.  Just type "sudo apt-add-repository ppa:bitcoin/bitcoin" in your terminal, then install the bitcoin-qt package.MAJOR BUG FIX  (CVE-2011-4447)The wallet encryption feature introduced in Bitcoin version 0.4.0 did not sufficiently secure the private keys. An attacker whomanaged to get a copy of your encrypted wallet.dat file might be able to recover some or all of the unencrypted keys and steal theassociated coins.If you have a previously encrypted wallet.dat, the first time you run bitcoin-qt or bitcoind the wallet will be rewritten, Bitcoin willshut down, and you will be prompted to restart it to run with the new, properly encrypted file.If you had a previously encrypted wallet.dat that might have been copied or stolen (for example, you backed it up to a publiclocation) you should send all of your bitcoins to yourself using a new bitcoin address and stop using any previously generated addresses.Wallets encrypted with this version of Bitcoin are written properly.Technical note: the encrypted wallet's 'keypool' will be regenerated the first time you request a new bitcoin address; to be certain that thenew private keys are properly backed up you should:1. Run Bitcoin and let it rewrite the wallet.dat file2. Run it again, then ask it for a new bitcoin address. Bitcoin-Qt: Address Book, then New Address... bitcoind: run the 'walletpassphrase' RPC command to unlock the wallet,  then run the 'getnewaddress' RPC command.3. If your encrypted wallet.dat may have been copied or stolen, send  all of your bitcoins to the new bitcoin address.4. Shut down Bitcoin, then backup the wallet.dat file. IMPORTANT: be sure to request a new bitcoin address before backing up, so that the 'keypool' is regenerated and backed up."Security in depth" is always a good idea, so choosing a secure location for the backup and/or encrypting the backup before uploading it is recommended. And as in previous releases, if your machine is infected by malware there are several ways an attacker might steal your bitcoins.Thanks to Alan Reiner (etotheipi) for finding and reporting this bug.MAJOR GUI CHANGES"Splash" graphics at startup that show address/wallet/blockchain loading progress."Synchronizing with network" progress bar to show block-chain download progress.Icons at the bottom of the window that show how well connected you are to the network, with tooltips to display details.Drag and drop support for bitcoin: URIs on web pages.Export transactions as a .csv file.Many other GUI improvements, large and small.RPC CHANGESgetmemorypool : new RPC command, provides everything needed to construct a block with a custom generation transaction and submit a solutionlistsinceblock : new RPC command, list transactions since given blocksignmessage/verifymessage : new RPC commands to sign a message with one of your private keys or verify that a message signed by the private key associated with a bitcoin address.GENERAL CHANGESFaster initial block download.Thanks to everybody who contributed code or helped test this release:Alan ReinerAlex BAlex WatersAng Iong ChunCelilChris HowieChris MooreDavid Joel SchwartzDavid PerryForrest VoightGavin AndresenJanne PulkkinenJeff GarzikJoelKatzKhalahanLuke DashjrMatt CoralloMisbakh-Soloviev Vadim ANils SchneiderPieter WuilleVictor LeschukWladimir J. van der Laancelil-kjcjdelisleflowerglobalcitizengmaxwellkwaaakmarkp2k
Yes.But not being able to download the block-chain sounds like a networking issue that 0.5 is unlikely to fix. Release Candidate 7 binaries are available at:  https://sourceforge.net/projects/bitcoin/upload/Bitcoin/bitcoin-0.5.0/test/Difference between rc6 and rc7 :  rc7 does not remove BDB (Berkeley database) log/* files, because that is causing un-readable wallets on some people's machines (all the reports were from people running 64-bit version of Linux, but that might have just been coincidence-- I could never reproduce the problem in any of my test environments).What that means:  old private keys can remain in a file on your disk even after wallet encryption, but they will eventually be removed.  Details:BDB closes the old logfile and opens a new one when it get close to 10megabytes big.When bitcoin shuts down cleanly, it asks BDB to remove any unused log files, and BDB will remove all but one file from database/log.*So: if you encrypt your wallet, unencrypted private keys will be in the old part of the log file. But after running for a half a day or so, BDB will close that old log file and open a new one. Then, the next time you restart bitcoin, the old log file containing the unencrypted keys is removed.This seems like a reasonable compromise between security and safety for now; a better wallet encryption solution for the next version of bitcoin (for example, one that doesn't require shutting down and restarting after encrypting the wallet) is a good idea, but out of scope for this release. They're not throwing away 0.01 BTC, they just haven't redeemed them yet-- they're using valid-but-strange transactions. Absolutely no guarantee is made that old, pre-rc6 private keys will not end up unencrypted somewhere on the disk.There is no guarantee that newly generated, post-rc6 private keys will not end up on the disk, either, although the code tries to keep that from happening (locking memory so it is not swapped to disk, for example).There should be no files containing unencrypted private keys after rc6 rewrites the wallet, though.Thanks for helping test! Why limit it to bitcoin businesses?Somebody should create a website where you can get a few bitcoins for free, to subsidize adoption.You mean give a significant amount of bitcoins to the 'important' businesses?Who decides which are 'important' ?How do you make sure somebody isn't creating fake businesses just to get free bitcoins ?If you want to subsidize bitcoin businesses and have answers to those questions, then I heartily encourage you to go for it! I don't have a Linux64-with-GUI machine available to try to debug this, and I've failed to reproduce it on an Ubuntu 10.10 'maverick' server.If you can, please test (and, if you can, help debug) on 64-bit Linux.  This is the last issue holding up the release. First: sounds like a bug in Mt Gox's bitcoin address validation code that they should fix.Second: Do you own the testnet wallet with that address in it? If you do, then it is possible to transfer the public/private keypair from your testnet wallet to your main wallet and recover the coins (but you'll need to use PyWallet or one of sipa's export/import private keys bitcoin branches).Because the coins are recoverable, you shouldn't expect Mt. Gox to refund the transaction... (otherwise everybody could create testnet versions of their main-net bitcoin addresses, withdraw, and then as Mt Gox to "refund" their "mistake") If I recall correctly, the courts have ruled that "commercial speech" is not as protected-- so laws that restrict (for example) cigarette ads on television are OK.Bitcoin transactions would, I think, be very likely to be classified by the courts as non-protected speech, if they were classified as 'speech' at all. The hosts of Free Talk Live know quite a lot about Bitcoin-- I had lunch with them last year (there's a thread in here somewhere about that....).RE: "don't emphasize the potential illegal uses" -- mmmm.  Last I heard, Ian was enthusiastic about the Silk Road, so I'd expect it to be part of the conversation.And I think one of the people associated with the show (I'm being vague because I don't want to reveal something they don't want revealed) lost some bitcoins when MyBitcoin went away, so I'd expect security/trust issues to be raised, too. Updated to release candidate 6: https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.1/test/ https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/Two changes were made between rc5 and 6:1) When you encrypt your wallet for the first time, a new keypool is created before Bitcoin-Qt/bitcoind shuts down. This prevents losing bitcoins if you backed up your newly-encrypted wallet, received coins to new addresses, and then later restored from the backup.There is still a potential problem when you upgrade a previously-encrypted wallet:  in that case, the wallet file is rewritten on startup and will be left with an empty keypool (new keys cannot be written because in this case the code doesn't have your wallet passphrase). The release notes suggest backing up the re-encrypted wallet after generating a new address.2) Be less aggressive about deleting the database/log.* file(s) on shutdown -- with rc6, they are only deleted if the wallet is successfully encrypted/re-encrypted (to make sure unencrypted private keys are not left in them).Please report only show-stopper bugs in this thread-- normal bug reports or feature suggestions should go into the github issue tracker:  https://github.com/bitcoin/bitcoin/issuesPlease DO add to this thread if you've done some testing, giving what you tested (0.4.1? 0.5.0 ? win32 exe ?  zip ? linux ?), what operating system you tested on, and if you were testing a fresh install or upgrading (and if upgrading, was your wallet encrypted before?). Yes, VGA out. I had grand plans to make this the center of a Linux-powered multimedia center... but after doing nothing with it for a couple of months I think I just won't ever have the time.This is an Intel Atom D410 -powered little computer, with 1GB of memory and a 250GB hard disk, running a custom version of Linux (easily upgraded to the latest Ubuntu or other Linux distro by booting from a USB stick, though).Like new in the original box with all the original parts (keyboard, mouse, stand, power cable). New at Amazon: $229Selling for 90 BTC, I'll pay shipping to the US or Canada. Good idea. You might want to set up a testnet-in-a-box environment, so you can pretty easily create blocks yourself to get transactions confirmed quickly:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ D'oh!  I was running a -testnet bitcoind....Never mind. Neither of those addresses are valid according to my bitcoind:Code:$ bitcoind validateaddress 1AYSPTVt8WytG12Kz9guUpXjwAMFZG9CJh{    "isvalid" : false}$ bitcoind validateaddress 1AYSPTVt8WytG12Kz9guUpXjeAMFb7AX2K{    "isvalid" : false}The checksum in addresses is 4 bytes, so there is a one-in-four-billion chance that a random typo would get you a valid address. bitcoind follows the JSON-RPC-over-HTTP spec for reporting errors, but it sounds like Sergio's library follows a different spec. You're not the first person to complain that bitcoind returns HTTP error codes; here's a one-line patch to change that behavior with a "-rpcerrorstatus=200" argument/option:Code:diff --git a/src/bitcoinrpc.cpp b/src/bitcoinrpc.cppindex 31ef725..447b55c 100644--- a/src/bitcoinrpc.cpp+++ b/src/bitcoinrpc.cpp@@ -2088,6 +2088,9 @@ void ErrorReply(std::ostream& stream, const Object& objError, const Value& id)     if (code == -32600) nStatus = 400;     else if (code == -32601) nStatus = 404;     string strReply = JSONRPCReply(Value::null, objError, id);++    // Allow overriding the HTTP status response:+    nStatus = GetArg("-rpcerrorstatus", nStatus);     stream << HTTPReply(nStatus, strReply) << std::flush; }Let me know if that solves the problem and/or if it causes any other issues; if it doesn't, I'll submit it as a PULL request. Fixed, thanks for finding it. To be absolutely sure, you need to extract your private keys and then run a tool to look for them in your wallet.dat file (or other files on your disk).If you are able to compile a custom version of bitcoin and run python, here's how:  https://gist.github.com/1361001If you can't compile a custom version of bitcoin or run python code, then you'll have to trust other people to thoroughly test. I've uploaded release candidate binaries for Bitcoin versions 0.4.1 and 0.5.0 to SourceForge:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.1/test/  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/The 0.4.1 release is the old wxWidgets-based Bitcoin with a critical fix to the wallet encryption feature.The 0.5 release is the new Qt-based Bitcoin (which also includes the wallet encryption bugfix).Report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issues
No, I've been busy. Although I have in the past said that I'm worried about long-term incentives for relaying transactions (and am not worried at all about the block reward dropping and being replaced by fees).I skimmed the paper, and I'm really pleased to see very smart people thinking hard about the incentive structures built-in to Bitcoin. I think most people see all the digital signatures and peer-to-peer networking technology but miss that much of the brilliance of Bitcoin is how the incentives are designed.Overall, I think the paper is most valuable as a demonstration of how to prove that a particular solution to the problem could work-- whether or not the particular solution the authors propose (rewarding the relaying nodes) is the "best" solution I'm not sure -- there are lots of dimensions of 'goodness' here -- lowest cost, fastest transaction confirmations, easiest to implement, most compatible with the network we have now, etc.A while ago I proposed another potential solution:  have relaying clients drop their connection to 'greedy' nodes. If you have a node that sends you new blocks but isn't relaying you new transactions, maybe drop your connection to it and ban it's IP address from re-connecting to you for a while. Or maybe don't relay (or relay after delaying a couple of minutes) new-block messages that you first see from that node.  The idea is that a mild dis-incentive should be sufficient to encourage nodes to do the right thing and relay all valid transactions and blocks.Figuring out "isn't relaying you new transactions" in a spoof-proof way would be a little tricky-- you want to see real transactions, not miner-generated "I'm pretending to be a good network citizen" transactions. A scheme where you relay transactions to half of your peers and then monitor the other half to see if you receive the transaction back from them should work to detect nodes that are relaying many-fewer-than-normal transactions or blocks.I've also said repeatedly in the past I'd like to see more diversity in the networks used to transmit bitcoin transactions/blocks (with bridges between them so we're all working on the same block-chain). There doesn't have to be just one right answer to this problem, and I would love to see people simulate or experiment with variations on the existing network protocol or radically different protocols. You mean the wiki page that describes an overly-complicated scheme with your pet feature that nobody else likes (hexadecimal amounts)?And that we're all ignoring because we don't feel like getting into wiki editing wars with you (see the history from 9 May)? Huh what?  Version 0.5 supports drag-and-drop of bitcoin: URIs. And there's a pull request pending for click-to-pay support.One fear is bitcoin-address-rewriting malware, like the URL-rewriting phishing malware we have today. Actually, combining the two would be very effective (direct the user to a phishing site where all the bitcoin: URIs pay or donate to the scammers). We need better ways users can be certain they are paying who they think they are paying. Code review and testing for the proposed fix is welcome:  https://github.com/gavinandresen/bitcoin-git/tree/encryptionbugHere's how I tested:I dumped private keys from an unencrypted wallet (using bitcointools).I wrote a little tool that took a list of private keys and a filename and reported whether or not the 32-bytes of any of the private keys appears anywhere in the file.I also hacked a copy of bitcoin to dump any newly-generated-private keys into debug.log before they are encrypted and written to disk.I verified that new keys for an encrypted wallet are never written to any of the Berkeley DB database files by encrypting the wallet, invalidating all of the existing keypool keys, generating new, encrypted keypool keys, sending bitcoins to a new, encrypted key, and checking all of the files for any unencrypted copies of the new private key.So the problem became how to deal with old, previously-unencrypted keys that were ending up in the wallet.dat file.I hoped that telling Berkeley DB to 'compact' the file would remove the 'slack' space that contained the old data (the root of the problem is BDB doesn't actually completely delete/overwrite data when you delete a key/value pair; if I missed a setting that makes it do that, please let me know). Doing that reduced the number of old private keys found by my tool, but didn't eliminate the problem.Pieter worked on a different solution in parallel-- completely rewriting the database to a new file when encryption is turned on, then, assuming the rewrite succeeds (we trust BDB to do what a database is designed to do-- reliably write data to the disk), replace the old wallet.dat with the new wallet.dat.rewrite. During that process, all keypool keys are marked as 'used' (which actually means just not writing a 'pool' entry for them in wallet.dat.rewrite). That works-- no old private keys made it into the new wallet.dat.But during testing I ran into two issues:1) The wallet.dat file isn't the only place the old private keys were found; the database transaction log (database/log.000..N) and some of the __db.00N files also contained them.  Adding a call to remove() the database environment at shutdown fixed the __db.00N issue; I had to write code to remove the database/log.000..N file on clean shutdown.2) If more wallet database operations were performed after the rewrite (I had written code to top-up the keypool with new, secure keys before locking the wallet), old private keys could end up in the new wallet.dat.To fix both of those issues, we modified the code so that a shutdown happens after wallet re-encryption.... which reminds me of something else I need to test:  if you startup with a wallet encrypted by bitcoin versions 0.4.0 or 0.5.0, the wallet is re-encrypted and all of your old keypool keys are considered used.  (I believe it does not shutdown after doing that, though, but it should)We've never made any guarantees that unencrypted private keys will not end up on your hard disk; if you have a virus on your system that can directly read blocks off your hard disk then it can almost certainly also read system memory, and could steal your wallet passphrase the first time you sent bitcoins.Filling up free space on your disk (as suggested in this thread) might work, but it is a much better idea to send all of your bitcoins to new, 'born-encrypted' keys. Once fixed binaries are available, that will be easy-- just upgrade and then send all of your bitcoins to yourself, using newly-generated addresses.Suggestions for more radical solutions, like storing private keys in a separate file, are out of scope. We got what we got; I personally think that a really good "deterministic private keys" solution, where the private keys for your wallet are derived from a passphrase that is only in your head (and maybe written down and stored in your safe deposit box) would be a better use of developer time rather than reworking how we store private keys on disk.Even better would be further work on multisignature/multidevice solutions so even if your private keys are compromised an attacker can't spend your coins. Luke-Jr is planning on supporting 0.4-based releases (finding somebody to fix wxWidgets-related bugs is an issue, though).The issue I have with calling any pre-1.0-release 'stable' is it implies a level of maturity that I don't think we're at yet. I can see 1-year develompment->unstable->stable release cycles once we're at a solid Bitcoin 1.0 release that I can actually feel comfortable recommending to my non-geek relatives.My fear is that developers would happily code away and use the development branch, bugs would pile up against the unstable branch (and would get ignored because developers were happily coding away on dev, and nobody really wants to do bug fixing or QA testing), and unstable would never become stable enough to tag 'stable.' But I've never led an open source software project before, so I might very well be wrong (best way to convince me is to point to other small open source projects that we can emulate-- I don't think emulating big projects like Ubuntu will work).I agree that when a fix has been tested and is available an alert to the affected versions is a good idea.Unfortunately, TruCoin ran into a funding crunch because an investor got cold feet and had to stop paying for anything besides directly-related-to-TruCoin work. That's not quite right-- you need to exhaust all of the keys in your 'key pool' to be safe, so you'd have to ask for 101 new keys.Part of the fix is marking all of the keys in the keypool as used. A serious bug was been found in the "encrypt wallet" function of bitcoin versions 0.4 and 0.5: private keys may be left unencrypted in the wallet.dat file after encryption.If your encrypted 0.4 wallet file is stolen, an attacker may be able to recover some or all of your private keys and steal some or all of your bitcoins.The development team has been working on fixes for bitcoin versions 0.4 and 0.5, but it will take at least a few days to test them thoroughly. Until they are available, you should assume that your 'encrypted' wallets are as vulnerable as an unencrypted wallet, and follow all the best practices for keeping them safe (see here for a list).It is embarrassing and astonishing that this critical a bug was not caught before the 0.4 release; constructive suggestions on how to improve the testing and release processes that do not assume access to hundreds of thousands of dollars of funds to hire security consultants or QA teams are welcome. Getting sufficient testing of code BEFORE it is released has been a chronic problem for this project. Discussing how to fix this in IRC now.This IS a show-stopper issue for the 0.5 release. https://github.com/gavinandresen/Bitcoin-protocol-test-harnessStart with dumpblocks.py No issues with export wallets/private keys. I share gmaxwell's concerns about making it easy to shoot yourself in the foot, but most of us are grown-ups and if you're talking using the RPC interface there are already plenty of ways to shoot your feet.Remove private key I had issues with, because if you're using the 'accounts' feature then removing keypairs from a wallet (and their associated transactions) does unpredictable things to account balances. At the very least, I think it should tell you what effects it had.  Maybe a JSON result that tells you how account balances changed, e.g. { "" : 1, "John's Wallet" : 6.2, etc.}. That way, if it had an unexpected effects you would know to restore the wallet from backup.And it seems like 'sweep private key' and 'merge wallets' is really the functionality most people want, not import private key/wallet keys. The only issue I have with them is they are slow because of the rescanning of the block chain, and they may not work or may not be secure if you don't happen to have the whole block chain downloaded. This would be a good bitcoin.stackexchange.com question.Do what deepceleron says... although you might want to copy JUST the two blk*.dat files (you don't need addr.dat or the database/ subdirectory). Have you tried running rc3 on W2k?  I don't have a W2k machine to test on (I did sanity test rc2 on XP SP3), but I don't know of any reason it would fail. I purchased this laptop:  http://www.ebay.com/itm/290608305269... to do Bitcoin 'gitian' builds.  It's a perfectly good laptop, runs nicely, but I'm re-selling it because its Core Duo CPU can't do 64-bit builds.Specs are:  1.83 Mhz Core Duo processor  120GB memory  2G disk  WifiRunning Ubuntu 11.04, includes laptop, battery and power supply.Asking 50 BTC, I'll pay shipping anywhere in the US; if I don't get any takers here, I'll re-auction it on Ebay on Friday, Nov 11. If you can, please help sanity test Bitcoin 0.5 release candidate 3 binaries: https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.5.0/test/Files and checksums are:Code:5077db912792ed1e341d0acecdd158717de97510  bitcoin-0.5.0rc3-linux.tar.gz73e72328523482c91fceed6e676ec9e3b728a621  bitcoin-0.5.0rc3-macosx.dmg6171be62a7dd18ce787889531525def80be13219  bitcoin-0.5.0rc3-win32-setup.exe3c53c0008218ea5c4604984d07b5c5ddaaaf2287  bitcoin-0.5.0rc3-win32.zipLinux and Windows binaries are created using the gitian-trusted/reproducible-build tool; the OSX binary was built by me.I'll be writing up release notes this afternoon; assuming no 'show-stopper' bugs are found, these binaries will be the 0.5 release.Please report bugs using the issue tracker at github:  https://github.com/bitcoin/bitcoin/issues   Let me think... a problem that affects a small number of people... means you end up with 8 connections instead of more than 8... and has an easy, obvious workaround... and if fixed will be difficult to test thoroughly...Not high on my priority list.Things that ARE high on my priority list:+ Getting the 0.5 release out the door+ Improving initial startup and block download times+ Solutions for wallet security and backup I'm proposing one new RPC command:  'addmultisigaddress'  ... that combines several public keys into one BIP 13 -style newfangled bitcoin address.You get the public keys from the 'validateaddress' RPC command, which I've extended to give the full public key if you give it one of your bitcoin addresses.I extended the 'send*' RPC commands so they know how to send to the newfangled bitcoin addresses, and can send coins you received as multisignature transactions if you hold all the corresponding private keys (listtransactions will also show you them, getbalance counts them in your balance, etc).  So yes, anybody can generate new transactions to test...Alan Reiner is proposing BIP 10 as the 'real' way to get multisignature transactions signed and spent:  https://gist.github.com/1321518(no implementation yet, as far as I know). See BIP 12, the Backwards Compatibility section, for gotchas-- block chain forks are possible if you're not careful. They won't happen by accident, but if you assume there is an attacker that just wants to cause inconvenience by forking the chain then you have to roll-out the change carefully.To test on testnet:Apply the patch. Then use the extended 'validateaddress' RPC command that is part of the patch to get public keys for several of your bitcoin addresses (use getnewaddress to generate new ones if you need to).Combine those public keys into multi-signature addresses using the new addmultisig RPC command:   addmultisigaddress <nrequired> <'["key","key"]'> [account]So for a 2-of-3 escrow you'd call:   addmultisigaddress 2 '["...pkey1...","...pkey2...","...pkey3..."]'It returns a multisignature bitcoin address.You'd do that on all the machines involved in the escrow transaction.To fund that multisignature address, you just use the normal sendtoaddress (or sendmany or sendfrom) RPC commands, using the address returned from addmultisigaddress.To spend those funds... more patches are needed.  You CAN actually spend them if you have ALL the private keys in your wallet; if you do, then the multisignature transaction is treated just like any other transaction you've received, and will show up as part of your wallet's balance, in listtransactions output, etc.Modifying the patch so that you can spend them if you have <nrequired> keys is probably the right thing to do, although the security implications of that for shared-wallet providers needs to be carefully thought through. And in almost all of the real multisignature use cases, a RPC calls to create and sign partially-signed transactions is the right thing to do, NOT importing private keys from the other people involved in the transaction. See: https://gist.github.com/1321518   and  https://bitcointalk.org/index.php?topic=39471.msg597785#msg597785  for a proposal on how to do that. 0.5.0 is next; just working out the last build/deploy issues now...A day or two after a release is final I always bump the third version number, so somebody running "git head" (the latest source code) has a newer version number.  So there was a 0.4.1 that was never released; the switch to Qt for the graphical UI was a big enough change to justify a jump to version 0.5 I'd like to see one or more of the alt chains take:  https://github.com/gavinandresen/bitcoin-git/tree/op_eval... and start supporting OP_EVAL, multisignature transactions, and the new bitcoin address type.(and thanks to coblee- he (she?) did help flesh out the ideas) Great!Unless Mike messed up his implementation of the OP_NOP1 and made it do something other than be a no-op, there should be no problem  (OP_EVAL re-defines OP_NOP1 to do stuff instead of doing nothing, but all OP_EVAL transactions are valid if the OP_EVAL is interpreted as a no-op).Publish how? I already made a couple of testnet transactions using OP_EVAL; I will make a few on main net (assuming Luke doesn't change Eligius to reject OP_NOP1 transactions). And I wrote thorough unit tests that create valid/invalid OP_EVAL transactions.What do you mean by "everytime there's a block change" ?"OP_EVAL" can be anywhere in the coinbase, I'll probably write a little tool using bitcointools to look at OP_EVAL adoption over time will make sure it doesn't care where the string appears.
The beauty of OP_EVAL is it is backwards-compatible with old merchants/users/vendors/miners; there is no reason to require that they all switch over at the same time, they can continue to operate with their old software for as long as they like (assuming all this happens, there will be increasing pressure over time for them to upgrade so they can pay to newfangled BIP 13 bitcoin addresses). Good question. The timeline for clients is less critical, as long as a majority of hashing power will properly interpret OP_EVAL clients that relay/generate those transactions can be rolled out anytime after Feb 1.So I'd suggest releasing a 0.5.something or 0.6 after the Jan 15 "are the big miners on board" evaluation that turns on OP_EVAL support Feb 1.Same time.Another very good question. The timestamp in the block will be used to determine whether OP_NOP1s in the block are interpreted as no-ops or OP_EVAL when checking block validitity (wall-clock GMT time will be used to figure out if the node should relay/mine OP_EVAL transactions). I'll double-check my code, I think I did NOT code it that way.That seems exceedingly unlikely; once the big mining pools switch, there is a very strong incentive for the smaller pools to switch, too. OP_1 through OP_16 push single bytes (0x01 through 0x10) onto the stack.RE: updating the wiki:  good idea, I'll go do that... OP_0 pushes an empty array of bytes onto the stack, so you should RIPEMD160(SHA256([])).(thanks go genjix for setting me straight, I'd been thinking OP_0 pushed a 0x00 onto the stack, and that isn't right.  The scripting engine knows that an empty array is 'False', and FIPS standards make sure hashing empty strings/arrays is well-defined...) I just sent this email to several of the top mining pools; I'm also putting it here to get wider feedback from "the mining community":I'm writing to the top mining pools to see if you will support Bitcoin Improvement Proposals 11, 12, and 13: https://en.bitcoin.it/wiki/BIP_0011 https://en.bitcoin.it/wiki/BIP_0012 https://en.bitcoin.it/wiki/BIP_0013I think they are critical to making Bitcoin more secure for people who have never heard of GPG or AES. They don't solve the wallet security problem, but they put in place low-level mechanisms that will allow higher-level services that DO solve the "computer virus stole my bitcoins" problem. Once multi-signature transactions are supported by the network, Bitcoin wallets can be coded to contact "Wallet Protection Services" to get a second signature/authorization before coins can be spent (details of exactly how the Wallet Protection Service and the client communicate will be in future BIPs). They will also make it possible to create escrow services that cannot spend the bitcoins in escrow among other interesting use cases.This same feature might be used to keep your pool's bitcoin balances more secure, also-- you could run your own Wallet Protection Code on a separate machine that (perhaps) required manual intervention before providing a second signature on pool payouts if some unusual payout activity was occurring because somebody managed to break your security and get access to the pool's wallet.I'm proposing extreme caution rolling out support for multi-signature transactions, and, especially, supporting the OP_EVAL feature that allows more secure bitcoin addresses-- and that is why I'm asking you whether or not you're willing to patch your mining pool software sometime in the next two months to support the new 'standard'transaction types.I've already written an implementation for Bitcoin 0.5 that will soon become a PULL request.The new features are backwards-compatible with existing miners and clients, but we do have to be careful when rolling out OP_EVAL because an attacker could create non-standard transactions and try to split the block-chain.Here is the timeline I've proposed in BIP 0012 :Now until Jan 15, 2012 : miners update their software, start including CHECKMULTISIG and OP_EVAL transactions in blocks they mine, and indicate support by including the string "OP_EVAL" in the blocks they produce.Jan 15, 2012: we assess support for the new feature by looking at the percentage of blocks that contain "OP_EVAL". If a majority of miners are not supporting it, then deployment will be delayed or cancelled (a setting in bitcoin.conf controls the switchover date, with the default being Feb 1, 2012).Feb 1, 2012: assuming there was majority support on Jan 15, OP_EVAL is fully supported/validated.--------------Questions I have for you:Is there anything I can do to make it easier for you to support these new features?  For example, would patches against an earlier version of bitcoind be useful?  (if so, what version?)Is the timeline reasonable?Questions you might have:What happens if you don't support these new transaction types but a majority of other miners do?If you do not put non-standard transactions in your blocks, then nothing will happen.If you DO put non-standard transactions in your blocks, then you would be vulnerable to an "invalidate blocks under the new rules" attack, where somebody sends you a transaction that is valid under the old interpretation of the OP_EVAL opcode (which is a no-op) but not valid under the new rules.  Your miner would put that transaction in blocks that you mine, and all of your blocks would be rejected by the majority of miners.What happens if you DO support these new transaction types but a majority of other miners do not?All transactions that you put into blocks will be valid under both the old rules and the new rules, so there is no danger that blocks you create will be rejected by the network. There IS a danger that the rest of the network will accept a block under the old rules that you consider invalid under the new rules; that is why I am proposing that we evaluate acceptance of the new rules on January 15.Can you support one of the BIPs but not all of them?Yes-- supporting CHECKMULTISIG as a standard transaction type (BIP 11) can safely be deployed right now, there is no danger of a block-chain-split, etc.BIPs 12 and 13 will let users (or mining pools) use short bitcoin payment addresses to have bitcoins go directly into secure, multi-authentication-required-to-spend wallets. Anybody know why it says I found a block? I am not mining... See src/test/script_test.cpp in git HEAD.Or for more examples of testing script operations, the unit tests I wrote here:  https://github.com/gavinandresen/bitcoin-git/blob/op_eval/src/test/script_op_eval_tests.cpp  https://github.com/gavinandresen/bitcoin-git/blob/op_eval/src/test/multisig_tests.cpp What were you testing that you needed to dedicate about a month of multi-GH mining effort? 1. TxOut scripts are not evaluated until they are spent-- those are probably unspendable TxOuts.2. The inputs must be valid (you're looking at coinbase txns with no inputs though). Again, TxOuts aren't evaluated until they are used as inputs in another transaction; as long as they deserialize properly they'll be accepted.3. I don't know of any other bugs in the scripts ops, but I don't know that anybody has written thorough unit tests for them (anybody looking for a good get-your-feet-wet project that could be a good one to tackle; there are already unit tests for CHECKMULTISIG in the repostitory....). Another quick update:Wladimir figured out what was breaking the Win32 cross-compiled builds (one of the 'hardening' gcc flags is apparently busted for mingw32 cross-compiles), so Linux and Win32 binaries of a rc2 should be available soon. Yet another hurdle was thrown in my way by Mother Nature Saturday night; we got over a foot of snow, and my house and home office still have no power. Mac builds won't be available until my main machine has power... One million percent is a 10,000 times rise in price.The first trades on bitcoinmarket.com were at a price of something like 0.001 US dollars; 10,000 times that would be $10, and lots of bitcoins traded over $10 earlier this year.So I think the Fool got it right. Auto-reset once a month...  very interesting idea.It'd make a mess of peoples' testnet wallets-- they'd be full of orphaned 0-confirmation transactions.  But deleting your testnet wallet once a month wouldn't be that big a burden, and that should prevent people from trading testnet coins as if they were worth something.Somebody who wanted to be annoying could still drive up difficulty after every reset and make life miserable for anybody testing their new exchange or merchant software, though.The problem with just doing more frequent difficulty adjustments is somebody with lots of hashing power can still over-write huge parts of the chain whenever they like. I suppose you could argue that bitcoin services should be written so that they can handle suddenly getting a 600-block-long chain-reorg... but that just does NOT happen on the real bitcoin network.More hare-brained thoughts: could automatic block-chain lock-ins for the testnet be implemented somehow?  Fetch a block depth/hash pair from a website somebody volunteers to create (auto-updated once a day...) ? I'm starting this thread to brainstorm rule changes for -testnet and talk about a possible testnet reset for the next release.The testnet isn't currently usable, because hashing power on it is unpredictable.  Difficulty shoots up because somebody decides to throw lots of machines at it, then they leave and it takes MONTHS for difficulty to drift back down.Here's a shot at hair-brained rules for the testnet:+ Fix the difficulty at 1.0, no matter how many people are mining.+ Clients reject new blocks with timestamps more than 1 minute different from their time (implies:  you have to have an accurate system clock to play with the other nodes on the testnet, otherwise you'll be on your own fork).+ Clients reject new blocks if their timestamp is less than 2 minutes after the previous best-block's timestamp.+ Clients prefer to build on blocks that include more memory-pool transactions, instead of taking first-block-they-receive.Goals behind those rules:  Always easy to mine  Limit block-chain growth (max 1 new block every 2 minutes)So: could a griefer make life miserable for the rest of us under those rules?  What would happen if there were five or six people with a fair bit of hashing power all trying to mine as fast as possible on testnet?  (lots of block chain splits, I think, but that's probably just fine on testnet) I was just thinking today about resetting the -testnet with new rules to make it more stable/useful... RE: BIP 0010 :  Cool!Suggestion:  if we're going to borrow PGP's file format, then we should be as compatible as possible, and reference their standards document:  http://tools.ietf.org/html/rfc2440In particular, they use Radix64 encoding, not hex...  Quick update on why there is no final 0.5 release out yet:Short answer: because I'm really paranoid about bitcoin binary builds, and the switch to Qt means a change in the way the builds are done.Long answer:Linux builds should be all set; the 'gitian' trusted build process works nicely.Windows builds are being difficult; we need a gcc expert to help debug the 'gitian' cross-compile (see https://github.com/bitcoin/bitcoin/pull/587 ).Unless somebody steps forward and says "I'll support compiling bitcoin-qt/bitcoind with Visual Studio) I'm going to remove src/makefile.vc and make sure the readmes say that only the mingw toolchain is supported.Mac builds were slightly broken for the 0.4 release (they don't run on OSX 10.5-- you need 10.6 or greater). I'm "recompiling the world" to hopefully fix that, and hope to have mac binaries available soon (let me know if you can help test, especially if you have a 32-bit Intel mac running 10.5).On my wish list for builds (anybody want to volunteer?):I think it'd be spiffy to have a .pro file to compile bitcoind; maintaining N different makefiles is annoying and error-prone. Here's my public key, or you can fetch it from the MIT pgp keyserver.  Or it is linked on the bitcoin.org homepage.-----BEGIN PGP PUBLIC KEY BLOCK-----Version: GnuPG v1.4.9 (Darwin)mQGiBEy8srURBADlAamWM3TkgAKyVBVftUsg5aZ3zOA5UAlg+yI/6bzfTkYLtspALQ6typamac9re+lqnWdDMa4qVwSmaOMxLOlGhCWWfmA38QprU+ZfuesnxWrVAMG8TDHLT2vBCa+9iC50soo/imsDqqe6ujm7a+Pd1KSNvFR5KXgEgeEHSiyEqwCg3iAaDH3lNWzNOgJgi8PUiszqbcsD/2mfNBYJsazYabXcbNdh8VheNnyK2KLUE8Lg1WzUld/Sd1gu67oPSFfTiFZ5OBjdHI/XmlFAT4r4eNy1IIf0nELJWWQ6hlzm0a0/DO4bBUoapjUjAYWDyeeeALDHK7EQboqtwWBlRONyY/+yB9usgbvAK2khRlzBhQonGJEsFpdQA/9bQzVgpEE1q/ZSnvLp0nOFA3E51SS9uvGGnAdQMjwDp7iGBzh7gRz4ko1kLG3Sa5fNe21VvlKFcMTaZN9Pd5fDd7gEoDkjUDlf9lRX+YT5zf+SSoeCIGuNMVzsf8Z2H414dYDOJPBkhYWcqFhGhz11QtWgug5n8GaewC2YOiPU8LQoR2F2aW4gQW5kcmVzZW4gPGdhdmluYW5kcmVzZW5AZ21haWwuY29tPohmBBMRAgAmBQJMvLK1AhsDBQku/geABgsJCAcDAgQVAggDBBYCAwECHgECF4AACgkQdYgkL74406h8rwCgyMwSbwfJ+t3B2IRbhnDIsLo4UtAAnRqMmznLBNLe97fbWYjkcgiAkr2UuQINBEy8srUQCADLdLYPEFwz9DEMHoQID/USG6QBP8LXVWCy+84aWsR/SMP2k7BmqtiBEOAZvq9jTf4/6WoYkU++vDUiq2QefmCnUSfNiD7TcVAQOm631Kg7TkCQU3TZY5rzJ8DAoh2DvMuYhWVr0grvlJcF6x0A2/YopfR1BO7SNq87LoG/ZqdbFgijNNePBXEfDGG0T0dgXkZAKsf6v/rgQYWjSgOx1jn/cH7opoum4xyGLVDE+sU3aKBUwaWOV1hLUHWVwgC7FwXs+nxWPVitR4Ri6aYGlFTrql9DbrQipaybFTRsbdlCrSEpwz5sKK/FE3aRSo5++X6fj590uOEPHtu9RDtBcCePAAMFB/9/hCzl8OVZER2fayOTwCauYbt/21D+RvQJ67bFMMiPxEgWcyueZmpF2Z5KXc61z8mMa831wUNdkkcr2BSr2FEIArlpoynwYHPeKyzy1hhhXxdy7uOObicgPMnOx94ZRuvc/xD8LMDLbQ2tpAZn+TCXvwE7fvIxOCnr6JKUmd2GpQKVnFSbfS9to3pImnZe8OLwoFoBXQ3CBViJo5vYLUHHH+OgIs28PV+8fcQVJTUQpkDOjNg3fPFd8/YGzaE55+MTqacr5VoSR6aUweMpRCFHNb5PEv/HsY6m4Q5ypXJBMwWZZlDtiPJnnTaWPwCZLFoj3zEE2VgVGSuoxUMDisPRiE8EGBECAA8FAky8srUCGwwFCS7+B4AACgkQdYgkL74406gxCQCfa3UFF31O14UKmnyuJFUTiik+YBsAoLiC5B6DhN25fJRKWhdvih2hQWrX=oDeQ-----END PGP PUBLIC KEY BLOCK----- I've been thinking a lot about transaction IDs and how to gather signatures for multi-party transactions, too.For the most part, I think all the details should normally be hidden from users-- I think "Select Transaction Type" is much too geeky.Thinking out loud, and starting with what I think will be a very common use case:  buyer and seller and somebody to resolve disputes that arise (2-of-3 escrow).Are you imagining all three are using a bitcoin client? In my head, one might be using bitcoin-qt, another a web-based wallet service, and the dispute resolution would be done by a company with a website. I don't think "we're all running bitcoin on our computers" will be the common case.So here's how I see it working (my ClearCoin experience may be biasing me):Buyer and Seller sign up with the escrow service. During signup, they each give the escrow service a public key.  How?  -- Clunky way:  they poke a "Advanced.... New Public Key" button and then copy&paste a long string of hex  -- Better way: they poke a link on the escrow status page that does some magic     (maybe there's a bitcoin:sendnewpublickey?destination=https://www.clearcoin.com/newkey/user1234 URI type that can be made to Do the Right Thing)Buyer or Seller then creates an escrow at the escrow service's website.  -- Escrow service creates or assigns a keypair for their part of the 2-of-3  -- Escrow service creates a newfangled bitcoin address using the 3 public keys.Buyer sends bitcoins to the newfangled bitcoin address (by clicking on it at the escrow service's page-- it could be a bitcoin:... link)Escrow service's wallet sees the payment to the newfangled bitcoin address, updates the status page.Buyer tells seller they paid.  Seller checks the escrow status page, clicks on a "send me the money" link and ships the product to the buyer.What does the "send me the money" link do?  It needs to get a signature from the seller for a transaction that spends from the 2-of-3 transaction and sends to the seller's wallet.  Another bitcoin: URI that does magical stuff?  (bitcoin:signtransaction?tx=...hex...&destination=https://www.clearcoin.com/... ) Or some other clunky copying-and-pasting of long hex strings?Days later: Buyer gets the product and is happy. They visit the escrow status page and click on a "send THEM the money" link, which does more magical stuff. Or more clunky copying-and-pasting of hex strings.  In any case, the escrow service gets the second signature and sends the transaction to the bitcoin network, and the coins show up in the seller's wallet.Couple of notes:I don't see the newfangled-bitcoin-address being part of the buyer's or seller's wallet, and adding it to their wallet would be yet another step.Need to think about what happens if the escrow service suddenly disappears... they can't steal any coins, but if neither buyer nor seller knows the public key the escrow service is using then they can't complete the transaction by themselves.  Perhaps the bitcoin: URI that the buyer uses to fund the transaction should include all the public keys and should be added to the buyer's wallet...All of this would be much nicer if there was a more user-friendly, security-friendly representation of bitcoin addresses / public keys. I hate to be a wet blanket, but if "they" wanted to stop this why couldn't "they" simply pass a law stating that it was illegal to buy or sell bitcoins?Or "they" could impose a punitive tax on purchases or sales of bitcoins.I suppose my point is: if "they" really want to make bitcoin illegal, then they will find a way to do it; I don't think creating bitcoin derivatives will help much on the legal front. Depends on who "we" is and what corporate form the Foundation takes...... but the one of the first orders of business will be more discussions with lawyers who know about those types of things.  
Bitcoin is revolutionary because it is decentralized, with no single point of control or failure.However, over the last six months or so it has become obvious to me that the rest of the world isn't set up to interact with a radically decentralized system like Bitcoin, and I think forming a not-for-profit organization will be a positive step towards Bitcoin's long-term success.I'm posting this to see if there is a consensus on what a Bitcoin Foundation should be.To get the conversation started, here are some functions I think a Bitcoin Foundation could perform:Interact with the legal system, where a centralized entity is needed: for example, to hold the Bitcoin trademark, own/control the bitcoin.org domain name, etc.Act as a central library for accurate information about Bitcoin, so journalists and policymakers have an 'official' place to learn about Bitcoin.Collect donations to fund infrastructure necessary for Bitcoin's growth (organize regular developers' conferences or get-togethers maybe? pay for development of cross-implementation testing tools? pay core developers' salaries? create a certification/testing program for Bitcoin implementations? create a central clearinghouse for information about legal issues surrounding Bitcoin across the world?)Other not-for-profit organizations that could be emulated:The Anti-Phishing Working Group (the APWG's chairman, David Jevans http://en.wikipedia.org/wiki/David_Jevans, is willing to help make a Bitcoin Foundation happen).The Tor ProjectThe Apache Software FoundationAre there others that work well, or are there examples of what NOT to do? Assuming there is rough consensus that a Bitcoin Foundation is a good idea, I would like to get something imperfect up and running quickly, with the expectation that it will evolve over time. I think Casascius did the right thing.He has no way of knowing how many people got the phishing email, and no other way of contacting people who might fall for the scam.If you're upset because you have to poke the 'delete' button on your email one extra time... then I think you're overreacting. Yes, but if you are spending a lot of time or effort trying to make money on an essentially unproductive activity then I think you should ask yourself if there's something else you could be doing that would be more effective at making the world a better place.I think a lot of buy-low-sell-high, there-is-always-a-bigger-fool, or high-frequency trading fits into the "isn't making the world a better place" category. If you're competing for a bigger slice of a fixed-sized pie, I think you should think hard about what you could do instead to make the pie bigger for everybody.Mmmm.... pie...... Thanks to Amir for agreeing to be the "BIP editor" and getting these up:https://en.bitcoin.it/wiki/BIP_0011https://en.bitcoin.it/wiki/BIP_0012https://en.bitcoin.it/wiki/BIP_0013 You == me?There's a sticky here about creating a pull request, it'd be most excellent if you could make you==you and fix the doc/readme-qt.rst file.I'll try hard to remember to mention this for the 0.5 release notes, but I'll warn you I'm really good at forgetting things. I don't know nuthin about error-detecting checksums, but I think the time it would take to implement it and argue about it would be better spent on more user-friendly, secure ways of making bitcoin payments. I haven't heard of even a single case of "I manually typed in a bitcoin address and the coins got lost because I made an undetected transposition error." Yes. Although there might be a way of accomplishing the same thing without recursion:Use case:Imagine we want, in the future, to support "this" OR "that" transactions.  Where "this" and "that" are themselves possibly complex multisignature or escrow or whatever transactions.Most straightforward way might be a new standard transaction that looks like:Code:DUP HASH160 <hash160> EQUALIF  OP_EVAL      "evaluate the this"ELSE DUP HASH160 <hash160> EQUALVERIFY OP_EVAL       "... or evaluate the that"ENDIFSo you'd redeem it by putting one script or the other on the stack (along with the signatures needed by the script).So.... maybe you want to recurse so that the IF/ELSE script is itself part of a standard, single-hash OP_EVAL, so you can use a newfangled bitcoin address to send to it.  That would look like:Code:scriptSig:  <signatures> <this_or_that_script> <IF/ELSE script>scriptPubKey:  DUP HASH160 <hash of IF/ELSE script> EQUALVERIFY OP_EVALI am NOT proposing an IF/ELSE "this or that" standard script type; I think there is plenty of enough work to do to actually make secure wallets and in-the-chain escrow work.  But supporting limited recursion for non-standard or future transactions seems easy and safe...(terminology footnote:  calling scriptSig+scriptPubKey "transactions" isn't accurate, the transaction is the bigger thing, but I'm not sure what else to call them; I hope y'all follow what I'm saying) Draft BIPs, comments very welcome:https://github.com/gavinandresen/bitcoin-git/wiki/BIP-OP_EVALhttps://github.com/gavinandresen/bitcoin-git/wiki/BIP-Bitcoin-Address-01https://github.com/gavinandresen/bitcoin-git/wiki/BIP-M-of-N-Standard-Transactions I pulled a Satoshi and decided to implement OP_EVAL to make sure it would actually work.  https://github.com/gavinandresen/bitcoin-git/tree/op_evalNot ready for pulling, expect rebasing/tweaking/changing. But it is fully working on the testnet.(example transaction here)The code puts "OP_EVAL" in the coinbase of generated blocks, so the rest of the network can see how many miners support it.I gathered contact information for the top ten mining pools last week; when there is rough consensus on the details, I'll contact them to see if they have concerns and/or are willing to support OP_EVAL.I started writing up BIPs for the various pieces of OP_EVAL, I'll post them soon. Example possible BIPs:URL syntax for bitcoin paymentsNew OP_EVAL scripting opcode for receiver-specifies-transactionNew bitcoin address format to support OP_EVAL(I'm actually working on those two)Informational:Process for announcing/scheduling/implementing a potentially block-chain-splitting change.-----------You can browse through the PEP's at http://www.python.org/dev/peps/  to get some idea of the kinds of things that might be good BIPs; changes to the on-the-wire protocol to make blockchain downloads faster would certainly be appropriate. Amir started the "get more formal about changes to bitcoin" ball rolling by creating BIP 0001, starting from the Python "PEP" / BitTorrent "BEP" processes.The idea is to use BIPs for changes that may or will affect every bitcoin implementation (not to use them for proposed changes to one particular implementation).I'd like to propose some minor changes to the process:I propose that BIPs be wiki pages, with a social convention that the Author gets final word if any editing wars break out.If he's willing, I propose that Amir take the role of BIP editor.I think bitcoin is still too small to have a specialized "bitcoin-ideas" mailing list; I propose that new potential BIPs be discussed either here or on the bitcoin-dev mailing list. What are you optimizing for?  Ease of implementation? Wallet size?Here's a naive implementation that I bet would work well in practice:+ Sort potential inputs by priority (priority is #confirmations * amount)+ Use the N highest-priority coins whose sum >= amount neededIf you want to optimize for fragmentation and/or paying of fees, then also do:+ If the change transaction is larger than some threshold amount, then split it in half (or maybe split it into Y change outputs, each of which is about the size of the threshold amount).+ If the change transaction is small and there are other small-valued/low-priority inputs available, add a few small-value inputs to merge them together.You could also optimize for privacy (try to avoid using more than one input and/or always create multiple change outputs), or tweak the above rules to try to always avoid fees... Double-huh?  You write your Mt.Gox account information on the deposit, Mt.Gox has all the information necessary to report to FinCen (because only upgraded Mt.Gox accounts can use the service) if required (if depositing more than whatever the daily/weekly FinCen requirements are, yada yada...).What's up with the attitude Matthew? More ways to purchase bitcoin is a good thing... So... what would convince you?  What if you could pay 10% of your expenses using bitcoin, and it cost you 1% less if you used bitcoin?There are lots of chicken-and-egg problems that bitcoin has to overcome to compete with the dollars or euros we're all using now; I see two paths to bitcoin's success:Maybe there are enough ideologically motivated people to form a self-sustaining economy. If even 1% of people find the idea of bitcoin attractive and started using it for 1% of their transactions that would still be huge.Or maybe one or more 'killer apps' for bitcoin will emerge, giving it a foothold in certain markets. Maybe it will never expand beyond those markets, or maybe it'll slowly grow beyond them because of lower cost and higher tech.If you're not excited by the idea of being an early adopter for what could be a massively influential idea, then you should probably come back in three or four years and either tell us "Told you it'd never work!" or join what should, by then, be a much more stable and easier-to-use system. I never started with bitcoinjs/nodejs, because I'm not a JavaScript programmer (and I'm too busy to take the time to learn).It would be lovely if somebody who is a JavaScript programmer decided to show me how easy it would be and took bitcoinjs/nodejs and created a really nice cross-implementation testing framework with a bunch of test chains.RE: Mike's point that creating full-difficulty test chains is a pain in the ass:  I think that one-time pain is worthwhile, because I don't think we can count on every bitcoin implementor making it easy to run their implementation in a unit-test mode with super-low difficulty. And creating difficulty-1 blocks with a GPU is actually pretty darn quick... Pass a 0 as the third argument to sendmany and it will send unconfirmed coins:  Code:sendmany <fromaccount> {address:amount,...} [minconf=1] [comment] Nice work!That's almost exactly the direction I'm heading with the cross-platform testing framework I've been working on, although I was planning on storing blocks in JSON format and was planning on using Python's Twisted/Trial framework to feed the different chains to the implementations to see if they accept or reject them.I got sidetracked by the 0.5 release and then sidetracked again because I couldn't resist experimenting with the "OP_EVAL" idea and multisignature bitcoin addresses... Corrupting how? Did they install 0.5 and then downgrade (is it a backwards-compatibility issue)?Did it get corrupted when they encrypted?Anything interesting in their debug.log? Thinking out loud:If miners (or other nodes) not relaying transactions starts to become an issue, "we" could write code to detect and discourage it.Detecting: the node says it is a full node but you get many fewer 'inv' messages from it compared to your other peers.Discouraging: you refuse to relay or build on any new-block messages that you get from that node.See https://github.com/gavinandresen/bitcoin-git/tree/discourageblocks for a framework for the 'discourage' part. I can't resist, the problem of how to bootstrap a new chain in the face of massive, hostile hashing power fascinates me.CoinHunter, what will happen to SolidCoin if, God forbid, you get hit by a bus? What are the plans for the trusted CPF wallets? Do your heirs get control of them?And what if SolidCoin is wildly successful-- so successful that each SC is worth 1,000 euros? Will somebody still need 1 million of them (so have to be a euro billionaire) to be trusted?
None taken.  I've been trying pretty hard lately NOT to be The Central Authority, I don't want the job and I think the whole idea is contrary to the Zen of Bitcoin. kano, you seem to be under the mistaken impression that I am King of Bitcoin.I told you that if you don't like the getmemorypool RPC method, you would need to gain consensus either on the Dev&Tech section of these forums or the bitcoin-dev mailing list. That's how bitcoin works-- rough consensus, not "submit requests to the King" or "petition the Central Committee." This forum is for "Technical discussion about Satoshi's Bitcoin client and the Bitcoin network in general. No third-party sites/clients..."Would Open Transactions discussions be more appropriate in Off-Topic or Alternative Clients ? Hmm?  testnet accepts non-standard transactions today (I've been doing some experiments with multi-sig transactions on the testnet). I just tagged the git tree "v0.5.0rc1". If you are able, please compile and help test.See the INSTALL file at the top of the source tree for instructions on compiling. Binary releases for at least unix and mac should be available in the next day or two (there is a show-stopper bug on Windows, and we could use help from people familiar with cross-compiling using mingw to update the Windows build process).Major bugs you should be aware of:Wallet does not relock on Win32Major changes from version 0.4:Switched from wxWidgets for the GUI to Qt, using Wladimir J. van der Laan's bitcoin-qt. Why? We didn't have any wxWidgets programmers contributing fixes or improvements.New JSON-RPC commands:getmemorypool : alternative to 'getwork' that provides everything needed to construct a block with a custom generation transaction.listsinceblock : Get all transactions in blocks since block [blockid]signmessage/verifymessage : sign/verify a message with a wallet public/private keypairDeprecated JSON-RPC features:'midstate' data item from getwork requestsDeprecated JSON-RPC commands that have been REMOVED:setlabelgetlabelgetaddressesbylabelgetamountreceivedgetallreceivedgetreceivedbylabellistreceivedbylabelRun: git shortlog --no-merges v0.4.0..... to get a complete list of changes, and thanks to everybody who is contributing! Huh?  getmemorypool discussion is/was here:  https://bitcointalk.org/index.php?topic=39088.0I'll just note that I'm damned if I do pull stuff that has some discussion here (and no objections raised), but damned if I don't pull stuff that first had no discussion, and then had a little discussion with some dissent. This is why I don't pull additions or major changes to RPC commands without at least a couple of people looking at them and either saying "yup, that's exactly how I would do it" or "it'd be better if...."I agree with Mike, the -coinbaser <cmd> should be separate from setauxwork.Does setauxwork interact with the new getmemorypool RPC command at all?  Should it?And should there be a listauxwork RPC command? Good news: I'm just about to get a Bitcoin-Qt version 0.5 Release Candidate 1 out, with a much-improved GUI.Bad news: all the translations for the old wxWidgets Bitcoin are obsolete, and the process for making translations is different.Is anybody willing to write new translations?  Here's what you'll need to know:Three translations already exist: de nl and ru.Translations are stored in ".ts" files in the src/qt/locale folderThe 'QT Linguist' tool can be used to create translations... or maybe an online tool like Transifex could/should be used to crowd-source the workAnd is anybody willing to take the job of coordinating translation efforts, figuring out if Transifex is a good tool to use, and writing some documentation to make it easy for people to create and submit new translations? Mmmm.... Twisted....I started defining a BitcoinProtocol class derived from twisted.internet.protocol.Protocol for my cross-implementation at-the-network-level testing project.  I plan on using Twisted and Trial (the Twisted unit testing framework) to feed canned block-chains to "empty" nodes and make sure they Do The Right Thing (reject blocks that violate the blockchain rules or contain invalid transactions, accept blocks that contain weird-but-valid transactions, etc).  https://github.com/gavinandresen/Bitcoin-protocol-test-harness/blob/master/BitcoinClient.pyAnyway, the BitcoinProtocol class might be a good place to start for anybody who wants to do some python-based bitcoin network programming.  Good example to demonstrate is a little dump-blocks tool I wrote to spit out a blockchain in JSON format:  https://github.com/gavinandresen/Bitcoin-protocol-test-harness/blob/master/dumpblocks.py(I'm a Twisted newbie, so improvements, suggestions, etc are very much appreciated) RE: 0-confirmation OP_EVAL transactions:I think I'm doubly-wrong.OP_EVAL transactions are non-standard to old clients, so they are dropped before being added to the memory pool.  Old clients will not relay them, old miners that follow the IsStandard rules won't put them in blocks.When a transaction comes in that depends on a transaction that is not in the block chain or memory pool, it is shunted into the orphan transaction pool, and isn't listed by listtransactions or show up in the GUI until all of its inputs are satisfied.The risk would be a rogue miner putting invalid OP_EVAL transactions into blocks, which would trick old clients into showing transactions that depend on them as 0/ or 1/unconfirmed. RE: "but bitcoin addresses are UGLY and the WRONG way to do it!"Okey dokey.  If I recall correctly, people were saying exactly the same thing about URLs 10 years ago (...google... yup).If your argument is OP_EVAL is possibly insecure... it seems to me it is much easier to reason about the security of OP_EVAL than to reason about the security of URI schemes or schemes for passing around a transaction to be signed or using SIGHASH_ANYONECANPAY.I agree that protocols for passing around either transactions or signatures are needed, I just don't think agreeing on what those protocols aught to be will happen anytime soon (how much you want to bet there will be a protocol buffers versus JSON debate that rages on for at least six months?)RE: writing up a full design doc: I've always admired the IETF's "rough consensus and running code" approach to standards-making, so I'll be happy to write up a full design doc after I've got running code.  Actually trying to IMPLEMENT multisignature transactions has taught me a whole lot about what will work in practice and what won't.Finally, to try (in vain, probably) to focus discussion:  The use cases I care about are:1. A user running bitcoin on a device that gets infected by malware. I want them to be able to subscribe to some service that will provide transaction confirmation for any outgoing bitcoin transactions above a certain amount per day (like my bank does with my ATM card).2. And I want them to be able to have a 'master wallet key' stored in physical form in their safe-deposit box so they can recover their wallet if they forget their passphrase or lose all their backups.OP_EVAL appeals to me because I can see EXACTLY how to make those use-cases work with minor variations to the infrastructure we have today for performing bitcoin payments. He wouldn't have included NOP1 through NOP10, either.I file this under "Satoshi is a genius, part 9,432".  It gives a smooth upgrade path using the same blockchain if ECDSA or SHA256 start to get fragile.Attacking old clients by sending them coins with "will-never-be-satisfied-but-they-can't-tell-that" inputs is a concern-- it is basically the Finney attack, but anybody will be able to try to pull it off and there is no time constraint.However, I think the benefits of being able to send to a truly secure address FAR outweigh the risks, I don't think it will be difficult to get people to upgrade to a newer, more secure client, and accepting 0- or 1-confirmation transactions is always a bad idea.I also think you're exaggerating the impact-- OP_EVAL does not invalidate all of the security review that has been done so far, especially if the scripting language being EVAL'ed is unchanged from what we have today.(PS: the latest git-head QT bitcoin contains a working bitcoin URI handler) In an effort to keep discussion on track, I split the discussion of Lamport versus Bernstein signature schemes into its own thread.So: can anybody think of any potential attacks that would be enabled by having a standard form:Code:DUP HASH160 <scripthash> EQUALVERIFY OP_EVAL... spent by providing:Code:<signatures> <serialized script>The simplest <serialized script> would be <pubkey> CHECKSIG.Things that occur to me or were brought up in the IRC discussion:Denial-of-service if <serialized script> is allowed to contain OP_EVAL.Proposal on the table is to completely disallow recursion, which eliminates that threat.  I'm tempted to allow limited recursion (max 2 levels deep maybe) because it would allow some really cool things to be done in the future....Stealing coins because old miners/clients will not verify the signature hidden inside <serialized script>.If 50+% of the hashing power on the network support OP_EVAL, then transactions that pass the <scripthash> check but fail the signature check inside the <serialized script> would be accepted as valid by old miners and clients, but would fail to confirm because they would be rejected by the majority of miners.That CANNOT be used to trick exchanges or people using old software, because the old software will not recognize the new script form, and will simply ignore the transaction-- you will not get "0/unconfirmed" OP_EVAL transactions displayed in old versions of Bitcoin. Wrong again!  See casacius' excellent response.Creating or modifying <serialized scripts>Maybe there's an attack waiting to happen because an attacker could trigger a buffer overflow bug by doing something like:<safe serialized script>  119 OP_ADD  OP_EVALBut if there is a buffer overflow bug in an implementation's transaction script interpreter, then an attacker can almost certainly just send a "tx" message containing a non-OP_EVAL script that triggers the bug. OP_EVAL certainly does mean one more thing for an implementation to get right, but it isn't actually very hard to implement if you're already able to validate "tx" messages.Any other attacks anybody can think of? If implementations are strict in which transaction forms they'll accept as "valid AND mine (counts towards my wallet balance)", but liberal in what transaction forms they'll accept as "valid, but I can't spend it" then it seems to me the risks are small. ... but isn't it the signatures that give each transaction its unique identity?  I may be wrong, but without the signature hashes I think you can get two different transactions (two transactions that are exactly the same as far as scriptPubKeys, but spend different outputs) that hash to the same value, which would cause all sorts of problems, including replay attacks re-using old signatures.Interesting... too radical a change for right now, in my opinion.  (I think Pieter's proposal is too radical a change for right now, too... I'm on the fence about whether OP_EVAL is too radical a change, but I think the advantages outweigh the risks).Pieter's proposal is <signature+2bits> I voted no because of the fine-print in your original post.I think setworkaux is OK, but I don't like "doesn't work on windows" changes to support one mining pool. Good idea. Who wants to volunteer? I'm too busy... Wow, so many great ideas!RE: There is already code to warn the user if they are on a minority chain more than 6 blocks long-- see GetWarnings():It just warns, it doesn't stop you from generating/sending transactions. Perhaps if the longer fork is more than 120 blocks ahead it should.ByteCoin: we can prevent the scenario you describe (generate a block with a NOP1/EVAL transaction whose validity is different in old and new clients) by:1. Requiring that EVAL transactions be valid if the EVAL is interpreted as a no-op.  New clients can replace EVALs with no-ops and re-evaluate them to make sure that is true.2. Waiting until a majority of hashing power has upgraded before turning on EVAL.gmaxwell:  I really like the idea of implementing key recovery to save space in the block chain. It can also be done in a backwards-compatible way if only CHECKSIGs "hidden inside" of EVALs support it (CHECKSIG would be aware of whether it was being executed inside of an OP_EVAL, and if it was it could use a compressed version of the public key instead of the full public key).All the ideas about figuring out what percentage of miners have upgraded:  seems like that deserves its own discussion thread. First: sorry for conflating the off-by-1 and the asymmetric adjustment issues.  As I said, I haven't taken the time to consider changing the bitcoin difficulty adjustment algorithm (too big a change for too little benefit, in my opinion; if we lose 90% of hashing power in a month then there that is a sign something much more serious is wrong with bitcoin than the difficulty algorithm; speculation on what will happen when the block reward drops seems pointless to me, I don't think we'll know until it happens).Second: I've written 'discourage blocks' infrastructure:  https://github.com/gavinandresen/bitcoin-git/tree/discourageblocks  (code reviews welcome)... which should give us the ability to nudge miners to Do The Right Thing.  Discouraging blocks that appear to be gaming the off-by-one bug should be enough incentive to prevent 50+% cartels from forming, without requiring a blockchain-splitting change. So in an escrow situation all three parties have to exchange public keys and agree on one particular way of putting them together into a Script that they all agree on (so they all agree on the Script's hash).  That seems OK-- the three parties have to exchange public keys before creating any transactions in any case. Fine, then ponder this for a while:  https://bitcointalk.org/index.php?topic=42417.msg517020#msg517020Executive summary:  asymmetric difficulty adjustments and adjustments based on time are really, really hard to get correct.I haven't thought about it hard, but I trust ArtForz when he says he thinks it is IMPOSSIBLE to get it right. He did. He said ArtForz brought them up in the Alternative Currencies board.See this thread for details:  https://bitcointalk.org/index.php?topic=43692.msg521772#msg521772
Summary of a discussion that happened in IRC chat this afternoon:There are 10 no-op opcodes that are explicitly for expansion:  https://github.com/bitcoin/bitcoin/blob/master/src/script.h#L150They are currently enabled, and do nothing.If we did the obvious thing and used one of them for OP_EVAL, then, surprisingly, OP_EVAL would not necessarily cause a block chain split.  Why?Old clients see: Code:<sig> <...serialized script...>  DUP HASH160 <hash> EQUALVERIFY OP_NOP1New clients see: Code:<sig> <...serialized script...>  DUP HASH160 <hash> EQUALVERIFY OP_EVALOld clients will consider the transaction valid as long as <serialized_script> hashes to the correct value and is not OP_FALSE, because a script evaluates as valid if it leaves a non-false value on the top of the stack when it is done.New clients will do full validation: the hash has to be right AND the <serialized script> has to be valid (has to leave a non-false value on the top of the stack).So:  If upgraded clients and miners start producing transactions and blocks with OP_EVAL in them, they will be accepted by old clients and miners as valid.That means OP_EVAL could be supported as soon as 50+% of the network hashing power upgraded, instead of requiring that 100% of the network (clients and miners) upgrade before a certain time or block.Anybody want to volunteer to write a BIP that works through all the details? Bugs can be reported via the github issues system:  https://github.com/bitcoin/bitcoin/issues... although the entire GUI is changing for the next release, so reporting GUI bugs like not being able to sort in the address book will be a waste of time. I agree. Security is really high on the priority list; I'd like to see secured bitcoin addresses in people's forum signatures within a year. I'm sure one of the alternate blockchains will take this idea and run with it, so much of the hammering-out will happen there. I split ByteCoin's OP_EVAL post and followups into it's own thread. RE: be wary of OP_EVAL:Agreed, we need to think hard about whether or not attackers could Do Evil Things like create an innocuous little script that pushed an infinite amount of data onto the stack or something  (lets see... Serialized(<OP_DUP OP_DUP OP_EVAL>) OP_DUP OP_EVAL would do that...).  Disallowing recursion (no OP_EVALs allowed in the OP_EVAL data) would, I think, prevent all of that mischief.RE: OP_EVAL means no more IsStandard:  I agree with ByteCoin.  A ScriptSig would be IsStandard if it's ScriptPubKey was IsStandard, and if it's ScriptPubKey was the generic OP_EVAL form then the last value pushed by the ScriptSig would also have to pass the IsStandard test (deserialized into a Script).RE: data should always be protected by a hash script:  I think the answer is "don't be an idiot" and "use standard transaction types that have been banged on / thought through."RE: sender/recipient negotiating a transaction: I think that may become the most common way of creating a transaction, but I don't think it will ever be the only way. -logtimestamps  command-line param or logtimestamps=1 in the bitcoin.conf file.(I dont' remember when that option was added, a 'git blame util.cpp' will tell you, look for fLogTimestamps) The new QT GUI (in git HEAD) has a nifty block-chain-download-progress indicator.I'd like to pull together a version 0.5 release candidate and start testing it early next week.Maybe the big feature for version 0.6 can be fast initial download (I'm thinking the best thing to do for brand-new, starting-with-an-empty-wallet installations is to download only block headers, function as a 'lightweight' client, and 'backfill' full blocks until you're caught up with the full chain-- then function as a 'full' client). I like OP_EVAL better than BEGIN...ENDDIGEST. I'm going to shoot myself in my foot again thinking about stuff late in the day and week when my brain is tired...... but here are some half-baked thoughts:The:   DUP HASH160 <hash> EQUALVERIFY   that we're currently using to hash a 65-byte public key into a 20-byte bitcoin address could be generalized into something like:n DIGEST160 <hash> EQUALVERIFY  :   create a secure 160-bit hash from the <n> items on the stack, make sure it matches a given hash.That would be very useful for creating multisignature transactions where <hash> is really some arbitrary combination of public keys.But it would be really spiffy if the complicated transaction could be in the ScriptSig (specified when the coins are spent) and not the ScriptPubKey (so the sender doesn't need to know what kind of transaction they're funding).  Maybe something like:ScriptPubKey:  END_DIGEST160 <hash> EQUAL... and the generic ScriptSig would be:<sig1> <sig2> ... <sign> BEGIN_DIGEST160 ... an arbitrary script with public keys and CHECKSIGs and stuff....BEGIN...END_DIGEST160 would create a secure hash for all the opcodes and data between the begin and end.I think I can convince myself that would always be secure.  Concrete example of the simplest, one-key transaction would be:ScriptSig:  <signature>  BEGIN_DIGEST160 <public_key> CHECKSIGVERIFYScriptPubKey: END_DIGEST160 <hash> EQUALNobody can put another Script in the ScriptSig, because that would change <hash>.And the signature must be valid because it is checked in the ScriptSig.If we're going to schedule a blockchain split to support new stuff, something like this seems like the right thing to do. Yes, I want wallet security and backup as soon as possible, so I want transactions that support that functionality relayed and included in blocks as of the 0.5 release, if possible.Current state:  (old news for those of you on the bitcoin-development mailing list)I've made a PULL request for "standard"  (a and b),   (a or b),  (a and b) or c   transactions to eventually support keys split between different devices, wallet backup, and wallet-backup-with-split-keys.  https://github.com/bitcoin/bitcoin/pull/541Supporting lockTime or 2-of-3 escrow transactions or more generic 'standard' transaction in the future is certainly possible. Put together a solid pull request that adds support for relaying/including in blocks, with unit tests and a testing plan and, assuming there's general consensus that what you're proposing is safe and secure and is near the top of the "will make bitcoin better" priority list, it will get pulled. Honestly, I don't think the future of bitcoin is running "heavy" nodes on our personal computers.I think the vast majority of people will be using bitcoin through web or mobile apps in the not-too-distant future. So I'm not personally inclined to put a lot of effort into splitting the node and wallet, unless that makes creating lightweight web and mobile apps easier.That said, the new QT gui does a much, much better job of letting you know what bitcoin is doing, both during initial startup and initial blockchain download. Submit bugs here: https://github.com/bitcoin/bitcoin/issuesAlthough all of the GUI code is being replaced in the next version, so don't bother submitting UI bugs.RE: debugging what bitcoin is doing in the 10 minutes it takes for the window to come up:  tail -f ~/.bitcoin/debug.log... should tell you what it is busy doing.  Probably loading the block chain and reading the wallet (do you have a very large wallet.dat?) Very cool etotheipi.Have you tried using mmap() to page the blockchain file into RAM instead of copying it explicitly? Operating systems are typically very well optimized for accessing mmap()'ed files. I pulled Bitcoin QT into the master branch of https://github.com/bitcoin/bitcoin/ this morning.See doc/readme-qt.rst for instructions on building Bitcoin QT.And I updated doc/build-*.txt; they are now instructions for building bitcoind and don't mention wxwidgets at all.There are still loose ends to tie up, like modifying the build scripts and the windows installer; I hope to tie those up in the next week or so, and have a release candidate for a version 0.5 available soon. I pulled Bitcoin-QT into the main bitcoin tree this morning. Encouraging people to expose their private keys makes me nervous. They're "private" for a reason, and it seems to me the vast majority of private keys will, a few years from now, either be stored on a secure device which is designed to never reveal them or will be split.Why would a merchant "wish to accept typed or scanned Bitcoin private keys as payment" ? They're going to generate a transaction immediately anyway, it seems to me making a payment that way just opens up more potential ways of getting defrauded (e.g. merchant keeps the private key in case more bitcoins are ever sent to the same address, or merchant sends change to the same address and then a few days later uses the private key to take back the change).I don't see any privacy or transaction-fee-saving advantages, either; am I missing something?(I do see the usefulness of importing private keys into your wallet, that's a different feature that I'd like to be in the next release). I seem to recall (but am too lazy to look up) some interesting research on the gini coefficient for subgroups in the United States; if I recall correctly (and it is very likely I don't), Scandinavian Americans as-a-group have a lower gini coefficient than Scandinavians.That is either evidence for economic oppression of underprivileged groups in the US, or evidence that culture matters when it comes to economic success, depending on whether you're left-leaning or right-leaning. A real crash.In a perfect world, Bitcoin version 0.1 would have included code that looked for a "Bitcoin version X or later required to read this wallet.dat file" setting, and notify the user and exit cleanly if X is greater than the version you're running.We don't live in a perfect world.So the second-best solution was to have version 0.4 and later do the "Bitcoin version X or later required to read this wallet.dat file" thing.  And write a value into the wallet that causes previous versions of bitcoin to crash on startup.If previous versions didn't crash when given an encrypted wallet, they'd just ignore the encrypted keys, generate a bunch of new, unencrypted keys, and give people heart attacks when they ran the old version of bitcoin and told them they had a 0 bitcoin balance. There is not a donation address for the whole development team; if there was, somebody would have to be in charge of keeping track of the bitcoins, deciding what they should be spent on, etc.I don't want to be that somebody....If you like the wallet encryption feature, send bitcoins to:  Matt Corallo :  1JBMattRztKDF2KRS3vhjJXA7h47NEsn2cand Jeff Garzik : 1BrufViLKnSWtuWGkryPsKsxonV2NQ7TcjMatt (aka "BlueMatt" in IRC) did the hard work of making wallet encryption happen, and deserves a ton of credit for being persistent and reworking his Jeff's initial implementation a few times based on feedback and suggestions.Gregory Maxwell ('gmaxwell') also deserves credit and donations, he gave a lot of feedback and did a lot of testing:  gmaxwell : 1LjPAUKf23kDBy9sLJbiLfsvjde3ZdHcbJ(corrected to give Jeff credit for the initial implementation-- sorry Jeff!) More details are in the doc/README file in the tree:  https://github.com/bitcoin/bitcoin/blob/master/doc/README#L70
I've been wondering about that-- is it possible to write a password cracker that generates all the lower-entropy passwords first?That's the kind of theoretical computer science problem that it seems like should have an answer, or have a proof that it is equivalent to the halting problem. Well, CPUs are easy-to-program general purpose hardware that can do lots of things (and several things at the same time, in these days of multicore CPUs) pretty darn fast.GPUs are hard-to-program more-specialized hardware. These days they can do pretty much any raw calculation a CPU can do, faster-- it just takes a lot more effort on the programmer's part to figure out how. That extra effort is only worthwhile for the most performance-critical code.When I worked at Silicon Graphics I saw several interesting algorithms implemented using OpenGL operations reading and writing to texture memory and/or the accumulation buffer and/or the framebuffer. That was before OpenCL and GPU programming languages, but the experience gave me a lot of respect for the ability of good programmers to look at problems sideways and come up with ... interesting ... solutions. The 'open' command is the best way to run Bitcoin.app from the command line:Code:open /Applications/Bitcoin.app --args -datadir=/Volumes/Bitcoin Oh, forgot to add:  Thanks to everybody who helped out! Bitcoin version 0.4.0 is now available for download at:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.0/The main feature in this release is wallet private key encryption;you can set a passphrase that must be entered before sending coins.See below for more information; if you decide to encrypt your wallet,WRITE DOWN YOUR PASSPHRASE AND PUT IT IN A SECURE LOCATION. If youforget or lose your wallet passphrase, you lose your bitcoins.Previous versions of bitcoin are unable to read encrypted wallets,and will crash on startup if the wallet is encrypted.Also note: bitcoin version 0.4 uses a newer version of Berkeley DB(bdb version 4.8) than previous versions (bdb 4.7). If you upgradeto version 0.4 and then revert back to an earlier version of bitcointhe it may be unable to start because bdb 4.7 cannot read bdb 4.8"log" files.Notable bug fixes from version 0.3.24:--------------------------------------Fix several bitcoin-becomes-unresponsive bugs due to multithreadingdeadlocks.Optimize database writes for large (lots of inputs) transactions(fixes a potential denial-of-service attack)Wallet Encryption-----------------Bitcoin supports native wallet encryption so that people who steal yourwallet file don't automatically get access to all of your Bitcoins.In order to enable this feature, choose "Encrypt Wallet" from theOptions menu.  You will be prompted to enter a passphrase, whichwill be used as the key to encrypt your wallet and will be neededevery time you wish to send Bitcoins.  If you lose this passphrase,you will lose access to spend all of the bitcoins in your wallet,no one, not even the Bitcoin developers can recover your Bitcoins.This means you are responsible for your own security, store yourpassphrase in a secure location and do not forget it.Remember that the encryption built into bitcoin only encrypts theactual keys which are required to send your bitcoins, not the fullwallet.  This means that someone who steals your wallet file willbe able to see all the addresses which belong to you, as well as therelevant transactions, you are only protected from someone spendingyour coins.It is recommended that you backup your wallet file before youencrypt your wallet.  To do this, close the Bitcoin client andcopy the wallet.dat file from ~/.bitcoin/ on Linux, /Users/(username)/Application Support/Bitcoin/ on Mac OSX, and %APPDATA%/Bitcoin/on Windows (that is /Users/(user name)/AppData/Roaming/Bitcoin onWindows Vista and 7 and /Documents and Settings/(user name)/ApplicationData/Bitcoin on Windows XP).  Once you have copied that file to asafe location, reopen the Bitcoin client and Encrypt your wallet.If everything goes fine, delete the backup and enjoy your encryptedwallet.  Note that once you encrypt your wallet, you will never beable to go back to a version of the Bitcoin client older than 0.4.Keep in mind that you are always responsible for your own security.All it takes is a slightly more advanced wallet-stealing trojan whichinstalls a keylogger to steal your wallet passphrase as you enter itin addition to your wallet file and you have lost all your Bitcoins.Wallet encryption cannot keep you safe if you do not practicegood security, such as running up-to-date antivirus software, onlyentering your wallet passphrase in the Bitcoin client and using thesame passphrase only as your wallet passphrase.See the doc/README file in the bitcoin source for technical detailsof wallet encryption.Signed SHA1 checksums of the binary release files:-----BEGIN PGP SIGNED MESSAGE-----Hash: SHA125c3ec9683d62235afea24d4a147d4616d8a884f  bitcoin-0.4.0-linux.tar.gza800d9fa4aa61527e598708f4ace7f855c22a46b  bitcoin-0.4.0-macosx.dmg1d2c8d82ede5e8aa9f83b59da07e443de89c5c8f  bitcoin-0.4.0-src.tar.gzecf1304ff467bd30dc668b3dadff3044c3c86df1  bitcoin-0.4.0-win32-setup.exe6034efe23e4bd76b0860f633e81710cd66d499db  bitcoin-0.4.0-win32.zip-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)iEYEARECAAYFAk58n20ACgkQdYgkL74406ibEACgzyZj86lsQORi5HTs/N3ABCesPg8AoKFXU1vxiZI9qZOQ5ZET60ewcynW=sY+Q-----END PGP SIGNATURE-----Full changelog ("git shortlog --no-merges v0.3.24..")-----------------------------------------Abraham Jewowich (1):      Fix bug with accessing vchData[0] when vchData is empty.     Fix typo in CBase58Data::CompareToAlex B (2):      Romanian translation added      Spanish translation updateAlex Waters (1):      Updated readme fileDaniel Folkinshteyn (1):      Update the list of seednodes.Dawid Spiechowicz (1):      added polish wallet encryption messagesDean Lee (1):      Update to the Chinese Simp translationDev Random (4):      Linux gitian config with separate wxWidgets build      Mingw gitian with separate wxWidgets and boost      Mingw gitian build with deterministic bitcoin.exe by use of faketime      Add Gitian Build descriptors for Boost and wxWidgets.Doug Huff (1):      Make mlock() and munlock() portable to systems that require the address to be on a page boundary.Dylan Noblesmith (1):      mlock() all private keys in memoryEric Hosmer (1):      Added crypter to makefile.vc.Fabian H jr. (1):      Updated checkpoints, maybe Tx fee should be reduced to 0.0001 from 0.0005 and maximum minimum tx should be 0.0010.Gavin Andresen (24):      Do-nothing MapPort() ifndef USE_UPNP.  fixes #450      Don't std::advance past beginning of transactions array.  Fixes #465      Remove unused ScanMessageStart function      Compile with DEBUG_LOCKORDER to detect inconsistent lock orderings that can cause deadlocks      CHECKMULTISIG unit tests.      Highlight mis-matching locks      Fix rpc-hanging deadlocks      Fixed potential deadlocks in GUI code.     Also changed semantics of CWalletTx::GetTxTime(); now always returns the time the transaction was received by this node, not the average block time.     And added information about -DDEBUG_LOCKORDER to coding.txt.      Fix typo ("you own security")      SetCrypted() obtains keystore lock, to be safe.      Logic running with -keypool=0 was wrong (empty keys were being returned). Fixes #445      Fix RPC call name in error message.      obtain cs_wallet mutex to protect vchDefaultKey      Fixed regression I introduced: wallets with lots of transactions were unusable in GUI.      Fix bad merge: getaccountaddress was broken for new accounts      Give hard-coded seed nodes a random last-seen time, to randomize order they're tried.      Do not try to download blockchain from 0.3.23 nodes      If compiled -DDEBUG_LOCKORDER and run with -debug, print out every mutex lock/unlock (helpful for debugging something-is-holding-a-mutex-too-long problems)      Stay connected to seed nodes; disconnecting causes problems if you are trying to make the initial blockchain download.      Versions 0.3.20 THROUGH 0.3.23 have trouble with blockchain downloads; avoid them      Bumped version numbers to 0.4.0rc1      Optimize database writes for transactions with lots of TxIns.     Patch from ArtForz, who discovered the problem.      Fix AddAddress cs_mapaddresses/db transaction deadlock      Fix QA email addressGiel van Schijndel (15):      fix warning on 64bit systems: cast to pointer from integer of different size [-Wint-to-pointer-cast]      fix warnings: expression result unused [-Wunused-value]      fix warnings: using the result of an assignment as a condition without parentheses [-Wparentheses]      fix warning: comparison of unsigned expression < 0 is always false [-Wtautological-compare]      fix warning: X enumeration values not handled in switch [-Wswitch-enum]      fix warning: unused variable 'X' [-Wunused-variable]      fix warning: unused function 'SigIllHandlerSSE2' [-Wunused-function]      fix warning: variable nMinDepth set but not used [-Wunused-but-set-variable]      fix warning: control reaches end of non-void function [-Wreturn-type]      Make some global variables less-global (static)      Cleanup makefiles such that diffs to them are smaller      Move func 'REF' from util.h to serialize.h      Start moving protocol-specific code to protocol.[ch]pp      Move CAddress to protocol.[ch]pp      Move CInv to protocol.[ch]ppHan Lin Yap (2):      Comment "deprecated"      Add a note to only include .po fileJay Weisskopf (4):      Add logos/branding currently found on bitcoin.org into NSIS installer.      Set default compression for NSIS installer to LZMA.      Remove NSIS branding from bottom divider.      Increase resolution of Windows icon.Jeff Garzik (8):      Update CWallet::LoadWallet for proper return type.      Bump version to 0.3.25      doc/README: word wrap into something readable      CAddrDB::LoadAddresses: properly initialize CAddress      src/makefile.unix: remove -DFOURWAYSSE2      Add reference python miner, in contrib/pyminer/      README.md: word wrap text file      Revert "Define MSG_NOSIGNAL to 0 on platforms where it is unavailable."Jeroenz0r (1):      Translation from "Open Bitcoin" to "Verstuur Bitcoins"JoelKatz (1):      Fix UNIX-specific thread handle leak.Johannes Henninger (1):      Identify as "Bitcoin + version number" when mapping UPnP portLuke Dashjr (7):      Update nTime after nExtraNonce to avoid potential race     (extraNonce being reset due to just-occurred time change after nTime is set)      Reset extraNonce only every 15 seconds, just in case some miner is updating time himself and stuff      Reset extraNonce only when prevBlock changes, so miners can continue updating the time on their work until it's stale      Support for boost filesystem version 3      ignore stuff      Save coinbase, not just extraNonce      Bugfix: Use timestamp in coinbase rather than "bits", needed to ensure coinbase txn is unique even if address is the sameMatt Corallo (35):      Add minversion to wallet.      Add wallet privkey encryption.      Set the number of SHA512 rounds based on the speed of the computer.      Push unlocked_until in getinfo.      Dynamically remove/insert the Options for encryption in the menus.      Add the walletlock RPC method to lock the wallet manually.      Add Wallet Encryption section to README      Use DB Transactions when encrypting wallet.     This speeds up the encryption process significantly.      Make an invalid addrIncoming so that old clients crash.      Update makefile.linux-mingw to work with crypter and UPnP fix.      Fix makefile.linux-mingw      Fix crashes when a wallet is locked and GetReservedKey() is called      Generate Warning when using default key.      Fix Build in GetReservedKey() in wallet.cpp      Fix bad return values in LoadWallet.      Actually use mapAlreadyAskedFor.      Fix EncryptKeys crash introduced by a9ba4710, identified by TD.      Check for duplicate txins in CheckTransaction.      Make it clear that setting proxy requires restart to fully apply.      Don't listen if on TOR (resolves #441).      Add missing include to serialize.h      Add file for transaction tests.      Cleanup test suite output to be more useful.      Unify copyright notices.      Missed a 'password' should be 'passphrase'.      Fix incorrect RPC error messages      Add specific wallet encryption details to doc/README      Upgrade dependancies and tweak build process.      Update binary mos to latest translations.      Fix build process to actually work.      Add binary mo for new translation.      Update gitian build descriptors to produce proper builds.      Update bitcoin icon to make nsis setup exe deterministic.      Update binary mo to match latest po translation.      Restructure gitian files and add download config files.Michael Bemmerl (4):      Basically some grammatical fixes of the German translation.      Added German wallet encryption messages translation.      Changed Russian translation according to comment in issue 395      Updated German translationMichal Zima (1):      Updated czech translationNils Schneider (2):      log low-level network messages only when fDebug is set      missed printf in AbortMessage(); merged printfs in EndMessagePatrick Varilly (1):      Single DB transaction for all addresses in a messagePieter Wuille (11):      Prepare codebase for Encrypted Keys.      Do not use obsolete CPrivKey for passing keys around      Bugfix: add autogenerated addresses to address book      get rid of mapPubKeys      Use CBitcoinAddress instead of string/uint160      split off CBase58Data from CBitcoinAddress      Fix for small change outputs      Bugfix: don't overuse limited ExtractAddress      avoid strAddress + validity checks      SocketHandler thread can be detached      Updated dutch translationStéphane Gimenez (1):      Single DB transaction for addresses from DNS seedsVegard Nossum (6):      Add missing includes to key.h      Add missing include to script.h      Add missing includes to net.h      Fix testing setup      Add prototype for EvalScript() to script.h      Add a file for script testsVenkatesh Srinivas (4):      Test for SO_NOSIGPIPE rather than assuming all BSDs support it.      Qualify make_tuple with boost:: namespace.      Use 'unsigned char' rather than 'char' for pchMessageStart.      Define MSG_NOSIGNAL to 0 on platforms where it is unavailable.Wladimir J. van der Laan (2):      remove magic number: change threshold for nLockTime to constant      make SetHash160 return a value (as specified in the function signature)cjdelisle (1):      wxWidgets needs to be at least version 2.9.1 because wallet crypto uses ToStdString() which is not in 2.9.0ovdeathiam (1):      Edited locale/pl/LC_MESSAGES/bitcoin.po via GitHub I split this from "Be Safe" thread in Alternate Cryptocurrencies, and moved it here so more people could voice their opinions. RE: a be-safe thread for bitcoin:  There are already a couple "be safe" threads stickied in the Bitcoin Discussion forum (e.g. the beware of trojan wallet stealers thread, the newbies article that links to keep-your-wallet-safe, etc).Writing a more general one is not a bad idea; if I knew last November all the craziness that would happen this year I would have written one back then (but back then nobody was spending tens of thousands of dollars speculating on bitcoin).RE: putting my employer in my forum signature:  what do other people think? Would that be unfair advertising for TruCoin or good full disclosure?If it drives more business to TruCoin then that will eventually, hopefully, mean more money in my pocket, so if it is up to me heck yeah I'll mention TruCoin in my signature! I like the idea of trying to prove that the DoS code doesn't increase the chance of network fragmentation.The DoS countermeasures should be careful not to penalize or ban peers for any messages that the client will (or might, in another situation) relay.For example, double-spent transactions don't trigger the DoS countermeasure code.That should be sufficient to prevent split-the-network attacks; if an attacker wants to try to split the network, the only way the attacker would be successful is if it could somehow send messages to peers that ARE relayed and trigger disconnections elsewhere in the network.Looking through the patch:  https://github.com/bitcoin/bitcoin/pull/517/files... I see a couple of cases where relayed messages are penalized (block times too far off, and hitting the free transaction relay limit).  To be safe, I'll remove them.As for relaying block headers for banned peers:  "banned" means "if you try to connect to me I'll simply drop the connection attempt." I feel strongly that is the correct behavior; the motivation for the DoS prevention code is to "whitelist" peer behavior, and try to prevent possible 0-day attacks like "if I send you THIS invalid transactions followed by THAT sequence of weird bytes followed by THIS corrupted block header THEN I trigger an obscure bug in the version of OpenSSL that you're running and compromise your machine...." Pronounced "barfy"  GPUs suck at accessing main memory.But they're very, very good at accessing on-board memory.  See, for example (from a couple of years ago) http://blog.cudachess.org/2009/07/cpu-vs-cuda-gpu-memory-bandwidth/I predict it'll take... mmm... 3 weeks after source code is released for the first faster-on-a-GPU solidcoin 2.0 closed-source miner to come out.  8 weeks until there's an open-source one available.But my predictions are often wrong. There's been a little discussion on the bitcoin-dev mailing list.I think it is a great idea, but "BEP" is the wrong name (because there are already BitTorrent Enhancement Proposals). No.Why not? I don't remember. Why would you want to un-encrypt it?  (I ask because if you want to save an unencrypted backup then maybe a better feature would be "backup wallet" with an option to backup encrypted or unencrytped) Status of the multisig proposal:  There are two, a stripped-down, simplified one:  https://gist.github.com/39158239e36f6af69d6f... and a supports-more-use-cases-but-is-more-complicated one:  https://gist.github.com/dba89537d352d591eb36 RE: long delay, no window on startup:  will be made much better by the QT splash screens in bitcoin 0.5.RE: lots of GUI bugs: whole rafts of wxwidgets-related bugs will go away with the switch to QT in bitcoin 0.5.RE: incompatible on older version of windows: I don't know nuthin about windows compatibility, somebody want to volunteer to investigate?  Is bitcoin 0.4 less compatible for some reason than 0.3.24 was?  (shouldn't be...) Linux and Windows and Mac binaries are available at sourceforge:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.4.0/test/And HTTPS download from the Amazon Cloudfront content distribution network: https://d24z2fz21y4fag.cloudfront.net/downloads/bitcoin/bitcoin/bitcoin-0.4rc2-win32-setup.exe https://d24z2fz21y4fag.cloudfront.net/downloads/bitcoin/bitcoin/bitcoin-0.4rc2-win32.zip https://d24z2fz21y4fag.cloudfront.net/downloads/bitcoin/bitcoin/bitcoin-0.4rc2-macosx.dmg https://d24z2fz21y4fag.cloudfront.net/downloads/bitcoin/bitcoin/bitcoin-0.4rc2-linux.tar.gzThe d24z.... downloads are an experiment; I like that they're https, I don't like the obscure d24z... URL (that's actually github's CloudFront id; I asked, and they have no objections to linking directly to the https version of the downloads).Executive summary release notes:The main feature in this release is wallet private key encryption;you can set a passphrase that must be entered before sending coins.See below for more information; if you decide to encrypt your wallet,WRITE DOWN YOUR PASSPHRASE AND PUT IT IN A SECURE LOCATION. If youforget or lose your wallet passphrase, you lose your bitcoins.Previous versions of bitcoin are unable to read encrypted wallets,and will crash on startup if the wallet is encrypted.Also note: bitcoin version 0.4 uses a newer version of Berkeley DB(bdb version 4.8) than previous versions (bdb 4.7). If you upgradeto version 0.4 and then revert back to an earlier version of bitcointhe it may be unable to start because bdb 4.7 cannot read bdb 4.8"log" files. No.There are 1,461,501,637,330,902,918,203,684,832,716,283,019,655,932,542,976 possible bitcoin addresses.If your calculator can handle numbers that big, you can play around with how long it would take to try generate one quadrillionth of them if you could generate a trillion per second.(I get an answer of a bit over 46 trillion years) sendfrom needs the minconf to know if it should fail because of too few confirmed coins in the account.move used to need minconf for essentially the same reason, but as of (some release in the past) it always succeeds.E.g. if account A has 5 0-confirmation bitcoins and 5 1-confirmation bitcoins then:  move "A" "B" 10... used to fail, because A's 1-confirmation balance was only 5.Now it will succeed, giving it a -5 one-confirmation balance.  move "A" "B" 100 will also now always succeed, making A's balance go negative. 0.4.0 : Out real soon (0.4.0 release candidate 2 binaries are available on sourceforge now)0.4.1 : I'd give about a 80% chance of happening (major bug or security problem found in 0.4.0)0.4.2 : I'd give about a 20% chance of happening (major bug or security problem found in 0.4.1)0.5.0 : Will be the Qt release.Beyond that...  who knows? RE: cannot act as a RPC client:I believe it will still be able to act as a RPC server.So you can run the GUI with the -server switch, but you'll have to talk to it using (for example)  bitcoind getinfo... as opposed to today, where you can run "bitcoin -server" to get the GUI and then run "bitcoin getinfo" to talk to the running GUI process.RE: why switch:  because no wxwidgets programmers stepped up and made it better.  And from what I can see, QT is more popular and supported (so there are more programmers able and willing to help improve).RE: screen shots:  See the bitcoin-qt thread in the Alternative Clients sub-forum here. So the plan is for the next release of bitcoin to switch from the wxWidgets GUI we have now to the vastly nicer QT GUI that John Smith created.I spent some time yesterday compiling Qt and bitcoin-qt, and some time this morning doing a very quick code review (executive summary: looks great!).I'm mostly posting this as a brain dump of "stuff not to forget" when it is time to pull QT and remove WX.Major behavioral differences I noticed during code review:Does not generate new receiving addresses automatically (good idea, I think, but may be controversial).Cannot act as a rpc client (ok with me, we'll still compile/ship a headless bitcoind)Will-need-to-be-done stuff:Find and replace or remove references to wxwidgets in documentation, makefiles, etc.Change makefiles to track rpc.cpp --> bitcoinrpc.cpp name changesThe QT library is LGPGL licensed; do we need to change READMEs or other files?... and probably a bunch of other little things I didn't notice or I forgot to write down.
When did it happen:  I made time to fix it a few days ago. Please don't spread misinformation.I agreed to join TruCoin a couple of months ago, because I knew Eric (chaord) and Chris (cbrunner) through these forums and I think their vision and experience give TruCoin a really good chance of being an important company in the bitcoin economy.And they hired me because TruCoin won't go anywhere if core bitcoin falls apart. I will (and have) mostly be working on core bitcoin issues, jumping in and writing code that I think is critically needed that nobody else is stepping up to write and working to make bitcoin as stable and secure as possible.If Eric and Chris tell me to do something that is bad for bitcoin, I'll let them know what I think. If they suddenly lose their minds and stop listening, then I'll quit.If I lose my mind and start doing things that are bad for bitcoin as a whole (or if I start trying to do things to bitcoin-core that benefit TruCoin over everybody else), then you-all should fire me. Relevant discussion on the bitcoin-dev mailing list is here:  http://sourceforge.net/mailarchive/message.php?msg_id=28082081 A Radeon 6990 has 4 gigabytes of ram.If the task is "find a number that bcrypts/scrypts to less than a given hash target," I don't see anything that would stop a GPU programmer from implementing bcrypt/scrypt on the CPU and parallelizing at the try-different-nonces level.Maybe I'm missing something; I'm probably biased because I worked at SGI from 1988 to 1996 and saw first-hand the evolution of GPUs from very-special-purpose chips with very limited memory to very-general-purpose vector-processing pipelines with very fast access to lots of memory. I think it would be wise for any alternative block-chain to discourage creation of exchanges for at least a month or three to get the bugs out.That should also help build trust that the alternative chain developers/promoters aren't just trying to make some quick BTC. Non-standard transactions are allowed-by-default on the test network. So people can test things out.They are "discouraged-by-default" on the main network (discouraged means not relayed to peers, and not included in blocks by the default mining code).I think etotheipi is right: last I heard, Eligius was the only mining pool with different rules for non-standard transactions. RE: where in the code:  script.cppCode:static const size_t nMaxNumSize = 4;CBigNum CastToBigNum(const valtype& vch){    if (vch.size() > nMaxNumSize)        throw runtime_error("CastToBigNum() : overflow");    // Get rid of extra leading zeros                                                                                                                     return CBigNum(CBigNum(vch).getvch());}... and all of the arithmetic binary ops do a CastToBigNum()nMaxNumSize = 4 means numbers added must be 32-bits or less.RE: simpler version being redeemed by anybody by rewriting:  D'oh!  Right, definitely need a signature so the transaction can't be modified between being broadcast and being included in a block.  I'll remove it from the wiki page. RE: hidden recipient address:I dug deeper into the Script OPs when working on the multisig proposal, and OP_ADD can't add bignums, so the 'hidden recipient' script won't work.A simpler version would, though; I'll update the wiki. The testnet has suffered rewrite-the-block-chain-with-more-hashing-power attacks.It does bad things to your wallet, if your wallet contains transactions that depend on previously mined but now-no-longer-valid blocks. I suspect it will cause lots of heartburn for exchanges; this patch from sipa (which hasn't been extensively tested because long block-chain re-orgs on the main chain are not an issue) might help:  https://github.com/bitcoin/bitcoin/pull/195Alternatively, removing all the wtx wallet transactions stored in the wallet and then running with -rescan should get back to a sane state.  Although an exchange may very well find customers end up with negative balances after doing that, and customers will likely be upset that their balances are likely to change from what they think they have if they've deposited invalid-under-the-new-chain transactions.Successfully bootstrapping an alternative chain starting from a low difficulty, given that there are people with lots of potential hashing power and the willingness to mess around with the chain "just because they can," seems like a hard problem to me, although if people were willing to accept some centralization until hashing power got to a "safe" level it could be solved by a central authority publishing block-chain checkpoints every X blocks. Hi Jeremy! The yoursway create-dmg script had the same problem.I changed the approach to using a "template" .dmg file, as described here:  http://digital-sushi.org/entry/how-to-create-a-disk-image-installer-for-apple-mac-os-x/The .dmg includes Bitcoin.app, a compiled bitcoind daemon, and the source code .zipped up. As an experiment, I've uploaded a Mac .dmg disk image with 0.4rc2 binaries to:  https://github.com/downloads/bitcoin/bitcoin/I'd like to switch from sourceforge to github for binary release downloads, because sourceforge doesn't support https for downloads.Help improving the script I used to create the .dmg file would be most appreciated; see this branch for what I done did:  https://github.com/gavinandresen/bitcoin-git/commits/osx_dmgFor some reason setting the "Drag and drop to install" background image isn't working...shasum checksum is: 6621bdb82fd4520f6efcb87f489e47a587d8915f  Bitcoin.dmgFixed.  New shasum checksum is: c86229b4c973da2207f516962804958424e94e08  Bitcoin.dmg They won't lose any money to fees, because they won't broadcast their transactions-to-self, they'll just include them in blocks that they create.So, evil miner does:Gets some myselfcoins.Creates transactions that pays themselves the myselfcoins, and pays BIG fees.Does NOT broadcast those transactions.... eventually mines a block that contains those transactions (they're a miner, they can put whatever transactions they like in their blocks).Then does that again and again, re-using the same coins, getting richer and richer from the FEES+10% I haven't seen anybody post about what would be my biggest worry if I were trying out alternative block chains. I realize this may be perceived as "Gavin is FUD'ding anything that isn't bitcoin!"  (FUD == Fear, Uncertainty and Doubt)  But I think some of you might be forgetting some basic computer security fundamentals in the excitement to be early adopters.When I first heard about bitcoin, my questions were:1) Can it possibly work (do the ideas for how it works make sense)?2) Is it a scam?3) If it is not a scam, could it open my computer up to viruses/trojans if I run it?I answered those questions by:1) Reading and understanding Satoshi's whitepaper.  Then thinking about it for a day or two and reading it again.2) Finding out everything I could about the project.  I read every forum thread here (there were probably under a hundred threads back then) and read Satoshi's initial postings on the crypto mailing list.3) Downloaded and skimmed the source code to see if it looked vulnerable to buffer overflow or other remotely exploitable attacks.If I were going to experiment with an alternative block-chain, I'd go through the same process again. But I'm an old conservative fuddy-duddy.If you want to take a risk on a brand-new alternative block-chain, I'd strongly suggest that you:1) Run the software in a virtual machine or on a machine that doesn't contain anything valuable.2) Don't invest more money or time than you can afford to lose.3) Use a different passphrase at every exchange site. 0.3.24 Linux/Windows releases weren't built on EC2, but was built on 'gitian' virtual machines (lookup trusted build process here for more info, or get in touch with devrandom). Very nice bitrick!By the way, this patch speeds up initial download quite a lot:  https://github.com/gavinandresen/bitcoin-git/commit/042a619709fab1329e8286c6aedbb2cdc8eb3497...as do these, which have already been pulled into git head:  https://github.com/bitcoin/bitcoin/commit/fb45259967032d409bca4d542b55414a7c522fba  https://github.com/bitcoin/bitcoin/commit/ec74e8a44338202bfb82faa2cef4611cc37e7fa5 I think everybody would like to merge bitcoin-qt as soon as the 0.4 release is shipped (see the bitcoin-dev mailing list for the current known bugs).Closing the dozens of wxWidgets-related GUI bugs in the issues list will give me great pleasure... Y'all probably want this:  https://github.com/bitcoin/bitcoin/pull/491However, I don't think you can fix all the problems that a fixed transaction fee cause; the real problem is that basic economics says that you need to let the price of a scare resource change, ideally in a market, to match the underlying real costs.(bitcoin's fee structure isn't right either, and fixing it to create a market between miners and clients is high on the TODO list) Good idea.The developers listed on bitcoin.org are the people who have 'push' rights to the github source tree, but I like the git approach.Who wants to volunteer to make it happen? Optimizing the accounts code to add a berkeley db index table that indexed wallet transactions by account, and that cached account balances (and invalidated or updated the cache on receive/send) shouldn't be terribly hard for somebody who already knows c++ and berkeley db.It is not on my short-term TODO list because there are too many other higher priority things on my TODO list, but a nice clean well-tested upward-compatible patch would be most welcome.PS:  for ClearCoin, I used the "bitcoind keeps track of the bitcoins" architecture, and I never regretted it-- no problems with synchronization, less possibility for MtGox-like hacks that create mythical bitcoin balances out of thin air by adding an entry to a database.
+1 No hard limits, but the bitcoind "accounts" code hasn't been optimized for that.  For example, computing an account's balance loops through all transactions in the wallet, so will take an increasing amount of time the more transactions you have in the wallet. I got a copy, too.  If you use gmail, use the 'Report phishing' function (in the Reply drop-down menu). Those are "Proposal 1" -- enabling all the 'plain-old' OP_CHECKMULTISIG transactions.groffer reports finding a bug in CHECKMULTISIG (pops too many items off the stack), which makes me wonder if it would be better to avoid it. For small n, using CHECKSIG multiple times is straightforward and doesn't make the transactions much larger.The (a and b) OR c transaction with public keys instead of addresses isn't in the proposal, but for consistency's sake I agree it should be. My worry is that we'll schedule a blockchain split 6 months from now, and between now and then somebody implements a secure, way-cool, everybody-decides-to-use, way to use your email address as a bitcoin address.So my receiving address is 'gavinandresen@gmail.com' and suddenly all the arguing over length of the bitcoin addresses used behind the scenes was just a huge waste of time.I'm as guilty of doing stuff like that as the next geek-- I can get so focused on one little bit of a problem I don't even realize solving a larger problem makes the whole issue go away.  Slap me upside the head if you see me going down that path... Phew.  Ok, I feel better; consensus seems to be that enabling some or all of the proposed 'new standard' transactions is a good idea.All the rest (new address format?  send to old addresses and immediately resend?  etc etc etc) can be argued to death later. Because I want to enable these features reasonably soon, and modifying the way CHECKSIG works means a blockchain fork for clients that haven't upgraded.  Which means giving at least 6 months notice to give everybody time to upgrade their clients.At some point that will make sense, but with what I'm proposing it is not necessary. When SHA3 is finalized or a weakness is found in ECDSA or SHA256 maybe it'll be time to do that... I uploaded a PDF file of my slides here:  http://skypaint.com/bitcoin/DevDirection.pdf Clients could make c the base for a deterministic key; derive a series of keys from c, and use them in subsequent transactions.  (given full public key for c, you can derive a series of public keys without having the private key)Same could be done for the 'wallet protection service' key b -- every time you use b, contact the protection service and ask for a b' derived deterministically from b.  Then b'', b''', etc... The multi-device use-case I'm imagining:I sign up with Acme Bitcoin Security Solutions, Inc.  They give me a WalletProtection public key (or bitcoin address, doesn't matter) and a unique-for-me URL.  I put the address/pubkey into my bitcoin client as "Second factor off-device Send Authentication." Or something.(ABBS also sends me the private key in the mail and tells me to keep it safe in case they go out of business)Now I want all coins sent to me to require signatures from keys in my wallet AND the ABBS key to spend.What bitcoin address do I give to people so that all coins going into my wallet have that property?If it is raw CHECKMULTISIG, then I need to give out addresses containing 2 full public keys.  Which would be 186 characters in base58 and look something like this:LeFKX5Uhue9B4bVNqFouRdH9xyJ4uVksV16Gc3v5Kov6SEtyUmKmF3j582VHcmhKGEfBXvrft6SHAq4 SQPw5kbGryZj4aGqZKGFSPsotRJvrmQXCT8qZ2LZd3KyxFLDt1rsBx2uisukHPvBnyCpbyVdgNhyQYn z3Cf4oakK9Rm6oxFHwjHxHnnbdW3Using 20-byte hashes and the more complicated 2-of-2 transaction i'm proposing, the address is a more reasonable 61 chars:2SEe6qhJ11baZfpk9qXt3gfz3qAgFj4BMc2FXh9ojoBoLU4GAhft1hJAb5TAK You're right, I think even without blockexplorer Satoshi would've added the IsStandard() check.  There were a series of "oops, didn't think of that" moments that pushed him to disable a bunch, tighten up some requirements on existing opcodes, and add IsStandard().In general, I believe in "whitelisting" instead of "blacklisting" to try to prevent harm. Enable functionality that you can prove (or convince yourself beyond a reasonable doubt) will not cause problems. I'm strongly influenced from watching web content systems that fail repeatedly trying to detect malicious HTML or CSS.RE: allow non-standard transactions but give them a very low priority so they take a very long time to confirm:  I like that idea.  I'll have to think a little more about possible unintended consequences (will they tend to fill up transaction memory pools and crowd out low-priority standard transactions?  Do they need their own memory-limited pool?  etc)The intent was always to relax the rules when SPV/headers-only mode was implemented and non-mining clients didn't need to download the entire block chain.  However, nobody tackled that work (it is on my TODO list, right after I tackle some testing framework work). Sunday at the bitcoin conference I led a little brainstorming session on extending the set of 'standard' transaction types, and I've been picking people's brains via email and IRC chat (and pull request comments) to work through the details.My motivation for wanting to do this NOW is because it will allow features like:+ Multi-device confirmation of spends, so if your computer is infected by a trojan it cannot spend all of your coins.+ Master-key emergency backup, so if you lose your wallet (and all of its backups) you can get the master key from your safe deposit box and recover all of your coinsIt will also enable third-party escrow and some other nifty features that aren't as important to me.  The first step in doing all of these things is to work out the lowest-level transaction format and to allow those transactions to be relayed and included in blocks.  That is ALL I am proposing right now (actually implementing something like multi-device spend confirmation will require a little protocol for the devices to communicate, a new kind of bitcoin address that people will send into, etc etc etc).Working out a common way of doing (for example) 1-of-2-keys-required transactions will make it much easier for sites like blockexplorer to display them intelligently, and will generally make life happier for anybody writing tools that look at the blockchain.I'd rather not have this turn into a "lets get rid of the IsStandard() check" or "lets re-enable a bunch of currently disabled opcodes", so if you want to talk about that start a new thread.Current draft proposal is here:  https://gist.github.com/39158239e36f6af69d6f I've been working on a proposal to enable {1,2}-of-{1,2,3} signatures-required as standard transaction types.I'll start another thread with more information... I enjoyed the conference, and I usually hate conferences.Apologies to everybody who I met and whose name I've already forgotten.  My secret super-power is forgetting names.And congratulations and a big Thank You to Bruce and company for organizing and making it happen! If you need a stable testing environment, the self-contained testnet-in-a-box works very nicely:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/You do have to remember to run -noirc or keep your testnet listen port closed, because if a 'real' testnet node connects to you you'll get the 'real' testnet block-chain. Why couldn't the-collective-we only revoke the double-spends (and subsequent txns that depended on them) ?A hard-coded list of invalid txids wouldn't be hard to insert into the is-valid-transaction checks, and that along with a blockchain checkpoint would work just fine.  Valid transactions on the bad chain would move to the new chain (actually, they'd already be on the non-attacker chain, since the miners on both sides of the block split would have included them). Yes, would you be interested in building? Yes, but if two blocks are found with the same difficulty then they are considered equal work-wise (even if one has a smaller hash value-- the "Bits" field in the block is used to compute chain work, not the block hash).If there are several valid tip-of-block-chain choices all of which have the same work, then miners are free to build off whichever one they like. The rule everybody (I think!) is using now is "build off the one seen first." Transactions have multiple inputs and outputs.If you have 0.5BTC inputs, then 50 of them will be bundled together and a transaction with 50 inputs and one output will be created.... but that's not what will actually happen. A 50-input-transaction will be over the "small enough to be free" transaction size limit, so 51 will be bundled together and a transaction with 51 inputs and two outputs (one to the destination, one back to you for any change leftover after paying the transaction fee) will be created.There is no ledger, there are just transactions with inputs and outputs.  Your bitcoin balance is the sum of all the outputs to addresses that you own that haven't yet been used as input to another transaction. +1 for vector76's hypothesis.If mybitcoin was running bitcoin behind Tor, and had just one connection (through a Tor exit node) to the rest of the bitcoin network, then they'd be particularly susceptible to this 1-confirmation attack.
Bitcoin addresses are not public keys-- they are hashes of public keys (RIPE-MD-160 hash of the SHA256 hash of the public key, with a version number and checksum, to be annoyingly specific).I agree that associating a message with a bitcoin transaction would be spiffy. I'd say the short answer to "is it possible to accept them again in the near future" is no (where "near" is in the next six months).I agree with Maged-- before enabling new opcodes, I'd like to see a peer-reviewed academic-style paper that works through the security implications of the existing set of opcodes and gives a nice framework for thinking about new (or disabled old) opcodes. Doing that is way outside my own personal level of expertise; I know only enough about designing secure algorithms to know that I  have no idea whether or not re-enabling OP_XOR would have security implications for bitcoin.Same goes for enabling nLockTime / transaction replacement, although I suspect that proving that transaction replacement doesn't open up any subtle attacks may be harder than proving security properties of opcodes. Yes, I'll send... oh, I dunno, $200 or so worth of bitcoins at a time to the Faucet.RE: not holding the EFF in high esteem: I still strongly support the EFF. They're good people working to make the world a better place, and I trust them to know better than I do whether or not accepting bitcoin donations is good for both them and the bitcoin project. Update:The EFF donation account/address was at mybitcoin, so half of them are gone.I received 1,879 from the mybitcoin claims process.  They are now safe in an offline, encrypted wallet; here is the transaction: http://blockexplorer.com/tx/4b32ed2f7c1422ced7f1f0be88b2afe355c59180be72e942df085d93f1c8737aAccording to block explorer, 3515.06 BTC were donated to the donation address I had for them: http://blockexplorer.com/address/1MCwBbhNGp5hRm5rC1Aims2YFRe2SXPYKt49% of that would have been about 1,722 BTC, not 1,879. I'm guessing the difference is because of donations from other mybitcoin customers just crediting the eff account without generating a block-chain transaction.Before sending coins to the Faucet, I think I'll create a patch to always send "change" to the same address, so it is really easy to keep track of these bitcoins and make sure they're not sent anywhere other than the Faucet. RE: negative account balances:There is (was?) a patch proposed with an RPC call to prepare a send transaction, which would lock the inputs involved and return the transaction fee and a transaction id.  And commit/reject RPC calls, which take the transaction id and either commit it or rejects it.  That's the only really right way to estimate transaction fees before sending. I haven't reviewed the patch, and I don't think it has been thoroughly tested; there might be denial-of-service attacks possible or odd edge cases (e.g. could one customer who decides to go to lunch while the "this transaction will cost you 0.0005 BTC, OK/Cancel?" dialog is open tie up the entire wallet's balance, making sends fail for everybody?)There's also an estimatetxfee patch, but the problem is that between the time you estimate the tx fee and the time the send happens the state of the wallet might change, making the estimate wrong.The real question is why should customer A pay a transaction fee just because customer B funded their account with tons of tiny transactions? If customer A puts 1,000 bitcoins in their account and pays 0 fee, they're going to be pretty upset at you if you charge them to withdraw THEIR money from the account.For ClearCoin, I just treated transaction fees as a cost of doing business, and refunded customer accounts when a send resulted in a transaction fee (via the RPC move method from a special FEES account that I pre-funded to cover transaction fees).So sends look like:  sendfrom "account" <to> <amount>    ... return txid  gettransaction <txid>    ... return txinfo  if txinfo says a fee was paid:    move "FEES" "account" <amount-of-fee-paid>RE: static addressesI don't follow.  You mean have one address per account?  You could call getaddressesbyaccount and the return the first address or (if empty array) return getaccountaddress?  Or if you create an account when a user signs up for your service, call getaccountaddress and then you KNOW that getaddressesbyaccount will return at least one address. Really?  You do realize that will just start an arms race with maxmint; he or she will write code to detect and ban bots, somebody will deploy bots via multiple IP addresses to workaround, maxmint will be forced to add a CAPTCHA, etc...maxmint: it can be kind of fun to try to scam the scammers.  If you detect them, just never let them win (but don't tell them you're not letting them win).However, they'll eventually figure out you're doing that.  The only way to win the arms race is to make it more expensive for the scammers to win than the reward.  If I recall correctly, getting around one-per-IP-address and CAPTCHA restrictions costs a scammer a few US pennies.  If you're giving away 1BTC worth $10, then you'll have to make sure the scammers will have to solve several thousand captchas to win. Two different encryption schemes and/or passwords seems like a bad idea to me, both from a code maintenance/security point of view and from a usability point-of-view.Can you expand on "private keys in base-58 export format are great for swapping around" -- what's the use case?  Who are you swapping with, and how? Couple of things:First, I want to squash the "Satoshi mined a bunch of bitcoins on his own before releasing the bitcoin chain" idea.  He publicly announced bitcoin version 0.1 six days after he generated the genesis block: January 9, 2009:  http://www.mail-archive.com/cryptography@metzdowd.com/msg10142.htmlAccording to the block chain history, he generated about 10 blocks total before the announcement.  And we know that he didn't pre-generate blocks because the genesis block contains a quote from the January 3rd Financial Times newspaper.Second, I have no problem with alternative block chains, I just don't personally like how this particular alternative block chain is being promoted and developed and introduced. In particular, I think it is unfair to keep hundreds of thousands of whatever-coins for yourself, and it is unwise to think that a bitcoin variation that is "almost exactly like bitcoin, only different because... well, just because" will ever have anything more than speculative value. So... I got this unsolicited email:... and I'm trying to figure out why my immediate reaction is "yuck."I guess I just don't see the point of IxCoin.  I just spent some time looking back through all the original poster's messages, and I don't see any prior discussion of goals of IxCoin, how it should be designed, etc.If the goal is to let more people be early adopters of a new cyber-currency, then it seems to me giving early bitcoin adopters a bunch of IxCoin goes against that goal. Half-baked thoughts on transaction relaying (I agree that it may become a major problem because there are no incentives to properly relay transactions right now):I think writing code to reliably detect that a peer isn't relaying transactions is possible. Something like: Generating a new transaction:  Pick a connected peer at random "P"  Relay new transaction to all nodes EXCEPT P  If, after a little while, P doesn't tell us about our new transaction then it is likely P is not relaying properly.   (assumption is that we are not P's only connection, and it will get the transaction from its other peers)And I think something like the above could be one of the metrics used to measure "ill-behaving peers" (other metrics might be number of double-spend transactions or orphan blocks received, number of spammy-looking transactions received, etc).  If a peer is too ill-behaved, the penalty could be shunning-- drop its connection and add its IP to a temporary refuse-connections list.(maybe lesser penalties make sense, too-- maybe order-of-relaying is based on good behavior, so the code announces new blocks/transactions to better-behaved peers fore worse-behaved peers).If cheating miners find themselves disconnected from the rest of the network, that is a strong incentive not to cheat.I'd really like somebody with a lot more network design experience than me to run some simulations and see what network behavior would be like with/without rules like I'm proposing.  Or tell me that disconnecting ill-behaving nodes is a terrible idea because it makes it easy for an attacker to shatter the network into a gazillion pieces... FYI: I started a discussion of development priorities for the next release or two on the bitcoin-development mailing list:  https://sourceforge.net/mailarchive/message.php?msg_id=27928380 -wallet=foo.dat  command-line param would be easy (unless you allow an absolute path, in which case the code that detects whether two instances of bitcoind are trying to write to the same wallet would have to be changed).But if you pass it on the command-line, then wallet-stealers can just adapt and look in the process list to figure out where the wallet is.  If you put it in the bitcoin.conf then the wallet-stealers can also look in the bitcoin.conf to figure out where it is.I like the 'deterministic wallet' idea that's been floating around (enter a password passphrase at startup, and keys are magically derived from that password passphrase and never touch the disk at all).Seems like there would be a clever way of combining that with white-box cryptography to make the private keys extremely trojan-resistant.In which case the wallet-stealers will just rewrite the bitcoin address/amount after you press the "send coins" button...Edited to replace 'password' with 'passphrase' It will get pulled/released faster if you help test it.  Pull the patch, compile a custom bitcoind, then run it and report any bugs.  If you don't find any bugs, add a short note either here or in the PULL request.Testing is currently the bottleneck for getting new features... Everybody likes this feature, and it feels like it is very close to being ready for inclusion.There are two reasonable requests in this thread that I think should be implemented before this is pulled:1. Pieter's change to the API, so the <pubkey> is extracted/verified from  verifymessage <bitcoinaddress> <signature> <message>2. ByteCoin's request that the <signature> be industry-standard-base64-encoded instead of hex or base58 encoded.The nonce/no-nonce argument seems like "angels dancing on the head of a pin" to me; seems to me the tiny iota of theoretical added security (...sometime in the future maybe when SHA256 is broken or partly broken...) isn't worth the extra complexity. Alternative algorithms for determining the "best" block chain would be a good research topic, I think.Model or simulate either a 'natural' block-chain splits (X% of the network gets disconnected for time T) or attacks (attacker with 51+% of hashing rate double-spends a transaction by surprising the network with a N-length better block chain).Then see what the behavior is like under different potential algorithms for determining the best chain-- the one we have now (most difficulty always wins) or some variant (like more recent blocks are given greater weight).And think really hard about potential attacks, especially mixed-mode attacks (what if the attacker can mount a Sybil attack on one of the big mining pools?  Or can DOS one or more of the big mining pools? etc) I'm curious to hear what other people think.  I shut down ClearCoin when the value of its wallet threatened to get so large I was no longer comfortable self-insuring it with my own personal bitcoins.  It is still shut down because I haven't found a group that I would trust to run it securely (and I don't want to take the time to raise the money and hire experts to run it properly).We are starting to see well-capitalized, experienced companies creating bitcoin businesses; at this point, I think if you are holding other people's bitcoins then having insurance or posting a bond to self-insure up-to-some-value for each account is reasonable.In my view, if your business model for your free service doesn't cover the cost of insurance or a bond, then you're just pushing a lot of hidden risk onto your users. The plan is the same as before: EFF coins will be redistributed via the Bitcoin Faucet.Last week the folks at the EFF said they'd be sending the coins to a secure wallet I created for that purpose "tomorrow."I asked that they send them to address: 1vc3ZU4ae2cF6ZxqE44j5Ak3wfsZqybtbI'll let you know what happens; they never told me where the coins are being held, it is possible they got caught in the mybitcoin disaster.I'll keep that wallet secure and offline except to periodically top-up the Faucet's balance. So factor out the swings in value by insuring in a more stable currency.Obtaining insurance for "up to £X worth of bitcoins per account" seems like it aught to be possible. If X is a small number, then that's a strong indication that people shouldn't be using Vibanko for secure storage of coins.If you can't find an insurance company that will cheaply sell you (say) £1,000 of coverage for (say) 10,000 accounts then that is an indication that maybe you're riskier than you think.  Can you afford to self-insure, and put up a £10,000,000 bond to cover potential losses?  Or work backwards: how large a bond can you afford to put up?  Divide that by the expected number of users and that's a good indication of how much wealth users should trust you with. Potential questions for the FAQ; these are all questions I wish I had insisted on getting answered before trusting MyBitcoin with some of my coins:Are the bitcoins on deposit bonded or insured against theft or loss?Are the bitcoins on deposit backed up off-site? How often?How many people have access to the wallet? How do you know you can trust them, or how are they audited?What happens if you decide Vibanko is not a viable business and has to be shut down? I think the rise from less than $1 per bitcoin to over $30 per bitcoin was purely a speculative bubble, fueled by all the press/publicity. Even in the absence of global financial uneasiness I think a bubble was inevitable; maybe a lot of the interest in Bitcoin is/was driven by people looking for a deflationary escape, but I doubt it.  Measure bitcoin prices in milligrams of gold (the time-tested deflationary escape) and you'll still see a big bubble and pop over the last few months.I think it will be years (if we're lucky) before a significant number of investors look at Bitcoin as a deflationary escape from other assets.What's your prediction for the number of bitcoin bubbles over the next three years?  (measured against whatever basket of currencies or assets you like)  I based my projections on "feels about right to me."
I'm resurrecting this old thread because I like to reality-check my predictions.Number of bubbles so far:  one.(the $0.008 to $0.014 price rise turned out not to be a bubble; the recent $10 to $30 back down under $10 was definitely a bubble)Zero to one bubbles and crashes per year for the next three years still seems about right. I'll be there. RE: protecting an innocent person:  any lawyers here?I have trouble believing that you could get into legal trouble for having illegal incidental data from legitimate activities on your computer. If you can, then we're all in trouble, because it is very easy to put illegal data in your web browser's cache (JPEG and other image file formats let you store arbitrary, not-normally-shown metadata, for example). I don't think it would be hard to convince a jury that the block-chain is like your web browser's cache-- full of lots of incidental stuff that is needed for the system to work, but doesn't have anything to do with you.  Now if you happen to have one of the private keys involved in the illegal transactions, THEN you should go directly to jail....Adding code to "shun" certain spend-able transactions wouldn't be hard, although I think that's a bad idea for the same reason it is a bad idea to respond to trolls on forums-- you'd just encourage the bad guys by drawing attention to their misbehavior. Putting illegal content in the block chain and announcing it as an attempt to undermine Bitcoin seems like a good way to get yourself arrested.  Much better than tweeting about exploits.You'll have both law enforcement and techies trying to track you down, and given that people are already deploying de-anonymizing tools it seems pretty darn likely that you'd get caught. Alternative algorithms for accepting deep block-chain re-orgs sound like a research project to me. Before changing something that critical I would like to see simulations of how different re-org policies behave under different attack scenarios, and non-attack "what if there is a bug that causes an inadvertent block chain split" scenarios.And I'd like to see a whitepaper that lays out the issues and summarizes simulation results.  And lots of extra credit if it gets peer-reviewed and published in one of the IEEE or ACM journals. The wiki page is luke-jr's baby. Several of us are tired of having wiki-editing wars so we just ignore it.Suggestions for a better "RFC process" are welcome; which open source project should we emulate?  (e.g. bittorrent has BEPs, python has PEPs, are there other models to follow?) Two pull requests seem appropriate: one for the generic issues (talk with TheBlueMatt about the upnp #define, I believe it is working as designed), and one for DragonFly-specific stuff.Frankly, DragonFlyBSD-specific stuff is unlikely to get pulled; there just aren't enough DragonFly-BSD systems to justify the work of maintaining support for it (according to bsdstats.org it isn't a very popular BSD variant). No.A better question might be: what would make me trust something like your BitDollars?If you were bonded or insured for all of the bitcoins that you held, by a bank or insurance company or people I trusted (and were audited by that bank or insurance company or people to see how many bitcoins you were holding on behalf of other people), that might get me to trust you with real bitcoins. They're both unpredictable?You lost both to some jerk on the Internet?(six months from now):You didn't appreciate them when you had them, but now they're gone you want them back? I whitelisted Dan and moved this thread here.(yes, I'm beyond-a-reasonable-doubt-certain dakami is Dan Kaminsky, we had an email discussion about interesting-but-smushed-bug#8 earlier in the week) Private insurance with reliable, reputable insurance companies. Private bonds deposited into reliable, reputable financial institutions.All of which cost money, which was a problem a year ago when nobody really knew much of anything about bitcoin.We need legal contracts with businesses that are in a legal jurisdictions where the contracts can be enforced in court.  I don't think we'll get a non-governmental legal system in my lifetime, so I'm personally happy to rely on the imperfect government courts we've got today. blk0001.dat stores all of the transaction data for the block chain.So to "inject" data into it you transmit valid transactions that are then included in blocks. Dan crafted transactions that contain the tribute message.I think it is a neat hack. ("hack" in the sense of "clever, non-obvious way to use technology")  I wonder how much it cost in transaction fees, or if he managed to do it entirely with free transactions... For future reference:  the Public Relations wiki page has good advice:  https://en.bitcoin.it/wiki/Public_relations I followed the JSON-RPC-2.0 spec for errors, as described here:  http://groups.google.com/group/json-rpc/web/json-rpc-2-0?pli=1(see section 5.1)... with several bitcoin-specific additional error codes that I'd have to look at the source code to remember.I thought I'd documented the additional bitcoin error codes, but maybe that information got lost in the wiki move that happened last year or maybe I'm mis-remembering.  Quick grep through rpc.cpp gives:Code:(-10, "Bitcoin is downloading blocks...");(-11, "Invalid account name");(-12, "Error: Keypool ran out, please call keypoolrefill first");(-12, "Error: Keypool ran out, please call topupkeypool first");(-13, "Error: Please enter the wallet passphrase with walletpassphrase first.");(-14, "Error: The wallet passphrase entered was incorrect.");(-15, "Error: running with an encrypted wallet, but encryptwallet was called.");(-15, "Error: running with an unencrypted wallet, but walletlock was called.");(-15, "Error: running with an unencrypted wallet, but walletpassphrase was called.");(-15, "Error: running with an unencrypted wallet, but walletpassphrasechange was called.");(-16, "Error: Failed to encrypt the wallet.");(-17, "Error: Wallet is already unlocked.");(-2, string("Safe mode: ") + strWarning);(-3, "Invalid amount");(-32600, "Method must be a string");(-32600, "Missing method");(-32600, "Params must be an array");(-32601, "Method not found");(-32700, "Parse error");(-4, "Error refreshing keypool.");(-4, "Transaction commit failed");(-4, "Transaction creation failed");(-5, "Invalid bitcoin address");(-5, "Invalid or non-wallet transaction id");(-5, string("Invalid bitcoin address:")+s.name_);(-6, "Account has insufficient funds");(-6, "Insufficient funds");(-7, "Out of memory");(-8, "Invalid parameter");(-8, string("Invalid parameter, duplicated address: ")+s.name_);(-9, "Bitcoin is not connected!"); Here's a scheme that would work:1. Exchange creates a special bitcoin keypair for each exchange rate it wants to publish.  E.g. maybe there is a   1mtgxbtcusd9873919fp876...   address for mtgox btc/usd2. Exchange funds that address with a bunch of bitcoins.3. Every 10 minutes the exchange performs a send-to-self transaction FROM that address TO that address with the number of bitcoins that correspond to the current exchange rate.Voila, exchange rate is broadcast to anybody who cares to listen. You know it is the exchange, because the exchange is the only entity that can spend bitcoins from the special exchange address.You have to trust the exchange not to broadcast a bogus price...  I've wanted a libbitcoin since... well, since I first started browsing the bitcoin source code.The consensus of the core bitcoin development team is to move towards a libbitcoin in small-ish, incremental steps, NOT to move to a full-blown API in one fell swoop. The Bitcoin Consultancy folks disagree with that approach, and are moving ahead with a libbitcoin of their own that it rewritten from scratch, and I suspect there will be at least two or three other alternative implementations rewritten from scratch popping up over the next year or so.  Which is why I'm spending a lot of time thinking about and working on cross-implementation testing.(I'm supposed to be on vacation here in Australia, but I'll try to find some time to upload what I've done so far to github). I've been making slow but steady progress on my at-the-network-level testing tool. I don't put a lot of faith in standards documents-- it is too easy to misinterpret or ignore them. Good implementation-independent test suites seem like a better investment of time.What's working:  python-based code that serializes/deserializes messages in both bitcoin's binary format (to talk to the node being tested) and JSON (so it is easy for us humans to tweak/examine test data). Connecting and requesting all blocks.Still todo: actually start writing test cases, figure out what other tools I need to write to create good test cases, and start systematically going through the "rules of bitcoin" and devising tests to make sure the rules are being followed-- starting with the super-important "get this wrong and you split the blockchain" rules.I hope to recruit some of you to help out with all that...  I'll be creating a github project with my progress so far very soon. The google link on the bitcoin.org homepage is/was my idea."The One True Forums" for bitcoin doesn't make sense to me-- the whole point of bitcoin is to be decentralized. I sincerely believe that open and free competition makes everything better, and I hope that more places to discuss bitcoin pop up and compete to be the best.In the future, I'd like most of the links on the bitcoin.org home page to be google searches, including the "download bitcoin" links (I think we'll see some great new bitcoin clients released over the next six months or so). Works for me (from a private testnet bitcoind):Code:    {        "account" : "",        "category" : "immature",        "amount" : 50.00000000,        "confirmations" : 2,        "txid" : "0b1783e595b50580c6732c2891e92ad63b351a57a50e004013f7b60ecd89d337",        "time" : 1310870932    },    {        "account" : "",        "category" : "immature",        "amount" : 50.00000000,        "confirmations" : 1,        "txid" : "f4c244602f7d23951bd21abd89147312075a270286d1420d0bae0a1d8397597a",        "time" : 1310871263    } Bitcoin 0.3.24 adds a   -port=  option to listen on a port other than 8333 for incoming connections.
Don't do that, you'll just spend a lot of time re-downloading the block chain and then be back in the same state you were before (unless you happen to get lucky and your transactions get confirmed while you're waiting for the block chain to download again).Restarting bitcoin and letting it get 8 fresh connections might help. Allowing incoming connections so you have more than 8 connections should also help your transactions get confirmed.Safest thing to do is to be patient; your transactions will be rebroadcast and eventually will get confirmed. If they're not confirmed in a week, then there are ways of deleting the transactions from your wallet and "freeing up" the stuck bitcoins, but messing with your wallet should always be a last resort. Yes, all of the send* methods return a transaction id on successful send. Because to non-technical users, "privacy" is a single feature, not a series of separate technical issues. Does this patch give any sort of warning if bitcoin isn't being used through a proxy?I worry that a user will be REALLY careful keeping all their addresses separated so their ordinary transactions are separate from their fund-the-oppositition transactions, and then will get busted by the Secret Police who were eavesdropping on their bitcoin IP traffic at their ISP. Very-low-priority transactions will get dropped by peers, because they look like "spam" transactions and network bandwidth is not free.I don't know if the current rules are written down anywhere besides the source code; improving the fee-handling and spam-detecting code in bitcoin is high on my bitcoin improvement wish-list, so if they were written down they'd be likely to change fairly soon... It will get confirmed; it is already 'funded' (you can never send more coins than you have in total in your wallet).This example might help; if you have exactly two accounts in your bitcoin wallet and their balances are:Account A: -0.1 BTCAccount B: 1 BTC... then if you tried to send 1 btc from account B the send would fail with an "insufficient funds" error.I'd suggest funding a 'TransactionFees' account, and then when a sendfrom results in transaction fees reimburse the account by moving funds from TransactionFees. I'm thinking about how to do higher-level testing of bitcoin, and I think we could get a lot of mileage out of a testing harness that works at the network protocol level.I'm thinking of testing things like proper handling of block chain re-orgs and valid and invalid transactions.Examples:Block chain re-org test:Start a bitcoin client with an empty wallet and just the genesis block, -noirc listening on a non-standard port.test harness connects, then feeds it a pre-canned block chain   ... then sends it a longer forktest harness makes sure client accepted the longer chain by sending it a getblocks messsage  (or disconnects and re-connects and checks the start_height in the version message)Valid/invalid transaction testsStart bitcoin client as abovetest harness connects, sends a series of valid and invalid transactions (via inv message and then responding to getdata).test harness checks to see if transactions were accepted or rejected by checking responses to getdata (should be no response for invalid transactions)A set of good data files with "tx" and "block" (and "inv" and all the rest) messages in them, combined with something like pexpect could make a good test system. I'm thinking they should be human-readable (with a proxy listening tool or wireshark plugin or something that dumps bitcoin protocol into the human-readable form) but pretty low-level; maybe a version message looks like:Code:{ "version" : [ "u32:31900", "i64:1", "i64:1309899496", "addr:127.0.0.1:8333", "addr:127.0.0.1:5432", "u64:1235876", "s:", "i32:98645" ] }So, before I start working on something like this:  Anybody already doing something similar? Losing double-spent transactions should probably be reported as -1/unconfirmed, -2/unconfirmed, etc -- meaning "there is a N-confirmed transaction that conflicts with this one."-6/unconfirmed seems like the natural "this transaction ain't never gonna be confirmed, time to report it as -N/orphan."-1/unconfirmed should be enough to stop re-transmitting it.And -120/orphan seems like a safe time to "unspend" any inputs (let them be spent by new transactions) that weren't spent by the other, conflicting transaction.... he says nonchalantly, knowing full well that actually making bitcoin behave that way means a lot of very careful coding and lots and lots of careful testing...The shortcut, maybe-good-enough-for-now solution:  export all the private keys from all the messed up wallets.  Start with a clean wallet, then re-import all the private keys and let the clean-slate bitcoin figure it all out. So go ahead and document it, volunteer to keep it up to date (that's the hard part), and submit a patch. After the latest source-file re-org, there is a top-level doc/ directory where a "wallet_format.txt" file would go. https://github.com/bitcoin/bitcoin/pull/379I think this is critical enough to include in 0.3.24rc2. Who decides whether or not a miner has broken the rules? Several people have asked me about buying it, but I won't sell it unless I trust that the team that takes it on has experience keeping customer's money safe and the resources to do all of the things I don't have time for-- penetration testing, better customer support, insurance on the coins in escrow, etc. bitcointools has a fixwallet.py that can often fix broken wallet.dat files.  https://github.com/gavinandresen/bitcointools/ One of the speakers at the Emerging Technology conference I attended at the CIA was from Facebook Payments, and he seemed pretty adamant that they're committed to doing what they can to keep the people buy the credits (users who want to play games) separate from the people who cash them out (the game developers).So a facebook app implementation of bitcoinjs would very likely not be approved for Facebook payments. One of Bitcoin's major challenges is the legal uncertainty surrounding it.It is really no different from other new Internet technologies (should Skype be regulated like a phone company? Does google's deep-linking violate copyright? ... to give two examples from a few years ago...), but because it is money there are a lot more laws and regulations that may or may not apply.It'd be easy to ignore that and just damn the torpedoes, full steam ahead with the technology. And given the nature of geeks on the Internet, that is what is going to happen anyway... but I decided it wouldn't hurt to try to be proactive and start a conversation with my representatives in Washington, DC about the Bitcoin Project.So I met briefly with staffers from Rep. Olver and Sen. Brown's offices yesterday. I gave a very brief overview of bitcoin, mentioned Senator Schumer's "eradicate Silk Road" press conference, and stressed that Bitcoin is meant to be a stable, secure, international currency for the Internet, NOT a currency for criminals.I also mentioned that the legal uncertainty is a barrier to innovation, and asked for advice on what, if anything, could be done about that. There is no good answer-- government moves really slowly, and they're wedging newfangled Internet ideas into legal structures that were created when telephone were the latest and greatest technology.However, the house of representatives staffer I talked with did suggest that encouraging you-all to introduce yourselves to your congressperson's staff is a good idea.  If they know that interesting, job-creating bitcoin businesses are happening in their districts and they've met the person making it happen, then they're much more likely to support bitcoin-friendly legislation.So, if you're an upstanding, law-abiding, clear-thinking citizen doing interesting things with Bitcoin, I encourage you to take a little time and introduce yourself to your representative's staff. I wouldn't bother talking to the representative-- they're probably too old to really understand bitcoin ("Tubes!  Money through the tubes I say!"). Talk to a 20-something staffer who grew up with the Internet and is likely to be a lot more sympathetic to the idea of a peer-to-peer Internet money. Wow, this snuck up on me...So I'm headed to Australia in a week.  I'll be in Sydney for a few days; anybody want to meet for lunch on the 9'th or 10'th?Then I'll be in Hobart for a couple of weeks, then near Cairns for a couple of week beginning July 22'nd; send me an email if you're nearby. I moved this from the Newbie forum-- looks like a great project! I'd like to see somebody work on a "shun ill-behaved peers" patch.So if one of your peers sends you lots of garbage (blocks/transactions/addresses/whatever) you just disconnect from it and refuse to accept connections from it for a while.The trick is thinking really hard about what is really 'garbage' and what might be honest, it-happens-every-so-often weird behavior due to block chain splits or other network events.The goal would be to prevent a wide range of denial-of-service attacks. A long-term fix for transaction fees (as opposed to the ad-hoc "we'll just try to guess what the 'right' fees are") is high on my priority list for bitcoin. There are only two very-high-priority things on my bitcoin wish list:  fix scaling issues and make sure we have any infrastructure in place to support ultra-high-security wallets. Fixing transaction fees is a scaling issue."Pick a fee and hope my transaction makes it into a block" is NOT the right answer. And we've already seen what happens when there is a mismatch between miner transaction fee policies and client transaction fees (remember the big backlog of low-priority transactions we had a couple of months ago?). Facebook credits are designed so that dollars go in, but only flow back out to the companies with facebook games.And Facebook tries hard to ensure that the companies cashing out the credits are real companies, and not people just trying to move money through their system. There are no open exchanges, by design.
I've been struggling recently to keep ClearCoin moving forward while I also try to keep core bitcoin on track, and with all the demands on my time I can't spend the time on ClearCoin to make it a project that I'm really proud of.So in the next day or two I'll stop allowing the creation of new escrow transactions. Existing transactions will be unaffected, and I'll keep ClearCoin running for at least two months after the last active transaction has expired.I hope ClearCoin will be back at some point in the future, but I won't bring it back until a lot of behind-the-scenes work is done to make it a robust, scalable business. RE: cryptocards instead of an online service:Seems like we aught to be able to come up with a protocol that works over the web or that can talk to http://localhost:SOMEPORT to interact with an attached smart-card device (there'd be helper software running on localhost:SOMEPORT that spoke the protocol and relayed to the smart card).I wanted to start this discussion to make sure we don't re-invent the wheel, and to think in advance about what changes to core bitcoin (if any) are needed to support this kinds of functionality. Here's a use case I'd like to work:I tell Bitcoin running on my computer or cell phone to run transactions through a bitcoin security service-- maybe I give it a https:// URL for the service.I tell the security service "auto-approve small-value transactions, but give me a call for any transactions above $X (or $XY per day)."The security service sends me something in the mail that I keep safe, but that I can use to recover use of my bitcoins in case the security service goes out of business or disappears or I decide to stop paying for the service.I get bitcoin addresses either from my bitcoin client (not trustworthy!) and/or from the security service that require both my computer and the security service to sign to spend.  And I have people send bitcoins (or I self-send my own bitcoins) to those addresses.Spending coins is done as usual-- I type in an amount and an address.  Behind the scenes, magic happens, and if the transaction is greater than $X I get a phone call -- "Press 1 to confirm payment of $X bitcoins to bitcoin address blah, press 2 to cancel."If I suddenly get random phone calls, I know my computer has been infected. I took error's work and further tweaked so it works (and is rebased against) latest git head.... but I'm not 100% happy with it. I'm not sure it properly handles block chain re-orgs and dependent orphan transactions. Would be nice to write some tests to exercise those edge cases, and figure out what it SHOULD do in those cases. The risk profile I care about is:User's computer is completely compromised by a root-kit trojan, but they don't know it.However, the user has access to some other device or service that they have setup in advance to be a "second line of defense" to prevent their entire wallet from being stolen. I don't want to keep putting band-aids on the transaction fee problem, so I'm against adding Yet Another Button to the client.If you're impatient and can't stand the thought of paying half-a-millibitcoin for a transaction, then compile your own version of bitcoin. Just don't complain if you end up with a wallet full of 0/unconfirmed transactions that tie up all your funds. Anybody else already working on tests?Steve: mind if I pull out just the boost-unit-test bits of your tree? Zero-knowledge proofs... ummm....Nice to know it can be done securely. I'll leave it to the professionals to actually do it. EFF blog post: https://www.eff.org/deeplinks/2011/06/eff-and-bitcoinRE: refunding donations by proving you own one of the private keys that donated:  interesting idea!  Anybody willing to write code to do that?  Could be a fun project... (find all the transactions that donated to EFF, dig out the public keys, come up with a way to sign/verify a message with private key proving you own a public key, then keep track of which donation transactions have already been refunded) Cindy Cohn, legal director at the EFF, called me a while ago to figure out what to do with the bitcoin donations they were sent, and what to do with coins that might be sent to their donation address in the future.Ideally, they'd like to return them, but that can't be done-- bitcoin has no "return to sender" function. Returning to the last-address-the-coins-were-sent-to doesn't work because people use shared online wallets and can, and do, send their coins to new wallets and delete old wallets.The EFF is firm in their decision NOT to cash them in (they'll be coming out with a blog post explaining their reasons very soon), and after talking over several possibilities the idea they liked best was to redistribute the coins via the Bitcoin Faucet (and have any donations that trickle in get passed back out via the Faucet).  The reasoning is that anybody who donated bitcoins to the EFF would also support the mission of the Faucet-- to promote bitcoin by giving people new to the currency a little bit to start.Other options for what to do with the EFF donations (like setting up a non-profit entity to take the donations and... do something with them...) were rejected as too complicated and/or costly.I'll need to do a little bit of thinking about how to handle the EFF coins safely (just dumping them all into the Faucet's wallet is not a good idea; I would hate for them to get lost if somebody managed to hack the Faucet's web-facing code). Whatever I do, I will make sure the process of moving the coins from the EFF's donation address to the Faucet is absolutely transparent. I just uploaded pdf and KeyNote versions of the talk I gave at the CIA last Tuesday: https://s3.amazonaws.com/gavinandresen-bitcoin/GavinAndresenCIATalk.pdf https://s3.amazonaws.com/gavinandresen-bitcoin/GavinAndresen_Bitcoin.keyI took questions in the middle, before I dove into the technical details. I was asked about whether or not I thought price instability would be a problem ("yes, I'll talk about that later") and how/why I got involved.Later, at the panel discussion, I was asked a question that showed I need to do a better job of distinguishing bitcoin addresses and IP addresses. And I was asked if there were moral issues, since bitcoin can be used by criminals ("I'm working on bitcoin because I think the potential benefits to the world are much, much greater than the costs.")The other speakers were from PayPal, Facebook Payments, M-Pesa, Heartland Payment Systems, and the Federal Reserve, so it was worth going just for the connections. Bitcoin is definitely the new kid on the block, and I presented it as such; not "bitcoin will take over the world" but "bitcoin is a very interesting experiment that could be world-changing if it works out."And now... there is plenty of work to be done, so I'm going to stop reminiscing about the good old days last week.... RE: pulling the wallet private key encryption ASAP:  Agreed 100%I wanted to start discussing split keys now because if we need a new standard transaction type then it is best to do that in stages-- let clients relay, and miners include in blocks, the new transaction type.  Then once most of the network will accept the new transactions, people can actually start USING them. RE: making it harder to brute-force:I have a couple of thoughts.  First, if users choose passwords like 'abc123' or 'password' or any of the other top-1,000 passwords it doesn't matter if we're scrypt'ing; they're toast. I'd rather see work on either giving users feedback on how strong or weak their password is rather than adding a tiny-little-bit-more security by scrypting.That said, changing the 'ekey' data so that ONLY the 256-bit private key is encrypted should increase security with very little extra code. Consider what you'd have to do to brute-force:1000 x SHA256(password_text)Now you have a 256-bit number.  Is it the right private key?  To check:ECC multiply to get candidate public keyRIPEMD160(SHA256(candidate public key)), and check to see if it matches public key.Anybody know how easy it is to GPU parallelize ECC multiplies?  A quick google search gives me the impression that is an area of active research.RE: pre-computing wallet keys:  ??  wallet private keys are 256-bit random numbers.  Am I misunderstanding you gmaxwell? I agree; I think allowing commas in numbers is a bitcoin GUI mis-feature. Because sending to a multiple-signature-required address requires a new standard transaction type, a new type of bitcoin address, and a protocol for Device 1 <-> Device 2 communication. More code means more possibility of bugs, so I was hoping there is a simpler solution.And as I said in the original post, I wanted to start discussion:If the answer is "multiple signatures" then so be it. Yes, don't trust me, please.  I am human and will make mistakes.The CSRF vulnerability on ClearCoin is fixed. I will be contacting any ClearCoin customers who have changed their refund addresses to make sure that they were not the victim of a CSRF attack. I'm busy watching the Red Sox whoop the Brewers.I'm planning on posting my talk's slides tomorrow. I gave a general report on the visit on Bruce's Bitcoin Show. FYI: I posted this here on the forums because I see the mailing list as being for nuts-and-bolts "lets talk about exactly how to get XYZ done."And I see these forums as a better place for brainstorming and pie-in-the-sky maybe-it-will-work-maybe-it-won't discussions.Also, equations don't look pretty in plain-text emails. Planet Money is one of my favorite podcasts.They interviewed me when I was in France, and I hope I didn't say anything too stupid. They seemed "appropriately skeptical." So I've been thinking a lot about wallet security; Matt's password patch is a good first step, but maybe we can at least build in some infrastructure for a better solution.We really need a solution where transactions are generated on one device and then verified on a second device, so malware must compromise both devices (e.g. computer and mobile phone, or web wallet and mobile phone) to steal coins.gmaxwell from IRC thinks it can be done without multiple signatures (just with the standard transaction we have now), and staring at the ECDSA math on this wikipedia page I think he's right.  I believe he was inspired by ByteCoin's observation that you can create a vanity public key generating service that is secure-- the service can generate the public key but not know the private key.I'm mostly writing this to convince myself it could work and to give ByteCoin and Hal and gmaxwell and anybody else who knows a whole lot more crypto than me a chance to poke holes in it. And then point me to a FIPS standard that has it all figured out already...So:  generating an ECDSA keypair means choosing a private key dA, then calculating the public key QA = dAG (where G is a fixed point on the elliptic curve).The key generation can be split; have device 1 choose dA1 and device 2 choose dA2.  Device 1 then sends QA1 to Device 2, and it can calculate QA1dA2 = QA1*A2.  Or in english, Device 1 finds a public key on the curve.  Then Device 2 uses its part of the private key to do a bunch more elliptic curve multiplies to find the composite public key without ever knowing Device 1's public key.So great, neither Device 1 or 2 needs to ever have both parts of the private key on them to generate the shared public key.Now lets say Device 1 wants to spend a TxOut that is one of these split keys.  The key bit of the signature generation algorithm (see the Wikipedia page: http://en.wikipedia.org/wiki/Elliptic_Curve_DSA#Signature_generation_algorithm ) is:...4. Calculate s = k-1(z+rdA)(mod n)...That can be rewritten as:Calculate s = k-1(z+rdA1dA2)(mod n)And now I'm stuck.  Can that equation be refactored so that Device 1 can compute part of the signature, send its partial result to Device 2, and have Device 2 complete the signature (without Device 2 being able to figure out 1's part of the private key?)?
https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ Bitcoin's technology is unstoppable, like p2p filesharing has proven to be unstoppable. But "the Bitcoin Project" could fail in a bunch of different ways.If mainstream people think "Oh, bitcoin is that internet thing used by criminals", that is bad for bitcoin. It might be bad enough to kill the project (note that I said "the project", not "the technology").If bitcoin really does turn into an internet thing only used by criminals then I'll personally consider it a failed experiment and will find something else to do.PS: the cbsnews interview was with Jeff, not me, and my last name is "Andresen" +1If you can, please help test, it really helps. Patch for wallet encryption is at: https://github.com/bitcoin/bitcoin/pull/232As bitlotto says, us a wallet with very few coins in it and/or run with the -testnet flag to use test network coins. If your device (computer, mobile phone) is infected and your bitcoin wallet keys are stored on that device (encrypted or not), then the bad guys will get your coins sooner or later.Sooner if the wallet is not encrypted. Later if it is encrypted.Come up with all the fancy "measure timing and enter your fingerprints and choose an 80-character-long password and store your private keys inside the Trusted Platform Module Chip" pseudo-security measures you like; if your device is infected they will not work.The bad guys will simply hack the software so that you THINK you're securely sending 1 bitcoin to your cousin (because that's what it says on the screen), but instead you're REALLY authorizing sending your entire bitcoin balance to the bad guys. https://en.bitcoin.it/wiki/Scalability As long as the questions are core-bitcoin-related and not specific to your alternative client.Good alternative client question:  "I'm writing an alternative client that doesn't store private keys at all (they are generated from the user's password). But I'll need a bitcoin protocol message that does XYZ to make it work; are other clients willing to support that new message?"Bad alternative client question: "I'm coding my alternative client in Forth; what's the best GUI toolkit to use?" Yep. Every transaction you make potentially leaks a little information about other transactions to/from your bitcoin wallet.That's why I always say "bitcoin anonymity is complicated" and "bitcoin transactions are more private than credit card or bank transactions, but less private than cash transactions" or "staying completely anonymous while using bitcoins is hard."And that's why you won't find (or, at least, shouldn't find) any claims that bitcoin is anonymous on the bitcoin.org home page or in the bitcoin source code.What can you do? Use separate wallets. Make your donation address an instawallet or mybitcoin address that you don't use for anything else. I exchanged email with Jacob, and he's predicting bugs because some very good "white-hat" people are looking hard at the code, trying to find bugs or vulnerabilities.That's all.  And that's good news; the more people who try to find problems with the code (and who will report any problems responsibly so they can get fixed before they're exploited), the better. I'm reposting from the ClearCoin news blog:   http://clearcoin.blogspot.com/2011/06/charity-escrow-changes.htmlI've been contacted by a charity who is not happy that they were listed as a donation option for ClearCoin charity escrows.I made the mistake of assuming that charities would appreciate the extra bitcoins; it never occurred to me that ClearCoin customers might contact a charity and ask THEM for their (supposedly-donated) coins back. Charities can't be expected to resolve ClearCoin disputes.To fix the problem, I have disabled all charities for new escrow accounts except one: the Bitcoin Faucet. I will be writing to any charities that received ClearCoin donations from already-created escrow transactions to make them aware of the situation and will ask them to forward any ClearCoin-related issues to me. Busy... very busy... This would be like a 6-blocks-back block chain lock-in.  Maybe not a bad idea at this point (unlike the early days when legitimate users might throw lots of new hashing power at the network or there might have been network splits because there were so few nodes).I think there would have to be an override, in case there WAS an hour or two or three network split.Or maybe some attempt to detect double-spends (e.g. more-than-5-block-split OK if all transactions are valid on both chains). I still think selling boot-able USB sticks that contain a Linux distro, bitcoin, a bitcoin miner, and "starter" bitcoins would be a great eBay business/product. You're not selling currency, you're selling software and a USB stick.You'll have to have a good eBay rep, though, because the person who gets it would have to trust that you didn't keep a copy of the wallet. Does anybody have the full text of the open letter? Mr. Google is failing me when I search for it... I'll confess: the bitcoin GUI is not a high development priority for me because I think downloading and running software on your computer will soon be almost extinct.I expect pretty soon most people will be using bitcoin through web applications (like mybitcoin or instawallet) or as apps running on their mobile phones.I'll also confess that I like the bittorrent model-- create a great technology, a "good enough" interface for it, and encourage the creation of compatible applications that have great user interfaces. See https://en.bitcoin.it/wiki/Proper_Money_Handling_(JSON-RPC) for relevant advice.As Pieter says, bitcoin converts all user-entered values and JSON-RPC values to fixed-point 64-bit integers as soon as it gets them. All calculations except for that conversion are done using 64-bit integers.Bitcoin does not "use floating point", it parses numbers-containing-a-decimal-point values that come from JSON (the Number type in JSON is double-precision float; let's not restart the "we should pass numbers as strings in JSON" debate, please, there are several long threads from a couple of months ago about that) or from the GUI. Testnet faucet is up and running if you need testnet coins:  https://testnet.freebitcoins.appspot.com/Although I've mostly been using testnet-in-a-box for testing recently:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ Can you make one that says "I am NOT Satoshi Nakamoto" ? I'm going to keep the main Faucet closed until the 0.3.23 client with default 0.0005 fees are in place, and I'll drop the reward to somewhere around 1 millibitcoin (which, at $30/BTC, is 3 cents). I think I meant to post my version and just got busy and forgot... Buying lots of bitcoins with dollars, driving the price up (and maybe creating an expectations bubble), then waiting for the price to stabilize before selling all you've bought (hoping to create panic selling) would, in my humble opinion, be an effective attack by anybody who had a lot of money to spend, didn't mind making the owners of the bitcoin exchanges very wealthy, and wanted to create fear, uncertainty, and doubt in the bitcoin market.Of course, if there was somebody with a lot of bitcoins willing to sell on the way up and buy on the way down to stabilize prices...
No, there's no way. No, they're always mixed. If you're worried about a "fund account with tiny bitcoins" attack, you should charge users that fund accounts with gazillions of tiny transactions an "excess account activity fee."  I've been thinking about writing code for ClearCoin that does that, but at least so far it doesn't make sense for me to spend time doing that.And see:  https://github.com/bitcoin/bitcoin/pull/285   for the current thinking on how to handle fees at sending time. 40 cents per visitor is definitely too much; I've set the Faucet to "down for maintenance" again, and will keep it that way until two things happen:1. I change the amount awarded.  and2. bitcoin version 0.3.23 is released with lowered fees, so people can actually SPEND the bitcoins they get from the faucet. Really?  I've been encouraging alternative implementations, who is the power-hungry core developer?Ok.  Start here:  https://github.com/bitcoin/netspecOr here: https://en.bitcoin.it/wiki/Category:Technical If it is any consolation, I made the same mistake a few days ago (and am still waiting for the 25 BTC to appear in my account...) I wrote a blog post about this:  http://gavinthink.blogspot.com/2011/06/but-you-can-use-it-to-buy-drugs.html Exactly right. I will to do what I can to help the police catch scammers and crooks who want to steal from people.  The police might use those same tools and techniques to help catch people who use bitcoin to pay for drugs; I can't stop them from doing that.I personally don't think drugs or gambling should be illegal, because I believe you should be free to do whatever you like with your own body and your own money. But I also believe those are separate issues from bitcoin, and if I felt really strongly about it (it isn't one of my own personal hot-button issues) I would be donating money to, or volunteering to work for LEAP and NORML, not mixing "bitcoin is a great new technology" with "drugs should be legal." Really?  The testnet faucet didn't get them.By the way: what's going on with the testnet?  Is/was somebody playing around with "I've got more than 50% of the hashing power" attacks? Ian:Great letter! I agree that the "stop campaigning for bitcoin's destruction" message might backfire, and the message should be "we're an innocent bystander here." You might even offer to help law enforcement better understand bitcoin so they can develop tools and techniques to catch criminals who use it.I've been thinking of how to react to this story, and am tempted to appeal to people's greed/fear with a message of "your country may miss out on a huge new opportunity and be left behind if you try to stamp out innovative new technologies like bitcoin." My mistake; I didn't test some new code thoroughly enough.  Fixed now. First, don't sudo; there is no reason for bitcoin to run as root.Second:  it isn't done downloading the block chain.  I just checked a bitcoind I've got running on an Amazon micro instance, and it is using less than 1% of the CPU.  After you've got all 128,909 blocks the CPU usage should drop. Well... they COULD get punished for failing to relay.  Just drop/ban them if they're not sending you "enough" valid transactions. RE: Fee sheet:  won't work, miners will lie to get higher fees.RE: analyzing previous blocks to determine fees:  I think it could work. Keeping track of how long transactions take to get into a block and looking at what transactions are in past blocks would, I think, work pretty well.  Until/unless the criteria for including transactions gets really complicated.  And new clients that haven't seen many transactions (and so can't tell how long prior transactions had to wait before being included in a block) might be an issue.When we have multiple client implementations one of the ways I imagine they'll compete is to have smarter calculate-the-optimal-fee algorithms ("Use SpiffyBits(tm) and pay 2% lower transaction fees than the original bitcoin client!").RE: hashcash for transactions:  that is exactly equivalent to fees (because you could be hashing to earn block rewards instead of hashing to get your transactions accepted).RE: limiting number of small/free transactions that can go through a node in a given timespan:  we're already doing that.RE: canceling transactions:  are there really people who would rather have their transaction tied up for half a day because they don't want to pay a half-a-penny fee?RE: randomly dropping low-priority txns: interesting idea. I've been thinking that dropping the connection to a peer that is sending you "too many" low-priority transactions might be a good idea (where "too many" is maybe N standard deviations away from the number your average peer is sending you... or something....) No, because you're probably not directly connected to those pools, and the nodes you are connected to will drop transactions if they don't include the 'right' fee.Bitcoin already supports showing and sending less-than-0.01 BTC amounts.  It is just smart and only shows 2 decimal places instead of always showing lots of extra zeroes. It costs the bitcoin network something like 0.001 US cents to process a typical transaction, so transactions less than about a cent don't make sense.RE: using market forces for transaction fees:  I agree 100%.   But that code has to be written and thoroughly tested.  The hard part is figuring out how miners communicate their "fee schedules" to clients (you can't just ask miners "what's your fee schedule" because they have an incentive to lie to try to get higher fees...).So in the very short term fees are being dropped from 0.01 BTC per kilobyte to 0.0005 BTC per kilobyte.I'll say it again:  expect more growing pains like this.  There will be more of them. Start here for possible holes:  http://scholar.google.com/scholar?q=%22mix+networks%22 The current plan is to password-protect private keys in the wallet and unlock them when coins are sent (with an option to 'remember the password' for a certain period of time) for the 0.4 release.That doesn't completely fix the problem (a keystroke logger can get your password, and a virus can insert itself so instead of sending 10 BTC to your grandma in Boise it makes bitcoin send your entire wallet balance to Little Bobby Blackhat).To almost completely fix the problem transactions would need to be created on one device and then verified on a second device.  Assuming both devices aren't infected/compromised, that will be safe. The two devices would be your computer and something else-- maybe a website, If anybody has experience with that type of cross-device security/programming and is interested in helping Bitcoin out, help would be much appreciated. Technical growing pains like the ones we're dealing with right now-- IRC channel filling up so new people are having trouble connecting, BTC/$ going up so the 0.01BTC transaction fees are too high, etc.  There will be more of these as transaction volume increases, some in the core bitcoin code and more affecting bitcoin-running websites (who will find they have to upgrade their servers to handle increased volume/users, etc).Legal growing pains.  I expect somebody doing something illegal and using bitcoins to help do it will get caught, put in jail, and that will be mis-reported as "bitcoins are illegal!"  I'd say there's a 1 in 5 chance of bitcoin being made outright illegal in the USA, but I also know that I'm terrible at accurately predicting stuff.Security growing pains. My biggest worry is what to do about non-technologically-savvy people running bitcoin on a virus-infested personal computer or mobile phone and losing all their bitcoins the first time they enter their password (I'm assuming their wallet will be password-protected) to send a couple coins to their friend.And just plain new-technology growing pains. Expect some (maybe most) bitcoin-related companies to fail, because most startups fail. Some people will lose money when they do.Again, I'm optimistic because there are, and will be, lots of motivated people working to solve all of these problems, and because I believe the core technology is solid. But I don't expect smooth sailing. If I worked at AMD, I'd suggest that.I started my professional career at SGI, writing 3D graphics demos and benchmarks, some of which were used to "burn in" the new hardware.  Running a bitcoin miner along with a couple graphics demos (to exercise all the graphics hardware) might be a good way for ATI to make money on their burn-in process.
I'm optimistic about bitcoin because of two metrics:1. Lots of people are interested in it, all over the world.2. There are lots of interesting, innovative projects being built around bitcoin.It is still VERY early days, and I'll say it again:  expect growing pains. A huge block-chain re-org on the testnet confused the heck out of the testnet faucet (leaving it with lots of 0-confirmation, used-to-be-valid sends that made it think it had a negative balance).Clearing its wallet of the 0-confirmation transaction fixed it, but left it with a very small balance.  It is up and running (at https://testnet.freebitcoins.appspot.com/ ), but if you generated a bunch of testnet coins, please send some to the testnet faucet at miGuMc6qtVEKS6Pf1jKddaa81DeHjMzkpB .Also, for anybody who doesn't know about it already:  I've been using testnet-in-a-box (thanks Mike!) very successfully for testing.  It gives you a nice, well-defined, controlled environment for reproducing bugs.  Get it from:  http://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ Diversifying is a good strategy.I wouldn't trust that an Internet cafe computer was safe; if I were you, I might buy some bitbills ( bitbills.com ) and have them mailed to your home address.  I ordered some bitbills shortly before I left for France and the mailman delivered them to me with the rest of my held mail when I got home. What theymos said.  There's another thread about this, too, and I'll ask here what I asked there:  what is the use case for an 'estimate transaction fee' function? What if the estimate is wrong, what would your application do? Depends on your definition of "micropayment".  Bitcoin is not suitable for transactions of less than a US penny, because of its fixed costs of processing transactions. Yes, diversity is good. If you do decide to go for it, do lots of testing on either the test network or with a testnet-in-a-box setup before even THINKING about handling real bitcoins. If you screw up and lose other people's money it will take a long time to earn back their trust.Oh, and speaking of trust... unless you have a recognized Brand Name, I don't think you'll have any success with a closed-source client. I flagged it as scams/fraud.It'll be interesting to see if scammers/fraudsters manage to pull off many "big scores" -- in the age of instant Internet feedback and crowdsourced self-policing, it might be tough. I fixed ClearCoin (restarted the bitcoind daemon) as soon as I got home; I apologize again for the service interruption.  I can't yet promise it won't happen again-- I'm still a single point of failure for ClearCoin.  But I'm working on changing that. I split this topic from the Public Relations thread.  Apologies for any mistakes I made selecting which posts to split.For the record:  I think a main block chain reset is a terrible idea. Bitcoin isn't suited for transactions worth less than about one US penny-- it wasn't designed or intended for lots of micro-transactions.That said, building a micro-transaction system on top of bitcoin is certainly possibly (see witcoin or youtipit for some examples-- or see the way the Bitcoin Faucet is handling payments recently, bundling up lots of small transactions to send them without paying outrageous fees). Sounds like this is good for pool operators that have high 'getwork' loads-- have any high-volume merchants sites or e-wallet sites tried it?I've got a long list of things to do when I get back from vacation week after next, or I'd volunteer to run it on the Faucet to help stress test it. Huh?  That's backwards, transaction fees are smaller (as a percentage) if you're sending more BTC.  Number of bitcoins being sent doesn't matter, number of inputs and outputs to the transaction matters.RE: estimating fees beforehand:  what is the use case where that is actually useful?  What do you want the user experience to be?And what happens if the estimate turns out to be wrong? June 14th at CIA HQ, Langley Virginia.  It is not open to the public, conference is for the US intelligence community only. If only the FAQ was a wiki that anybody could edit, then thedrs could add it him or herself...(hey, wait a minute!  it IS a wiki!) Released, transaction id fe5ee70feac0db3963d20fa746257ec18fec7379f90ca6a1ef4c1df564c6e413I'm still not sure why they didn't release automatically; they should have.  Debugging the problem fully will have to wait until I am back home on my main development machine.  If anybody else has the same problem, send me an email and I'll fix it ASAP. If the network was split 50/50, then each half would generate blocks half as fast.  So it would take 34 hours.For an "Egypt splits off from the rest of the network" scenario, it would probably split something like "less than 5% generated in Egypt, 95% rest of the world" in which case it would take 17/.05 = over two weeks for the blocks generated in Egypt to mature. Sure.  But if They sent you some of the bitcoins that were in that wallet then They might be able to track you down when you use those coins at a Ferrari dealership that is cooperating with or run by Them. For debugging your own sites, a testnet-in-a-box setup is nice and stable, completely under your control, and has a good supply of mature coins to debug with. See http://sourceforge.net/projects/bitcoin/files/Bitcoin/testnet-in-a-box/ Bad peer code that drops the connection and refuses reconnection seems like a good denial-of-service prevention measure.My only hesitation is accidentally causing a network (and, therefore, block-chain) split if "bad" turns out to be "my peer is running a newer version of the protocol and is accidentally sending me messages I don't understand."RE: net neutrality:  if you have to worry about your bitcoin traffic being shut down, I think that problem is better solved with TOR or another network proxy solution. Search the forums for "Sybil attack" and you'll find relevant discussion.
I'm looking forward to meeting everybody-- I be at the big red spider thing at 12:30.I've got a temporary mobile phone, number is: 06 19887172 Ooh!  Ooh!  50 more bitcoins for the "Bitcoins Lost Forever" thread! If processing old transactions becomes expensive, then miners will start charging transaction fees to include them in their blocks.Speculating about exactly HOW the miners will charge (will they subscribe to an 'old transaction service' or somehow contact the old-transaction-spender for the merkle branch of the old transaction?) is a waste of time, in my humble opinion. The only reason I can think of is it relies on the boost::xpressive regular expression parsing .hpp, and that slows down the build.I did refactor most of this into a rpcmonitor.cpp file; rpc.cpp was getting huge, and was taking a ton of memory and time to compile. RE: moving to another hashing algorithm for bitcoin addresses:Did you read what Satoshi wrote?If you want to make money, you are far, far, far, far, far, far better off using your hardware to generate blocks than trying to find a bitcoin address collision and steal bitcoins.  Potential address collisions are not a weakness, and switching to another algorithm would be just busy-work for us developers who should be spending time on REAL weaknesses (like figuring out how to make bitcoin more secure against trojans and viruses). I vote for removing dead code; less code means less bugs, and less chance of security issues.  The source control system is the right place for code that we "might need again someday..." If I understood the paper correctly (I skimmed it very quickly), this is a timing attack that requires the attacker send a bunch of things to be signed with the same ECDSA private key.The good news is it they also give a patch to OpenSSL to fix it.  The other good news is bitcoin only signs things with private keys when you send coins, and if you have the ability to ask bitcoin to send coins then we don't really care if you can get the private key.We do have a patch in the "pull queue" that adds a RPC command to let bitcoin sign stuff ( https://github.com/bitcoin/bitcoin/pull/183 ), but, again assuming I read the paper correctly, even that doesn't worry me, since if you have the ability to run that RPC command you could either go through all the trouble of the timing attack to figure out the private key... or you could just issue a "send" command to steal all the bitcoins out of the wallet. I'm just quiet because I've been busy being jet-lagged and sightseeing in Paris. So with the recent avalanche of press interest in bitcoin, I thought I'd share my thoughts on how I'd like to see bitcoin positioned.  I'm not writing this as "This is the Official Bitcoin Organization Position" -- as always, I expect everybody to have, and express, their own views.I'll restate what I see as the goal of The Bitcoin Project:  To give us control over our finances by establishing a stable, secure, global, "democratic" currency.I think positioning bitcoin as "revolutionizing the financial system" is the goal-- not more radical statement I've heard (like "destabilizing governments").  Most people either like or are indifferent to their governments (I know, I know, sheeple and all that... lets not go there).  I don't think most people get the warm fuzzies when thinking about bankers and Big Corporations; bitcoin as "The People's Money" is the right way to think about it.Also, whenever I talk to the press, I try to be realistic.  Bitcoin is still an experiment that has never been tried before; there is still a good chance it will fail, and there is still a lot of work to do to make it stable and secure.  I'm excited because bitcoin is a big idea that might change the world for the better, but I also realize that our little project is just a baby compared to the decades-old financial systems that we all use every day.I think it is important to set expectations; I still wouldn't recommend that my mom use bitcoin for anything just yet, because it is not easy enough to use securely.  And the road ahead is likely to be bumpy; there will be technical issues that need fixing, there will be legal questions, there will be price bubbles, and there will be scams.  I predict that some company using bitcoins to do something illegal will be caught and prosecuted, and that will be mis-reported as "Bitcoin is illegal."I said a year ago that creating solid technology was just the first step in a long road for bitcoin.  I'm very pleasantly surprised at how far the bitcoin project has come in a year; the innovation and experimentation and level of interest and excitement is fantastic.Here's an email exchange I had with a reporter yesterday:New technologies are always at least a little bit dangerous-- they can usually be used for both good and bad (think of gunpowder or ChatRoulette), and are certainly dangerous to the status-quo that they replace (think of cars and buggy-whip-manufacturers).Bitcoin is a really ambitious project; we're trying to let people take back control of their money instead of trusting bureaucrats or bankers or politicians to keep it stable and safe. It is international, decentralized, and completely open to innovation, very much like the Internet.  Like the Internet, I expect its early years to be full of amazing successes and spectacular failures, and I don't think anybody will be able to predict in advance what will succeed and what will fail.I think the real question is whether or not bitcoin will appeal to the majority of people who are happy with our current financial system. If it doesn't, bitcoin may fade away or end up as a niche currency used for a tiny percentage of global financial transactions. I'd suggest removing/replacing the "it is anonymous" claim.Anonymity and bitcoin is...complicated.  I'd suggest:"It is like cash" -- no one can steal your identity Sure, we'll call it GavinCoin and I get all the coins to start.If you want some, you just send me some of that worthless fiat currency that you have laying around.Sound good? That is exactly what -connect does (if I recall correctly; you might need -connect and -nolisten together). Just think of that guy who gave away 10,000 bitcoins through the Bitcoin Faucet... No, no, no and yes.  I'm planning on making the answers to all of those questions "yes" within the next six months, although I need to look at how many bitcoins are contained at any given time in the ClearCoin wallet; it might make more sense to send double or triple that amount of bitcoin to a publicly verifiable address, prove I own the coins, and guarantee any losses due to ClearCoin getting hacked.(note: I just looked, and right now there are 540 bitcoins in the ClearCoin wallet, so spending $50,000 to protect them really wouldn't make sense).Yet another bitcoin chicken-and-egg problem that will get solved by investors taking a risk and giving bitcoin entrepreneurs the resources to do security right (or wealthy entrepreneurs stepping up and making the investment themselves). My advice:  don't reinvent the wheel.  There are already standards and organizations dedicated to security practices surrounding currency, both physical and virtual, and financial transactions.  It doesn't really matter if the currency is bhat or bitcoin, the principles will be the same. They haven't paid the ECDSA price.  The decision is "I know how big this transaction, how many OP_CHECKSIG opcodes I'll have to compute to verify it, and how much transaction fees it pays.  Should I do the work of verifying it or should I just ignore it?"@ribuck:  yes, the UI would be much simpler, but internally the client needs a model of what the miners are accepting.  Maybe a really simple internal model will work if the UI is really simple... Would it be good enough if I volunteered to write a little perl or python or php or bash script that reads the passphrase from a file descriptor and then posts the right JSON-HTTP request?If the consensus is to teach bitcoind to read arguments from file descriptors, somebody please figure out if there's a standard for how other unix apps do that.  Here's what curl does: In the long run, block size will NOT be the bottleneck, so it will NOT determine the marginal cost of a transaction.The bottleneck is, and I believe will continue to be, the number of ECDSA signature verifications a miner can perform per second.  Each miner (or mining pool operator) will have a transaction processing capacity of N transactions per second.If there are more than N transactions per second going across the network, then the smart miners will select the most profitable N for inclusion in their blocks and drop the least profitable.And the smart miners will keep track of how much it would cost them to invest in more CPUs or specialized ECDSA-verification hardware so they can process N+M transactions per second.  And figure out how much they would make in fees or side-deals (or whatever) when they handle those extra M transactions per second.  If it is profitable, they will increase their transaction processing capacity.I think what bitcoin is missing right now is code in the clients to figure out the "right" amount of fees.  We're currently relying on hard-coded rules that match in the client and in the miners (because it was All One Application to start).  We need to move to something more dynamic.  Some thoughts I jotted down last night:Users want to know what fee to pay, given the constraints "I want this transaction confirmed in B or fewer blocks with probability greater than P".If we think of that as an equation:Code:fee = f(txn, B, P)... then the question is can a client estimate f by looking at the block chain and/or observing transactions as they fly across the network and (eventually) get included in blocks?  Or can we come up with a protocol to communicate f between clients and miners? My rule of thumb is "never inline methods more than 1 line long."Unless you're doing something super performance-critical, in which case my rule of thumb is "don't change anything until after you've written a realistic benchmark."But I'm an old-fashioned C++ coder, kids these days seem to want to put all the code in .hpp files. To be completely sure you get all the donations you deserve, you should put the donation address on an https:// page.Otherwise hackers can hijack http: pages if they can insert themselves into the network between you and your web visitors, and replace the donation address on the webpage with their bitcoin address.
Random thought RE: passwords and RPC:I was thinking a better way of handling the password might be a new RPC command:walletpassword <password> <timeout>... which would store <password> in memory for <timeout> seconds.  If you know your server is secure, you'd give a very long <timeout> at startup.That same <timeout> mechanism might be very handy in the GUI (somebody who knows more about password security might have something intelligent to say about the tradeoff between the risk of storing hashed-password in memory versus the convenience of not having to constantly re-enter it).A walletpasswordchange <oldpassword> <newpassword> seems like it would be very handy, too.Tacking <password> onto the beginning of RPC argument lists seems like the wrong thing to do. To get even more "meta" : ask yourself why anything has value.Tools, like hammers or cars or pants, have value mostly because they're useful and it takes effort to create them.Some things have value because they're beautiful or rare.Bitcoins have value because they are useful and rare.  As more and more people use them, they're useful for more and more things-- so their value will increase.  A lot of the current value of bitcoin is people who realize this and are trying to 'buy in early' -- they think that bitcoin will be used for more trading next year, so the value will be higher, so they want to get some now before the price rises.I have no idea what the "right" value for bitcoin is, but I am very encouraged by all of the fantastic, innovative ways people are using bitcoin.  I expect most of those experiments will fail, and I hope that everybody realizes that there will be lots of failures along the way to what I hope will be a huge success. Downgrading does not "fix" it.  The earlier version would broadcast the transaction, and then it would (most likely) either sit in the network with 0 confirmations for half a day or sit on your machine with 0 confirmations for a few hours, until it aged enough to graduate from the 'very low priority' category.The rule of thumb is 1 BTC you just received needs 144 confirmations (1 day) before it is considered 'normal priority.'  10 bitcoins requires 1/10'th that-- 15 confirmations would do it.Given the recent rise in bitcoin value, I think it makes sense to modify that formula so 1 BTC takes (perhaps) 10 confirmations to be considered 'not likely to be spam'. Yes, the 0.3.21 release will charge a fee if you want to do things like send 0.05 bitcoins to yourself.Why?  Because some people were sending 0.05 BTC to themselves over and over and over again, wasting everybody's disk space, bandwidth, and CPU time.  The fee is there to reveal the hidden costs of sending lots of tiny transactions.Next release the normal fee will be dropped from 0.01 BTC to 0.0005 BTC.The long-term goal is to figure out how to make fees dynamic; maybe in a few months you'll get a slider that lets you choose fees on a transaction-by-transaction basis, and will show you how long you're likely to wait for various amounts of fees... Good, that looks like it will be easy to find. Yep, if you control more than 50% of the hashing power you can just refuse to work on anybody else's blocks and your chain will always eventually be the longest.Of course, if you do that there will be constant block chain splits and transaction confirmations will take twice as long (because you'd be throwing away the other half of the network's hashing power), so we'd all notice.And I'm pretty confident we'd think of an effective way to ignore your blocks.  Seems like an awfully big risk for a +50% pool operator to take; why would they want to undermine the system that is (almost certainly) making them lots of money? I think sipa is right-- it will just look like a weird double-spend.Probably a good idea to reject transactions with non-canonical signatures (reject if encode(decode(tx)) != tx ).I assume the DER-encoded ASN.1 octet representation is the same between different ECDSA implementations (so if a non-openssl-based implementation creates transactions its transactions would be accepted), is that a good assumption? I like "mills" or "millies".The new default transaction fee is 5 mills per kilobyte, by the way. daemon=1... is the right syntax for the conf file. That'd be exactly when the power goes out. I make the Amazon virtual machine images that I used to build the Windows and Linux binaries available... but Amazon recently took them down because they contain my ssh public key in the "allowed to login without a password" file. Removing the public key and then making the modified virtual machines public again is on my TODO list (Amazon doesn't want anybody to have a 'back door' into a public machine image, and bravo to them for checking-- I had no intention of logging into other's bitcoin-build-environment virtual machines, I just needed an easy way to login while I was putting together the releases).If you have an EC2 account, you can run them and recreate the exact build environment and check to make sure you get exactly the same executable code  (the compilers may put timestamps inside the files which you'd have to ignore).The plan for future releases is to use devrandom's 'gitian' build system, which is a spiffy way of creating a well-defined virtual machine image from signed and trusted repositories, fetching a specific version of the code from the git source tree, and compiling in a way that is completely reproducible. See: https://github.com/devrandom/gitian-builder If you're willing to muck with the transaction processing code, you could only allow transactions to addresses that have been created and blessed by the Central Authority.  You'd have to also teach the wallet code not to create lots of addresses, but if you're going to require users to register and not be anonymous you might as well centrally create and issue them their wallets.You then need a mechanism to broadcast new, blessed public keys to the entire network, but that might be as simple as generating a transaction from a baked-in blessed address (owed by the Central Authority) to the newly created blessed address.Implementing and debugging would be a lot of work, and I'd be nervous about neglecting some little detail and leaving the system open to hacks (Bitcoin is nice because so many people are extremely motivated to find any chink in the system and either exploit it or patch it-- a small complementary currency wouldn't have that advantage).  But it could be done. This is where I think maybe a standard https-based protocol might work nicely, so the same address shortening services can be used either in the bitcoin client and for online e-wallets.Something simple, like user says "Please use these services for resolving addresses:   https://bitdex.net/resolve   https://btcquick.com/resolve   https://mtgox.com/finduser"Protocol could just be POST the text the user types into the address field and get back JSON with a bitcoin address and maybe some extra information to reassure the user that they're paying gavin@acm.org "Gavin Andresen (my picture) (my gpg key fingerprint)" and not gaven@acm.org "Gaven Smith (some other guy's picture) (no gpg key fingerprint)" ... Oh, and what version of bitcoin are you running?  0.3.21 includes a patch from luke-jr that modifies the coin-selection algorithm to avoid sub-cent change when possible.It will also help if you keep a good selection of 'old' coins in the shared wallet.I agree that transaction fee accounting/handling needs improvement. Looks ok to me, assuming $account and $address are strings and $amount is a number. The send RPC methods return a transaction id.Pass the transaction id to the gettransaction RPC method, and it will give you details of the transaction, including what fees were paid. In the future, there will be many more than 4,000 transactions per block. -nolisten turns on -noirc.Try:addnode=69.164.218.197... to connect to the testnet Faucet bitcoind. The input-transaction-selection algorithm in bitcoin tries to use older transactions, which will have higher priority.I'd guess that online wallets with lots of users have plenty of old transaction to choose from, so they don't need to pay transaction fees.  Actually, it'd be interesting to try to measure how quickly the average bitcoin in an e-wallet stays in the wallet before being used for an outgoing transaction... Neat idea!  All sorts of chicken-and-egg hurdles to overcome (what good is a bitcoin loan if there is nothing to spend the bitcoins on?), but microlending bitcoins would be great.  I'm spread a little thin at the moment, but if you think a conversation with kiva right now might be worthwhile then go for it.  You don't need anybody's permission or advice to become the Bitcoin-Kiva Liason Officer.
Your 0.07 transaction is very-low-priority, and still waiting to get in a block.  From bitcoincharts:Code:2011-05-11 15:34:58 2cf664377d1923089d0aed9d7aab3f8d51f69c76409a71e3d88b378a13e3612eThis is a low priority transaction.size: 258 bytespriority: 12,250,000input: 0.12900000 BTC0.12900000 BTC from 9bea18121283bc7f9618eb8b50ce94e9df4698eb51468152fa686bfe94387d2d:0 (1CM9WjjPScLSfQaYXq9YY5VgqUh6bP87rw)output: 0.12900000 BTC0.07000000 BTC to 1KCJ79R4CexWmqK6qa2HBeFv8bG3a3wAfX0.05900000 BTC to 14Q7k5u5UAhEWC5E52BGwLVFKWeW3ffBtAIt might take a few days, but it will eventually get confirmed. Why would you "bring up the issue" ?Just declare bitcoin-related income or capital gains as income, and bitcoin-related expenses as expenses, translated into units that the IRS understands (dollars), and follow the rules for WHEN you must declare income, capital gains and expenses and I bet a bitcoin you'll be just fine, even if you get audited. That's actually a very hard attack to successfully pull off; I file it under "theoretically worrisome, but practically not a high priority."It is hard because:  + targeting a particular node is hard.  The long-running nodes that you probably want to target (merchants or exchangers or e-wallet services, where double-spending could get you a significant number of bitcoins) will already have 50+ connections to legitimate nodes, and an addr.dat full of the addresses/ports of legitimate nodes.  + you have to feed the target a bogus version of the block chain.  And you won't be able to feed them new blocks very fast, because difficulty is so high (unless you invest a ton of hashing power to generate bogus blocks... but that's stupid, you're wasting money mining worthless blocks so you can try to pull off a probably-low-value double-spend???).  Anybody you target is going to wonder why their transactions are taking so long to confirm and why their block count is falling behind everybody else's.Putting a few addnode=...  to connect to trusted nodes (with static IP addresses) at startup in your bitcoin.conf is a good idea.  For (3), detecting dramatic, statistically-nearly-impossible-normally changes in the hashing rate is a better way to detect sybil attacks.  That's on my personal "it'd be nice to have" list (because, as I said, I don't think this is a big threat). All this talk about neato-spiffy future hub-and-spoke supernodes-and-leaves architecture is great.But I was kinda thinking of first solving the problem that anybody who just wants to download the client, get a few coins from a friend, and then spend them on something has to wait a very long time right now.  That doesn't require any re-architecting of the system or any new networking messages, and should make the "out of the box" bitcoin experience much better for lots of people.And it is a step towards a future neato-spiffy Uber-efficient hyper++client. Because that requires that you do some math to figure out how many to send to pay the escrow plus release the right amount.And because I'm planning on eventually implementing "receiver creates and pays" escrow transactions, so merchants can setup escrow transactions (via the API) for their customers.  Merchants are used to paying fees as just a cost of doing business.RE: how will I prevent you from creating new escrow transactions if you don't pay?  Click on "Create Escrow" and you'll be taken to a page that politely explains you're not allowed until you pay.  If you use the API, the create_escrow call will fail.I realize some people may try to cheat by using/creating multiple Google accounts.  That will be a cost of doing business for me.  Perhaps I will reserve the right to publish deadbeat account email addresses on a "hall of shame..."  (I'd implement a Terms of Service Agreement to which you would have to agree before creating a new escrow)RE: will this affect coins in existing escrow accounts:No, existing escrow accounts will be unaffected, these new rules will be for new escrow accounts only. I've been working on making the ClearCoin escrow service's fee structure simpler; here's the new structure, which will "go live" in the next day or two:ClearCoin costs 0.5% (one half of one percent) of released coins. For example, if you are paying for something worth 100 bitcoins the cost will be 0.5 BTC.Fees are paid only on released coins; no fees are charged on coins donated to charity or refunded to you.Coins in escrow will never be taken or held if you have unpaid fees; if you do not pay your ClearCoin fees within 30 days we may prevent you from creating new escrow transactions but will never prevent you from releasing coins from existing escrow accounts. However, given how quickly the value of bitcoins has been increasing recently, it is better for you to pay your ClearCoin fees quickly.Any month you accumulate more than a trivial amount of fees ClearCoin will email you an invoice with a detailed list and a bitcoin address to which you can send payment.  You can also pay at any time by sending bitcoins to an address on the ClearCoin website.All of these changes were prompted because I think it was confusing to pay fees directly from the bitcoins being used for the transactions-- if you were paying for something that cost 159.95 BTC, calculating how much to send to pay for the cost AND ClearCoin fees was complicated.  This should also be much easier for anybody creating a lot of ClearCoin transactions via the new ClearCoin API.As always, feedback, complaints, and suggestions are welcome. Raw dump of the notes I got from Satoshi with the headersonly patch (which is in the git tree as headersonly branch):My plan was to dive into what Satoshi wrote already, understand it, test it in fClient=true mode (sending/receiving/relaying transactions on testnet), fix whatever is broken/unimplemented.And then write code to switch from fClient=true to fClient=false, downloading full blocks, etc.  And then writing code that does the toggle when generation is turned on for the first time or when getwork is called (I think those are the only times you need full blocks).I haven't looked at or thought about the relaying code.  Simply relaying all transactions (without checking to see if they're valid) if fClient=true should work nicely. If I were going to implement it...  hmm...I think I'd just special-case the genesis block, so it has a value out of, oh, I dunno, 20 million CompleCoins.  Then maybe fix the mining reward to something small and constant (say 0.001 CompleCoin per block, forever-- or whatever you like).The central authority would create the genesis block, and so would have 20 million CompleCoins that it could issue (aka spend) however it pleased.The risk would be the central issuer ever losing control of its wallet/private key.  That risk could be mitigated a little bit by occasionally changing the key by spending all of the non-issued coins to a new address in a new, secure wallet somewhere and waiting a few blocks for confirmation.I'm having lunch today with somebody else who is interested in using bitcoin tech for a centrally issued alternative currency, so I've been thinking a bit about it... I'd tweak the formula to be:  max block size = 1000000 + (int64)(difficulty)... just to avoid "if block number is < X max block size = 1000000 else..." logic.  Adding in the current 1MB max limit means all the old blocks are valid under the new rule.I like Mike's point that difficulty and transaction volume aren't necessarily related.  Maybe a better formula for miners would be something like:max block size = 1000000 + (average size of last N blocks in the best chain)... where N is maybe 144 (smooth over 24-hours of transactions)Anybody have access to what Visa daily transaction volume looks like in the days around Christmas?  Are there huge, sudden spikes that the above formula wouldn't handle? So whenever you meet (or communicate with) somebody who owns bitbills check your bills' public address against their bills' public address.  If there is significant counterfeiting going on, eventually you'll find a match.  Try to redeem both and you'll quickly find out which is real and which is counterfeit (or that both are counterfeit).I was going to suggest creating a public Google Documents doc where people could enter their bitbill public keys, but griefers could just look at the block chain and pretend that they were holding bitbills that they don't actually own. Wait a while and they will be free again.If you are sending 1 BTC (that you just received) in a 250 byte transaction, you need to wait 24 hours (1 day).Send 0.25 BTC, you'll need to wait 4 days.Send just 0.01 BTC as a 250 byte transaction, and you need to wait 100 days before you'll be allowed to send it for free.priority is calculated as:  #BTC * #confirmations / transaction size.Very-low-priority is defined as less than 1 * 144 / 250   (1 BTC, 144 confirmations == 24 hours, 250 bytes), and they require a fee.The tentative plan is for fees to be reduced to 5 mils (0.005 BTC) half a mil (0.0005 BTC) for the next release.  Changing the definition of "very low priority" at the same time probably makes sense.(corrected proposed fee) giraffe.heliacal.net is also known as irc.lfnet.orgCode:PING giraffe.heliacal.net (92.243.23.21): 56 data bytesPING irc.lfnet.org (92.243.23.21): 56 data bytesLaszlo runs that IRC chat server, and bitcoin uses it to "bootstrap" to find other machines running bitcoin.Unless you run with the -noirc switch, in which case it won't -- it will try to connect via a list of compiled-in 'seed nodes' (which I'll try really hard to remember to recruit somebody to update for the next release).After you've run bitcoin once, it stores nodes you were able to connect with in the addr.dat file, so you can run -noirc just fine.  But if everybody did that, newbies who just downloaded bitcoin would have a hard time finding people to connect with. bitcredit:  do you have ideas or suggestions?I think a global currency like bitcoin will do a lot to promote understanding and diversity, but did you have something specific in mind? Sure, I'd like to see a lot more banging on the testnet to try to break it.(python code is not obfuscated, I assume). Golly, journeyofrivers is really going to hate me when he finds out I'm an Elected Official and a Cog in the System.  Last night I voted to steal millions of dollars from taxpayers and give it to public (I know!  Terrible!) schools.(I'm only barely an elected official, one of 251 elected Amherst Town Meeting members.  My punishment is long boring meetings late at night a couple times a year...)Seriously, we probably agree on most things on a philosophical level.  I just believe I'll get farther by taking "small steps to a much better world." I shoulda butted in, I think I'm too polite to be on a show with Jason Calacanis... Extending the getnewaddress RPC call to take a [count] parameter would be easy.  Doing the same for the GUI would be pretty easy, too...    https://github.com/bitcoin/bitcoin/pull/215This pull is prompted by changes I'm making to ClearCoin, and should apply to any service where customers will owe the service bitcoins.   It removes the account balance checks from the RPC move command.I'll use it to create accounts associated with users that keep track of how many bitcoins they owe; for example, if I owed 1 bitcoin ClearCoin will tell bitcoin:  move 'gavinandresen' 'total_owed' 1.00Assuming I'm not carrying a balance, that makes the gavinandresen account balance -1.00 BTC.  When I pay to one of the addresses associated with the 'gavinandresen' account, the account balance will be automatically credited.If I were a professional accountant I probably would have written 'move' this way to begin with... Have you done any benchmarking to see if that is true? Fine, the entire transaction except for:  "The scripts for all transaction inputs in txCopy are set to empty scripts"... is signed.   You're starting to make me grumpy...
The entire transaction is signed.  See:  https://en.bitcoin.it/wiki/OP_CHECKSIG  for the rules. Agreed; that is the longer-term goal.  This is a short-term fix. No, it is not possible, there is a rule against that. Collusion to gain oversized-profits never succeeds in the long-term, unless there are artificial barriers to entry (like government regulations).I won't worry until our governments decide to pass the Officially Licensed and Inspected Bitcoin Generating Devices Law. Will all of the internationalization/translations from the wxBitcoin port straight over to qtBitcoin? No and no, in my opinion.I think being able to explain the block reward as "starts at 50 every 10 minutes and is cut in half every 4 years" is a big advantage.  I like simple-- "the simplest possible solution that will work" is a good engineering rule of thumb. Good idea:  https://github.com/bitcoin/bitcoin/issues/206 Why?  Thats years and years away.  I don't think any of us can predict exactly what is going to happen 10 or 15 or 20 years from now; I don't think it is possible to get a consensus now because there has never been a system like bitcoin before, so predicting how merchants, miners, and users will interact in 10 years seems to me to be impossible.So:  do you think this supposed problem will happen all at once?  Or will it happen slowly over time?  If you think it will happen all at once, would there be any warning signs?  If it is a problem that we can clearly see coming, then there will be time to react.I'm much more worried on the problems I see coming in the next year or two or three-- bitcoin-specific viruses and trojans, poorly coded bitcoin web services, and maybe bitcoin service operators getting charged with financial crimes that they didn't know they were violating. They tend to get put back together when you send larger payments.The algorithm that the current bitcoin client uses isn't the best possible algorithm for deciding when to combine or split coins; ideally, it would have some notion of how big your average transaction would be, and when sending coins it might split change or combine extra coins to make change that is about that big (so the next time you make a transaction there are old, previous, high-priority transactions it can use).If you ask nicely, I bet tcatm or somebody else will create a little web service that could tell you how long you have to wait for a 0.10 (or whatever) coin to mature before you can send it without a fee. Wednesday May 25'th bitcoin lunch in la Défense is on my calendar. The networking code is the same in either case, so it was almost certainly just a coincidence and you got unlucky with the peers you connected to running -server from the command line. The rules that the GUI (and bitcoind sends) follows to figure out if you should pay a fee are now the same as the rules in the block generation code.  The rules themselves didn't change. I learned long ago that it is much better to create a sub-optimal system that is simple and robust than to try to create a perfectly optimal system.Pretty darn good, with the right incentives in place to drive the long-term desired behavior, is good enough for me right now.  I think "we" have been pretty good at responding fairly quickly to problems as they appear.   I'm keeping a close eye on the free-transaction backlog, but I think tcatm's recent changes to http://bitcoincharts.com/bitcoin/ , showing transaction priority, and the recent change to the bitcoin client, so the default fee rules are the same for miners, relaying across the network, and the client, are working nicely. If your 0.33 bitcoins came from one or two recent payments to you, then waiting a day or three to let the inputs "mature" will let you send them without a fee.  The transaction priority fee rules are designed to discourage people from sending lots of small bitcoin transactions in a short time.If your 0.33 bitcoins came from 20 or 30 penny-sized payments to you, then you'll have to go to a lot of work to send them without a fee, because a 20- or 30-input transaction will be too big to qualify to be free.  The transaction size fee rules are designed to discourage people from wasting everybody's disk and network bandwidth by sending big transactions.If you did receive lots of tiny payments, you can try to bundle them up in chunks-- you might be able to send three payments of 0.10 BTC without a fee (because each of them would be smaller than the "too big to be free" size).But you should ask yourself:  is it really worth your time?  0.01 BTC is less than 5 US cents.  If it takes you more than 20 seconds to send 2 or 3 payments to avoid the 0.01BTC fee, then you're valuing your time at less than US minimum wage. Priority is a function of how many bitcoins are involved in the transaction (more is higher priority), the size (in bytes) of the transaction (smaller is higher priority), and the age of the transaction's previous transactions (older is higher priority).Your transaction is taking a long time because it involved only 0.14 BTC which you got from a transaction that happened earlier today.  If you were running bitcoin version 0.3.21, it would have required that you add a 0.01BTC fee to send it. This has been lingering for months, and got bogged down in discussions of some nifty new mega-efficient binary protocol for stuff.  That hasn't happened.  So:  https://github.com/bitcoin/bitcoin/pull/198This adds these new RPC commands:monitortx/monitorblocks: POST JSON-RPC to a URL when new wallet transactions or blocks are received.listmonitored: list URLS that will be POSTed togetblock: get information about a block, given depth in main chain.monitortx posts the same information you get from gettransaction.monitorblock/getblock posts:Code:{    "hash" : "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048",    "blockcount" : 1,    "version" : 1,    "merkleroot" : "0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098",    "time" : 1231469665,    "nonce" : 2573394689,    "difficulty" : 1.00000000,    "tx" : [        "0e3e2357e806b6cdb1f70b54c3a3a17b6714ee1f0e68bebb44a74b1efd512098"    ],    "hashprevious" : "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",    "hashnext" : "000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd"} No, the send-from address is not available, for a couple of reasons:1)  When people using a shared wallet service like MyBitcoin or MtGox send payments the "from address" could belong to any of the other users of the service (or could be a "change" address that doesn't belong to anybody).  It is a bad idea to think that "address == person".2) If more complicated transaction types are ever "turned on" in bitcoin, there might be more than one "from address".   Satoshi designed-in support for complicated transactions like "this payment can only be spent if 2 of these 3 keys sign the transaction".   In that case, there would be two "from addresses".If you need this to refund coins, you'll need to ask the customer for a refund address. If you want each receiving address treated as its own account, you can:setaccount <address> <address>... and then use <address> as the name of the account.And validateaddress will tell you what account is associated with an address. +1 I'll brain-dump my second half-baked idea of the day:github has a nice API for basically everything it does (issues getting closed,etc).I've been working on an API for ClearCoin (creating escrow accounts, etc).Marrying the two might work nicely.  Coders could publish their bitcoin addresses in their github profiles.Bounties could be established for bugs (or, grumble, features) by creating a ClearCoin account, linking it to the issue (maybe by posting a machine-readable comment via the github api).And when the issue was closed via a commit the bounty could be automagically paid to the coder(s) who contributed to the commit.  (somehow... via a yet-to-be-written way for ClearCoin to get a where-to-release-coins address that is not set in advance).Reasons not to do it:  allegations of corruption/favoritism if people doing the pulling have to decide between two pull requests.  Maybe less cooperation to find/fix things if people are competing for bounties.
Half-baked thoughts:Broadcasting policies makes me nervous-- it is too easy to lie, and there might be some advantage to lying.Couldn't clients infer all the information they need to know about what transactions/fees are being accepted by miners by keeping track of transactions in the memory pool and looking at the last 10,000-or-so generated blocks? Block 70136 has 0.03BTC in un-spendable transactions.9050+     0.03---------9050.03 TED is about "the vision thing"; somebody really good at public speaking and putting together compelling presentations should do it.Somebody who actually enjoys travelling around and speaking about something they are passionate about.  I want to spend my time building stuff, not talking about stuff.PS:  I think bitcoin needs another year of growth before it is TED-worthy. The project needs more bug fixing and testing, so I would rather NOT see bounties for new features.Bounties for fixing bugs would be ok.  And maybe a bug bounty, for finding significant bugs. +1 So, team:  anybody interested? I was actually thinking a return address would be a good use for the arbitrary-message-to-receiver OP_DROP transaction type.Maybe make a convention that bytes be a JSON dictionary, so it could be:{'return_address':'n2cGZYsiii1uAiDPM6ipPBqqXa4Z9bXh2t'} OP_DROP ...etc...... which would be inefficient (58 bytes to encode the 20-byte return address) but wonderfully extensible.And again:  I'd like to see experimentation on testnet. The latest version of bitcoin does try to avoid "sub-cent change" by adding more inputs.If it can't avoid it (e.g. you have 32.29 in your wallet and you send 32.28999999), then the sub-cent change becomes a sub-cent transaction fee.  It isn't lost, the miner that includes the transaction will get it. bitcoind doesn't prompt before adding fees because it is meant to be used by websites and other services where there may not be a person available to push an "Ok, pay a fee" button.  There might not even be a place to put the button, either.Your Transaction 2 paid a fee because it ran into the "small, low-priority transactions must pay" code that is new with version 0.3.21.  It was low priority because its outputs were small and its input was fairly new. Bitcoin 0.3.21 puts a 'bestblock' entry in the wallet so it will automatically -rescan if you restore an old wallet (and it only rescans the blocks necessary to get up-to-date). RE: agreed upon spot to place or distribute messages:I think it is time to start experimenting with a <bytes> OP_DROP OP_DUP OP_HASH160 ...etc transaction type on the testnet.And time to finish implementing headers-only-for-initial-download mode so new users don't have to wait so long to get their free Faucet bitcoins. You're suggesting:ECDSA_SIGN(SHA256(RIPEMD160(SHA256(public_key))+"fixed string"+message)) is more secure than:ECDSA_SIGN(SHA256("fixed string"+message))It sure looks more secure!  But maybe some super-smart cryptographer will tease out a relationship between all the hashing and signing in the first version and it will turn out to be less secure; maybe she'll figure out a way to factor out the private key if the public key is involved in the salt.I like the simpler version better. Neat idea!I don't like the economics of it, though.First, it reinforces the "if you started mining early you are rich only because you were lucky enough to be early" idea.  And a lot of people already think that is unfair; give the early miners a current mining discount and you're just "helping the rich get richer."Second, what stops an attacker from offering early miners $$$ for their (already spent) coinbase private keys?  If they have value because they give a mining discount, then there WILL be a market for them.  A wealthy attacker could just buy up as many as they can find and then take over the network with less hashing power... All command-line options (except for -datadir and -conf) can be specified in the config file. I launched a new version of the Bitcoin Faucet today, with a few changes:1. Payout is now 0.02 bitcoins (down from 0.05), to reflect the rise in value of bitcoins versus other currencies.2. Recent Sends page, showing scrambled email addresses and (not scrambled) IP addresses of the last 100 people to get coins from the Faucet.3. Behind the scenes, faucet payouts are bundled up and sent in batches every N minutes, to minimize the fees that the Faucet pays.I want to recruit some trusted volunteers to be "Faucet Police" -- if somebody notices a fishy pattern of either IP addresses or email addresses, I'll give the Faucet Police the ability to temporarily stop the flow of coins from the Faucet.If you're willing to help out and you've got a good reputation/history here on the forums, email me (gavinandresen@gmail.com) your google account information along with what time zone you're usually in, and I'll try to pick a couple handfuls of people so no matter what time of day or night, somebody will be awake and ready to turn off the spigot. "you didn't offer a fee" is misleading; the bitcoin software 99+% of people are using today doesn't let "you" very much flexibility in how you offer fees.  So basically, 99+% of people using bitcoin are charged fees based on a set of built-in rules.If you want to send a fee with every transaction, you can run bitcoin with the -paytxfee= option; there isn't much reason to do that now, unless you're generating lots of very small (few-bitpenny) transactions.  The Bitcoin Faucet is running with -paytxfee=0.01 because it DOES generate lots of very small transactions.From the wiki: tail -f ~/.bitcoin/debug.log... will show you what bitcoind is doing. Nothing against jav, but I think instawallet needs a month or three of 'soak time' to give the scammers and script kiddies time to try to break it (and to see how jav reacts to the scammers and script kiddies trying to break it...). The built-in coin selection algorithm already prefers using older coins rather than newer ones. Uhhh...  maybe a specific example will help.  Lets say you start with accounts/balances of:A: 5B: 5"": 1Total wallet balance: 11Now you send 5 BTC from A, and pay a 0.01BTC fee.  Account balances will be:A: -0.01 BTCB: 5"": 1Total wallet balance: 5.99The fee isn't 'taken' from either B or "".  You'll have to decide how to handle fees; for ClearCoin, I keep a positive balance in the "" account and automatically move coins from there if a transaction results in a fee (so for the above case, 0.01 bitcoins would be moved from the "" account to A, so A ended up with a zero balance and the fee is paid from "").
It is definitely an issue-- the account code doesn't keep track of where the coins it is sending out came from, so if you accept 0-confirmation coins you're vulnerable to double-spending attacks (see, for example, the discussion of the "Finney attack" in these forums).Seeing coins show up right away is a fantastic feature, though, so I'd suggest getting the 0-confirmation balance and a 3+-confirmation balance, allowing only 3+ confirmed coins to be withdrawn, and displaying the difference as 'waiting confirmation'. But they won't have the experience jumping through all the banking system regulatory hoops, or experience dealing with currencies other than bitcoin.I expect lots of successful bitcoin vault services, and I expect one or more of them to be purchased by one or more banks and made a part of the banks' money services business.  If they see bitcoin vault services making big profits, they'll want to own one.My predictions are frequently wrong, though.  Maybe US banks will fight bitcoin tooth-and-nail, or maybe the legal issues will be too unclear for any bank to risk getting involved. Fantastic idea!My only suggestion would be a "copy to clipboard" icon/link next to the funding address (I need to do that for ClearCoin, too-- haven't looked into how to do it yet, but github does it so I know it can be done...) You're running into the "very low priority transactions require a fee" rule.  Priority depends on the value of the transaction (fewer bitcoins == lower priority) and how long ago you received the bitcoin(s) (older == higher priority).That rule was in place for 0.3.20.2, but only for most miners.  Most would not include very-low-priority transaction in blocks until they were old enough to have a high priority.  The result was a big backlog of very-small transactions starting to build up.With 0.3.21, the rules are the same for miners, for relaying transactions across the network, and for the user interface-- if your transaction is very-low-priority, it won't get relayed and the user interface will insist that you pay a fee if you really want it transmitted RIGHT NOW.If you really really really need to send 0.01 bitcoins right now, then you'll have to pay the fee.  If you're willing to wait a while, you'll find you can send it without a fee after it is old enough and has enough priority.All of this is to discourage people from "penny flooding" -- constantly sending pennies back and forth to themselves without a fee just because they can.Footnote:  if you don't upgrade, you can send that 0.01 bitcoins without a fee.  But as everybody else upgrades, you'll find that it will take a long time for that transaction to get confirmed. 0.001 BTC at today's exchange rate is uncomfortably close to the estimated network-wide cost of processing a bitcoin transaction (which is about 0.001 US dollars).The danger is a flood of micro-transactions that keep everybody's CPUs busy, driving up that hidden cost and, eventually driving people to stop running bitcoin because the costs aren't worth the benefits.Also: lets not confuse the "how many free transactions" with "what is the smallest transaction amount you can send." I think there's a good chance (mmm... 65.3%) that within 4 years one or more of the largest 1,000 US banks will support currency exchange to/from bitcoin for their customers.Why would bitcoin be a threat to banks?  They're really good at securely handling currency; that's a valuable service, whether the currency is dollars or euros or bitcoins. We got a request a couple days ago for somebody to do an interview with a Brazilian radio station about bitcoin.Any volunteers? Yep, I live in Amherst, Massachusetts; my family moved to the US when I was 5 years old.I will be visiting Australia (Sydney for a couple of days then Tasmania for a couple weeks then Cairns for a week or two) in July. Me and my good friend Charlie will spend it on hookers and blow, of course. RE: Mac builds:  what BlueMatt said.  Despite using a Mac as my development machine, I am not a Mac developer-- I'm an old Unix developer at heart. I learned enough Windows "Win32-api" programming to create a couple of products, and I know a lot about web development, but I'm a newbie when it comes to making applications for the Mac.RE: wallet encryption:  I want encryption of wallet private keys (requiring you to enter your password to send coins) to be part of the next release, and I think that is a big enough feature to bump the next release version to "0.4".RE: x86-64 client:  for the Windows?  or for Linux?  32-bit should work find on 64-bit Windows, there's no real reason to do a 64-bit version.  For Linux, there should be a bitcoin in bin/64/RE: bitcoind not forking by default any more:  yes, that is intentional, and I forgot to mention it in the release notes.  When the mac binary is done I'll update the README.  Run bitcoind -daemon (or put daemon=1 in the bitcoin.conf file) and you'll get the old behavior. Wow, I new this would generate discussion... but wow!A couple of quick notes:noagenda nailed it-- I was contacted specifically by In-Q-Tel, the CIA's "look for interesting/promising new private technologies and then invest in them" spin-off.  I get the impression they organize the conference.  This year the conference is about money.They are serious about security; there will be no recording, and I will not be allowed to bring any electronic devices with me.  I am planning on posting my talk, and if I get my act together in time I'll try to post it before I give it so y'all can give me feedback.I'll be signing an agreement that I, or my company, will not use my appearance for publicity purposes.  So please, no unofficial "from the bitcoin community" press releases about this.If talking to them makes y'all trust me less... then good!  I'd like to see more careful code review, and, as others have pointed out, if bitcoin can be destroyed by one person, or requires the leadership of one person, then it has failed to be the strong, decentralized system that I think it is.RE: me == satoshi:  here's some C++ code I wrote 15 years ago:  http://oss.sgi.com/cgi-bin/cvsweb.cgi/inventor/apps/demos/revo/RevClass.c%2B%2B?rev=1.1.1.1I have a very different coding style from Mr. Nakamoto.  And I don't know nearly enough crypto to build something like bitcoin by myself.And one final note:  the US government is a really, really, really big organization.  Like any big organization, different parts have different motives and goals.  I hope I'll get a little tiny glimpse into what one part of that big organization thinks about bitcoin. Yup.  I think this might be the last release I do that, though...EDIT: Done, svn revision 251. I want to get this out in the open because it is the kind of thing that will generate conspiracy theories:  I'm going to give a presentation about Bitcoin at CIA headquarters in June at an emerging technologies conference for the US intelligence community.I accepted the invitation to speak because the fact that I was invited means Bitcoin is already on their radar, and I think it might be a good chance to talk about why I think Bitcoin will make the world a better place.  I think the goals of this project are to create a better currency, create a more competitive and efficient international payment system, and give people more direct control over their finances.  And I don't think any of those goals are incompatible with the goals of government.I'm only very slightly worried that talking about bitcoin at the CIA will increase the chances they'll try to do something we don't want them to do.  I think accepting their invitation and being open about exactly what bitcoin is will make it less likely they'll see it as a threat.PS: Full disclosure: I'll be paid a one-time fee of $3,000 to cover expenses and pay me for my time.  I don't want any "Gavin is on the CIA's payroll" rumors to get started, either...As always, comments and questions and discussion welcome.  I'd really rather not hear any conspiracy theories about how they'll secretly implant a mind-control chip in my head while I'm there, though.... -----BEGIN PGP SIGNED MESSAGE-----Hash: SHA1Binaries for Bitcoin version 0.3.21 are available at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.21/Changes and new features from the 0.3.20 release include:* Universal Plug and Play support.  Enable automatic opening of a portfor incoming connections by running bitcoin or bitcoind with the- -upnp=1 command line switch or using the Options dialog box.* Support for full-precision bitcoin amounts.  You can now send, andbitcoin will display, bitcoin amounts smaller than 0.01.  However,sending fewer than 0.01 bitcoins still requires a 0.01 bitcoin fee (soyou can send 1.0001 bitcoins without a fee, but you will be asked topay a fee if you try to send 0.0001).* A new method of finding bitcoin nodes to connect with, via DNS Arecords. Use the -dnsseed option to enable.For developers, changes to bitcoin's remote-procedure-call API:* New rpc command "sendmany" to send bitcoins to more than one addressin a single transaction.* Several bug fixes, including a serious intermittent bug that wouldsometimes cause bitcoind to stop accepting rpc requests. * -logtimestamps option, to add a timestamp to each line in debug.log.* Immature blocks (newly generated, under 120 confirmations) are nowshown in listtransactions.SHA1-checksums for the binary files are:54254cba039b02a2f49fdc98b8fe820d0fd4e410  bitcoin-0.3.21-linux.tar.gz3f94d6a8b08c455a7886561089270247eaada7b4  bitcoin-0.3.21-win32-setup.exef9a39404433b01b5a22225855f42275c1c902c26  bitcoin-0.3.21-win32.zip(mac version should be ready soon)Thanks to all those who contributed to this release:Dan HelfmanDan LoewenherzdevrandomEric Swansongjs278Jeff GarzikLuke DashjrMatt CoralloMatt GiucaNils SchneiderojabPieter WuillesandosSantiago M. MolaSven SlootwegGavin Andresen   gavinandresen@gmail.com-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.9 (Darwin)iEYEARECAAYFAk24UbsACgkQdYgkL74406jQlwCeOPf1avdfugmzfiVtuT0hUacm4DEAoJcAR0ha8VKQ8Mu6QoG9ywDLvwjI=DRxu-----END PGP SIGNATURE----- What operating system?  This sounds like a wxWidgets or bitcoin client bug that needs fixing. So: the danger isn't revealing private keys (I mis-remembered),  the danger is a naive developer will see the signmessage RPC command, not realize that signing arbitrary data can be dangerous, and put up a web page that lets somebody enter arbitrary data to be signed with one of the developer's public keys.This might just be a documentation issue, although if signmessage was changed to sign a hash of the passed-in message instead of the message itself then it would be completely safe. To steal your bitcoins by breaking crypto (as opposed to getting your private key), somebody would have to:1. Break RIPEMD160.  Because your bitcoin address is a RIPEMD160 hash...  AND2. Break SHA256.  Because your bitcoin address is a RIPEMD160 hash of the SHA256 hash... AND3. Break the ECDSA elliptic curve encryption signature algorithm, to figure out the private key that corresponds to the public key that they got from breaking (1) and (2).That's assuming that you don't re-use bitcoin receiving addresses (your public key is revealed the first time you spend coins that were sent to that address).  If you do re-use the same receiving address, then they just need (3).I don't spend any time worrying about whether or not the NSA (or anybody else) can break ECDSA. RE: other weird variable type requirments:sendmany's second argument is a JSON Object, with string keys and number (float) values.  I think the equivalent in PHP is a PHP Array (indexed by string).Several routines take boolean arguments.All the rest are strings or numbers. I've deployed a -testnet version of ClearCoin, at:  https://testnet.clearcoin.appspot.com/It is fully functional, so feel free to creates some escrow transactions and get some testnet bitcoins from the the testnet faucet (which I will eventually move to testnet.freebitcoins.appspost.com).For anybody else developing on App Engine, here's what I did to make it work:In my main.py:Code:  # Set testnet namespace                                                                                                                  if 'test' in os.environ['CURRENT_VERSION_ID']:    set_namespace('testnet')CURRENT_VERSION_ID is the version of your app that's running, and is set by App Engine.set_namespace makes all subsequent datastore and memcache operations read/write from a different database.  So almost all of the code for ClearCoin doesn't care whether it is handling testnet coins, it just works.The only other change needed was a check for 'test' in os.environ['CURRENT_VERSION_ID'] when deciding which bitcoind server to use.  I run the -testnet bitcoind for ClearCoin on a different machine than the production bitcoind, so experiments on the test net won't affect the production ClearCoin at all.If you're not running on App Engine, you should think about building in the equivalent of CURRENT_VERSION_ID and 'set_namespace' so deploying test and production versions of your application is easy. Best thing I've bought:  Boston Red Sox tickets (from a friend who has season tickets).Second best: my alpaca socks.And I've bought three or four lunches with bitcoins so far (also from friends-- they pay, then I repay them in BTC).I really wish I had a use for Golden Mean Calipers, they look nifty.
You are forgetting that there are (at least) three players in the bitcoin economy:  miners, users... and merchants.If transaction fees are driven to zero so miners start dropping out, then merchants have an incentive to step in and start mining themselves so their transactions get processed in a timely manner.  Otherwise they don't get paid. The testnet Faucet has 7,000 testnet coins in it, you can get 50 at a time at: https://freebitcoins.appspot.com/TEST/ If I were Satoshi...  I would have built a modest amount of inflation in to bitcoin.  "Modest inflation is what most people are comfortable and familiar with," I would have reasoned to myself, "so that's the right thing to do."However... I'm not so sure that would have worked.  It is very nice to be able to say "bitcoins are valuable because they are rare, and they are rare because they are designed that way-- there will never be more than 21-million of them."  That is easy to understand, and gives bitcoins a clear advantage over existing currencies. That really aught to be openssl .. && rm -f ...... or maybe something more complicated to make sure the wallet encryption/writing completed OK before removing the wallet.dat.  Like checking to make sure wallet.dat.aes256's filesize doesn't get smaller through the decrypt...use...re-encrypt cycle. I dunno, you tell me-- the idea is anybody can use gitian-builder to create trusted releases, right?  Working with BlueMatt to make the nightlies use it seems like the right place to start.Mucking with the Linux build process isn't high on my own personal TODO list, I have my hands busy wrestling with the Windows build (can gitian build windows mingw bitcoin binaries?) and setup.nsi... What's the extra CPU cost for recovering the public key?  Current bottleneck for bitcoin transaction processing is the CPU cost of ECDSA signature verification, not disk space or bandwidth, so saving bytes at the expense of more CPU is not the right thing to do. I thought I'd explain a little more why I think most conservatives might have a negative reaction to bitcoin, why libertarians love it, and why I think liberals might be convinced to love it.I'm starting from Jonathan Haidt's Moral Foundation Theory, which says that we all have five basic universal moral foundations:Harm/careFairness/reciprocityIngroup/loyaltyAuthority/respectPurity/sanctityDifferent cultures and people of different political or religious viewpoints feel more strongly about some of these than others.  Conservatives score pretty highly on all five; liberals score very high on the first two.  Libertarians... are complicated.  More like conservatives when it comes to money, more like liberals when it comes to social issues.So: how do I think people will react to bitcoin for each of the five moral foundations?Harm/care:  if Bitcoin gets a reputation for 'that online currency that the criminals and drug dealers use' then that's bad.Fairness/reciprocity:  if Bitcoin is seen as 'that online currency that made a bunch of early adopter geeks obscenely wealthy' then that's bad.Ingroup/loyalty:  I think conservatives might feel like bitcoin is an affront to Their National Currency (whatever currency that happens to be).Authority/respect:  Conservatives probably won't like a rag-tag band of open source rebels trying to overthrow The Authorities.  I'm not happy about the tone of the recent Forbes article, for example.Purity/sanctity:  Assuming we can get past the Harm/care problems, I actually think bitcoin could be positioned as the purest form of online money.Moral Foundations Theory strikes me as probably right (and it's backed by pretty solid research, it is not just philosophical musings).  I've been thinking about how to "frame" bitcoin to appeal to people on a moral/emotional level.  Random thoughts:Fairness/reciprocity: if you're an early adopter geek, start circulating your coins-- send them to MyBitcoin or MtGox and then back to yourself if you want to keep them, but make it hard to tell if there ARE any early adopter geeks holding lots of coins.  And if you're talking about bitcoin, compare it to the fairness of the current system, where bankers are allowed to create (and profit from) creation of money.What do y'all think? Governments can print money, so if they want bitcoins it would be much more efficient for them to just buy them (with newly printed money) than try to mine them.Going on a bit of a tangent:Once common criticism of bitcoin is that there is nobody like the Federal Reserve to "smooth out the bumps in the economy by manipulating the money supply."  Set aside for a minute whether or not the Fed actually does a good job of that or whether or not the Fed actually has the ability to do that.One response is that there is absolutely nothing stopping the Federal Reserve, or anybody else, from stepping in and "smoothing out the bumps in the bitcoin economy."  The Fed could buy bitcoins when it thought the value was too low, and sell them when it thought the value was too high. It'd have to plan ahead and keep a big stock on hand so it had some to sell, of course.That might lead to a productive discussion on why that would or wouldn't work, and if or how it is different from what the Fed (or the World Bank) does now. All that Icelandic geothermal power could make them a mining hot spot, too. I am mostly a pacifist. My turn to be the newbie:  Is there a high-level discussion of the economics of NameCoin or DNS in general somewhere?  What is the scare resource that needs to have a price attached?My half-baked thoughts:Seems like domain names are not the scarce resource; CPU power available to process transactions is the scarce resource.  So it seems to me simply not allowing any free transactions, allowing an arbitrary number of "new domain" and "domain transfer" transactions with arbitrary fees attached, and allowing the mining nodes to decide which transactions to accept into their blocks and which to drop will create the "right" number of domain names at the "right" price.Any individual, well-known domain name is a scarce resource.  "google.namecoin" is worth more than "xblkje4klj21.namecoin"... but if I want to get the google.namecoin domain name from google (or a domain squatter), and google or the domain squatter is willing to keep paying the (minimal) NameCoin renewal transaction fee, then I can just offer them cash or bitcoins (or NameCoins) to transfer the domain to me. Today, it costs the entire network something like $0.001 to process each transaction.The limiting factor is checking to see if the transaction is valid or not (the CPU cost of ECDSA signature verification).  When the transaction volume gets high enough miners will have to start prioritizing which transactions they check, and they will use transaction fees as a quick initial check to see if they should invest CPU cycles to include transactions in a block.  Yes, miners want to include as many transactions with fees as possible in their blocks, but it won't be economical for any miner or mining pool operator to include an infinite number of them.And speaking of mining pools... they are a lot more efficient than individual miners because they allow transactions to be verified once instead of requiring that all of the miners in the pool do that work.  Very small miners will be driven to join a mining pool, and the big mining pools will be competing to have the lowest fees and highest payouts (and so will be optimizing their ECDSA verification code and will figure out which transactions are profitable and which aren't).So:  I don't think bitcoin will have very few miners.  I think it will have lots of miners connected to a smaller number of mining pools, and the whole system will optimize itself to be wonderfully efficient. Very good idea.  Anybody want to implement it?  I've got a Python tool that walks the block chain gathering transaction statistics:  https://github.com/gavinandresen/bitcointools/blob/master/statistics.pyTeaching it to compute 'bitcoindays destroyed' shouldn't be terribly hard.  I think.This morning I taught it to add just the smallest or just the largest output in each TxOut and report the range to get an estimate of 'true' transaction value being exchanged without counting change TxOuts or mining pool payouts.So, to be conservative, assume that the biggest-value TxOut for every transaction is change and the smallest is the actual bitcoins being transferred.  Taking the smallest TxOut of all the transactions last month, an average of about 35,000 BTC were sent per day.This month the average is about 55,000 BTC per day.   Add in the MtGox trading volume to get a reasonable lower estimate of something like 70-80,000 BTC changing hands every day. +1Y'all have heard of the KISS principle, right? Because there is a real cost to the network for every transaction, and the code hasn't been fully optimized yet.Allowing users and miners to set fee policy without recompiling will happen, but I think there are higher priority issues to tackle first. 18-21 August works for me.  New York City in August: ah, I can smell it now.... RE: changing the confusing transaction fee message:  good idea, and yes, "we" can.How about:This transaction requires a transaction fee of at least 0.0N because of its amount, complexity, or use of recently received fundsI don't want to use the word "recommend", because the GUI doesn't let you try to send them without a fee. We've already got ParseMoney in util.cpp, this patch adds parseNumber/uriParseAmount.  Having more than one way to convert strings into bitcoin amounts is not a good idea, in my humble opinion.Also, instead of having a separate executable it would be more 'wxbitcoin-like' to have one executable that acts as either client or server depending on what command-line arguments are given.  The problem with two executables is you'll have clueless users double-clicking on bitcoinuri.exe and then wondering why it doesn't do anything.I do like the use of boost message queues to communicate. Actually, Clearcoin only requires 3 confirmations.And now that I've got some pressing core bitcoin stuff off my plate, I'll get back to working on a -testnet version of Clearcoin, and as soon as that is done I'll be announcing a JSON-RPC API so you can write code that interacts with clearcoin (creating escrows, getting their status, releasing coins if you're properly authorized, etc). After putting together the 0.3.21 release candidate today, I'm thinking after 0.3.21 is out the door it might be a good time to do a major source tree re-org.   I like the idea of following the GNU directory layout standard, and it would make my job easier if source was in src/, readmes/etc were in doc/, scripts to automate the Windows build were in build/, etc.PS: jaromil is the second person I've heard who says they'd prefer a development mailing list.  I don't care one way or another, but it would be easy to create one using SourceForge's mailing list feature.  What do others think?
Linux and Windows binary releases are at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.21/Changes and new features include:Support for Universal Plug and Play to open a port for incoming connections (off by default, turn it on using the -upnp=1 command-line switch or the checkbox on the Options dialog box).Sending and displaying arbitrary precision amounts of bitcoins (you can send exactly 1.0001 bitcoins if you like).  Sending less than 0.01 bitcoins requires a 0.01 bitcoin fee, however.New rpc command "sendmany" to send bitcoins to more than one person in a single transaction (already being used by some of the mining pools for payouts).Several bug fixes, including a serious intermittent bug that would sometimes cause bitcoind to stop accepting rpc requests.If you find bugs, report them at: https://github.com/bitcoin/bitcoin/issues This is a single-line change that allows non-standard transactions to get into the transaction memory pool (and, therefore, relayed and written into blocks) on -testnet.Satoshi suggested this to me in an email a few weeks ago, and I agree it is a good idea-- we should encourage people to experiment on -testnet with new features, or they will figure out less efficient ways of wedging what they want to do into the existing standard transaction types. The 0.3.21 release (I hope to have a release candidate available today) will support full-precision values-- you will be able to send 1.00123456 BTC, if you like.Sending less than 0.01 BTC still requires a 0.01 BTC fee, though.  Changing that to "sending less than 0.01 BTC requires a 0.001 BTC fee" might be worth thinking about, but I think there are higher priorities on the core bitcoin TODO list. It is a Berkeley DB binary database file.https://github.com/gavinandresen/bitcointools  has fairly easy to read python code for parsing it-- seehttps://github.com/gavinandresen/bitcointools/blob/master/wallet.py Nope, penny-flooder. Run the gui with the -server switch. Yup, although I'd like more brains to think it through-- are there any potential denial-of-service attacks if bitcoin is listening for RPC commands by default (note that JavaScript in your web browser CAN access http://localhost:8332/, the same-origin-policy for JavaScript doesn't apply to localhost URLs)?Does it open up any extra security holes if you're on a multi-user system?And I don't think it should go into mainline bitcoin until there is a compelling need for it-- and I don't think there will be a need until the 'click on a link, popup payment dialog from bitcoin' functionality is worked out... It might make more sense to allow non-sensitive RPC commands to function without a password.  Where "non-sensitive" would be getblockcount/getdifficulty maybe getnewaddress/getaccountaddress and a new 'you clicked on a bitcoin: URI so popup a payment confirmation dialog'."Making it easier for other applications to integrate with bitcoin" is bad if the other applications are trying to steal your wallet, so I'm reluctant to have bitcoin do things like create passwords for users. I pulled a patch that makes Linux/Mac bitcoin/bitcoind write a bitcoind.pid file when started with the -daemon switch (and erases it on shutdown).Next release will have several changes to make startup on Linux/Mac more unix-standard-like. When you launch your instance, make sure the firewall ("Security Group" in AWS-speak) is setup to allow remote desktop access from your machine's IP address to port 3389.I run Remote Desktop Client on my Mac, but the process should be the same on PC.Connect using the "Public DNS" machine name-- something like:   ec2-184-2-91-236.compute-1.amazonaws.comLogin as Administrator, password:    bitcoin development(I just launched the 0.3.20.2 Windows AMI to get ready to build a 0.3.21 release candidate). Thanks for the suggestions and comments, everybody; I think a combination of dropping the faucet reward again (I'll start bundling up faucet payments into 'sendmany' transactions, so the transaction fees are lower) and "community watch program" will work.The 'community watch' will be a web page that anybody can see that shows the last 100 IP addresses that got payments along with an obfuscated version of the email address (I'll obfuscate by randomly turning an email address like 'gavinandresen@gmail.com' into 'gavniadresen23@gmail.com').  And I'll recruit some trusted people and give them access to a master faucet shut-off switch if it starts getting abused again. It always bothered me that the MySQL's SELECT... LIMIT statement could skip records if the database was changing between calls, but that doesn't seem to bother anybody else.This patch is very much like MySQL LIMIT, is needed for the same reason (paging through results efficiently in a GUI), is backwards compatible, and looks good to me. There are actually a few different ways to get a negative account balance.1. As theymos said, the "" account is special, and can go negative if you use sendtoaddress instead of sendfrom.2. Other accounts can go negative if they receive coins on a bitcoin address, you send those coins from that account, and then you use setaccount to re-assign those received coins to some other account.3. They can also go negative by the transaction fee amount if you sendfrom the coins in an account and the send needs a transaction fee.Also as theymos says, you can never send more coins than are in your total wallet.  And it should ALWAYS be true that the sum of coins in all accounts equals the number of coins you can send. You're right-- full-precision is in git-head, but wasn't in 0.3.20.  It will be in 0.3.21. No, they don't. As of version 0.3.20, the GUI and JSON-RPC both allow full-precision values for sends.  So you can send 1.00123456 BTC if you like.And the GUI will display full-precision wallet balances/etc (it truncates trailing zeros past .00, so you won't notice unless you have sub-cent BTC in your wallet).The 'dust spam' rules are still in, so you're expected to pay a fee if you are sending less than 0.01 BTC-- that is, if you try to send 0.00001 BTC it will trigger the fee (sending 1.00001 would not trigger the fee). RE: paying somebody to monitor the faucet:  good idea, although I like the idea of some kind of "community watch" more.  And monitoring the Faucet is an all-day-and-night, all-the-time kind of job.  And if the scammers are willing to try to drain the faucet slowly then they could create accounts with more realistic-looking names and would be able to sneak by the monitors...RE: just using testnet coins:  I worry about people starting to trade testnet coins, giving them real value.  Giving lots of newbies who don't really understand bitcoin testnet coins seems like a really good way to make that happen!RE: proof-of-work before getting coins:  Interesting idea!  Some JavaScript in-the-browser proof-of-work that required keeping the 'get some' page open for a minute or six might make the cost to the scammers high enough that the bitcoin reward wouldn't be worth it.RE: looking at the google account creation date:  that information isn't available to the Faucet's code (unless I'm missing something in the Google App Engine API). That fails the fairness test, too-- identical twins won't get their fair share. If you figure out a cheat-proof, distributed, fair way of doing that please let me know.  I need that magical solution for the Bitcoin Faucet. I'm not really ugly, am I?  You should have seen me in college when I was too cheap to get a haircut...So:  bitcoind doesn't ask for confirmation before sending fees with a transaction because it is was much easier to implement that way, and for most uses of bitcoind paying an occasional transaction fee isn't a problem.If you'd like to help fix it, patches are welcome.  I think a new setting that says "don't pay more than N bitcoins for any transaction without asking me" and a new argument to the send routines to say either "I'm willing to pay up to X bitcoins for this transaction" or "I want to pay X bitcoins in transaction fees with this transaction" is a good idea.
That pattern is definitely the faucet.  The big mining pools are already using the new 'sendmany' functionality to pay lots of people with one transaction.I'm thinking of doing something similar for the Faucet.  Perhaps:+ Bundle up requests for payments, so instead of sending out payment right away you have to wait a bit (15 minutes or an hour or... something somewhat random and non-predictable).+ Dropping the Faucet reward AGAIN so there is less incentive to cheat.  I'll need to use sendmany so the faucet isn't paying as much in fees as it is in bitcoins it gives out.And maybe:+ Publicly display the queue of waiting requests.  This would be the tricky part-- I don't want to just dump email address and IP address, but I do want to dump enough information so people looking at the information can tell the difference between a cheater and legitimate users.+ A way of flagging requests as "looks like cheating to me".  This is also hard-- griefers might decide it would be fun to flag lots of legitimate requests. I've turned off the faucet; somebody is definitely stealing from it.  There were 500 sends queued when I woke up this morning.They are using a different IP address, different google account, and are even changing the browser ID string on every request-- here are three entries from the request log, for example:Code:121.1.54.214 - zqdckyxnhmjj [14/Apr/2011:05:20:19 -0700] "POST /getsome HTTP/1.1" 200 1206 "http://freebitcoins.appspot.com/getsome" "Mozilla/5.0 (Windows; U; Windows NT 6.0; nl; rv:1.9.2.6) Gecko/20100625 Firefox/3.6.6,gzip(gfe)" "freebitcoins.appspot.com"213.0.109.214 - clkjqwbhwefj [14/Apr/2011:05:20:15 -0700] "POST /getsome HTTP/1.1" 200 1206 "http://freebitcoins.appspot.com/getsome" "Mozilla/5.0 (X11; U; Linux x86_64; fr; rv:1.9.2.3) Gecko/20100403 Fedora/3.6.3-4.fc13 Firefox/3.6.3,gzip(gfe)" "freebitcoins.appspot.com"193.110.115.0 - rdcxalrgxyrvb [14/Apr/2011:05:17:40 -0700] "POST /getsome HTTP/1.1" 200 1206 "http://freebitcoins.appspot.com/getsome" "Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.2.7) Gecko/20100726 CentOS/3.6-3.el5.centos Firefox/3.6.7,gzip(gfe)" "freebitcoins.appspot.com""zqdckyxnhmjj" and "clkjqwbhwefj" are the google account logins, which are obviously bogus.  Well, obvious to humans, anyway... I can see the GUI not allowing a less-than-CENT to save fat-fingered users from themselves, but I think the RPC should allow it; at the very least it makes it possible for a kind of grass-roots movement to arise between miners and people generating transactions so if we start seeing a lot of transactions with less-than-CENT-per-kbyte-fees then that's a really good indication the default definition of "free" needs to change.And now that the RPC and GUI allow full-precision amounts for send/move, there is no problem with "I got 50.000001 bitcoins from mining, how do I send ALL of them?" One address per client is a good idea. Neat idea-- I've been thinking about how to let people/companies sponsor the Faucet.The next couple of things on my TODO list are getting the 0.3.21 bitcoin release process started and an API for ClearCoin, but I might tackle Faucet donations after those are done. That sounds overly complicated.  Does your ruby/json implementation have double-precision (64-bit) floats?  If it does, just multiply by 1.0e8 and rounding to the nearest integer.Quick way to tell if your ruby implementation does 64-bit floats:  see what you get converting 21000000.00000001*1e8 to an integer. I'd rather see more non-technical bitcoin-related videos rather then "this is what the block chain looks like" technical videos.I'm going to brain dump some half-baked thoughts:So I watched this talk by Jonathan Haidt on the moral roots of liberals and conservatives and started thinking about how it might apply to more mainstream acceptance of Bitcoin.  If Jonathan is right, then I think conservatives will find reasons to hate bitcoin, but liberals might be convinced to love it.So what are the videos that liberals love?  Well, there's The Story of Stuff, which I think is wrong-headed but is incredibly popular.I'd like to see a video targeted towards left-leaning people that argues from their world-view-- why the existing monetary system is unfair and benefits a rich elite at the expense of the working masses.  How Bitcoin can change that and be a People-Powered money, backed not by empty promises from rich bankers but by the strength and trust of the person-to-person Bitcoin Community.  How friends and neighbors using Bitcoin can keep money in local communities.  How using Bitcoin lets you interact with people all over the world, promoting peace and understanding.  How it is better for the environment than gold mining or trucking coins and cash to and from stores and banks.Of course, early adopter libertarian-leaning bitcoiners will probably HATE it, but they wouldn't be the target audience... I can't see how it could work.  If I knew my LunaCoin balance was going to be reset at midnight and it is 1 minute to midnight, I'd be crazy to accept them.  Reason backwards from there and I don't see how you could possibly have a stable economy, at least not in the last few days leading up to the reset.  People would try like crazy to get rid of their LunaCoins, and it would get harder and harder to find somebody willing to take them.TiagoTiago asked if anything like "reset everybody's balance at the beginning of every month" has ever been tried, and it reminds me of historical debt relief, where all debts are forgiven every N years, usually by people of a certain religious background.If I recall correctly, people were very creative about finding ways to get around it, but I don't have any references handy. In 2009:   SourceAll mobile phones will be internet-enabled in 10 years, and I think it is pretty safe to assume that most people on the planet will have some access.  It won't surprise me if bitcoin first goes mainstream in an up-and-coming third-world country or region. 0.3.20.1 -maxsendbuffer was too small for the initial block download-- you were probably just unlucky and connected to a 0.3.20.1 node.   Connect to somebody running either 0.3.20.2 or an earlier release and you won't run into that problem (does bitcoinj re-connect if disconnected during block download?) Kel'Thuzad, US.  But I haven't played much since my 85 Warlock got the "Explorer" title. GMT is always +0:00, so why not hardcode that instead of using %z or %Z?RE: changing locale:  good idea. Transaction spam is not a high-priority issue, in my humble opinion, and I don't think we need to do anything more right now.We were running into big free-transaction backlogs because of the rise in popularity of the mining pools, but with the big pools now using the new sendmany feature to pay (with a transaction fee) their users that issue has gone away.The improved -limitfreerelay and sendmany will both be in the next release, which should further improve the situation.  And I think in the next few months lightweight download-headers-only clients will start to appear.I would much rather see work on optimizing the network protocol so that hashed of already-spent transactions deep in the block chain aren't sent to (or stored on) new nodes joining the network. What is meant by "rather inefficient"?  Speed of serializing/deserializing?I can't imagine that is a significant factor for communicating with bitcoin; if you're running into JSON-RPC bottlenecks (is anybody running into performance bottlenecks due to JSON-RPC yet?  If you are, what are you doing?) then the lack of persistent connections, lack of JSON-RPC-2.0-multicall support, or bitcoin single-threaded RPC are likely much, much bigger issues. The problem with that idea is if the transaction fee is that low spammers won't notice it either.  They can just invest 0.01 BTC and send millions of "non-free" transactions. ... only if the investments are in things that don't make us more productive.There are really three categories, in order of desirability:1 Investment in productive activities2 Savings3 Investment in non-productive activitiesThe broken window fallacy is confusing categories 1 and 3. I'll be in Paris with my family next month, and would like to arrange a meeting or two with other bitcoin-people.  Who is in/near Paris, and what would be a good time/place to meet?PS: sorry for not writing in French, it has been a very LONG time since high-school French class... Hundreds of google accounts AND hundreds of IP addresses (the Faucet does still check IP address).  And the patience to solve hundreds of CAPTCHAs...I'm pretty sure almost all of the bitcoins going out of the Faucet are new people trying out Bitcoin.  We're getting between 500 and 1,000 downloads of bitcoin binaries from the SourceForge site per day (stats here). PS: Thanks again to everybody who donates to keep the Faucet running! Limit-per-ip-range is an interesting idea.I'd like to give the current not-yet-released solution a month or two to work before trying something else.  I see two possible directions:+ Limit-per-{connection,ip-range}.  Trouble with this is an attacker who has multiple IPs (think botnet operator) can mount a distributed flood attack.or/and+ Take transaction priority into account when deciding what to drop.I'd really like to talk to a p2p network researcher; it seems to me it might be possible to keep some statistics on what "typical" bitcoin network traffic looks like; perhaps nodes could drop neighbors if they notice network traffic from them looks way out of whack (e.g. sending a much-larger-than-typical number of addr messages or free transactions or...). Huh.  One-to-three day transfer times doesn't seem to have hurt the dollar much: http://www.depositaccounts.com/blog/inside-look-at-ach-transfer-speeds-at.html"Instant" payments with world currencies is an illusion created by your bank of financial institution based on how much they trust the person or institution sending the money.  There is nothing stopping bitcoin financial institutions from using the same trick, and I think as the bitcoin economy grows and companies start to trust each other instant transfer times will happen.
Stuff is valuable because it is either useful (like hammers) or we think it is pretty (like Picasso paintings); the more rare, useful, and/or desirable something is, the more valuable it tends to be.We know how rare bitcoins are.  It remains to be seen how useful they are.  I think they're pretty useful as both a convenient way of paying for things and as a long-term store of value, but it will take time to convince most people that they're useful for those things. https://github.com/bitcoin/bitcoin/pull/138I think this is ready:I found one edge case during testing, and after discussion on #bitcoin-dev changed the information reported.  The edge case was reporting the coinbase transactions from orphaned blocks.  Here's the scenario:+ As soon as you generate a block, the coinbase transaction goes into your wallet as a 1-confirmation transaction.  Before this patch, that transaction was not listed in the listtransactions output.  With this patch, it is (as "category" : "immature", "confirmations" : 1).+ If that block is orphaned, the coinbase transaction is no longer valid.  With this patch, it will be reported at "category" : "orphan", "confirmations" : 0+ When a coinbase transaction has 120 confirmations, it will be reported as "category" : "generate" (as before). I added a comment to the PULL request-- I ran into an issue when sanity testing this (a testnet wallet that reports an impossibly high balance after conversion). Yes, and right now it will sit in your wallet at 0 confirmations and get rebroadcast once in a blue moon (ok, not that long, but I'm too lazy right now to dig out the rules for when transactions are rebroadcast) until it DOES make it into a block.And you'll have to hack your copy of bitcoin to be able to send a less-than-.01 transaction without a fee; the RPC send* methods automatically add the fee, and the GUI will tell you a fee is necessary (and won't let you send unless you agree to it). Be nice, y'all.  Todd emailed me directly and I steered him here because I don't have time to talk about economic theory with everybody who emails me these days.Todd:  if you were designing a new currency, what would it look like?  Are you imagining a LETS-like system of credit?Bitcoin is designed to be like a scarce natural resource, which is pretty conservative, really-- scarce natural resources have a long history of being used as currency.  I don't know enough about the alternatives to know whether or not they could work as an Internet currency-- the LETS systems I've heard about all rely on local interactions and trust to keep people from cheating.PS: I'm going to move this thread to the Economics forum. Better would be a new feature that tells the mining bitcoin "please credit generated bitcoins to THIS address (instead of a new one)."If you are just mining, you don't need the private key at all, the bitcoin address (or public key) is enough to create the coin generation transaction. Do these types of 'make money without doing anything productive' schemes bother anybody else, or am I just a financial prude who doesn't recognize harmless fun when I see it?I feel like we might soon need a Frequently Seen Schemes to go along with our FAQ, just to let people know that using a different currency doesn't suspend the laws of economics. That's not the ONLY question.  A question I've been thinking a lot about is what are an employer's potential liabilities if they are caught paying employees in bitcoins "under the table."I honestly don't know the answer if the employer is in Finland and the employee is in Ecuador, and suspect the answer might depend on whether or not the person doing the work is considered an independent contractor or an employee. I just bought two Boston Red Sox tickets from my friend Baer using bitcoins.  They really do work nicely for grassroots, person-to-person transactions, and the beautiful thing is you don't need a lot of people accepting them in one place to get started. Cloning your wallet to do anything besides backing it up is a bad idea.It might work perfectly for a while... but you are very likely to get weird behavior from bitcoin sooner or later, because doing that is not tested or supported.Where 'weird behavior' is one clone of the wallet shows one balance, the other clone shows another, and you might end up with bitcoins that you can spend from one wallet but not the other (or, worst case, end up with bitcoins that neither wallet is able to spend).If you REALLY REALLY REALLY want to do this... then get the latest code from git, pull sipa's 'Spent per txout' patch, and then spend a bunch of time testing to find out what happens when your cloned wallets eventually start using different keys from the keypool. From wikipedia:So, who are the merchants in the bitcoin rush? Adds support for the Tonal numbering system to bitcoin.  Branch is at  https://github.com/gavinandresen/bitcoin-git/tree/tonalPull request is:  https://github.com/bitcoin/bitcoin/pull/8(Note: you will need Tonal Git and a Tonal-capable browser to follow that link). Am I the only person here who looks at our documentation for how to use bitcoin from PHP and thinks "people are going to run away screaming" ?  See:  https://en.bitcoin.it/wiki/API_reference_(JSON-RPC)I strongly believe you are making the common cases (simple shopping carts or "hold a bitcoin balance for a customer and let them spend it") much, much more complicated than necessary.What do other people think?  I'd especially like to hear from people who have prior experience using PHP to implement shopping carts and other simple applications that deal with money.  Did you use BCMATH/GMP? HOW MANY TIMES DO I HAVE TO YELL THIS???Of COURSE you shouldn't use floats internally (unless you are doing something trivial like adding up items in a shopping cart).We are talking about the JSON-RPC api.  Which is an api for communicating between bitcoin and other applications, in which all values are turned into strings.So:  what are the best practices in the banking world for representing monetary values in strings?  As far as I can tell, the answer is "write them out as decimal values and convert them to Decimal() or integer as you read in or write out."Which is exactly what Bitcoin does, and which is what I think we should recommend to people. An IEEE double-precision floating point number has 53 bits of precision, which IS sufficiently accurate to store a bitcoin balance.Every single possible bitcoin value can be converted to and from an IEEE 64-bit float with no loss of precision.I agree that if you're going to be performing lots of calculations on bitcoin values you need a Decimal type (and ClearCoin stores and uses python's decimal.Decimal(precision=8) for all bitcoin values)-- if you don't, floating point errors can accumulate and eventually cause you to gain or lose .00000001 of a coin.But really the main problem with storing monetary values as any floating point type is you're likely to be embarrassed by mistakes like error's cash register receipt if you truncate values instead of rounding before printing. All righty, I hereby state:All money values in the bitcoin JSON-RPC interface Are and Shall Be treated as Decimal, with 8 digits of precision after the decimal point.If you're writing a banking application in a language that doesn't support Decimal types from JSON, then you should pack up your bags and go home. People keep claiming that, and yet I just did YET ANOTHER google search for "banking apis", clicked through to the Open Financial Exchange standard (from Microsoft and Quicken), and what do you know!  Money amounts look like floats:Code:           <STMTTRN>              <TRNTYPE>CREDIT              <DTPOSTED>20070315              <DTUSER>20070315              <TRNAMT>200.00              <FITID>980315001              <NAME>DEPOSIT              <MEMO>automatic deposit            </STMTTRN>http://www.ofx.net/OFXExamplesPage/OFXExamples.aspx Apologies to Nefario, I was reacting to the wiki pages written by genjix on how to use PHP with bitcoind that started with:+ First, compile my fork.+ Next, install the GMP and BCMath libraries...And why do I defend floats:  because simple things should be simple.  Using GMP/BCMATH is overkill for 98% of what bitcoin JSON-RPC users will be doing.And because certain people keep beating this dead horse.  I have said that I am PERFECTLY WILLING to support strings in the JSON-RPC interface if somebody can demonstrate to me someplace where it is actually a real problem (that isn't trivially solved using something like round(value*1e8+0.5) or printf("%.08", value)). Can you'all educate me about these mythical rounding errors that require using GMP?I can see, maybe, if you're computing interest down to the penny on a 30-year mortgage you might conceivably be off by a penny if you use 64-bit floats instead of 64-bit integers, although even there you're going to have to think hard about rounding as you get integer remainders.And I can see being really careful if you're writing a bitcoin exchange site or bitcoin bank that deals in thousands of internal transactions that must all balance exactly.But for the typical PHP website that is just going to add up 10 items in a shopping cart using plain-old PHP Numbers will be just fine.   I don't see PayPal recommending that PHP users of it's APIs install GMP.  Recommending that any website dealing with bitcoins compile genjix' fork and use GMP is a really good way to ensure that nobody accepts bitcoins. That's not part of the official API, that's just a fun hack I made one day on a whim.The technical information in the wiki needs more attention and polish; if you have time and are a decent writer, please jump in and help out.
So before deciding to do ClearCoin, I was thinking I was going to clone one or more of the PayPal shopping cart / payment APIs.The advantage would that all of the existing shopping cart interfaces that know how to talk to PayPal would "just work" with bitcoins (the PayPal APIs can already deal with multiple currencies) -- just replace the https://api.paypal.com/ URL (or whatever it is) and specify amounts in BTC instead of USD or EUR.The short-term business model would be an E-Wallet for businesses (like PayPal).  The medium/long-term business plan would be to get acquired by PayPal when PayPal decided they need to support bitcoin.If you don't like PayPal, then replace "PayPal" by "Google Checkout" or whatever other, popular payment processing gateway API is already being used by lots of websites.I still think this is a good idea, but I'm busy, so I'm throwing it out here and hoping somebody decides to do it. All this endless talking about the Perfect URI Scheme is very nice.So is anybody, you know, actually working on IMPLEMENTING something?You'll need to know how to write browser plugins for Firefox/Safari/Chrome/IE and figure out how to pass arguments to a running bitcoin/bitcoind and know how the bitcoin/bitcoind will prompt the user to confirm the transaction.  Oh, and figure out how to get the browser plugin(s) installed when bitcoin is installed.Deciding on whether it is bitcoin:address or bitcoin://amount/address is the easy part, and I think whoever actually does the work of making this happen should define the standard. ClearCoin requires 3 confirmations before coins are available to be released; the sender will see something like:... while they're in the process of being confirmed.I'll change the receiver's status page so it shows the amount awaiting confirmation, too. yes Feature request is here:  https://github.com/bitcoin/bitcoin/issues#issue/14 I think that's the right way to think about it.  And I think Jeff actually implementing a straw-man proposal is exactly the right thing to do.So:  I say we don't try to defend against (3), at least not right now.  If you have root then you can install a keylogger, read memory, intercept any system call, etc etc etc.   (I would like to see somebody implement a bitcoin client that required payment verification using a cell phone app or telephone call or PIN-sent-to-email and did all the magic key management to make that work securely, but I think that's beyond the scope of what we can reasonably do right now).Defending against (1) and (2) would help with:a) you forget to logout so attacker sits down at your computer, starts bitcoin and empties your wallet.b) attacker gets a hold of a filesystem backup that is not encrypted.c) sysadmin sets file permissions incorrectly so attacker on multi-user system can read your wallet.datd) attacker guesses or finds out your ssh password, logs in remotely and steals your wallet.dat.It won't help with:- sysadmin with root privileges is evil- system compromised by rootkit/trojan/keyloggerRE: encrypt everything:  I say maybe later.  Just encrypt everything isn't trivial: users would have to wait a minute or two or ten for Berkeley DB to rewrite all of blkindex.dat (bottleneck will be disk I/O, not the encryption), and we have to deal with "my disk filled up when I changed my password, things are half-encrypted and half-not, what do I do now?"   And I don't see a lot of value in encrypting all of wallet.dat; forget to shutdown bitcoin and an attacker that wants to know your public addresses can just open up the address book and take a screenshot. So one of my pet peeves is the United States Legal System.It has lots of rules.  The problem is nobody can possibly read them all.  And yet "ignorance of the law is no excuse!"I'm a big fan of a few general, fuzzy rules and common sense. ... and we're looking for volunteers.  See http://bitcointalk.org/index.php?topic=5052.0Quick "why no proper SSL cert" :   because it never made it near the top of anybody's TODO list.  The task is: + Figure out where the bitcoin.org domain is registered and make sure the MX records/etc are pointing somewhere so verification emails from the certificate authority don't get lost. + buy the cert and jump through the 'verify you are who you say you are' hoops. + replace the self-signed cert on the web server eideteker:  Can you ask the skeptics what we, the Bitcoin Community, could do to be less "smelly" or "sketchy" ?I find people are much more sympathetic if instead of saying "What's your problem?" you instead ask "What am I doing wrong, and how can I fix it?"And then you can get all jujitsu on them and praise their great ideas and gently suggest that you'd only screw up whatever it is they are suggesting (and you're busy doing other stuff already) so maybe they should just go ahead and do it... If only somebody would create a really nice animated video explaining what bitcoin is.... What theymos said.  Miners have a strong incentive to be well-connected (as do big merchants and exchangers and anybody else who generates or processes lots of transactions). ... and also remember that command-line switches override values set in the bitcoin.conf file, so if you'd modified your Windows shortcut to -paytxfee that would stick. You're hired! No, there is no 'mixed_debit' in my pull request.  Coins are 'immature' until they have 120+ confirmations, then they are 'generate'. RE: botnets:  if the botnet operator is economically rational, then their best strategy to make money is to just follow the rules, mine coins, and then sell them on the exchanges.RE: the original poster's question on "can somebody with lots of money and a willingness to spend it to mess with the bitcoin exchange rate and cause fear, uncertainty and doubt" :Yes.  Yes, they can.  That will be true while the bitcoin economy is small, and that is why I tell people not to 'invest' money in bitcoins that they can't afford to lose.I still predict that there will be natural price bubbles and artificial ponzi schemes and all sorts of other things causing wild swings in the value of bitcoins.   Next time I talk to an economist who knows something about currency markets I'll have to ask how big a currency has to be before it is mostly immune from speculative bubbles and price manipulation... Patches welcome.But be aware that any patch that is vulnerable to denial-of-service attacks will be rejected, and I can't think of a way to automatically adjust the block size that wouldn't be vulnerable to some big, anti-social miner (think "jerk with a botnet") deciding it would be fun to artificially drive up transaction volume, drive up the block size, and create a few gigabytes of worthless blocks we all get to download forevermore.When we get close to bumping into the block size limitation it will be easy to convince a majority of the network to upgrade-- that's one problem that is obvious and easy to fix. Pull request: https://github.com/bitcoin/bitcoin/pull/138/filesFrom a testnet-in-a-box test, here's what mature/immature blocks look like:Code:    {        "account" : "",        "category" : "generate",        "amount" : 50.00000000,        "confirmations" : 120,        "txid" : "14da5ea78b6a1451ba11445be08c520808ddd185cf55d550f012dd4c16e2f67d",        "time" : 1300074965    },    {        "account" : "",        "category" : "immature",        "amount" : 50.00000000,        "confirmations" : 119,        "txid" : "8181f1760c208c84f06183f1145d3ad5a142340fd331e63466d5de8c406435aa",        "time" : 1300075032    },PS:  There is a feature in the core bitcoin code that bothers me because I don't completely understand it:  coinbase transactions are technically spend-able after 100 confirmations (COINBASE_MATURITY in the code), but they aren't counted as spendable by the GUI or the RPC until 120+ confirmations (GetBlocksToMaturity() in the code).  I suppose a big block-chain re-org could run into problems if a just-barely-mature generation was spent at exactly the wrong time, but I need to think about that a bit more (and maybe ping satoshi...). So...  I'm working on a patch to add < COINBASE_MATURITY-confirmation generation transactions to standard listtransactions, and trying to figure out the right way to handle immature generation transactions.Either:a) list them as 'generate' -- they'll just happen to have confirmations < 100 (100 is the COINBASE_MATURITY, although the GUI doesn't show them until confirmations>= 120).b) list them as 'immature' -- a new transaction category.I'm leaning towards (b), because that way apps don't have to know that COINBASE_MATURITY is 100, and it is easier to double-check that listtransactions agrees with the getbalance API calls (immature coins are never counted in balances, because they can't be spent until they mature).The only drawback I can think of is that adding a new transaction category might confuse existing code. You can't see less-than-100-confirmation generations in listtransactions, but I agree, you should.   Does anybody have experience with valgrind -helgrind or other automated tools for finding potential deadlocks?Running it on bitcoind I'm getting a huge number of false positives...Should we just document every method that holds one or more locks?  I'm worried there are other possible deadlocks lurking.
D'oh!sendfrom should definitely CRITICAL_BLOCK(cs_main).  Nice catch ArtForz. No.  The end of the chain can, and does, fork, but the forks are short and the network pretty quickly decides on the One True Chain.Yes.Short answer: no.Longer answer:  it is complicated, and what you need depends on whether or not you're trying to generate new blocks.  To keep it simple, the original client downloads everything.  RE: fractional reserve bitcoin banks:I think it will happen, too.  Because of the nature of bitcoins they could arrange so that their reserves can be audited by anybody (easiest way:  prove they own a particular bitcoin address by signing something with its private key, then send all their reserves to that address). Wow!  Great job, excellent video (I like fast), fully deserving of the bounty in my opinion.And yeah, if it is OK with justmoon I think replacing my Ignite talk on the bitcoin.org homepage with the new video is a great idea. But how do you know that the transaction the hardware device signed is actually the transaction you wanted to make?  You might THINK you're sending 100BTC to your brother, your computer will SAY you're sending 100BTC to your brother, but the trojan might change the destination address that goes in to the hardware device.Unless the hardware device has some sort of display and physical button to OK the transaction.  In which case the hardware device sounds a lot like a smart phone. The Open Bank Project aims:I was contacted by Ismail CHAIB, who wonders if bitcoiners "might be able and interested to contribute to the project."  If defining an API to help bring more transparency to government, nonprofit, and perhaps corporate finances sounds interesting to you (I'd personally like to see much more government financial transparency): I think there is a strong possibility bitcoins will end up being used for something none of us is thinking about.  Maybe big multinational corporations will use them to pay their international supply chains in industries that are used to constant deflation. Making IsStandard() return true if fTestNet is a good idea.The process for getting a new transaction type into bitcoin would be to test it thoroughly on the testnet, get general consensus on its API and/or GUI and that it is useful, safe, and unlikely to be abused, and work with the 'infrastucture' sites (like blockexplorer and bitcoinmonitor) to make sure the right APIs or hooks are in place so they can do something intelligent with the new transactions. Neat idea!As theymos says, this will only work 100% reliably for addresses buried "deep enough" in the block chain that the likelihood of a block-chain-re-org is vanishingly small. If more bitcoin adoption means bitcoin mining replaces actual, physical gold and silver mining then that should be a net positive for the environment.  Gold mining is dirty, dangerous, and destructive; if bitcoins eventually become "a better gold", then there will be less pressure to dig up virgin wilderness.Right now, bitcoin mining is inefficient, but natural economic forces will make it become increasingly efficient.  We've already seen that, with more efficient GPU mining replacing CPU mining because you get more hashing for less electricity.Eventually, I'm confident you'll see big commercial-scale bitcoin mining operations in places where either electricity is clean and cheap to produce, or where the waste heat from bitcoin production is put to productive use (maybe we'll all have network-connected bitcoin-mining space heaters to warm our offices in 10 years).Before then, we probably will see bitcoin production using cheap, dirty electricity in poorer countries.  If history is any guide, as that helps to make those countries richer their citizens will demand better environmental standards.  Even if we all decided that is unacceptable, I don't see any way to prevent it-- there's no way to tell if a bitcoin was generated using solar panels in the Sahara or dirty coal in Pennsylvania. Thanks for the positive feedback!Markus did a great job putting together an outline for what we'd talk about ahead of time, so I had time to plan how to explain complicated concepts like public key cryptography in just a couple of minutes. In jgarzik's original implementation, an attacker can pre-generate a rainbow table with 2^32 entries, and that lets them take a shortcut so they only have to try 2^32 bits for any particular scratch card (algorithm is, essentially, "foreach value in 2^32: do some complicated math, then see if the result matches a value in the 2^32-size rainbow table; if it does, you've found the unknown 2^64 bits"). The average user will want to use a brand name they're familiar with; if we can continue to convince early adopters that bitcoin is a good idea, eventually PayPal or one of its competitors will start supporting it.  I hope. I didn't-- the first "community build" took long enough as it was, and I didn't want to add one more 'different from the way it was done before' variable.Next release I want to automate some of the manual steps, and maybe use the gitian process, assuming it will work inside an Amazon VM (DO nested virtual machines work?).  Unless anybody feels motivated to step in and do it first; with a verifiable build, anybody can take on the role of build-meister. I don't want to hijack the design discussion...... but I would like to open up discussion of content.  I'd like to see the bitcoin.org home page to be less about bitcoin-the-software and more about bitcoin-the-currency.You don't have to download and run any software to run bitcoin, and I think most non-technies are better off using an online wallet service rather than running bitcoin.exe.  So I'd like to see the DOWNLOAD/HOWTO sections moved to a separate page, and have the home page have links to there and to a Wiki page that lists the online wallet services (and starts with a little discussion of the tradeoffs of using an online wallet provider instead of running bitcoin yourself).I'd be perfectly happy if the design and content was improved (as already discussed) and then the content was changed later, if there's general agreement that de-emphasizing the download is a good idea. Satoshi has a bunch of features that he 'figured out from the start' that are not implemented yet; I'll ask him if this is one of them after I figure out exactly what feature I want and convince myself it is possible to do securely.  So I'm going to try to gather my thoughts and see if there is much point:This is the main problem I was trying to solve:A merchant's website should give the customer a unique payment address during the chekcout process.  Ideally, generating that unique address would be done entirely on the web server without requiring a RPC call to a bitcoind process running somewhere.Communicating with bitcoin or some merchant-services website during the checkout process adds another possible point of payment failure-- it is better for the merchant if their customers can continue to pay them even if their bitcoin daemon (or MyBitcoin or MtGox merchant services) is temporarily down for maintenance.OP_OVER OP_ADD solves that problem, and, thinking about it, has some other very nice properties.  Here's how it would work in practice:1. Merchant gets one or more public keys to use for payments.  They're stored in the web server's database.2. Customer checks out:  web server computes HASH160(public_key+order_id), and converts the result to a bitcoin address version#2 (first byte is not base58-encoded-0, but something else).3. That bitcoin address makes its way to bitcoin software running on the customer's machine (or at an online wallet service).  Since it is a version#2 address, bitcoin creates an OP_OVER OP_ADD.... transaction for it instead of an OP_DUP ... transaction.4. Merchant's web server software tells a bitcoind running somewhere "if you see payments to HASH160(public_key+order_id), that's one of mine."5. When the merchant want's to spend the bitcoins it got from the customer, it has to tell a bitcoind running somewhere the public_key,order_id pair.If the merchant doesn't completely trust the payment processor then keeping steps (4) and (5) separate is very nice-- the payment processor can't spend the merchant's bitcoins until the merchant tells them the order_ids  (merchant would have to use truly random order_ids to be completely safe, of course).And, as noted before, this is a little more private than standard bitcoin transactions because the public key isn't revealed until the coins are spent. You might care if you got the dollar bill from somebody you suspect is working for the Secret Police, you think think the Secret Police might be trying to trace payments by recording bill serial numbers, and you're spending the dollar to pay a local print shop to produce some illegal Subversive Propaganda.That's roughly similar to tracing bitcoin transactions. How long is the split?  There's really no problem if the split is less than the block generation maturation time (20+ hours)-- a bunch of miners will be disappointed on one side of the split or the other, but that's about the extent of the damage.Longer than 24 hours... is kind of hard to imagine for a big country.Would transactions continue to be processed:  yes, but...  the sudden drop in network hashing rate (and the drastic slow-down in block generation) might trigger future safety checks in Bitcoin, so you might have to do something special to tell it "yes, I really do want to generate transactions even though something weird is happening with the network."If a little country or region got split from the main network, it will probably have a lot less hashing power and it will take much longer to generate the 100 blocks needed to start to cause problems.  That's a feature, not a bug.After communication was restored the more-difficulty block chain would "win" and transactions from the losing block chain would get retransmitted and move over to the more-difficulty chain.If somebody had a super-secret communication channel that worked during the split they could use it to double-spend.  But if the bad guys have a super-secret channel then probably some good guys would, too, and as jgarzik points out, it only takes one little link to relay blocks and prevent a split. Actually, I'm surprised Mark doesn't remember (or maybe he just didn't want to get bogged down in details)-- he paid for my lunch, and I paid him back in Bitcoins.Which turned out to be a good deal for him, they went from about 40cents apiece to something like 60cents apiece in the week or so it took him to setup a bitcoin account and give me his receiving address (I paid at the 'when we had lunch' exchange rate, of course).If you have a bitcoin business and are thinking about advertising, FTL listeners might be a receptive market-- and I bet you might be able to convince Mark and Ian to take payment in bitcoin. ... I think that's right, you don't need the OP_OVER OP_ADD.  You have to know the random number to generate a valid signature, given only its hash.You'd have to be very careful NEVER to use the same random number anybody else has ever used or will ever use; if your 'random' number is an order number (or even common-hash-of-an-order-number) then you're sunk, anybody can generate a valid <signature> <public_key> <r> triple.For two extra bytes per transaction it might be better to hash in the public key, just so people don't shoot themselves in the foot.
They can only invalidate transactions that they made (or further transactions that spend transactions that they made).  That makes the attack a lot less likely in practice; if they had a lot of bitcoins, and purchased a lot of good or services (or exchanged them for dollars or euros) with a lot of people, then some of those people are likely to know WHO "they" are.  And if they're in the same legal jurisdiction, it seems to me you'd have a pretty good case for suing them for fraud.Even if 'they' decided to do this just to try to mess up the bitcoin network it might be messy for the exchanges to clean up but I don't think it would cripple them.  The bitcoin client already trys to select "old money" when it creates transactions, so assuming that the exchange has a good cushion of bitcoins on deposit all the attacker is likely to accomplish is to invalidate their own deposits at the exchange.All that said:  I'm not going to advise people to hold money they can't afford to lose in bitcoins until the network has a lot more hashing power.  There is still some risk while bitcoin is young. The bitcoin integration/testing source tree is at GitHub, and we (jgarzik/tcatm/gavinandresen right now) use GitHub's "pull request" feature to keep track of patches that people think are ready for integration into mainline bitcoin.  This post is a walk-through of how to create a pull request.1. You'll need a GitHub account; sign up for free, and set up git and ssh to work with GitHub.2. You need a fork of the main bitcoin source tree.  Login to your GitHub account, browse to the bitcoin project, then poke the little 'Fork' button near the top of the screen.3. Connect that fork at GitHub with source code on your development machine.  The easiest way to do that is to clone your github fork, using the SSH Read+Write URL github shows you on your fork's page.  For example:Code:git clone git@github.com:your_github_name/bitcoin-git.gitcd bitcoin-gitgit checkout -b niftynewfeature # Create a feature branch ... edit, test, re-edit, re-test...git commit -agit push git@github.com:your_github_name/bitcoin.git niftynewfeature:niftynewfeatureYou might already have a clone of the bitcoin git tree that you've modified; you should push those changes into your new GitHub fork.  Assuming you made your changes in the 'master' branch on your machine (next time you should create a specific feature branch), the command would be:Code:git commit -agit rebase -i remotes/origin/HEAD  # optional: lets you tidy up commits to create a clean patchgit push git@github.com:your_github_name/bitcoin.git master:niftynewfeature4. Submit a PULL request by going to your fork's GitHub page, selecting the branch containing the changes you want pulled ("niftynewfeature" in the above example), and then poking the "Pull Request" button.  Enter a good description of what your changes do and why they're a good idea and how everybody and their brother is already using them to make the world a better place .Eventually, if all goes well, after discussion and argument and nit-picking and revision, your changes will get pulled into the bitcoin repository.  If all doesn't go well, you (or the core developers) can close your pull request and resubmit it when the feature is perfect. Sirius and I both have access to the webserver, although Sirius knows a lot more about Drupal than I do.But if somebody puts together Drupal templates (theme?  what does Drupal call them/it?) with the spiffy new look I'd be happy to upload them.  Or, even better, create a Drupal account for that somebody so they can update the look and content themself and fix the bugs that are almost certainly going to happen. I got this question from an editor at TechWorld.com.au :... and I'm looking for good answers. Actually, falling asleep last night I realized what I proposed would be yet another variation on an 'anybody can claim' transaction (anybody can just choose an r1 that make r1 XOR hash_xor_r1 evaluate to a hash that they own).I think this would work:Code:OP_OVER OP_ADD OP_HASH160 <hash160(r1+public_key)> OP_EQUALVERIFY OP_CHECKSIG... supply <scriptsig> <public_key> <r1> to claim.I'm not suggesting anything like this get implemented any time soon, I started this thread just to explore what is possible. Very nice!The 'sig opcount <= 2' rule for tx relaying is slated to change with the 'sendmany' patch I pulled on Monday.The new rule will be 'sig opcount <= size/34Code:    // Checking ECDSA signatures is a CPU bottleneck, so to avoid denial-of-service                                                           // attacks disallow transactions with more than one SigOp per 34 bytes.                                                                   // 34 bytes because a TxOut is:                                                                                                           //   20-byte address + 8 byte bitcoin amount + 5 bytes of ops + 1 byte script length                                                      if (GetSigOpCount() > nSize / 34 || nSize < 100) return error("AcceptToMemoryPool() : nonstandard transaction"); Yeah... I can imagine clever ways of obfuscating it such that you can't tell who's getting paid until they actually sign the transaction and spend the output.  Make the txout something like:Code:   OP_OVER OP_HASH160 OP_XOR <hash160_xor_r1> OP_EQUALVERIFY OP_CHECKSIG... and to spend the txin is:  <scriptsig> <public_key> <r1> (where r1 is a random number used to obfuscate the publicly visible hash160).  Or something like that (I shouldn't be thinking about cryptography when I'm this tired). Thanks for the link to the wikipedia page in the other thread... so receiver CAN recover 'k' given the public key and signature.Cool!That doesn't solve the problem I'd like to solve (because you still need to generate a new keypair for every transaction), but it is cool. Googling for 'ECDSA broadband subliminal channel' to figure out what the heck you're talking about...... doesn't that require that the recipient (as well as the sender) know the private key?(you encode the message in the 'k' param, which the recipient can only recover using the private key?) It depends on how much you pay for electricity, what kind of computer you own (and what kind of graphics card it has), and whether or not you can figure out how to install and run "GPU mining" software. Right, that was the problem I was hoping to brainstorm about.  I didn't want to re-open the "add data to the transaction database" discussion (I think "add data to the block chain" is misleading, since transaction data isn't actually part of the block-header-chain or transaction-merkle-tree).I'm still wondering if there is a way to create transactions on the web server, without talking to bitcoind, using a small-ish number of pregenerated public keys, such that each transaction is unique and competitors can't tell how many transactions belong to any particular merchant.Pre-generating a bunch of keys works, assuming that competitors don't know the pre-generated keys (bad assumption long-term if they keys are re-used, since they could just order a bunch of stuff and note the keys used for paying). RE: opening up the "store random stuff in the block chain" argument:Several things make me not worried about that:1. OP_CHECKSIG drives network-wide costs (see the thread on network-wide transaction cost back-of-the-envelope calculations).2. New -limitefreerelay code will, I'm pretty confident, mitigate penny-flooding.3. 512 bytes plus inputs plus outputs will will make these either "very-low-priority-free" or over 1K non-free transactions.4. We're past the point where block chain download size is 'convenient' for new users.  We should implement lightweight client mode (download only block headers until you start solo mining) as soon as possible.RE: pregenerate a bunch of addresses to use for payment:I like that idea!   If you're getting, say, 20 bitcoin orders a day then 1,000 addresses would last you a month.  And even if you recycled them when you ran out it should be easy to match orders to addresses based on the transaction date and amount...The whole "click to pay" feature needs to be figured out, and should work nicely in all four cases of (customer,merchant) using (bitcoin,online wallet).  My brain isn't up to it today, though... The web server doesn't have the bitcoin private key, and the problem I'm trying to solve is an order process where the web server doesn't have to communicate with bitcoin at all to generate the "pay me" address/link. So I got email today from a merchant asking the most-frequently-asked question:  if I just put a bitcoin address on my "pay me" page, how do I know who paid me?Which got me to wondering... can we do better than answer "run a bitcoin daemon and ask it for a new address for every order"  or  "use a shopping cart interface from your online wallet provider" ?Ideally, the web software could generate a payment URI without talking to bitcoind, and copying/pasting or clicking on the URI would generate a transaction tagged with the right order ID.Adding another transaction type that allows (say) an extra, arbitrary 512 bytes of data mostly solves the problem; the web software could encrypt or hash the order ID and generate a transaction that is the store's public bitcoin address and the encrypted/hashed order ID (or customer number or whatever).Can we do better?  It would be nice if it was impossible to tell how many orders the merchant was getting... Focusing on the use cases is the right approach.One variation:5. Export keys to transfer funds to somebody else.  Recipient is expected to import and then immediately send-to-self.  Sender keeps the keys 'set aside' in the wallet until they are spent by recipient, or, if not spent by recipient (lost in transit maybe, or recipient chokes on a lollipop before having a chance to redeem), may be added back into the sender's balance.And one usability comment:Is "selected keys" the right way to go?  Just selecting an amount of bitcoins to export/send seems like a better way to go (with a send-to-self transaction generated, if necessary, to create the right amount), with maybe an "advanced" option later that lets you select specific inputs to export/send. Preventing that type of statistical network analysis attack is what Tor and i2p are for.  If you require that level of anonymity, run bitcoin via a proxy to communicate over those networks. I'd suggest using a standard, existing format instead of inventing a new one.Either get rid of the version number and do standard CSV:Code:91iwnurxhWmDF9gqwc4CbuLCB4HxuMXf5B2vEhTPDftY3rkMgDY,10806,moura6ybHvwzMtrWdyqiEN6n2mMakf8HxD,"50.01 BTC"92JsNVMJgG4RiC2ARxpduJp8DXKgdDMj9WREE5jo66Hg8UMdr3L,10870,mmFPR1oaDExBfJqpRohWBvbE2aCg86Kwcx,"0.00 BTC" ... etc (always 4 columns)Or maybe .ini-format, with each private key a different section:Code:version=1[91iwnurxhWmDF9gqwc4CbuLCB4HxuMXf5B2vEhTPDftY3rkMgDY]block=10806publickey=moura6ybHvwzMtrWdyqiEN6n2mMakf8HxDamount=50.01[92JsNVMJgG4RiC2ARxpduJp8DXKgdDMj9WREE5jo66Hg8UMdr3L]block=10870  ... etc(bitcoin already contains .ini-file-parsing code, from boost)I think there are lots of advantages to using an already-standard file format. PHP 5.3.3. on my mac gives:Code:object(stdClass)#1 (1) {  ["e"]=>  float(5.01)}Please be specific about what platform you're running on, what version of PHP are you running, are you running with a standard php.ini or have you tweaked it, etc. I tried it... got -999.04 on my Mac and Linux machines.  What platform gives the wrong answer? Sticky for creating a pull request:  good idea.JollyGreen: if you know, or are willing to learn, git then working from the git repo ( https://github.com/bitcoin/bitcoin )is smoother.  github has built-in support for turning a development branch into a pull request.
Who's that woman:  Anna LeeI don't know nuthin 'bout changing video default images.If anybody does, I'd be happy to replace or tweak the link to the video at bitcoin.org. Something like this is possible (I've been thinking about doing it, although I have higher priority things on my TODO list):Sophisticated user runs a tool on her computer that, giving the bitcoin address payment was sent to and "here's a description of me or what I paid for" string.  Tool looks in the wallet.dat and figure out which keypair(s) were used to pay.  Then it does some openssl magic and exports a file that contains the string, the public keys and ECDSA signatures using the private keys of the "description of me or what I paid for" string.Sophisticated user uploads that file to a "Prove I Paid" website, which checks the signatures and adds info to the database.Unsophisticated user goes to website and pastes the receiving address.  The public key corresponding to that address is looked up, and all the "here's a description of me or what I paid for" strings for that public key are shown.bitcointools+openssl (see grondilu's thread about "a shell-script implementation of bitcoin) are enough to do all all the public/private key, file-creation, and signature generation/checking stuff. You know, I was looking at the PayPal payment API yesterday, and $1.01 is sent as... 1.01"transmitting" != "calculations" That's just dumb.If the problem is jsonrpc-supporting-environments that don't support double-precision floats, then multiplying and slapping a zero on the end won't fix the problem-- you'll just either lose precision as it gets squeezed into a 32-bit float or get a 32-bit-integer-overflow error. Is there a PHP implementation that does not use double-precision floating point?After doing a little googling I couldn't figure out the answer to that.  I will be MUCH more sympathetic to changing the JSON-RPC api if there is.And mizerydearia:  re: the witcoin issue:  You say:"I see the transaction as 0.94 However, http://json-rpc.org/ retrieves the data as 0.93999999999999994671"So why when you display that value are you truncating it instead of rounding it to 8 decimal places?For example:... or to convert to an integer-number-of-base-unit:All of that assume that your php support double-precision floating point, which brings me back to my question:  are there any php implementations that do not? Who knows enough about wxWidgets to add a checkbox to the Settings UI for "Enable UpNP" (grayed out #ifndef UPNP...)?  Wanna coordinate with BlueMatt to get that done? Seems like this feature doesn't need to be part of the RPC interface-- why not just (ignoring error handling/etc) do the equivalent of:Code:ADDRESS = $(curl https://fishysnax.com:443/path/to?id=genjix)bitcoind sendtoaddress $ADDRESS 1... from whatever code is calling the RPC? In my head I was imagining a way of telling bitcoin to subscribe to some service(s) that did the mapping-- maybe a setting in the GUI where you could specify "use these six services, in this order, to try to resolve bitcoin addresses that aren't plain-old-bitcoin-addresses."  With the services specified by name+URL (and some standard REST-ful protocol was defined for mapping string to bitcoin address).  Or maybe name+pattern+URL.I haven't looked at genjix' patch, and haven't thought deeply about security issues-- but I bet there are lots... Why can't you just multiply the numbers by 1.0e8 and then round to the nearest integer?  That integer WILL ALWAYS BE EXACTLY RIGHT (assuming you're not running PHP on some really weird hardware).According to the PHP manual:I added a Python JSON-RPC library example on the Proper Money Handling wiki page. The Donate: address is hiding down at the bottom of the page:  15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC... and I just updated my forum signature, too. I think you have an incorrect assumption in your argument:  what makes you think there will be a high variability in block rewards (because they're mostly fees) 40 years from now?Assuming bitcoin is still around in 40 years, there should be at least tens of thousands of transactions per block, and with that many transactions sum(fees) should be pretty darn stable. Well, imagine an attacker did manage to surround your node.What can they do?a) Dropping outgoing transactions-- a send-coins denial-of-service.b) Dropping incoming transactions-- a 0-confirmation-receive-coins denial-of-serviceCan these be exploited somehow to the attacker's advantage?  Maybe if attacker and attackee were competing on a bidding site or the site being attacked was a bidding site and the attacker wanted to squash competing bids.  Rounding up thousands of IPs to try to get a better deal on biddingpond hardly seems worth it.  And an old-fashioned DDoS attack can probably take out any one particular node anyway, with or without bitcoin involved.c) Dropping new block announcements (that would be a 1+-confirmation-receive-coins DoS)d) ... and maybe feeding the attacked node attacker-generated blocks(d) is more serious, because the attacker could generate bogus N-confirmation transactions.  But it should be detectable; assuming the attacker doesn't have as much hashing power as the rest of the network, blocks will be generated much more slowly (either much more slowly after the last compiled-in block checkpoint if you're downloading the block chain, or much more slowly since the last time your node connected to the network). RE: 25 outbound connections instead of 8:If I recall correctly (and I probably don't), the percentage of nodes currently on the network that are accepting incoming connections and the -maxconnections limit isn't great enough to support every node trying to make 25 outbound connections.The major merchants and exchanges should accept incoming connections, so they have many more than 8 connections.  That will make them basically immune to Sybil attacks (e.g. the Faucet has 55 connections right now).I like the idea of major merchants and exchanges (also) communicating with each other over an invitation-only, trusted "backbone."  That would be in addition to the mostly-randomly-connected p2p network we have now, not instead of it.I'm concerned about Sybil attacks as a denial-of-service technique (attacker "surrounds" an 8-connection node and then drops all of their transactions just because they can).  Randomly disconnecting and re-connecting seems like a good approach.Detecting that you're being subjected to a Sybil attack seems like it might also be a good approach.  You don't really care if you're seeing a bogus version of the block chain unless you're in the middle of confirming one or more transactions; perhaps if transaction confirmation is taking significantly longer than expected the client should find some fresh peers. Making the fee transaction depend on the block's coinbase would run afoul of this code in CTransaction::ConnectInputs:Code:            // If prev is coinbase, check that it's matured                                                                                                                     if (txPrev.IsCoinBase())                for (CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < COINBASE_MATURITY; pindex = pindex->pprev)                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)                        return error("ConnectInputs() : tried to spend coinbase at depth %d", pindexBlock->nHeight - pindex->nHeight);... and the entire block would be rejected as invalid.  Which is a good thing, otherwise miners could get around the "no spending newly minted coins for COINBASE_MATURITY blocks" rule. You can run the front-end on one server and the back-end on another (and communicate via JSON-RPC over HTTPS).  That's how I'm able to run the Faucet and ClearCoin on Google's App Engine (they talk with bitcoind processes running on linode.com and aws.amazon.com servers).  bitcoind doesn't take much memory, bandwidth, or CPU (just don't turn on coin generation), so, for now, anyway, you can even use an Amazon "micro" server (which costs something like $100 per year).I'm not selling anything so can't comment on the shopping cart interfaces.  Screen-scraping web pages is a bad idea for lots of reasons. Somebody did that a few months ago (theres a message here in the forums SOMEWHERE...)If I recall correctly, after he was done he found that it wouldn't compile on Windows any more. Maintaining the faucet isn't a big drain on my time-- most days I don't think about it.Given the number of newbies who wander into #bitcoin-dev and mention they got 0.05 BTC from the faucet, I think it is still valuable as a nice introduction to using bitcoin.And Jim:  thanks!  Without donations the Faucet would have run out of coins long ago... You can't send messages with transactions.There was some discussion of adding another "standard" transaction type that allowed you to add N bytes of arbitrary data.  I think that is a good idea (I think people would find all sorts of interesting uses for it), but there are higher priority things on the development roadmap. Thanks-- there was indeed a bug in the "weren't you just here?" code... The Bitcoin Faucet ran out of coins this morning, so I took that as a sign that I should make some changes that I've been meaning to make for a while.The big change is the Faucet now requires you to have a Google account (and login with your Google Account) to get coins.  With IPv6 starting to happen, and people getting ever more creative in the ways they tried to get around the "X bitcoin per unique IP address" rule, I decided to let Google catch people trying to create lots of accounts.From what I remember, the cost of buying a google account is much higher than the value of the coins I'm giving out (as opposed to the cost of hiring somebody to solve captchas), so the only people working hard to create new Google accounts to try to rip off the Faucet will likely be teenagers with way too much time on their hands.One little change:  Faucet pay-outs are now:  0.11 BTC when balance > 500 BTC  0.05 otherwise (same as before).And an invisible change that actually happened a few days ago:  the Faucet pays a 0.01 transaction fee every time it sends coins.  That makes Faucet transactions get into blocks quicker when there are lots of other free transactions on the network, and leaves more room in blocks for free transactions.
Sure, here's one:  http://blockexplorer.com/testnet/tx/0d6c3d3470a89e4be56df04e80a9b7da1855bbe2cf07c1e99e22e0212688eb8b It is not a new transaction type-- transactions could always have multiple TxOuts.However, to prevent a denial-of-service attack (which was actually attempted-- see block 71036) transactions with more than 2 TxOuts are currently dropped by clients instead of relayed.Now that there is a need for it, the rules allow "reasonable" multi-output transactions, but still denies "unreasonable" ones (reasonable means:  is one of the 2 standard transaction types and only does one ECDSA signature verification per recipient).So:  no, this won't cause a block chain split.  And no, old miners will not disagree with new miners, so double-spending is not possible. I was just about to ask the same thing as LMGTFY....Running anybody else's code on your system is dangerous. There is no bug, but if you want to know one of your customer's bitcoin addresses (maybe you want to send them a refund?) you must ask them.  They might be using an escrow service like ClearCoin or, as theymos says, using a shared wallet service like MyBitcoin. Code:sendmany <fromaccount> {address:amount,...} [minconf=1] [comment]amounts are double-precision floating point numbers    https://github.com/bitcoin/bitcoin/pull/106Need for this is being driven by mining pool operators; it is much more efficient to pay lots of people with one transaction rather than lots of little transactions.Old clients will refuse to relay sendmany transactions, so to ensure timely inclusion in a block mining pool operators should either upgrade together and connect their clients together or wait until a good percentage of the network has had a chance to upgrade to the next version of bitcoin.Examples of use from a bash command-line (note you have to quote the second 'object' argument because the {} characters are interpreted by bash):Code:bitcoind sendmany "" '{"mvTt8hav6e9ESjSrXJ1yaJhyULHv8ywcN7":50}' 1 "To the Faucet"bitcoind sendmany "SomeAccount" '{"myeTWjh876opYp6R5VRj8rzkLFPE4dP3Uw":10,"mikZVLuasDcY1Jmph3rqgT1NXfjB1srSEc":15,"mvTt8hav6e9ESjSrXJ1yaJhyULHv8ywcN7":50}' RE: changing things now "just in case" :No, I think it would be dumb to switch hashing algorithms or public/private keylengths now, for at least two reasons:1. You'd just be switching from older technology that has the advantage of being well-tested and "battle-hardened" to something newer that you THINK will be more secure.2. There are much more important things to work on.  If you know enough about crypto to evaluate whether Whirpool really is fundamentally more secure than SHA-256, please apply your knowledge to the problems we have right now, like making users' wallets more secure against trojans and malware... So lets say I can create SHA-256 collisions fairly easily, and I want to replace an old transaction somewhere in the block chain.I create an alternate version of the transaction with the same hash... and then?  Whenever clients happen to connect to my node to get old transactions I feed them the bogus version?How do I get a majority of the network to accept the bogus version as valid, when the majority of the network probably already has already downloaded the old, valid version?Same question if I'm creating duplicate (old) block hashes instead of duplicate transaction hashes.I suppose I could try to double-spend with two transactions that hash to the same value... and hope that the merchant's bitcoin accepts Transaction Version 1 while the majority of the rest of the network accepts Transaction Version 2 (where I pay myself).   But if SHA-256 ever gets close to being broken I'm sure bitcoin will be upgraded so new clients only accept upgraded hashes for new blocks/transactions. You're browsing the web and see a link or button that says "Pay now with Bitcoin"-- you click it, and... stuff happens.  Where that stuff does NOT involve copying and pasting anything (I know WE all know how to copy and paste, but a surprising number of computer users don't) and certainly doesn't involve trying to type in a 35-character bitcoin address. WAAAAAY back in May of last year I did a little CPU mining.  Then stopped when I realized I was spending more on electricity than the bitcoins I generated were worth.  Bitcoins were selling for under a penny a piece, and I figured it cost a couple cents in electricity to mine them.So if you think there's a chance bitcoin prices will be 10 or 100 times higher in the next year or three, maybe CPU mining now isn't crazy.Just saying. Cool... but Hal just convinced me we don't need that feature for bitcoin 1.0.Is anybody willing to commit to actually implementing any of these?I know the bitcoin<->Berkeley DB code pretty well, so I'll volunteer to do the "Import a backed up wallet" feature. You mean fairly large fluctuations in BTC/$ prices?  Yes, yes it will.  If you're looking for a stable, boring investment do not buy bitcoins.I'm still surprised we haven't seen a real price bubble yet (where my definition of bubble is "doubles in price and then falls all the way back down").  Maybe we're in the middle of one still on its way up... Maybe it is time to start a bitcoin stack exchange site?Forums aren't really designed for Q&A. Conversation I had tonight:People who know me aren't shocked that I'm working on something wild and crazy, and by saying up front "this is a wild and crazy idea that may or may not work" I think they're more likely to really think about whether or not bitcoin makes sense. It is amazing how the brain can ignore things that it sees every single day...  (thanks for pointing that out, fixed).RE: removing wording about generating coins on the home page:  any objections to doing that? Pull request:  https://github.com/bitcoin/bitcoin/pull/101 I suppose if we figure out how to make click-to-pay work for both the "I'm using an online wallet service" and the "I'm using the client" cases, then users won't have to know how to copy&paste addresses and human-type-able addresses won't be critical.RE: DoS resistance:  please DO keep thinking about it; I'm not a networking expert (in fact, if you know any networking experts, see if you can get them thinking about it....). Good idea.  I opened a feature request at https://github.com/bitcoin/bitcoin/issues/100 Clearcoin now supports sending unreleased coins to a charity instead of refunding them, which gives both buyer and seller the same incentives. Crashing bugs, any bug that might result in loss of bitcoins, and security fixes are always highest priority, but here are the big things I think are very high priority that, as far as I know, nobody is working on.  I think they all need to be done before we can say we have a "Bitcoin 1.0" :finish download-only-blockheaders client modepassword-protect the wallet private keys (mitigate the steal wallet.dat problem: see https://gist.github.com/803170 )import a backed-up walletfigure out how to do click-to-paydesign/implement a secure DNS-like "map string to bitcoin address" system  (so I can send bitcoins to "gavin@acm.org")export+encrypt part of your balance (for long-term storage; I still waffle on whether we want to encourage that right now) The tag is v0.3.20.2, and it is signed by my (gavinandresen@gmail.com) gpg key.RE: roadmap for v0.4 :  I worry that we'll spend time creating a roadmap and then... people will work on whatever strikes their fancy.  So the 0.4 release will end up being completely different from what the roadmap says.That said, I'll start a roadmap thread; maybe we CAN all agree on priorities and find people to actually work on the highest priority stuff.
The maxsendbuffer bug (0.3.20.1 clients not being able to download the block chain from other 0.3.20.1 clients) was only going to getworse as people upgraded, so I cherry-picked the bug fix and created a minor release yesterday.The Amazon Machine Images I used to do the builds are available:Code:ami-38a05251   Bitcoin-v0.3.20.2 Mingw    (Windows; Administrator password 'bitcoin development')ami-30a05259   Bitcoin_0.3.20.2 Linux32ami-8abc4ee3   Bitcoin_0.3.20.2 Linux64(mac build will be done soon)If you have already downloaded version 0.3.20.1, please either add this to your bitcoin.conf file:Code:maxsendbuffer=10000maxreceivebuffer=10000... or download the new version. fopen() is a standard C library call; it is weird Bitcoin can't find it.Is anybody else running bitcoin on OSX 10.5 ?   I'm running 10.6.6; Laszlo does the OSX builds, I'll ask him what he's running. I was editing the bitcoin.org homepage to update the download links, and I couldn't resist make a few changes:I removed the "If you are running version 0.3.9 or earlier please update" message.  People running really old versions of bitcoin SHOULD update, but there is no longer any security risk if they don't.I replaced "there were X blocks as of Y date" with a link to jgarzik's Bitcoin Watch site.I made the SHA1 checksums at the bottom of the page tooltips of the download links.  I think it is easier to match up checksums to filenames that way, and I think it looks less intimidating for people who have no idea what SHA means.PS:  I read the thread about replacing the self-signed bitcoin.org security certificate, and agree that needs to be done... Nice analysis!  I'm tempted to put a link to your post in the code as a comment...The whole transaction prioritization scheme was written by Satoshi after I suggested that de-prioritizing "small new" transactions might help the spamming problem.  In the last couple of days we've exchanged email about possibly modifying it; pull request 88 is the first suggested change (it makes the CreateTransaction fee calculations match the CreateBlock calculations).Until somebody finishes implementing lightweight 'headers-only block download', we should try to keep block size small-- otherwise new users will have to wait an even longer time before being able to use bitcoin.Also:  the Faucet is now paying a 0.01 BTC fee per transaction.  With the CreateTransaction fix, it probably would be anyway (the transactions it creates look very spammy). I wouldn't have any objections to changes that let you decide which input transactions or receiving addresses to choose when sending coins, as long as it is well-tested, follows the coding guildelines (see coding.txt in the source directory)  and it doesn't make the "I just want to send some coins" case look more complicated (maybe hide it behind an Advanced... button in the Send dialog). fread failed means bitcoin couldn't read some data off of your hard disk.You might want to invest in a copy of SpinRite and check your hard disk for errors. There was a good Skeptoid podcast about it.Our brains are really good at pattern-matching, and are really good at fooling us into seeing patters where none exist. Please help test:  https://github.com/bitcoin/bitcoin/pull/95Sets the -maxsendbuffer and -maxreceivebuffer limits to 10MB each (so possible max of 2GB of memory if you had 100 connections).I tested by running a 0.3.20 node to act as server, then ran a client with:  -connect={server_ip} -noirc -nolisten... to make sure I was downloading the block chain from that 0.3.20 node. 500MB per connection times 100 connections would be 50 GB.  That re-opens the door to a memory exhaustion denial-of-service attack, which is the problem -maxsendbuffer fixes.As transaction volume grows I think there will be lots of things that need optimization/fixing.  One simple fix would be to request fewer blocks as they get bigger, to stay inside the sendbuffer limit...(ps: I've been re-downloading the current block chain connected to a -maxsendbuffer=10000 0.3.20 node, and the workaround works) Huh?  See that 'import json' statement at the top?  That would be the standard (as of python 2.6) JSON parsing library.The code I posted tells the standard JSON parsing library to read JSON Numbers as Decimal.  If you are doing monetary calculations in python, then you should be using Decimal.  That is what it is for. Oops.My fault-- I DID test downloading the entire production block chain with a 0.3.20 client, but I wasn't careful to make sure I downloaded it from another 0.3.20 client.Workaround:  if you are running 0.3.20, run with -maxsendbuffer=10000 You can't open and close the file; it is not thread-safe (thread one closes fp and sets it to NULL and sleeps, thread two wakes up and uses a NULL fp).And you can't wrap the open/close in a CRITICAL_SECTION, because logging happens at shutdown, CRITICAL_SECTION relies on a destructor to work properly, and you can't control the order in which C++ destructors are called during shutdown.I learned all that the hard way a few releases back.You can rotate the logs using the "copytruncate" feature of logrotate. genjix: here is how to do it right in Python2.6 :Code:import decimalimport json# From http://stackoverflow.com/questions/1960516/python-json-serialize-a-decimal-objectclass DecimalEncoder(json.JSONEncoder):  def _iterencode(self, o, markers=None):    if isinstance(o, decimal.Decimal):      return (str(o) for o in [o])    return super(DecimalEncoder, self)._iterencode(o, markers)decimal.setcontext(decimal.Context(prec=8))print json.dumps(decimal.Decimal('10.001'), cls=DecimalEncoder)print json.dumps({ "decimal" : decimal.Decimal('1.1'), "float" : 1.1, "string" : "1.1" }, cls=DecimalEncoder)print json.loads('{"blaa": 0.333331}', parse_float=decimal.Decimal)Produces output:Code:10.001{"decimal": 1.1, "float": 1.1000000000000001, "string": "1.1"}{u'blaa': Decimal('0.333331')}Note that EVEN IF YOU PASSED THE 'WRONG' strings to Bitcoin, Bitcoin would do the right thing. That is, these two are equivalent once they are parsed by bitcoin:Code:sendtoaddress FOO 10.000999999999999sendtoaddress FOO 10.001... because bitcoin does proper rounding.On the bitcoin side, this is a non-issue.  And if code on the other end of the JSON-RPC connection does the wrong thing (truncates values like 10.000999999999999 instead of rounding them to the nearest 8'th decimal place) then that's a bug in that code. Wiki page created:  https://en.bitcoin.it/wiki/Proper_Money_Handling_(JSON-RPC)genjix:  You should be calling json.loads(..., parse_float=decimal.Decimal) and use a custom JSON encoder class to convert decimals to JSON strings with no loss of precision... Can we not beat this dead horse?I think there are MUCH more important things to work on / worry about than whether or not "send 1 BTC" is expressed as "sendtoaddress FOO 1.00" or "sendtoaddress FOO 100000000" in the JSON-RPC.How about we (I'll start) write a "Proper Money Handling" page for the Wiki that discusses the issue and gives code example of how to convert to/from JSON double-precision floating point and 64-bit integer? Because JavaScript doesn't have a 64-bit integer type (all Numbers in JavaScript are double-precision floating point). If there is a virus on your computer, and your bitcoins are stored on that computer, then there is nothing the bitcoin software can do to prevent that virus from eventually stealing your coins.That said, allowing you to 'lock' your coins with a password, and requiring that you enter that password to send coins, is high on the list of things I'd like to see bitcoin do.  That would make it harder for a virus to steal your coins.But even then, a smart virus could lay in wait until you typed your password to unlock your wallet and take that opportunity to either capture your password or send the coins to a bad guy.  If you can't trust your computer, don't store your life savings on it (and yes, bitcoin software also should make it easy to save some of your bitcoins on USB sticks or CD-R disks so they can be stored safely in your safe deposit box at your bank). https://github.com/bitcoin/bitcoin/pull/88This makes CTransaction::CreateTransaction use the same rules for what transactions require a fee as CBlock::CreateBlock.The mismatch was the root cause of the transaction slowness (low-priority free transactions were created but weren't being included into blocks until they 'matured' and had a higher priority). ... and you get 'fatal error, can't create' when you try to compile bitcoin?Sounds like your obj/ dir is not writeable by whichever user you're using to compile. I've got a (private so far) patch that creates mass-pay transactions.  API is:  sendmulti <fromaccount> {address:amount,...} [minconf=1] [comment]This code in CTransaction::AcceptToMemoryPool will need to change, too:Code:      if (GetSigOpCount() > 2 || nSize < 100)        return error("AcceptToMemoryPool() : nonstandard transaction");(a mass-pay transaction will have N+1 OP_CHECKSIGs in it, where N is the number of people being paid).Replacing in the stock client with something like:Code:  if (GetSigOpCount() > 2) minFee += GetSigOpCount()*GetArgMoney("-masspayfee", CENT/100);... seems like the right direction to go.BUT: I think a higher priority is figuring out how to deal with fees for the other two send methods.
RE: limitfreerelay:Agreed, that's better.  I think we should start soft-coding the amount that is considered "free" instead of hard-coding CENT, and make the default less than 0.0001 BTC.Separate subjects:The entire transaction memory pool should be size-limited, with lower-priority transactions dropped.I agree with Steve-- free transactions are a HUGE selling point, and I think rational miners should realize that their bitcoins will be more valuable if there are more users.  And there will be more users if "free transactions" is a feature.  I think we can come up with a solution where "normal" transactions are free, but spam or abnormally complicated transactions (yes, like those bitpenny rewards pooled mining participants are currently getting once a day) "require" a fee (where "require" is really "if you don't include a fee your transaction will probably never be confirmed.")And finally... we've got a problem right now; lets think about what fix(es) move us in the right direction quickly, or think about fixes that will solve the current problem (that we may need to undo/rework later). No.  The only way to "break your stash" is to create transactions that are broadcast; splitting your wallet into lots of small transactions makes the problem worse for you and everybody else (it is more 'expensive' to handle fistfulls of nickels and pennies, even in the bitcoin world). Thanks for the donations, everybody!Catching up on questions:Is the faucet supported entirely by donations?  Not entirely-- the captchas have generated about $100, which will go into refilling it.  It looks like captcha revenue is only covering about 1/4 of the cost of the coins, although the company that does the money-for-captchas is a startup looking for more advertisers.  Actually, if you want to advertise a bitcoin-related business you should talk to them... (they're adscaptcha.com)Was somebody abusing the faucet?   Yep, somebody was exploiting a weakness in my IPv6-handling code.  I've fixed the weakness (the faucet is now much stricter about what it considers "different" IPv6 addresses), but I think I'm fighting a losing battle-- the next step will be to require you to login with a valid google account to get coins.  I hate to add another hoop to jump through...Is it time to reduce the payout?  Maybe soon, but I'd rather wait until the next release is out and then reduce the payouts another factor of 10 (so 'standard' payout if balance was above 500BTC would be 0.05BTC, and 0.005 when it was running low).Can I add a link to bitcoinmonitor.com?   Done. You can generate a 1MB block with only free transactions in it and it will get accepted (maximum block size is 1MB, although the standard bitcoin client will never generate blocks larger than 500K).The problem isn't the pool payout-- the problem is that people participating in the pool end up with wallets full of tiny (e.g. penny-size) transactions.  When they go to spend those tiny transactions, they're bundled up together to make a transaction that is small in value but large in size.Pools can mitigate the problem by requiring larger minimum payouts (e.g. 1 BTC instead of 0.01 BTC). This definitely needs fixing; it is another "people getting lots of very small change from mining pools" issue.The code that controls this is CTransaction::GetMinFee() in main.h and CreateNewBlock() in main.cpp.We should think about:+ Is setting aside a specific amount of space for free transactions the right thing to do?  Maybe blocks should just get filled in reverse priority order (with transactions with fees at the front of the line)+ What to do with the current transaction backlog.If old, big, low-priority transactions get flushed, then there needs to be some way for the bitcoin client(s) that sent them to reclaim those coins.  Perhaps the client should stop retransmitting, and reclaim, transactions if, oh, 5,000 blocks go by without the transaction getting accepted.Or maybe it makes sense to let those old transactions trickle in; perhaps the next version of bitcoin should take the oldest transaction in the memory cache and add it to the generated block. This is:  https://github.com/bitcoin/bitcoin/issues#issue/86currently (2011/03/01) a backlog of transactions that dont seem make it into blocks is building up (according to ArtForz now 670 transactions).People are starting to complain, see http://bitcointalk.org/index.php?topic=3835.msg57031#msg57031 for an example.This was discussed on #bitcoin-devArtForz> that tx should have a score of 20567855ArtForz> so it falls short of the dPriority > COIN * 144 / 250 testArtForz> and as tx size is > 4000, fAllowFree is never true for ittheymos> Ah. So it will never confirm?ArtForz> probably notArtForz> looks like the tx-sending code needs some fixingmolecular> like not generate a tx with a score too low, or suggest to add a fee?ArtForz> yepArtForz> check size and priority of transaction, if it's > 4kB and score < 57600000 require min feeArtForz> maybe reduce the size limit to 3.5k or so, otherwise it can only get into an otherwise empty blockMaybe the transaction cache should not be unlimited? Actually, I'm considering turning on transaction fees for the Bitcoin Faucet because small transactions with "new" coins are given very low priority, and recently new users are noticing that their Faucet coins are not arriving promptly. Good Idea.  You should do that.  Maybe marking issues at github with a "Launchpad" tag would be a good system? I was tempted to do more than fix the rounding problem...... but then sanity overwhelmed me.If you'd like to start a discussion of whether or not it is a good idea for one-thousand German bitcoin amounts to be displayed as "1.000,00", be my guest.  I think there was such a discussion in the past, but I didn't pay attention to it.  I think it would be nice if an amount like "1.001 BTC" (or even "1.001 tonal bitcoins") was unambiguous.RE: subcent throwaway change:  turn it into a proper PULL request (yes, you'll have to-- horrors! -- use that evil, not 100%-pure-open-source github) and it'll happen faster. 80 transactions per second is 6.9 million transactions per day.  That is a LOT.PayPal was doing about 2 million transactions per day in 2008; if there are three times as many bitcoin transactions as PayPal transactions in a few years that would be a very good problem to have, and I'm confident "we" would figure out how to deal with lots of transactions. It was LC_NUMERIC, I bet... (I'd just set LANG and unset the rest and assumed they'd all get picked up; internationalizing C++ applications is something I know very little about).I modified the patch to format numbers the way they were formatted before:  always , for the thousands separator, and . for the decimal point (instead of letting sprintf try to do the right thing). So?  So?!?  11 is my favorite number! Are you setting the ContentType as described here:  https://en.bitcoin.it/wiki/API_tutorial_(JSON-RPC)#.NET_(C_) Can anybody else reproduce this?  It works for me: The official client uses an older version of Berkeley DB (4.8, according to build-osx.txt).You're linking to Berkeley DB 5.1.19, so when you run your client it upgrades the bitcoin database files, which makes them incompatible with the official client. No.  Generated coins need a place to go (they're credited to the "" account), and coins you send using sendtoaddress (where you don't specify an account) need to be debited from somewhere (they're debited from the "" account).And it's theoretically possible somebody might could use one of your hidden "change" bitcoin addresses to send you coins; they'd be credited to the "" account, too. JollyGreen was asking about 'typical people'.  And I think he was asking about "right now".Typical people aren't going to distinguish the currency from all of the financial services that make the currency safe, convenient, etc.  And I think we should be honest-- bitcoin-the-currency needs more mature financial services before bitcoin-the-system makes sense as a payment solution for typical people. Saving for the future:  bitcoins are designed to be like gold: durable, only a limited supply.  They have some advantages over gold-- they're much easier to store safely (you don't have to buy a bank vault or hire guards or trust a storage company) and, because they're electronic, they can be backed up.  And when it is time to sell them the transaction costs are very, very low.Buy some goods online:  I don't think bitcoins have any significant advantage... yet.  Transaction fees are lower once you get bitcoins, but the transaction fees to get bitcoins probably eliminate that advantage.I think Bitcoin's real, hidden advantage is the fact that you don't have to ask anybody's permission or fill out any paperwork to start doing creative, innovative things with them.  Lots of people are doing lots of innovative things with bitcoins, and while most of those innovative things will probably fail (most startups fail), I'm optimistic that some will succeed and in 5 years we'll be using bitcoins in some way we haven't even imagined yet.  I'm not going to pretend to know which market niches bitcoin will fill-- maybe it will be migrant workers using bitcoin to send money back home and avoiding international wire transfer and currency conversion fees.Maybe teenagers in China will use them to buy stuff online because they can't get a credit card.Maybe big multinational corporations will decide to use bitcoins to pay their supply chain to avoid currency exchange risk and save 0.1% on their transactions.  Who knows?  Even if bitcoin turns out to be just "a better store of value than gold" it will be hugely successful. See:  https://en.bitcoin.it/wiki/Block_hashing_algorithmThe exact hash done is double-sha256: sha256(sha256(block_header_data))See: http://en.wikipedia.org/wiki/SHA-2... for information about sha256 Great suggestion, I will modify the code to refund the escrow fee (if any) and donate the rest.I have some preliminary plans for mediated escrows that will require all three parties to have ClearCoin accounts.  I'm still thinking about how to make it as simple to use as possible.Great idea, I'll put it on the "nice to have" list.Easy to do.  How critical is time?  Plus or minus 1 hour would be easy (there's a 'cron job' that runs once per hour to process refunds), but I don't want to make the Create an Escrow page more complicated than it really needs to be.I'll probably target transactions under $50 remaining free, and I'm thinking of capping fees at $4... but it is likely I'll experiment with different pricing models as I fill out features.  Paying mediators (before and/or when mediation is required) adds lots more wrinkles...Nope.  Maybe I'll franchise later if Bitcoin and ClearCoin really take off.No-- what authentication method would you like to see?  I don't like the idea of supporting arbitrary OpenID authentication, because it is so easy to create throwaway OpenID identities (creating throwaway Google identities is at least a LITTLE bit harder...).
Uh-huh...  storing a lot of bitcoins on a usually-network-connected device would make me very nervous.  I think we're going to see a LOT of smartphone exploits over the next 5 years (maybe I'll be pleasantly surprised and it will turn out the smartphone OS folks have done a great job making them secure).But security is not a boolean, and we clearly need to do what we can to help people keep their bitcoin wallets secure. What happens if:-- you dump a private key from bitcoin client 'A'-- shutdown A-- import it into bitcoin client 'B'-- spend it from B ... wait for a confirmation or three...-- restart ADoes A notice that the coin's been spent?  I think there's a bug that it does not, and I think that bug needs to be fixed before we make it easy to export/import private keys.  So, please bang on sipa's patch and see if anything else breaks! I've been thinking a lot and trying to educate myself on best practices for securing the bitcoin wallet.Part of the solution could be a smart card that supports ECDSA; the PKCS #11 standard supports elliptic key crypto, so it is feasible to have a hardware token that stores your private keys and never lets them out of the token.If the token includes some type of biometric identification (e.g. built-in fingerprint reader or mechanism for entering a password) then there is no way for the trojan to spoof new transactions.But [mike] is right-- if your computer is infected by a trojan the trojan can just rewrite the bitcoin address and amount before the software asks the hardware token to sign the payment transaction.  The only way to prevent that is if the hardware token can somehow display the transaction details independent of the infected computer.  That's one very sophisticated hardware token...Hopefully Hal and bitcoinex will now tell us how all this was solved years ago and how an iPhone app synchronized with a dumb-ish smart card can use smart crypto to make it all work.... I'm looking for feedback and suggestions for a new ClearCoin feature:  refund-to-charityHere's how it works:When Alice creates an escrow account at ClearCoin she says that, if the coins in the account are not released, they'll be donated to charity. She then funds the account, and shows Bob (the person she's trading with) that the coins are sitting in escrow.Alice knows that if Bob doesn't complete the trade he won't get the coins.Bob knows that if Alice doesn't release the coins she won't get them either.So neither Alice nor Bob has a strong incentive to cheat.  They each have a weak incentive if they'd rather the charity get the coins (and they're not worried about potential harm to their reputation).I've got an initial implementation up and running, with the list of charities from the Bitcoin wiki Trade page.I'm thinking of a few enhancements, and would love feedback on which ones you think are critical and which would be just nice-to-have:1. Give Bob (the person receiving the coins) a way to setup the escrow and send a link to Alice (who controls the account).2. Let Bob and Alice agree (in advance) to refund the bitcoins to an arbitrary address instead of a fixed list of charities.3. If the coins are refunded to charity, show Alice and Bob the transaction ID so it is easier for them to make sure ClearCoin isn't taking the coins.General feedback, criticism, etc. is also very welcome! RE: trading private keys with somebody:  theoretically you could, but that's not typical bitcoin usage and the current bitcoin client makes it hard to do.Practically speaking, if Bitcoin did have a feature to state: "On THIS date somebody using the identifier <foo@bar.com> controlled THIS public/private keypair"... that would just inspire the smarter bad guys to send stolen coins to new private keys before spending them.I can imagine a black market forming where dumber bad guys sell stolen wallet.dat files (at a discount) to smarter bad guys (or just plain greedy people who don't bother to ask where the wallet came from), who mix up the coins in them and then sell them. Yes, not implemented yet.  Do you want to remove them just so the listaccounts output isn't messy, or is the lack of a deleteaccount API call preventing you from doing something you need to do? From another thread:No need to embed the identification in the transactions, I don't think.  You just need to associate your public keys with 'you' at some place where anybody can see that association and prove that you originally owned the private keys associated with those public keys.Let's see, I think something like this would work:For every private key in your wallet:  Grab the corresponding public key  Sign it with the private key  Compute SHA256(public key, signature, "your name and email address")Then upload all of those SHA256 hashes to some secure central database somewhere, which stores it along with the time it was uploaded.Now if somebody copies your wallet and spends your coins, you can prove that you had the public/private keys in the past by showing everybody the (public key, signature, "your name and email address") that hashes to the value in the central database.The crook can upload their own SHA256, of course-- this relies on you uploading before the crook. Entering a password every time you want to send coins (or pulling out your... dongle... err, that didn't come out right, uhh, fetching your one-time-password-generating-device) might be annoying enough that withdrawing 50 or 100 bitcoins that you can spend with minimal hassle would be a nice feature. Converting from a double-precision float from the JSON library to an int64 bitcoin is:Code:int64 nAmount = roundint64(dAmount * COIN);... which will always do the right thing (COIN is 100000000).int64 to JSON string there are no code changes.GUI string to int64 is a direct conversion, no intermediate double precision.And int64 to GUI string is:Code:strprintf("%.08f", double(amount)/double(COIN))... which also always does the right thing (printf of a floating point number rounds, and there is enough precision in a double the rounding will always be correct).0.1 bitcoins will always become exactly 10000000 base units internally, and 10000000 base units will always be shown as exactly 0.10 (in the GUI) or 0.10000000 (in JSON). I just did some testing (on Linux) and the GUI seems to handle full-precision values quite nicely. https://github.com/bitcoin/bitcoin/pull/79This modifies FormatMoney to display full-precision values (with trailing zeroes trimmed correctly-- e.g. 0 is 0.00 but 0.00010000 displays as 0.0001).And ParseMoney allows entry of full-precision values.And JSON's AmountFromValue doesn't round to two places, so you can send/move full-precision values.I haven't tested this with the GUI bitcoin yet, it will probably require UI layout tweaks. Bitcoin is confusing at first glance because so many problems are solved using just a few ideas.  If you think about it long enough, it is quite elegant.The busy-work of finding a block hash that is "small enough" solves a couple of problems:First, by making it hard to create coins so they are artificially scarce.  That is really important; if it was easy to create gazillions of bitcoins we'd all have gazillions of bitcoins that were worth nothing.Second, it solves the double-spending problem-- the computer that solves the busy-work problem first gets to decide which transactions are "THE" transactions, and which ones are invalid (because you're trying to spend coins you've already spent). Our legal systems haven't caught up with the Internet.  What's the proper jurisdiction for somebody in Iceland using a bitcoin exchanger in the US who got ripped of by somebody living in (lets see, which country do I want to offend today....)  a seasteading community? "people" is me-- when I tweak the Faucet's code I erase my IP address from its database and then have it send coins to itself as a sanity test.And Hal's right, Bitcoin chooses transactions to spend, not specific outputs (which only matters for sends-to-self, where you own both outputs of a transaction). Hmmm...Thinking a little more, Mr. Lucky will have some coding to do.  Blocks are indexed based on their hash, so when he generates that second all-zero hash he's going to have trouble with the current implementation.  Actually, he'll have trouble before then, because if the target is low enough there won't be enough unique hashes...(and before somebody asks: YES, there is a very small chance that two blocks will be found with the same hash.  And NO, that is NOT a problem that needs to be solved, it is so improbable it is not worth worrying about). Looks like somebody's playing with a tweaked bitcoin-- if you trace back the inputs they're from a previous block that has the same odd pattern.The standard coin selection algorithm in bitcoin would generate a one input / one output transaction.Hal and theymos are right-- I misremembered how the coin selection algorithm works. Updated Mac build is on Sourceforge, as is a PGP-signed README.txt.I also just changed the links on the front page of the wiki; the links at bitcoin.org will be updated as soon as sirius and I are awake at the same time again  SHA1-checksums for the binary files are:7dfbc05b36112f59886a29f044cfd21c6c253169  bitcoin-0.3.20.01-linux.tar.gz3fe4c5f2a5406322a2f116b30aefbd402b079940  bitcoin-0.3.20.01-win32-setup.exedffb709a90a7abcff08c2ef1e79d3f9b54751786  bitcoin-0.3.20.01-win32.zipb540825d864e7561cc21465ad072fb299e0d817a  bitcoin-0.3.20.01.01-macosx.zip Rumor has it he stole an Infinite Improbability Drive. RE: a checklist:For the next release, I will write a script that does all of the build/package steps.  I'll let the computer run the checklist for me... and the whole process should be much quicker, easier and smoother.RE: 0.3.20.01Fixed builds are at sourceforge, named 'bitcoin-0.3.20.01' to try to avoid confusion.The mac build was 0.3.20.00 also; I am going to update that .zip when we get a .01 build, and I think I'll rename thelinux downloads to be consistent and, again, to try to avoid confusion.SHA checksums:3fe4c5f2a5406322a2f116b30aefbd402b079940  bitcoin-0.3.20.01-win32-setup.exedffb709a90a7abcff08c2ef1e79d3f9b54751786  bitcoin-0.3.20.01-win32.zipThe public Amazon AMI virtual machine image used to build them is: ami-7a21d213   982440761210/BitcoinMinGW I'll be re-releasing updated windows .zip and .exe files later today to fix these issues.And this time I'll triple-check versions on everything.
Did I put the wrong bitcoind.exe in the Windows exe and/or zip?D'oh!Companies I've worked for in the past had a rule-- programmers were not allowed to test their own code.  I'm still looking for people to volunteer to be dedicated quality assurance testers (and a quality assurance manager to organize them) to help keep this type of thing from slipping through. First:  the bitcoin.org homepage links will be updated as soon as sirius has a chance to wake up, read his email, and make the changes.A different skin for the Windows build is from upgrading the wxWidgets used to build (2.9.1 instead of 2.9.0).Did anybody test the -nolisten with the GUI bitcoin on Windows?I believe there is windows-specific code for checking to see if another bitcoin is running that looks at window titles; file an issue at github if -nolisten isn't doing what you expect. Binaries for Bitcoin version 0.3.20.01 are available at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.20/There were several changes and additions to the JSON remote-procedure-call interface;there are no significant user interface changes.  See:  http://bitcointalk.org/index.php?topic=3473.msg48839#msg48839... for details.This version does fix one significant denial-of-service attack (earlier versions ofbitcoin could be caused to crash due to running out of memory by a remoteattacker).SHA1-checksums for the binary files are:bitcoin-0.3.20-linux.tar.gz     7dfbc05b36112f59886a29f044cfd21c6c253169bitcoin-0.3.20-win32-setup.exe  2a4affd92dd11e0b759f90a8fa4bead58bdbf7b4bitcoin-0.3.20-win32.zip        7bf306554092e742d076d4157aaa077d95de6102bitcoin-0.3.20-macosx.zip       47ca28454e7ea0b576b80905353d1cea024e53fe Oops, sorry-- I forgot to change the admin password.  The correct pw for that instance is:  penguinsruleI change the password to match the MinGW VM and updated the AMI:  ami-d621d2bf    982440761210/BitcoinVC10Admin password:  bitcoin developmentYou should change the password as soon as you login or make sure you use a security group that only allows your IP address to access the virtual machine. No.  You should expect the testnet to be reset, if for no other reason than to keep people from using it as a "real" currency. Good idea.Patches welcome, as long as they're nice and stable and have had a fair bit of testing... CSV file with the private key and block numbers is a good idea, although for it to be a valid CSV file then it needs to have a fixed number of columns.I'd modify the design slightly to be just:base58 encoded privkey,block number... where block number is the block number of the earliest input (that'll save rescanning time-- you probably always want to rescan from the earliest block number, anyway, in case more payments were sent after you exported the key).Also what do you mean by "export" -- write and then remove the keys from the wallet?  Write a newly generated key and generate a payment-to-that-key for a given amount of coins?I think any code that removes keys from the wallet (or generates payments to keys that are never added to the wallet) needs to be structured as two distinct steps:1. Write the keys to <destination>2. Read <destination> to make sure it is valid, and, if it is, delete the corresponding keys from the wallet (or generate the send-to-self txn). Here's the public AMI for the dodgy 0.3.20 VC10 build:  ami-d621d2bf    982440761210/BitcoinVC10Bitcoin source is at c:\bitcoin(all the other dependencies are in the root c:\, too).Administrator password is:  bitcoin development Yes, I have the VC10 VM.  I am hesitant to make it publicly available because it has a copy of Visual C++ 2010 Express installed, and I don't want Microsoft to sue me for redistributing their software without permission.I'll uninstall it from the VM and then make the image public; you'll have to download and install (and agree to the license) Visual Studio Express yourself to get it working. Can you post examples of requests/responses with the "old" JSON-RPC and your new JSON-RPC?I'm still firmly against this change-- it seems to me you are "solving" a non-problem. There are approximately 2160 things higher on the development priority list. 1 petabyte is 1015 bytes.There are 2160 possible BTC addresses, each of which is 160 bits == 20 bytes long.So to store all of them you need 2160x20 bytes, which is 29,230,032,746,618,058,364,073,696,654,325,660 petabytes. Yes, it is public Amazon ami-2edd2e47   named  982440761210/BitcoinMinGWThe linux32 and linux64 amis I used to build the linux releases are also public. Did you get a debug alert with bitcoin 0.3.19 or earlier?And could you post a screen snapshot (or, even better, file an issue at https://github.com/bitcoin/bitcoin/issues )? Frankly, I'm not sure how I feel about this.I absolutely positively want more scrutiny of both bitcoin's source code and the underlying cryptographic concepts.However, I don't think offering a token amount of money (even in the form of bitcoins) is appropriate.A real, professional security review of bitcoin would take a lot of time and a lot of money.  I understand that's not what is being asked, but asking Mr. Schneier to write about bitcoin is really an irrational "Appeal to Authority" -- I think he'd say that any cryptography-related technology is never proven secure, but only gains trust by having multiple people and groups of people look at it, imagine potential attacks, try to attack it, etc.Or, in other words, if he writes an article about bitcoin now I think the summary would be "interesting new technology, doesn't appear to be a scam, worth keeping an eye on."   I think he'll write that article soon without any prompting from "the bitcoin community," just given the level of buzz bitcoin is generating the last month or two.  I don't think a few hundred bitcoins will motivate him to write the article any sooner. The only thing stopping me from announcing 0.3.20 "Final!" is confirmation from Windows users that switching to the mingw build process fixed the rendering issues.So:  if you're a Windows bitcoin user, please install the latest 0.3.20 from SourceForge and let me know how it works for you. Version 0.3.20.01 is now at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.20/Differences with the first release candidate 0.3.20:+ Windows built with mingw instead of Visual C++ (my fingers are crossed that fixes the rendering issue)+ Fix for a denial-of-service attack reported in IRC I've generated lots of blocks on the new -testnet. I've made public the windows, linux32 and linux64 Amazon Machine Images used to build bitcoin 0.3.20.  If you have an Amazon EC2 account, you can launch them and have your own working build environment for linux or windows bitcoin (paid for by the hour).They are:  ami-4adf2c23        32-bit Linux (Ubuntu 9.04)  ami-12df2c7b        64-bit Linux (Ubuntu 9.04)  ami-7a21d213       Windows (with MinGW)All created in the us-east-1b zone (I don't know if Amazon automatically migrates public AMIs across the world).After launching the Linux VMs, you login as root (using the ssh keypair you specify when you launch).After launching the Windows VM, you connect via Remote Desktop and then login as Administrator, password "bitcoin development" (you should change that for your instance as soon as you login, of course).They contain bitcoin, bitcoind, and everything needed to build them, already built.  You could launch instances and try to generate coins, but that's not cost-effective.(Updated 22 Feb with 0.3.20.01 Windows AMI) I just committed (to git and svn) an updated build-msw.txtThanks to m0mchil for putting together a working windows/mingw build environment.And I'll be making the 0.3.20 build environment virtual machines (for Windows, Linux32, and Linux64, in the Amazon EC2 cloud) public, hopefully, if all goes well, later today.
The linux binaries are built on Ubuntu 9.04; that's the earliest ubuntu that has all the required dependencies.Ubuntu and Debian are kissing cousins; Debian 5 would be a good choice if they don't have an Ubuntu that's more recent than 8.10. No, but there should be.Proposal:  treat immature coins as starting with -100 confirmations, and modify listtransactions to list immature category=generate coins (with negative confirmations).There's probably an off-by-one-error lurking there... (will have to make sure the coinbase transaction is spend-able when it goes from -1 to 0 confirmations). First, "potentially forking" changes like that would be structured as:if (block number < SOME_BLOCK_NUMBER_IN_THE_FUTURE)  ...old ruleselse  ...new rulesAssuming a super-majority of people agree with the change and upgrade before we get to SOME_BLOCK_NUMBER_IN_THE_FUTURE, the switch will happen smoothly.Is there a chance of changing?  Sure, but I think anybody who wants to make such a fundamental change would need to do a LOT of testing-- maybe spin up or recruit a few hundred machines all over the world on a test network, have them mine and simulate transactions to each other (ideally with similar volume to the real network) while going through the transition and making sure there weren't any unintended consequences.  And convince a super-majority of people that the benefit of their potentially forking change outweighs the risk of disrupting the network if there's some consequence they didn't think of or that their test network didn't simulate properly.Practically, would dropping the block time from 10 minutes to 1 minute be worth the risk?  I doubt it.  1-10 minutes (1 would be the average, get unlucky and it could take 10) is still too long to wait for small-value in-person transactions.RE: democratic organ:  bitcoin is a kind of a democracy.  Whatever code the majority of miners/nodes is running makes the rules. Update on the problem and release:m0mchil reports no rendering issues running a 0.3.20 bitcoin compiled using the mingw toolchain, and has volunteered to document/setup the build environment (in an Amazon EC2 virtual machine that I'll make public so it'll be easier for anybody to get a working bitcoin windows build environment up and running).And responding to alkor:  Windows/Mac open source coders seem to be a lot rarer than Linux... which is not surprising, I suppose.PS to genjix:  Looking good!  I'll try to find some time to give it a try (I don't know Qt programming so I probably won't be able to help code, though). Sure.   sirius:  after getting the 0.3.20 release out, I want to work with you (and everybody else) to make the bitcoin.org website more newbie-friendly. Huh.I live next to a major research university, and at least around here people get PAID to participate in psychological experiments.Not the other way around.So I guess my short answer would be "no". Thanks for all the positive feedback!And ribuck's right-- when I first started putting together the talk there were about 5 million bitcoins worth about 2.5 million dollars.By the time I gave it, they were worth about 4 million dollars.  And two days after I gave it bitcoins hit $US 1.00 ... The 5-minute Ignite! talk I did about Bitcoin is up:  http://blip.tv/file/4771178It was mostly what I wanted to say; I think I ended better than I started.  My slides and scriptwith exactly what I planned to say are here:  http://www.skypaint.com/bitcoin/GavinIgniteTalk.pdfFeel free to remix it.  If I ever do another Ignite! talk (they're 5 minute talks with slides that auto-advance ever 15 seconds) I'll plan to say less, try to interact with the audience more, and may hire somebody (with bitcoins, of course) to replace my text-heavy slides with more pretty pictures. One more thought:  the "finney attack" can only be profitable if the reward from cheating is greater than (reward of mining times the probability your block will be rejected because you delay announcing it while you "run down to the store").Reward for block is currently $50, that will (hopefully!) continue to rise for the next decade or two.Say it takes you 5 minutes to complete a transaction at the corner store (half the average block gen time)... today you'd have to make a $25-or-greater purchase just to break even.Seems likely this attack will be completely impractical for transactions under $200 when the block reward is worth more than $400.  0-confirmations (just wait N seconds to look for a quick double-spend) for any transaction under $200 seems "good enough" to me. I'm lost.  Who are X and Y?  You're going to spam the network with payments to X == yourself and Y == the corner grocery store in the hopes of... what?Remember the original attack:Again, it seems to me some rules that make attempted double-spends more costly to those who attempt to pull off double-spends might be a good idea.theymos' objection (that there's no real incentive for miners to try to detect/punish double spends) is worth thinking about.  Is there enough "interest in the common good" for miners to spend some CPU cycles so that the bitcoin system as a whole is more robust, or would self-interest lead to a tragedy of the commons where miners do the absolute minimum to just get their blocks accepted?bfever:  my gut reaction is that the "fast payment problem" won't be solved by more complicated transactions.  And my gut reaction to more complicated transactions is that that the more complicated something is the more likely it is to have security holes.... There is a bug in the 0.3.20 candidate release that causes rendering issues on Windows.I have no idea how to fix it; I don't even have a real Windows machine on which to test it (I built 0.3.20 on an Amazon EC2 windows virtual machine).Anybody willing to step up and fix it?If nobody steps up and commits to continuing to develop the wxWidgets GUI, we may have to stop supporting/developing it and start releasing only bitcoind. 2.1 quadrillion basic units should be plenty.  The US M2 money supply is (according to Wikipedia) less than 1 quadrillion pennies.If bitcoin is ever twice as popular as dollars, that would be a very good problem to have. The help text is misleading; never pass the "foo=" part.Somebody could teach bitcoin to accept either  getreceivedbyaccount foo 10    or    getreceivedbyaccount address=foo minconf=10... but maybe we should just change how the help text shows default arguments or improve the documentation. I think it is a reasonable assumption that major miners will be well-connected with each other.  There is certainly a strong incentive for miners to be well-connected in general (better connected == more likely to win 'block races').So I don't see how you could freeze the block chain-- if you generate lots of double-spends, the miners will quickly see both of spends and will drop those transactions like hot potatoes.  The "finney attack" only works if the first double-spend is generated by a miner that finds a block and includes it in the block without transmitting it.Also, my proposal was to only reject blocks containing 'suspicious' transactions that you hadn't seen transmitted that have a double-spend attempt before the next block. I'd just like a rational system where policy changes are proposed along with specific, testable predictions for those policy changes.Then the policy change is adopted.  Evaluated after a little while.And accepted or rejected based on whether or not the policy change had the intended effect.Then maybe we could take turns adopting our favorite policies, and see if that nice liberal "inequality reducing" policy actually, you know, reduces inequality (and we could argue about whether it is OK to do if it reduces inequality by making rich people a lot less rich and poor people a little more poor).Or if that nice libertarian "cost saving" policy actually, you know, saves money (and we could argue about whether the cost savings is worth it if it increases our chances of getting a scalp infection from an unlicensed barber). Mac binary uploaded to SourceForge (thanks to Laszlo, who builds the Mac versions). Yeah!  Those damn socialists! I agree with jgarzik:  the do-nothing << 0 is basically a comment saying "this is a bit-field." Excellent point.  Although there should be a meta-incentive to make the bitcoin system successful, so there are lots of transactions (and lots of transaction fees for the miners).  Certainly big payment clearing houses that want instant payments to work have the right incentives... Price swings won't settle down until: 1. The bitcoin economy is bigger (a "market cap" of hundreds of millions of dollars instead of just a few million dollars).and 2. Bitcoin is mature enough for people to really trust it.Unless there is somebody out there with very deep pockets and a willingness to spend a lot of money smoothing out the fluctuations there's not a whole lot we can do about it besides make bitcoin better, easier to use, more secure, etc.
Submit issues at the issue tracker on github if you run into issues:  https://github.com/bitcoin/bitcoin/issues Right... so then the question is "will the MYBITCOIN-like intermediary be able to verify transactions quickly without opening themselves up to systematic fraud."Without requiring users to pre-deposit funds with them, because users ain't gonna do that.Here's another possible simple rule for miners that might work (but, as Hal said, requires Deep Thought):"When I see a new block with transactions that I didn't see broadcast previously, mark those transactions as suspicious.  If I see double-spends of those transactions, stop building on that block-- assume it is cheating.  Switch to the previous block (or alternate block if there's a block race going on)."Miners won't try to rip off a grocery store for $50 worth of groceries if doing so makes their $50+ bitcoin reward for finding a block disappear.This rule would also give miners a strong incentive to detect and refuse to include EITHER side of a double-spend in their blocks (if they get both spends while they're working on the block). Please download and test the Windows and Linux release candidate builds of Bitcoin version 0.3.20.01:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.20/Summary of changes and new features (see pull requests for details):-nolisten : https://github.com/bitcoin/bitcoin/pull/11-rescan : scan block chain for missing wallet transactions-printtoconsole : https://github.com/bitcoin/bitcoin/pull/37RPC gettransaction details : https://github.com/bitcoin/bitcoin/pull/24listtransactions new features : https://github.com/bitcoin/bitcoin/pull/10Bug fixes:New seed nodes : https://github.com/bitcoin/bitcoin/pull/59New testnet genesis block : https://github.com/bitcoin/bitcoin/pull/53Optimize database writes : https://github.com/bitcoin/bitcoin/pull/43-maxconnections= : https://github.com/bitcoin/bitcoin/pull/42RPC listaccounts minconf : https://github.com/bitcoin/bitcoin/pull/27RPC move, add time to output : https://github.com/bitcoin/bitcoin/pull/21several improvements to --help output.SHA1 sums (UPDATED for 0.3.20.01):7dfbc05b36112f59886a29f044cfd21c6c253169  bitcoin-0.3.20-linux.tar.gz2a4affd92dd11e0b759f90a8fa4bead58bdbf7b4  bitcoin-0.3.20-win32-setup.exe Your second client hasn't downloaded all the blocks yet (according to the screen snapshot).When it has, it will be able to verify that the send transaction is valid, and will update your balance there. I think the real danger is that a large mining operator would create a side business selling space in their blocks for these types of intentional double-spends.  When they generate a block they could send a text message to a bunch of people saying "try to spend NOW".I wonder if there's some way to discourage that kind of anti-social behavior; could the network detect that was being done and "shun" that miner's blocks? Linux and Windows binaries are at:  https://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.3.20/Summary of changes and new features (see pull requests for details):-nolisten : https://github.com/bitcoin/bitcoin/pull/11-rescan : scan block chain for missing wallet transactions-printtoconsole : https://github.com/bitcoin/bitcoin/pull/37RPC gettransaction details : https://github.com/bitcoin/bitcoin/pull/24listtransactions new features : https://github.com/bitcoin/bitcoin/pull/10Bug fixes:New seed nodes : https://github.com/bitcoin/bitcoin/pull/59New testnet genesis block : https://github.com/bitcoin/bitcoin/pull/53Optimize database writes : https://github.com/bitcoin/bitcoin/pull/43-maxconnections= : https://github.com/bitcoin/bitcoin/pull/42RPC listaccounts minconf : https://github.com/bitcoin/bitcoin/pull/27RPC move, add time to output : https://github.com/bitcoin/bitcoin/pull/21several improvements to --help output. Here's what happens when you press the Get Some button on the Faucet and it sends you coins:+ A Google App Engine task is scheduled to actually do the send.+ The send tasks are (currently) scheduled to run at most once per minute, so huge spikes in demand for coins from the faucet are smoothed out.The nice thing about App Engine tasks is that they're persistent little buggers-- they'll keep going until they succeed.  If the send fails for some reason (I need to restart bitcoind for some reason, or the connection between the Google and my bitcoind server is down), App Engine will reschedule the task to try again after an hour.So, you were probably just very unlucky and the send failed twice in a row, OR you on the tail end of a couple hundred people all asking for coins at about the same time (the faucet will service a maximum of 120 requests in two hours). Easiest way would be to put it in the bitcoin.conf file.Create $HOME/Library/Application Support/Bitcoin/bitcoin.conf  and put:connect=IP ADDRESS... in it.  Any of the command-line options (except -datadir and -conf) can be put in the bitcoin.conf file. I'm halfway through creating releases-- I had a 0.3.20 candidate Windows release that didn't pass sanity testing (rendering issues that it looks like are fixed with a wxWidgets upgrade).If all goes well, 0.3.20 for linux and pc will be up and available tomorrow, 0.3.20 for the mac "real soon now".If not...  it will take longer. It is possible to generate transactions that "fan out" to an arbitrary number of recipients.They're non-standard transactions right now, so they won't be relayed or included in blocks.  But you should probably assume that they will be possible in the future (and a miner could, of course, include them in their own blocks now). Really?You don't think if bitcoin gets really successful and there are hundreds of millions of dollars poured into engineering efforts for it (and if it is wildly successful, big companies WILL invest huge amounts of money on it), that any scaling problems won't get solved?I bet I could find people predicting a few years ago that Facebook would never be able to scale to billions of users (it was written in PHP for pete's sake!). I think you're confusing libertarian with minarchist or anarcho-capitalist.Libertarians generally agree that police and a legal system to resolve disputes are a proper role for government. If you really want to sway people, you need to find areas of agreement and blissfully ignore things about which you strongly disagree.There is a lot to agree with in that FAQ, in my humble opinion.Oh, and you have to learn to ignore people who just won't listen to reason, or who are starting with different assumptions about how the world works than you. The Faucet has several abuse prevention features in place.  I'm not going to say what they are because then the 'bad guys' would have a road map for what to do to try to get around them.They're not 100% foolproof, but they're pretty good.The steady stream of transactions from the Faucet the last few days IS because of the increased interest due to the security now podcast and slashdot mention. No, that's the point: 0 is a magic number in our heads."1/50'th the cost of Paypal" will get, say, 5% of the people to switch."Free" will get 50% to switch.(numbers pulled out of my ass, of course, but you get the idea) Thanks Hal!If I had a cluster of bitcoin transaction processing nodes (or a big mining farm), I'd connect them with memcache and store transaction hashes/verified flag pairs, so signatures were verified once.  Or maybe just have one machine filter transaction/block traffic and only pass along valid transactions/blocks, and not have the rest of the machines even bother checking signatures.It will be tougher for individual nodes.  If they're not mining, they could just check signatures ONLY on somebody-sent-to-them transactions.  If they are mining... well, it seems to me  single-node miners will become increasingly rare as bitcoin scales up.  Hardware farms or miners using a mining pool seem like the way of the future. I agree.  However, at this point "we" have to decide what the default rules are, and what is decided now will influence what people think is "fair" two years from now (when, hopefully, bitcoin is in the process of becoming wildly successful).Also, I've read a couple of popular behavioral economics books (e.g. Predictably Irrational), and I think there might be some irrationality that could make bitcoin more successful.  For example, "free" is a magical number.  If we can make most bitcoin transactions "free" to the typical user, then that's a huge selling point.There ARE hidden costs; the reason I want to do the back-of-the-envelope is to figure out how big those hidden costs are now and how big they're likely to get in the future.  It isn't rational, but most people would rather have "free transactions", even if they end up paying 10 cents more in electricity costs every month whether or not they actually make any transactions.(I may move this to the Economics topic depending on where the discussion goes) I figure each bitcoin transaction is currently costing about $US 0.0003 (three-hundredths of a cent)Here's the back-of-the-envelope calculation I used to get to that number:Transaction size:  ~300 bytes.Disk space cost:  0.05 $US per gigabyte (about $100 for a 2TB hard drive these days)Bandwidth cost: 0.02 $US per gigabyteCPU cost:  0  (bad assumption-- anybody want to try to come up with a better estimate?)Size of bitcoin network:  ~10,000 nodesEach transaction is currently sent across the network twice (once on its own, and once when it becomes part of a block).  It is stored on disk once.  So disk+bandwidth cost for one machine is: (0.05+0.02+0.02)*(300/1000000000)... times 10,000 nodes gives $0.00027 per transaction.Please check my work-- I usually screw up and add or drop an extra zero when doing these types of calculations.  Connects via another port?Or would you teach bitcoin's minimal http implementation to keep the connection open?  (and service multiple connections at once)I've got a use case (google App Engine) where a persistent connection to bitcoin isn't possible (App Engine apps can fetch URLs, and can act as 'web hooks', but can't just open a socket and listen). Okey doke.  And the default value should be.... ?
WAY too many issues being mixed up here...   I'm sorry I ever framed this as "moving the decimal point"I think the next release of Bitcoin should:+ Show full-precision bitcoins in the GUI.  If you have 1.5 BTC, it will display as it does now ("1.50").  If you have 1.50001 BTC, it will display the extra precision.+ Allow you to send full-precision from the GUI and from JSON.  If you have 1.500001 BTC, you will see  you have that many and can send that many.+ Incorporate luke-jr's patch to avoid losing "dust change", when possible.  (e.g. if you have received transactions of 1.5000001 and 20 BTC, and then send 1.5, Bitcoin shouldn't choose just the 1.5000001 input transaction).Those issues are being driven by pooled mining-- a lot of people are getting sub-cent bitcoins from their pooled mining shares.Then there's the issue of "what is a micro-transaction for which you should be forced to pay a fee."  Currently, it is any transaction with an output less than 0.01 BTC.And the issue of "what is the minimum fee" (also currently 0.01 BTC).Ideally, transaction fees should reflect real-world costs... although just making them hidden costs that are spread between everybody running bitcoin might work perfectly well.  Still, I'd like to get a rough idea of the real-world cost of a transaction.It is too early to be worried about "paying 0.001 bitcoins for a pair of socks". I wonder how much a bitcoin transaction actually costs, in terms of bandwidth and disk space on everybody's machines.If nobody beats me to it, I'll try to do a back-of-the-envelope calculation later today. The -rescan argument in 0.3.20 does this. The public bug tracking/feature request system is at: https://github.com/bitcoin/bitcoin/issuesVote up issues/bugs that are important to you there. -rescan will be in 0.3.20.It takes about a minute right now on my machine (but that will get longer and longer as there are more and more transactions in the block chain). Are you missing your wallet.dat file or is it damaged?If it is missing, then grondilu's advice is the best anybody can do.If it is damaged, then it might be possible to extract the private keys from it.This type of thing is why off-site backups are a really good idea... Yup.Patches welcome, although before accepting any more patches "we" need to build the 0.3.20 release.  Assuming my cold doesn't get a lot worse, I'll be trying to make that happen tomorrow... Wiki for the trade page is a fantastic idea.And I like the idea of a re-organized, simplified home page.  Who should the home page target?  I think there are few potential audiences; successful web sites design their home pages to one or more specific types of visitors.  For bitcoin, I think visitors are likely to be:1. Geeks who are interested in "how is bitcoin supposed to work."2. Geeks who are interested in "how can I use bitcoin for a project I'm thinking of working on."3. Non-geeks who are interested in "what the heck is bitcoin and why should I care."There are also several audiences I don't think bitcoin.org should target (for example, people hoping that bitcoin is a way to get rich quick).  Am I missing anybody?I've been busy putting together a 5-minute talk for audience number 3; I think I can re-purpose some of what I wrote for the website. Huh?  Nobody is suggesting that any math be done with floating-point coins.But even if we were, your first example gives the correct result to the 8-places-of-precision that Bitcoin deals with: (round 0.032200000000000006  to 8 places and you get 0.03220000) I think it would be great for newbies who hear about bitcoin and decide they want to try it.USB stick is better than a CD because you could include a recent copy of Bitcoin (with most of the block chain), already configured, for Windows and Mac.So the user plugs in the USB drive, double-clicks the bitcoin app, and they're up and running.The seller would need to establish a reputation for no-viruses/trojans, no already-spent coins in the wallet on the stick, etc etc etc....... all the stuff that newbies are probably to clueless to worry about anyway.The value is both the "starter" bitcoins in the wallet AND the convenience of not having to download/install/configure bitcoin.  If PayPal asked, I'd say that I'm selling bitcoin software on USB sticks, and that the bitcoins in the wallet are just there because you can't use the software without having a few bitcoins to start.... In this thread I said:Bitcoin is still vulnerable to DOS attacks.  I'm not sure anybody knows how to prevent DOS attacks on a p2p network that allows untrusted/unverified peers to join (but I'd very much like a networking expert to tell me I'm wrong, and would like it even more if they volunteered to fix it....).Asking hackers to prove that they can DOS the bitcoin network wouldn't prove anything, it would just slow down transactions for however long they decided to keep up the attack.Giving bounties for uncovering vulnerabilities besides a network-denial-of-service attack is a good idea (demonstrated on the -testnet, preferably). They're not in 0.3.20; maybe 0.3.21.  https://github.com/gavinandresen/bitcoin-git/tree/monitorreceived... is the not-yet-ready-for-prime-time branch they're on. It doesn't 'feel right' to me.Seems like the ideal API would be:"Hey bitcoin, I want to keep track of all transactions for account FOO (or all accounts) that have [minconf] confirmations.  Please POST them to [url]."  or"Hey bitcoin, I want to keep track of all transactions for account FOO (or all accounts) that have [minconf] confirmations.  I'll be polling you to see if there are any new ones every once in a while, I'll pass you [unique_token] so you know it is me."... at least for the simple case.  You'd get back two lists of transactions:  new transactions with [minconf] that you haven't been told about before (maybe empty in the polling case), and a list of transactions you were told about before that now have less than [minconf] confirmations because of a block chain re-org (always empty if [minconf] is big enough).For the "I really want to shoot myself in the foot and deal with block-chain reorgs myself" you can call getblock and/or monitorblock to get all the gory details about which transactions are in which blocks. We've talked about these kinds of scaling issues in the past, and we've got a ways to go until they become an issue.I still strongly believe that we shouldn't worry about them until they actually start to become a problem.Long before we get to 300 million transactions per day there will be big companies spending lots of engineering dollars on their own highly optimized versions of bitcoin.I bet there will be alternative, secure-and-trusted, very-high-speed network connections between major bitcoin transaction processors.  Maybe it will just be bitcoin transactions flying across the existing Visa/MasterCard/etc networks (I have no idea what their transaction clearing/processing networks look like or how they work).Instead of worrying about "what will we do when we are wildly successful" we should be worrying about "what should we do RIGHT NOW so we become wildly successful." Spend 80cents to lower the price of something 50cents (and give you the privilege to look at the price)?Sounds like a terrible idea to me.So it'll probably be a huge success (I'm constantly amazed at the stupid things people do with their money). Yes, the delivery address and the fact that you're selling a physical product (the USB stick).Kind of like how you used to be able to buy cheap OEM copies of software but they had to ship a token piece of hardware in the box so they could say they were hardware vendors...  (actually, can you still do that any more?) Good Idea.  I think the PDF signing is overkill, but Good Idea.Here's a bitcoin business I want somebody to create and run:  "Coin on a Stick"You sell USB sticks containing Mac and Windows versions of the latest bitcoin (including the entire block chain) plus a wallet file containing N bitcoins.Sell them via Ebay or PayPal, and ship them ONLY to a PayPal-verified address.The buyer has to trust you not to double-spend the coins in the wallet, and has to wait for delivery of the physical USB stick.  But they don't have to download or install anything (they should be able to just run bitcoin from the stick and transfer the coins to themselves or a mybitcoin or mtgox account).But, since you are sending a physical product to a verified address, you'll be treated as any other merchant selling real goods by PayPal or the credit card companies. So if the merchant sees an attempted double-spend within 5 seconds they accept the bitcoins but don't give the merchandise/service/whatever.That sounds like a good idea to me.  Maybe instead of 5 seconds it aught to be "before the transaction is fully confirmed."The only drawback I see is buggy clients that might have bugs that cause 'honest' double-spending mistakes.Oh, and merchants would have to explain to customers whey they kept their double-spent coins (although the merchants could easily produce both transaction IDs to show the world that it WAS a double-spend, so they shouldn't have to worry about their reputation being sullied). Sure, every block has a unique hash.But I don't think that helps at all; you might see that transactions A B C D are in block #100,000 with hash H1, but after a block chain re-org block #100,000 might contain transactions A D (with block hash H2).The probability of that happening rapidly approaches zero as the block gets confirmed; after 6 confirmations you can safely assume it just won't happen. The fool-proof way of dealing with your use case (customer orders something, you want to ship after you're sure payment has cleared):+ Give each customer an account.  When they order, use getaccountaddress to get a bitcoin address to which they can send payment.+ Every N minutes ask bitcoin either the balance (with minimum 6 confirmations) for accounts with pending orders or all accounts+ If the account balance is enough to pay for the order, ship it and move the coins from the customer's account to a PAID account.   If not... either wait or tell the customer they paid the wrong amount or maybe refund any extra they sent (you'll have to ask them for a refund address).The inelegant polling will eventually be fixed by bitcoin POSTing when new blocks or transactions arrive, but I think you'll still need to ask bitcoin what the account's current balance is-- trust me, you really don't want to recreate all the bitcoin logic dealing with double-spent transactions or block chain reorganizations.If you grow to handling thousands of orders per day (which would be a very good problem to have) you'll want to buy or build a version of bitcoin optimized for high-volume transaction websites.  Or maybe you'll run 20 bitcoinds, each handling 1/20'th of the customers -- I dunno, I don't spend a lot of time worrying about problems I'll have when my project is outrageously successful.
No, there is a block chain re-org invalidating B and C.  D is still valid in my scenario.So the client remains oblivious to B and C being invalid, whether it asks for transactions older than T2 or transactions after D. Huh?  I don't see how passing <txid> makes that problem any better.Let's say you've got transactions A B C D (in that order).  With times T1, T1, T2 and T2 (A&B happened 2 blocks back, you got C&D in the last block).Now imagine a block-chain re-org, so B and C are now invalid.Ask for all transactions after D and you get nothing-- same as if you asked for all transactions with time greater than T2. If an optional time param is needed, maybe get rid of the "since <txid>" notion and just make it "give me all receive transactions for [account] with [minconfirmations] that have a time greater than [time]". Nice, I like your proposal.Do you know C++? Transactions are confirmed when new blocks are accepted; that's the idea behind my 95%-finished 'monitorreceived' code.  It will POST to a URL when new wallet transactions and blocks are accepted.  The block information includes all transaction ids (and a link to the previous block).As you note, you still have the issue of what to do if your code misses a POST.  That shouldn't be a big issue, though, because you'll resynchronize the next time a block is found.  Worst case, you'll ship to the customer 1 block (10 minutes) later than is optimal if your connection to bitcoind is lost. Good idea.I think the first spot for plugins in bitcoin should be "send address resolver" services-- If I tell bitcoin "send 100 bitcoins to obama@whitehouse.gov" it could ask the plug-in resolvers (in some user-defined order) "do you have a bitcoin address for obama@whitehouse.gov" ?If I tell bitcoin "send 100 bitcoins to eff.org" maybe a different resolver is used (DNSSec query to eff.org to get a bitcoin donation address, perhaps).  Or "send 11 bitcoins to +01-1-805-253-2751" ...There are lots of potential problems, of course, ranging from what if the resolver software service/author starts redirecting bitcoins to them to what if the user misspells the destination.  That's why I think starting with a way of pluggin-in different solutions to try is the right way to start. How do you think the code should deal with the issue of "a fixed txid might no longer be valid" ?  Or transactions that you THOUGHT had N confirmations and were in a block with timestamp T are re-organized to have M confirmations and are in a block with timestamp T2 ?tcatm and I chatted in IRC about this problem-- he has the problem of how to keep the Javascript GUI (which shows you ever transaction) up-to-date.Seems like you really want an efficient way of asking "Do I know about exactly the same set of transactions as bitcoind" (either for the entire wallet or for an account).  That's assuming transaction data can't change (somebody double-check that assumption for me-- if the transaction data changes, then the txid changes... I think).That led to some brainstorming of computing a hash of all transaction ids (maybe just XOR them all together).  Or maybe something more complicated like a merkle tree...   but that seems like overkill.Is there a good, simple solution to synchronizing "I have this set of stuff, give me everything I don't have" ? No, it won't sort itself out "after a few weeks".  Let me see if I can do a back-of-the-envelope:Difficulty on testnet currently at 373.  We want it no higher than, oh, 5, so with the typical 3-or-4 machines CPU-hashing on testnet generate a block in a reasonable amount of time.So we generate 2016 blocks over 8 weeks.  That cuts difficulty by four: ~90Then do it again: ~22and again... ~5  SIX MONTHS laterThat's optimistically assuming we can find people to cooperate to contribute hashing power to generate 2016 blocks at difficulty 300 in 8 weeks or less.If you'd like to continue using the old testnet chain, be my guest.I'm sympathetic to the "testnet and main net should have the same rules", but the truth is the testnet has, and always will have, many fewer people hashing on it.Changing the main net downard-difficulty-adjustment code might make sense, but that's the topic for another thread.  Allowing main net difficulty to adjust all the way from 22,000 to 1 isn't the right answer (it makes sybil attacks where an attacker feeds you a bogus version of the block chain much easier). Giving them all the same starting wallet is a bad idea; they will start out with the same keys, but will eventually each generate their own, so their balances will drift out of sync.In theory everything should work out, but in practice using the same wallet on multiple machines hasn't been tested much (I fixed a couple of bugs in the last couple of weeks related to a wallet shared between machines).So before cloning, delete the wallet.dat (assuming it has no bitcoins in it) and let the clones automatically generate a new wallet the first time they start. Two thoughts:listaccounts [minconfirmations]  (also new in 0.3.20, if I'm remembering correctly) will give you all accounts and their balances.  If an account's balance doesn't change, you know it hasn't received coins.And why do you need to periodically update the user's account/assets?  Could you just query bitcoind for their current balance when they fetch their 'account status' page (or wherever you show the user how many bitcoins they have)?  Are you doing something with the received bitcoins without an explicit action on the part of the user, and does that something care about the total balance or individual transactions? 0.3.20 will support listtransactions '*'  for all transactions.Transactions since <txid> ....  sounds dangerous.  Are you trying to mirror the transaction database that bitcoin keeps?  If you are, are you sure you'll deal properly with (rare) block chain re-organizations where transactions that you thought had one confirmation turn out to be invalid in a new fork of the chain?I can imagine subtle bugs-- you ask for transactions since <txid> but that txid turns out to be an orphan transaction (double-spend on the losing side of a block chain re-org) so bitcoin returns... what?All non-orphan transactions with transaction time equal to or greater than a given timestamp might work-- but what is your use case? You can setup your own f2f bitcoin network using the -connect option, connecting only to friends.One of those friends must be connected to the rest of the bitcoin world, of course.Experimenting with sending transactions and blocks over XMPP or some other network is a great idea-- go for it!  It shouldn't be hard to create a "bitcoin bridge" that relays traffic on the main bitcoin network to/from another network. So... who's excited about doing either a little wxWidgets programming or a lot of "port the bitcoin GUI to Qt" programming?This isn't going to happen unless somebody actually does it... I split this into it's own thread.Here's a counter-proposal:All RPC methods dealing with amounts take and report full-precision bitcoins.E.g. if you have 1 BTC getbalance reports 1.00000000  (as it does now)The send and move methods will be changed to NOT round to two decimal places.luke-jr's patch that makes bitcoin avoid creating sub-cent change (when possible) will be applied.The GUI will be modified to display full precision amounts, and will allow full-precision sends.  (if you have 1 BTC, GUI should show balance: 1.00   if you have 1.0001 BTC, GUI should show balance: 1.0001   ...etc)A new setting: maxtxfee  will be added, default will be 0.01 BTC.  RPC methods will fail with a new error message if a send/sendfrom would generate a transaction fee larger than maxtxfee.A new RPC method to change maxtxfee setting (maybe a generic RPC method to change any run-time option that can be changed on the fly?)The code should be checked and all references to CENT which really mean "minimum transaction fee" should be changed to reference a new "minimum transaction fee" constant (==CENT for now). Patch/pull request is:  https://github.com/bitcoin/bitcoin/pull/53 Very nice!Is there a standard spot to put the build descriptor file in the source tree, or a standard name for it?  I'd like to commit the build descriptor file.bitcoinex:  I'll tag the tree when I think we have a release candidate.  There are still a few loose ends I hope to tie up today:1. New -testnet genesis block.2. New block chain lock-in point.  I'm thinking block 105,000 is a good candidate for the lock-in point.3. Compile/run/sanity test on Windows.  I am planning on spinning up an Amazon EC2 Windows instance to create a build/testing environment (although probably a VMWare image would be better-- can anybody help with this?  I normally don't do windows).Am I missing anything else stopping a 0.3.20 release candidate? No, if necessary we'd change the difficulty adjustment rules and make the code:if (current block is > some_number)  ... new rules for adjusting difficultyelse  ... old rules for adjusting difficultyI could have done that and kept the testnet block chain, but it is cleaner to just reset it with new rules.And "pulling the same trick" means throwing an overwhelmingly massive amount of hashing power at the main network (like 16 times the current overall hashing power) for a significant amount of time, which is getting increasingly hard to do. Difficulty on the -testnet is annoyingly high.   I propose resetting the -testnet with a new genesis block, and changing the -testnet rules for difficulty adjustment as follows:1. Adjust difficulty on the testnet every 126 blocks (1/16'th the regular net adjustment).2. Keep the "difficulty can adjust up at most *4", but remove the limit on how quickly difficulty can adjust down.  Minimal difficulty would remain the same.Unless I hear howls of protest or better ideas, I'll generate a genesis block and submit a pull request with the changes.  I won't switch the -testnet faucet to the new chain until we've got 0.3.20 release candidate builds out. This seems like a good idea; maybe not for the next (0.3.20) release, but 0.3.21. From the jansson docs:"integer numbers whose absolute values are too large to be represented in the int type will result in an overflow error"As I said in the thread about possibly changing the ECDSA curve bitcoin uses, programmers like to solve "problems" that they know they can solve and that they think will make things a little bit better.  But, in my humble opinion, unless you're solving an important problem changing things because you think you know how is often a bad idea.This is a perfect example:  change the RPC to spit out 64-bit integers (or move to a new RPC that spits out integers) and anybody using jansson on a 32-bit-int platform will get an overflow error.I kind of like tcatm's suggestion to define new RPC methods that specify a base unit using strings... but then I thought more about it:We could use scientific notation, so 1 BTC would be 1e08 base units; then if we ever needed more precision the JSON interface wouldn't change, you could just specify 1e-03 as a value....... but that's exactly what we have now.  1 BTC is 1e00, 1 base unit is 1e-08, and if we ever needed more precision the JSON interface is ready.
ribuck:Accuracy/precision is a red-herring unless you're treating numbers as strings, since JSON-RPC numbers ARE ALWAYS double-precision floating point numbers (according to the JavaScript/ECMAScript spec).  Bitcoin could send a number that looks like 2100000000000001, but the code that interprets that JSON-RPC number will convert it into an inexact double-precision floating-point equivalent.  And then the code that displays that number will have to decide how to round and format that inexact floating point number and display it to the user.When we need more than 51 bits of precision (wouldn't THAT be a fantastic problem to have!), then we'd HAVE to send numbers as strings, and have the JavaScript (or whatever) on the other end feed them into a bignum-type library to handle them. It sends it from the ClearCoin wallet.  It doesn't do anything special to try to 'mix' coins, though, so if you send ClearCoin exactly 11 bitcoins and then release exactly 11 it is pretty likely the transaction history would be easy to figure out.Which reminds me... I released a new version of ClearCoin this week that lets you release an arbitrary amount.  So if you wanted to pay somebody 11 bitcoins but make it hard to figure out where the payment came from by looking at the transaction histories you could:Fund the escrow account with, oh, I don't know, 20 bitcoins.Release 11.Let the escrow expire, and you'll be sent the leftover 9. I haven't heard from anybody...  I'll ask again:  PLEASE HELP TEST luke-jr's patches got me thinking about whether or not passing double-precision values over the JSON-RPC api would ever cause problems.  I've convinced myself it isn't an issue:JSON numbers are 64-bit double-precision floating point values, which have 53 bits of precision.21 million bitcoins is actually 2,100,000,000,000,000 (2.1 quadrillion) of the smallest possible unit.  That's a bit over 251 -- you need just over 51 bits to represent them.So, unless your JSON library is buggy, you should never run into rounding errors converting to/from JSON, even if you're sending 0.00000001 bitcoins. Can you back up and describe what problems your patches solve?Here are the problems I care about:+ If a user receives 1.000001 bitcoins, there is currently no way to transfer the entire amount somewhere else using either the GUI or the RPC.+ If a user receives 1.000001 bitcoins, the GUI will tell them they have 1.00.I don't care about systems without a FPU-- are there any such systems that bitcoin actually runs on?I don't care about BTC vs TBC. No, not "everybody" -- if it is too expensive for you, then you stop doing it.  Only the people who can generate most efficiently will stick around, and they'll stop "going hard" when the cost of adding more generating hardware is more than the value of the bitcoins they get.Hopefully bitcoins will become more valuable over time (that will happen if people find them useful/valuable).Mostly no, total value of the transaction doesn't matter.  A large-value transaction that is made up of lots of little transactions is more expensive to verify, but so is a small-value transaction made up of lots of tiny transactions.  And for both, if they're big enough they'll have to include a transaction fee to get accepted. I made a google spreadsheet with the number of transactions occurring in the bitcoin block chain per month, and the total value of those transactions: https://spreadsheets.google.com/pub?key=0Ar4FtkFP4j73dDQyY3ZJWjdhMlBkZEtTSFJTZm9ieUE&hl=en&gid=0(click on the BitcoinTransactions spreadsheet; the first is just another version of #produced over time)Looks like bitcoin is growing nicely; I'm not sure why the big spikes in July and October...I made the calculations using my bitcointools python code:  https://github.com/gavinandresen/bitcointools/blob/master/statistics.py That would make an odd transaction pattern-- e.g. if you started with 11 bitcoins in your wallet, you'd generate a chain of transactions that was:A paid B 11 bitcoinsB paid C 11 bitcoinsC paid D 11 bitcoins ... etc, every 6 hours.  That makes it obvious what you're doing (a series of exactly-11-bitcoin transactions would be extremely unlikely).Ideally, you want the graph of transactions involving your coins to be indistinguishable from a random sub-graph of the entire bitcoin transaction graph.  Creating lots of wallets won't help you do that; you need to mix your coins with other people's, so the mixing looks the same as just ordinary "X paid Y" transactions. That's easy-- if #5 is the lowest ordinal piece of dust, then it goes to the first txout.  Etc.It's all arbitrary but deterministic, and all recorded in the block chain, so you could define rules to trace every .0000000001-of-a-bitcoin forward through transactions. Answering the original question:Arresting counterfeiters is a good government economic intervention.A counterfeit-proof currency like bitcoin is better, of course. Sure there is-- block 0 contains coins 0-49, block 1 coins 50-99, etc.If you get sent 500 bitcoins, they can all be traced back to generation transactions, so you "own" a bunch of little pieces of land in bitcoin-world. ribuck:  I did misunderstand, sorry.And maybe I should have been clearer:  the idea behind a reproducible virtual image is exactly to capture tools, version numbers, etc etc.   Auditors that create their own virtual images with the same CPU, OS, tools, etc. will be relied upon to confirm that yes, the bitcoin executables on the website were indeed built using standard compilers/linkers/etc from a particular source revision. ribuck:  what do you suggest instead?I've read Ken Thompson's paper; that is what motivated me to propose a reproducible virtual machine image as the best we can do IN PRACTICE.Yes, it is theoretically possible somebody might sneak bitcoin-stealing code into the gcc compiler.  Code that detects that bitcoin is being compiled and injects instructions to send coins to the sneaky gcc hacker.In reality, we trust that the gcc maintainers are trustworthy and careful and that they care about their reputations.   If you don't trust them, what is the alternative?Nefario: can "we" make building bitcoin easier?  I've been asking people to submit patches to the bitcoin linux build process, but so far none have been forthcoming...devrandom:  Nice! No.  Unless you're changing your wallet outside of bitcoin, rescanning isn't necessary.It would be nice if the GUI had "backup wallet" and "merge backed up wallet with current wallet" options-- the "merge wallet" would need do a rescan.  Maybe next release somebody will implement those features... You must have compiled against a newer version of Berkeley DB, and it uses a new log file format.  Try removing the ~/.bitcoin/log.* files before running the older bitcoin version.I changed build-unix.txt as you suggested. getinfo and getbalance (with no arguments)... are a little complicated.They include all 1 confirmation receive transactions, but (this is the complicated part) they also include 0-confirmation receives if they are self-sends (either the "change" from coins you just sent or all the coins if you sent to one of your own addresses).In any case, I think they will do exactly what you want-- show you coins that have at least one confirmation or that you are certain you are able to spend (because they are your own 0-confirmation coins). It will create 100 keypool entries the first time you request a new address or if you turn on coin generation (the mining threads each ask the keypool for an address to create the coinbase transactions).I don't know what the story is with "wkey". getbalance '*' 1... will do what you want in the next version of bitcoin.  I need people to help download and build and test it. Please checkout the git integration branch from:  https://github.com/bitcoin/bitcoin... and help test.  The new features that need testing are:-nolisten : https://github.com/bitcoin/bitcoin/pull/11-rescan : scan block chain for missing wallet transactions-printtoconsole : https://github.com/bitcoin/bitcoin/pull/37RPC gettransaction details : https://github.com/bitcoin/bitcoin/pull/24listtransactions new features : https://github.com/bitcoin/bitcoin/pull/10Bug fixes that also need testing:-maxconnections= : https://github.com/bitcoin/bitcoin/pull/42RPC listaccounts minconf : https://github.com/bitcoin/bitcoin/pull/27RPC move, add time to output : https://github.com/bitcoin/bitcoin/pull/21...and several improvements to --help output.This needs more testing on Windows!  Please drop me a quick private message, email, or IRC message if you are able to do some testing.  If you find bugs, please open an issue at:  https://github.com/bitcoin/bitcoin/issues What version of gcc are you using?  After a little googling I found this thread about the same issue:Unless somebody volunteers to fix/maintain this, I'm inclined to simply remove all of the "try to make the CPU miner go faster" optimizations from bitcoin.  CPU mining is, for most people, a waste of electricity.
There are:  1,461,501,637,330,902,918,203,684,832,716,283,019,655,932,542,976 possible bitcoin addresses.As ribuck says, that is a very big number.  There are approximately:133,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000.. atoms in the Earth, so even if you used just 100 atoms to store each bitcoin address, you'd run out of atoms before you were done generating addresses. From the Quora question:You can't spend 400 BTC 80 times in 1 hour.  If you control a majority of the generation you could spend them twice an an hour (assuming merchants require 6 confirmations).So you need to divide your expected profit per hour by 40, making your ROI very, very negative. You are confusing "control 50+% of generating power" with "control connections."Lets say you control 51% of the generating power.You can:Spend bitcoins once.  Then wait for them to be confirmed by the rest of the network as many times as the merchant requires, while secretly working on another version of the block chain where you did NOT spend them.  Your secret block chain should be longer than the network's, since you control 51% of the generating power.So you announce your secret block chain, and instead of sending those coins to a merchant you include a transaction where you send them to yourself.  YEAH!  you just ripped off the merchant!  Wahoo!You cannot rip off two merchants with the same bitcoins-- one or the other of the transactions will be seen as valid.And you cannot "unspend" the transaction to the merchant-- if you don't spend it SOMEWHERE, the merchant's bitcoin node will re-announce it to the network and all the other nodes will consider those bitcoins "spent, just waiting to be included in the next generated block."If you run the numbers again with the realistic double-spend scenario, you'll see crime doesn't pay.  There is no way you can rent enough hashing power to commit a profitable double-spend attack.If you can steal the hashing power (maybe you're a bot farmer), then if you run the numbers you'll find it is more profitable to just generate blocks and sell the bitcoins rather than try to somehow get stuff trying to double-spend. FreeMoney is absolutely right.The only way to get 80 people to accept the same 400 bitcoins would be to control all of their bitcoin connections and feed them different versions of the block chain.And THAT will be impossible, because the people you're trying to rip off (merchants selling stuff) are exactly the people with long-running, well-connected bitcoin nodes. It will have only 8 (outgoing) connections.With fewer connections, it will notice new blocks a tiny bit more slowly than the other machine, and blocks it finds will propagate to the rest of the network slightly more slowly than the other machine.  So it will spend a teeny-tiny bit more time working on an out-of-date block chain, and will be a teeny-tiny bit more likely to lose "announce a new block" races.  But I bet the effects are so small you'd never notice them.Yes and yes and no. The number of confirmations tells you which block a transaction is in:0 confirmations: not in a block yet.1 confirmation: in block number "getblockcount" block.2 : getblockcount-1 ... etc.Note that if there is a block chain reorganization which block the transaction is in can change (as can the number of confirmations). BioMike:  any progress tracking this down?I just committed a fix to the git integration tree CallCPUID code to declare ebx/edx clobbered... "Bitcoin, the New Zimbabwe Dollar" would be TERRIBLE marketing.  How about a nice, respectable country that is just tired of using somebody else's currency?  If the value of the dollar keeps falling, there may be a lot of those in the next 20 years. It is time to build and test a new version of bitcoin.In the past, Satoshi built the Windows and Linux releases, Laszlo built the Mac releases, and we trusted them not to put malware in them (or we compiled ourself from source).Satoshi is busy, and even if he wasn't he shouldn't be spending his time doing a job that a lot of the rest of us are capable of doing.  So we need a new process.Ideally, that process should be open and verifiably trustworthy.  So I'd like to propose that we do the following:1. For each platform, somebody creates a pristine, reproducible build environment, preferably as a virtual machine image that anybody can download, inspect, clone, run, etc.Anybody should be able to reproduce the build environment by running or following a script (e.g. "Install Ubuntu X.Y.Z.  apt-get the following versions of the following packages... etc"). 2. A copy of that virtual machine is used to build/package the release.3. Anybody can audit the process by re-creating the build environment and ensuring that they end up with "identical" executables.  (where "identical" means compare the code in the executables, ignoring timestamps or other meta-info linkers put into executables -- are there already tools to do that, or do we need to roll our own?).Feedback?  Suggestions for improvement, or are there better ways of creating 'trusted builds' ? Just to be sure:  "removed all bitcoin data" means you removed and reinstalled bitcoin.exe ?RE: wallet works fine on ubuntu:  did you happen to run the wallet on another machine, then copy it back to your windows machine?I don't know what to suggest-- I'm not a Windows person... I wrote a 'vanity bitcoin address' patch a while ago that lets you do exactly that:  https://gist.github.com/614460I bet finding an address starting  1HAL...  wouldn't take more than a few hours.  If I recall, it took a day or so to find one with the string 'gavin' in it. Because the first byte in a bitcoin address is a version number, and "version 0" is encoded as a "1" in the bitcoin address "base58 encoding" (because 0 is too easy to confuse with capital-o).Trivia:  -testnet addresses are version 111 (eleven is my favorite number), and begin with m or n (I haven't actually worked out whether they might begin with another letter, too...). Publicly announce where?Publicly announce it here and one of the moderators will delete it faster than you can type 'rm'.Announce it on your own website and I'd encourage the legal authorities and/or your ISP to shut you down.Announce it in IRC chat or via a Freenet/TOR/i2p hidden service and I would personally encourage everybody to shun and /ignore you... and very few people will hear your announcement, anyway.I suppose you could try to get a journalist or government interested in causing trouble for bitcoin to publicly announce it.  If you did, I would ask as loudly as I could why the journalist or government is complaining about innocent bitcoin users instead of trying to track you down and prosecute you. Yes, after posting I realized that self-mixing creates a mostly-self-connected sub-graph.  You really need to start with multiple transactions in, ideally randomly occuring during the mixing process, and not spend all your bitcoins at once.Somebody who knows a lot more about graph theory, statistics, and probability than I do should chime in and tell me how I'm wrong or come up with a good metric for the ideal amount of mixing (I bet too much is just as bad as too little).  Analyzing the connectedness of the existing bitcoin transaction graph might be a good place to start. If the threat model is as zipslack describes, then I think a "send to self" mixnet would work.Patch bitcoin so it generates, a random transaction every, oh, I dunno, eight hours or so, sending, oh, I dunno, 1/10'th or so of your bitcoins back to yourself via a newly generated address.And to erase your trail in case your wallet gets seized, remove the source transactions and their (spent) keys from your wallet.After a week of doing that you'll have put 21 extra transactions on the network and, on average, four extra transactions on the coins in your wallet (four because every send typically generates a change transaction).  Do it constantly and you'll have an ever-churning wallet that aught to foil any attempt to connect incoming <-> outgoing transactions.That is all assuming that you don't start with zero bitcoins in your wallet, get exactly 111.11 bitcoins from somebody, spend a couple weeks mixing them, and then pay exactly 111.11 bitcoins to somebody else.  That transaction network graph is easy to analyze, and it would be insanely unlikely that you "just happened" to receive exactly those same 111.11-worth of coins that were given out.Hmm, I wonder if the patch could detect a bad mix and warn you if you tried to do something stupid like that...Somebody who knows a lot more about mixnets than I do can probably work out the math to know how much, and what type, of randomness to add to the eight hours and 1/10th to make statistical analysis as difficult as possible. I spoke with the author last week; I think she did a great job explaining bitcoin for a not-super-technical audience and does a great job being realistic about the hurdles bitcoin faces: https://www.eff.org/deeplinks/2011/01/bitcoin-step-toward-censorship-resistant First: I am not a lawyer.Second:  No.  http://criminal-law.freeadvice.com/drug_crimes/unwitting_possession.htm I think you should begin by defining the threat model.Can the attacker see all unencrypted IP traffic to/from the sender's node, or is the traffic tunneled through an anonymizing network like i2p or tor?Does the attacker know any of the sender's receiving bitcoin addresses?  Is the attacker willing and/or able to send 'marked bitcoins' to the sender?  Lots of them? Run one instance normally.  It'll listen for incoming bitcoin network connections on port 8333, rpc connections on port 8332, and connect to other nodes.Run the other instance with a different -datadir, and a bitcoin.conf like this:nolisten=1rpcport=7332  (or whatever you like)noirc=1connect=127.0.0.1:8333You'll need to be running the latest source code from github for the nolisten option.The noirc and connect settings aren't strictly necessary; leave them out and the second instance will make 8 outgoing connections to other bitcoin nodes.  You'll save a little network bandwidth if the nolisten instance only connects to the other node. Having spent a lot of time working with the existing code, I don't think splitting the code into multiple files would make it much easier to work with.  The hard part is figuring out how everything fits together (for example "if I have a CWalletTx, how do I get the CBlock that it is in (if any)?").  Just rearranging the code that is there now won't make that problem any better.I don't think anybody who has worked on the code, except for Satoshi, has a lot of bitcoins.  I certainly don't.  I hope to earn some with Clearcoin....The listaccounts bug is nearly fixed.  I cannot reproduce the dangerous-looking bug, even running bitcoind under the valgrind memory-checking tool (valgrind actually simulates machine instructions to catch memory access errors)-- tcatm seems to be the only person having the issue.
Satoshi is busy.  Doing what, I have no idea-- maybe he's working on a GPL-version of bitcoin, but I doubt it.In any case, I wouldn't expect any opinion on GPL versus MIT from him.My opinion:  I've got better things to do than worry about which open source license is most appropriate.  No software license has magical powers that will prevent 'bad guys' from trying to do bad things. I paid for the download; nice little paper.  And interesting choice of pseudonym.Are you submitting it somewhere to get it peer reviewed?And do you mind me asking what you mean by "I'm a computer scientist with some knowledge in cryptography" -- are you a professor, grad student, postdoc, graduated-with-a-degree-in-computer-science-and-now-working-in-industry ? I don't think we have consensus that CORS in bitcoin is a good idea, so I'm not going to pull this now.tcatm's little proxy server is a good workaround. ribuck: The Faucet is currently giving out between 5 and 6 BTC per day (100-200 payouts per day).BioMike: Are you creating an AdWords-like service, but bidding/paying in Bitcoin?  One reason I like AdsCaptcha is because if won't clutter up the Faucet page with ads.[mike]: Thanks for the pointers RE: how much it costs to get google/yahoo/etc accounts; I have been tempted to give out more coins from the Faucet to people with Google accounts.I'm going to give AdsCaptcha a try; if the ads are annoying or offensive or inappropriate or doesn't work with ad blockers I'll switch back to reCaptcha. I'm thinking of replacing the Bitcoin Faucet's reCAPTCHA with an AdsCaptcha -- instead of solving a CAPTCHA to help scan books, people visiting the site would be shown advertising which would help refill the Faucet with bitcoins.My goal isn't to make money from freebitcoins.appspot.com, my goal is to make it sustainable without relying on donations.  According to the AdsCaptcha folks, they expect advertisers pay anywhere from 1 to 20 US cents per CAPTCHA solution, depending on web traffic, how well the website fits their product, etc.  The Faucet is currently giving out 0.05 bitcoins per visitor, which is 2 cents at current prices.I would also like to gradually relax some of the anti-cheating measures I have in place that occasionally make it frustrating for non-cheating new users who "look like" people who are constantly re-visiting the Faucet (using proxies and new bitcoin addresses) to try to get more than their fair share.One danger is that I implement AdsCaptcha, donations to the faucet stop, I find the revenue from AdsCaptcha is less than 0.01 BTC per visitor so that whole thing is even less sustainable than the current "somebody steps up and donates more when the balance gets low enough" model.What do you all think? As the owner of the Faucet, and having seen how far some people will go to get more than their fair share of bit-pennies from the Faucet, I've thought about this subject.My conclusion is that instead of creating tools to try to become "the Bitcoin Police", there are probably better things you can do with your time.  Because as soon as you create the tools, the bad guys will find ways to work around them. Adjusting the testnet difficulty every, oh, say 100 blocks (instead of 2016) seems like a good idea to me.That's a trivial patch; I nominate ArtForz and Xelister to write it and submit a pull request.Locking in the testnet block chain-- not so much.  I don't think it is worth the effort to either come up with a mechanism for distributing the lock-in points or manually put lock-in points in the source code. There's one tricky accounts-related bug that I think needs to get fixed before the next release:   https://github.com/bitcoin/bitcoin/issues#issue/25The only other possibly critical bug is:  https://github.com/bitcoin/bitcoin/issues/#issue/28... although I haven't been able to reproduce it, even running bitcoind on top of the 'valgrind' memory checker.I plan to pull patches into the integration git branch early next week, and I'll ask for help testing the result. Improving help is definitely helping-- thanks!And it would be fantastic to get somebody who knows, or is willing to learn, git to step up and volunteer to submit translation file patches.I'll soon be asking for building and testing help, too (after fixing another couple of bugs, I think it'll be time to pull non-controversial patches into the integration tree and start some serious testing to prepare for another release). The list of possible new features and bugs at https://github.com/bitcoin/bitcoin/issues is getting longer every day; I'd like to see the bugs resolved before the bug list gets so long we all just start ignoring it.So:  who is willing and able to help out?  Don't ask permission, just jump in, grab a bug that catches your interest, add comments to it as you start to figure out what the problem is (or isn't), and submit a PULL request when you have a fix.Your reward will be recognition, admiration and respect.  It is time to take bitcoin from, essentially, a single-programmer project to a robust open source project with lots of contributors. That is wxWidgets' internationalization machinery complaining about... something (the catalog is probably the list of english strings -> other language strings).As for fixing it:  "Not It!"   (I don't know nothing about wxWidgets internationalizations stuff) Should we start a betting pool to see how long it takes Google to decide bitcoin mining should be against its terms of service?I think.... three months. RE: point you in the right direction:File rpc.cpp, the CommandLineRPC method:I suspect what needs to be done is to properly JSON encode any strings passed via the command line.And then properly decode/recode any strings returned from the JSON RCP call before printing out the result. CORS support doesn't change this.IF the browser has a bug that lets JavaScript code read the local filesystem, THEN JavaScript code can get your rpc username/password from your bitcoin.conf file.And IF the JavaScript code can do that, then it can send rpc commands to bitcoind running on localhost (because, surprisingly, the same-origin policy does NOT apply to localhost: urls-- we learned that lesson here six months or so ago).That is all true right now, with the released bitcoin/bitcoind. Character set issues give me headaches.So I just ran a test at the command-line, moving 500 testnet bitcoins to an account named "฿"The account created is named "\u00E0\u00B8\u00BF", which is not what I intended.  E0 B8 BF is the utf-8 representation of the unicode Thai Baht character.Thinking this through, trying hard not to get a headache... My terminal window has:  LC_CTYPE=en_US.UTF-8So when I copy&paste the Thai baht symbol, it is being encoded as UTF-8.I pass a UTF-8 string to bitcoind, and it uses the JSON-Spirit library to convert it into a JSON string (which is defined to be Unicode... encoded using backslashes, I think: see http://www.ietf.org/rfc/rfc4627.txt ).  And there's the bug.  Maybe.  I think?Command-line bitcoind should be looking at the locale and converting JSON strings to/from that locale.  Anybody motivated enough about internationalized account names (and send comments) to teach it to do that? davout said (at the github pull request):If you've opened up access to the rpcport, then I don't think CORS support adds any significant vulnerability to password brute-forcing.  I suppose it means a 10-year-old non-programmer can repeatedly enter a username and password into a website to try to brute-force your rpcpassword... but anybody capable of writing or running a script could just write a brute-forcer that doesn't run in a browser.And, come to think of it, turning on CORS explicitly wouldn't stop the ten-year-old, either: they could just repeatedly browse to URL  http://your-bitcoind-machine:8332/ and try different usernames/passwords.Also, bitcoind already has anti-brute-forcing code.The only security vulnerability I could imagine with CORS is that it might encourage people to add:  rpcallowip=*... to their bitcoin.conf, so they can connect to bitcoin from any IP address.  And I worry that they might not bother to setup SSL, in which case their rpc username/password will be sent across the net in the clear. I wrote a blog post about peak oil a couple of years ago: http://gavinthink.blogspot.com/2008/04/peak-oil-more-like-speed-bump-really.htmlI still believe my conclusion:  we'll be fine.  We'll use less oil and more of something else.  After all we survived Peak Whale Oil (you know, whale oil, that essential commodity that was so great for high-tech oil lanterns). "Just turn on Berkeley db encryption and you're done" -- ummm:First, unless I'm reading the bdb docs wrong, you specify a password at database creation time.  And then can't change it.So, at the very least, somebody would have to write code that (safely) rewrote wallet.dat when you set or unset or changed the password.Second, encrypting everything in wallet.dat means you'd have to enter your wallet password as soon as you started bitcoin (because user preference are stored in there right now), when ideally you should only enter the password as you're sending coins.And third, there are all sorts of usability issues with passwords.  Users forget their passwords.  They mis-type them.  I wouldn't be terribly surprised if doing the simple thing and just encrypting the whole wallet with one password resulted in more lost bitcoins due to forgotten passwords than wallets stolen by trojans.I think creating a safe, useful wallet protection feature isn't easy, and there a lot of wrong ways to do it. The CPU miner code has all sorts of now-mostly-worthless (because GPU mining is so much more energy-efficient than CPU mining) optimizations.  Maybe hardened Linux doesn't like the assembly code or SSE instructions? I agree with mh-- if there are real compatibility issues or weaknesses, then those would be a good reason to switch curves.If there aren't, sep256k1 seems plenty good enough for the forseeable future.  I think most programmers (myself included) have a tendency to worry about small-probability "what if" problems that we know how to solve, when we'd be better off thinking about high-probability problems that we don't want to think about because we don't already know how to solve them.Like multifactor wallet authentication so trojans don't steal users' wallets....
https://github.com/bitcoin/bitcoin/pull/23Cross Origin Resource Sharing lets servers support cross-origin Javascript. It is supported by the latest browsers (although IE support is... different), and involves sending CORS headers in responses.Adding this enables Javascript code running in a browser to connect with any bitcoin/bitcoind that allows RPC connections from the browser's IP address and has the right rpc username/password.Code changes are minimal (4 lines of code to output CORS headers).  Thanks to tcatm for implementing and testing. https://github.com/bitcoin/bitcoin/pull/24This adds a new field to the output of gettransaction <txid> :  "details"It is an array of objects containing account/address/category/amount (and maybe fee).  For most transactions to or from your wallet, it will contain just one object, but for sends from one account to another it will contain multiple objects.Example output:Code:{    "amount" : 0.00000000,    "fee" : 0.00000000,    "confirmations" : 609,    "txid" : "b593920033b905c0e7c1d82d5b3e15a114841fa916719e968add3212e07c73a0",    "time" : 1294342907,    "details" : [        {            "account" : "Test2",            "address" : "mtQArCTnZHGsPf89jus6khxriYsJbU673P",            "category" : "send",            "amount" : -11.00000000,            "fee" : 0.00000000        },        {            "account" : "Test1",            "address" : "mtQArCTnZHGsPf89jus6khxriYsJbU673P",            "category" : "receive",            "amount" : 11.00000000        }    ]}I'm not sure "details" is the right name for this information; if you have a better suggestion, speak up. Great!  I'd like to see this good work make it back into mainline bitcoin; please talk with the other improve-the-build-process efforts and submit some patches. Great!  I'd like to see this good work make it back into mainline bitcoin; please talk with the other improve-the-build-process efforts and submit some patches. Great!  I'd like to see this good work make it back into mainline bitcoin; please talk with the other improve-the-build-process efforts and submit some patches. Great!  I'd like to see this good work make it back into mainline bitcoin; please talk with the other improve-the-build-process efforts and submit some patches. The smartcard-generates-a-private-key-itself seems like overkill.  No matter what, you have to trust the smartcard manufacturer.  Because even if the smartcard generates a private key, you have to trust that the smartcard manufacturer didn't: + Add a backdoor that lets them read the private key + Break the implementation so the private key created is predictableIf you have to trust the smartcard manufacturer anyway, it seems to me a much simpler solution is to just associated a bitcoin address with a tangible bitcoin.Redeeming the tangible bitcoin then means turning it over to the issuer and having them send the bitcoins to one of your addresses.It is easy to solve half of the "is this valid" problem-- you can easily check to see if bitcoins have been sent to that address and are still unspent.The other half of the problem is "is there another unredeemed copy out there?"Perhaps the issuer could publish a public database of unredeemed tangible bitcoins that is:  bitcoin address -->  hash of information that the tangible bitcoin purchaser providesI could then check that database to see if bitcoin address 1abc was sold ONLY to SHA256("Gavin Andresen 1-Jan-2011").  That stops the issuer from selling the same bitcoins over and over again.I still have to trust that the issuer won't decide to spend all the bitcoins (since they have the private keys) and disappear.  But that's really no different from trusting your smartcard manufacturer.(interesting thing to think about:  the issuer could actually use just one private key and generate as many public keys as they like that can all be signed using that one private key...) Good idea.  I vote for the new wiki as the right spot, with the Discussion pages there as the place to bring up issues with the documentation/etc.I'll put a pointer to the new wiki at the beginning of my bitcointools NOTES.txt.Do we need a separate forum specifically for network-related stuff?  Seems to me the Development forum here is the right place for those kinds of discussions. I've been reworking my old 'monitorreceived' patch to catch up with the latest JSON api changes, and I'm looking for feedback.New methods I've already implemented:monitorblocks <url> [monitor=true]: POSTs a JSON-RPC notification to <url> when new blocks are accepted.listmonitored : returns list of URLs that are monitoring new blocksgetblock <depth> : Returns information about block at depth <depth>getblock/monitorblocks give this information (this is one of the -testnet blocks):Code:{ "hash":"000000002eb339613fd83ea65f3620cc85a8247893ea7f1f85e40fc9632db50f", "blockcount":21109, "version":1, "merkleroot":"c0efb898417b55dbec645eeda3e5a3c092c22e21e17f423876e858bc223e721c", "time":1294269726, "nonce":595884571, "difficulty":4.81431771, "tx":[   "ea214bb68aeca12eea6e8467b3b72dcf4c3aef0de015e5d21b51d63ed9fba1a9",   "90727f2409ea326fcb5e218c1c4213608bf3f2e9d18b3191e52fff86ccda7701"  ], "hashprevious":"0000000002889316c2e34614eadcafea44cf0899945dde0da0fa7a765058aca6"}The monitor JSON-RPC notification wraps that information with a call to "monitorblock" -- see http://gavinpostbin.appspot.com/15depef for exactly what a notification looks like.I'm thinking about adding notification for 0-confirmation wallet transactions, too; something like:monitortx <url> [monitor=true]  : POST to url when wallet transactions (sends and receives) are accepted.Information posted would be the same as you get from calling gettransaction, and I'll change listmonitored to return lists of { "category" : block/tx, "url" : url }.Possible reasons NOT to add this to mainline bitcoin:1. I'm using boost::xpressive (regular expression library) to parse the urls.  Bitcoin is already dependent on lots of other pieces of Boost, and xpressive is compiled as a header-only dependency (no changes to the Makefiles)... but I wouldn't be surprised if using xpressive causes problems on SOME compiler somewhere.2. POSTing to https: URLs won't work if you're running on Windows (any windows/mingw experts want to take another crack at getting full openssl working?).3. Related to https/ssl:  if you POST transactions to a non-ssl url, somebody eavesdropping on your packets will be able to figure out which bitcoin addresses belong to you.  This is a potential privacy issue.As always, feedback, encouragement, and reality-checks are welcome. ... but Launchpad won't build (run the compiler on one of their machines) Mac/Windows software, or did I miss that feature when I looked at the website? Done. CIA...  sounds scary!I'll make it post to #bitcoin-devBy the way: I cleaned up the SourceForge project a bit today, adding a pointer to the Technical Support forum here for support and shutting off some unused features. trapezoid....  are you related to Dr. Gene Ray, Cube Phenomenologist and THE WISEST HUMAN?In the programming world, I'm a fan of what is called "duck typing" -- if it looks like a duck, walks likes a duck, and quacks like a duck, then it is a duck, even if you give it a fancy name like TrapezoidalFowl or MultiLevelBird. Very nice!  Let me ask some dumb questions:What does PPA stand for?Does launchpad help solve the 'trusted build' problem-- e.g. does the build process automatically fetch from source code that we can all look at and audit?How hard would it be to setup something similar to produce regular builds of the github integration repository?Right now, the bitcoin build process is "Satoshi does it."  Using Launchpad to create the Linux builds seems like the right way to go.Last dumb question:  are there services similar to Launchpad for building Mac/Windows software? You should be honest about what you're doing:  http://en.wikipedia.org/wiki/Ponzi_scheme Pulled into git integration repository. Pulled into the git integration repository. OK.  Lets talk here. Done.  Please feel free to make it better.Good idea. Mirroring all of the information that bitcoin keeps about transactions inside your bitcoin-oriented web app is probably not the right way to go.It violates the zero/one/infinity principle, and you're likely to have subtle bugs if (when?) the two copies get out of sync.See:  http://www.bitcoin.org/wiki/doku.php?id=accounts   for "best practices".  If you're willing to share what kind of thing your web app is doing, I'd be happy to brainstorm other approches, too...
It aught to be able to handle hundreds of accounts and thousands of addresses, although (as far as I know) nobody has done scalability/stress testing with that many (simulated) users.The listtransactions method scans through all wallet transactions (and then sorts them by time), so if you've got thousands or tens of thousands of accounts with millions of transactions and you're using listtransactions to show customers their account histories, that might be a bottleneck.However, I wouldn't be at all surprised if something ELSE becomes the bottleneck if you had that many accounts-- for example, there is only one RPC thread handling requests, and some requests (like a send bitcoins request) can take seconds to process.  I've been writing code long enough to know that I can't look at code (even code I've written) and figure out where the performance problems are lurking-- you've got to actually measure or simulate real-world behavior. Thanks!  It was the first interview I've ever done via IM/chat, and it worked well. I was surprised to see how little editing/reworking was done; I guess they were happy with what I wrote, too.Sure.  I run two instances of bitcoind on a "Linode 512" running Debian (sign up using this URL and I'll get a $20 credit).  They're used for the TEST and regular Bitcoin Faucets.I also use that system to compile bitcoin/bitcoind.  I've been very happy with Linode.The bitcoind for ClearCoin is running on an Amazon EC2 "micro" VPS instance, also running Debian, using an encrypted EBS filesystem.  I'm extra paranoid about security and reliability for ClearCoin because I'm handling other people's money. Happy New Year!It is going to be a good year.  It has to be-- because my favorite number is eleven. I agree it is natural to want to know who sends you the money.  That would be a nice feature to add to Bitcoin.Showing a 'from' address in bitcoin as it is now won't give you that feature, it will give you something that kind-of, sort-of, maybe-most-of-the-time works like that feature.And it's not obvious how to implement a "where did these bitcoins come from?" feature. The forum database is now being automatically compress, encrypted, and backed up to another of sirius' servers and to Amazon S3 every day (one per day, I don't delete the old backups, yet). Yeah, cool!Could you punch a couple of holes through the B?  I like topologically interesting money.And if you want to make it the absolutely coolest coin in the world, generate a new bitcoin address, send 1 bitcoin to it, and then engrave that address on the coin.Then you have physical currency that the owner can independently check to make sure the bitcoin backing it hasn't been spent. Playing devil's advocate for a moment:"Security theater" is popular.  It makes people feel safer.  Bitcoin-the-program will probably be more popular if it asks for a password before sending and there is a bullet-point on the feature list:  "State of the art AES-256 encryption."I believe TrueCrypt is open source; maybe it would be easy to use their password handling / encryption code in bitcoin.  Anybody here looked at their code? There really is no "from" -- there is just 'where the coins were sent last time they were sent somewhere.'If that 'somewhere' was a shared wallet (like a mybitcoin account) where all the incoming transactions get mixed up, knowing what address they were sent to previously is worse than useless information.  You might decide it is a good idea to try to refund bitcoins to that address and end up sending them to some random mybitcoin user, and NOT your customer.Adding possibly-worse-than-useless features to the bitcoin GUI is a bad idea.  Am I missing some other reason for wanting to see the last addresses to which the coins you received were sent? If you have a trojan on your computer you've already lost.  The trojan could easily log your keystrokes and send your password along with the encrypted wallet.dat to the bad guys. No, definitely not.  But if somebody implements a nice Javascript GUI I'll volunteer to teach bitcoin to spit out JSONP in addition to plain JSON to get around the same origin policy...RE: GWT:  I'd prefer a non-Java-to-Javascript-compiled solution (shipping compiled, not-human-readable .js files makes me nervous; do we have to add all the GWT compilation mechanism to the build process?  Or do we have to trust that you provided valid, not-messed-with, already-compiled .js files?) I'd love to see a pure-Javascript front-end GUI for bitcoind developed.I'm tempted to write one myself, but I've got a lot of other things on my TODO list right now.  Here's what I'm imagining:+ Open source, pure JavaScript interface to bitcoin that communicates with a running bitcoin/bitcoind using the JSON-RPC api.+ Open up the index.html page that is the GUI and you'd be asked for the host:port (default: localhost:8332), username and password.+ From there, you'd have a nice Javascript/HTML GUI showing all your wallet transactions (using RPC listtransactions).+ And it'd show your default receiving address, have a Send Bitcoins button, etc.+ And it'd poll bitcoin/bitcoind every, oh, minute or so to look for new transactions.I'm imagining shipping a webGUI/index.html (plus associated CSS/javascript/etc) as part of the bitcoin(d) source package. I think of this as a subset of the "I want to move N bitcoins from my wallet to a USB stick that I'll put in my safe deposit box so it cannot be hacked", "bitcoins as a long-term store of value" feature:  https://github.com/bitcoin/bitcoin/issues#issue/2A solution should: + Make accidental double-spending impossible (or at least, very hard) + Remove the private keys from your wallet so if the wallet is stolen they coins are safe + Be as close to 100% safe as possible, even if your computer gets hit by lightning at exactly the wrong time.That last one is the tricky bit. Let's try using the github Pull Request system for discussing pull requests:  https://github.com/bitcoin/bitcoin/pullsThat ties the discussion to the proposed code changes, is a natural way to create separate 'threads', and will be a convenient place to point to in release notes.And lets talk about potential code changes (pre pull request) here in this forum.I'd rather not introduce Yet Another Place (we've already got these forums, IRC chat, and github) to talk about bitcoin development. I don't think that belongs in Bitcoin-- I like solutions like i2p or ssh tunneling that put encryption down at the lower network layer (where it belongs, in my humble opinion).Are you worried about SourceForge and GitHub (the two 'official' trees) being forced, or deciding, to drop bitcoin?  At this point lots of developers have their own copies of the source code, I'm sure if that happened another site (maybe a hidden monotone repository inside the anonymous i2p network) would spring up.They can't stop the signal... You need a service that will let you send multiple, random-looking amounts at different times, and then, some time later, send an amount to the destination.   And then refunds any extra you sent (and you should send extra).  And if you're really paranoid, it should allow you to give several refund addresses, and random amounts of coins get refunded to each.Then you need to trust that service, which is the really big security hole.  What better way to catch money launderers than to setup a money laundering service for them?You're probably better off doing what has been suggested several times-- move coins between 'shared wallet' services like MyBitcoin or MtGox (and/or ClearCoin) or just between two machines of your own that are both running bitcoin. It dumps out keys in abbreviated hex (I worry about naive users accidently publishing screen snapshots showing their full private keys).Teaching bitcointools to dump out keys in OpenSSL ascii-armored format is a great idea.  It is just not high on my personal priority list right now. Can we brainstorm positive emotional arguments?  Maybe:* Get back at the bankers and megacorporations that robbed us blind and drove the economy over a cliff!* Bitcoin is The People's Money-- created by YOU, controlled by YOU.* Use bitcoin and tell (PayPal/your credit card company/the foreign currency exchanger) you're tired of paying outrageous fees just to send YOUR money to somebody else.More? TIPS (Treasury Inflation Protected Securities), which are sold by treasurydirect, compensate for inflation.  They are a good place to put money that you're pretty sure you will need "soon" -- within the next 5 years or so.  Assuming you trust the US government not to default on its debt (I do-- I think the government might try to inflate away the debt, but won't outright default).Money you won't need soon aught to be invested in something productive-- invest in some business or person that is making our lives more efficient or pleasant.  That should give you the best long-term return and will make the world a better place, too.  Stock market index funds are an inexpensive, mostly safe, mostly inflation-proof way to invest.If you have some 'playing around' money that you can afford to lose, you might want to invest in Bitcoins.  But bitcoin is a startup currency, and should be treated like a high-tech startup company-- high-risk, but very high potential reward.  You might lose your entire investment or it might turn out to be the best investment you ever made. If you expect a one-to-one relationship between transactions and bitcoin addresses, then yes, a multisend will be a problem for you.If I were implementing the anonymous fund-with-a-bitcoin-address system, I would do something like:Customer "Ed" gives a "send winnings to address"-- lets say it just happens to be   1Ed....Casino gives a funding address -- lets call that address   1fundEd...Casino creates an account named "1Ed..." and associates it with address 1fundEd.So any coins Ed sends to 1fundEd....  go into the 1Ed... account.When Ed wants to place a bet, casino checks to see if he has money:   getbalance 1Ed....If he does, he can place a bet.If he wins, casino sends money:  move BANK 1Ed...  <amount Ed won above his bet>  sendfrom 1Ed... 1Ed.... <amount Ed won>   # Account name and cash-out address are the same.If he loses:  move 1Ed... BANK <amount Ed lost>listtransactions is for showing Ed a detailed list of what happened to his account. I thought bitcoinex was asking about the weird multisend case, where there is one Transaction (so one txid), but two or more TxOuts with the same amount to the same address.
They won't be different-- you will get two entries that are identical.Bitcoin will sum them up for you if you use the getbalance or getreceivedby* RPC commands. Yes, that is exactly what the blkindex.dat file is.wallet.dat contains "extended dance mix" versions of all the transactions you care about (all of "your" receives/sends).  Those are loaded into memory at startup (and then kept up-to-date as new transactions are seen), so calculating "your" balance is quick (just scan through all wallet transactions in memory and total them up). Thanks!Can somebody volunteer to be "translation pull person" for the new git integration repository?  The job would be packaging up changes into "pull requests" (if the person doing the work can't or won't use git), giving them a sanity test, and then pulling them into the integration repository. Normal send; this one was:sendfrom Test1 mytzSq1rkXzPidP9tHvfhDuzXqDSSvvaCg 100Code:    {        "account" : "Test3",        "address" : "mytzSq1rkXzPidP9tHvfhDuzXqDSSvvaCg",        "category" : "receive",        "amount" : 100.00000000,        "confirmations" : 344,        "txid" : "210ea061bd3664c34349dfa4849b9f33889cfe2117bf02d62fd765cb0ee5b5b0",        "time" : 1292527858,        "comment" : "Test1 to Test3, 100"    },    {        "account" : "Test1",        "address" : "mytzSq1rkXzPidP9tHvfhDuzXqDSSvvaCg",        "category" : "send",        "amount" : -100.00000000,        "fee" : 0.00000000,        "confirmations" : 344,        "txid" : "210ea061bd3664c34349dfa4849b9f33889cfe2117bf02d62fd765cb0ee5b5b0",        "time" : 1292527858,        "comment" : "Test1 to Test3, 100"    },And a wicked-crazy multisend:sendfrom Test1 to:   mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX 3.0  AND   mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX 3.3  AND   msVM67gJZ4EKMRVdMjMFzwWEU32VzBUnqu 2.0Code:    {        "account" : "Test3",        "address" : "mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX",        "category" : "receive",        "amount" : 3.03000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },    {        "account" : "Test3",        "address" : "mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX",        "category" : "receive",        "amount" : 3.00000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },    {        "account" : "Test2",        "address" : "msVM67gJZ4EKMRVdMjMFzwWEU32VzBUnqu",        "category" : "receive",        "amount" : 2.00000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },    {        "account" : "Test1",        "address" : "mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX",        "category" : "send",        "amount" : -3.03000000,        "fee" : 0.00000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },    {        "account" : "Test1",        "address" : "mo5JUdFcaHQdT6VbWxee9q7Y7U8GZta4QX",        "category" : "send",        "amount" : -3.00000000,        "fee" : 0.00000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },    {        "account" : "Test1",        "address" : "msVM67gJZ4EKMRVdMjMFzwWEU32VzBUnqu",        "category" : "send",        "amount" : -2.00000000,        "fee" : 0.00000000,        "confirmations" : 342,        "txid" : "ed9d338586c0893b2469cd9e3af4d074654d807329a5a789e066f03063a08136",        "time" : 1292531730,        "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"    },Again, multi-sends are non-standard transactions.  And no, I won't give you the hacked code I wrote to generate multisend test cases...   https://github.com/bitcoin/bitcoin/pull/10Three changes to listtransactions:Add address to listtransactions output."multisends" (non-standard, use one transaction to send to multiple addresses) generate N "category":"send" lines.Bug fix: listtransactions wasn't reporting pay-by-IP-connection receive transactions. That's what I meant when I asked "are there significant costs?"If one of the mining pool folks think this would be useful in a production miner, then I see the value.  If it is only really useful if you're trying to debug a remote miner that isn't working quite right... I'm working on that. Anybody have a chance to compile/test this on Windows?I created an Official Pull Request for this, which I will accept and apply unless I hear objections today:  https://github.com/bitcoin/bitcoin/pull/9 I'm with Hal-- do we really need another special-case switch?  Are there significant costs to just always printing when pow fails? Well said!Trust is Bitcoin's biggest barrier to success.  I don't think there is anything we can do to speed up the process of getting people to trust that bitcoin is solid; it takes time to build trust.  However, there is plenty we could do to lose that trust, including overpromising or misrepresenting what bitcoin can do.Bitcoin is beta software; nobody should trust it 100%.  Do not invest your life savings in bitcoin-- in fact, do not invest any money you're not willing to lose.  Expect more ponzi schemes and fraud.  Expect irrational valuation bubbles, and, while the bitcoin economy is small, expect people to try to manipulate the bitcoin markets. Oh, and RE: extracting private keys from the wallet:I'm less excited about that idea.  What if the private keys are stored in a tamper-proof "trusted security module" hardware doo-hickey, and are impossible to export? I like this feature request; I think it will enable even more interesting uses of bitcoin.  I created a feature request at github for it.Example:  a store that accepts bitcoins could verify that a customer sending in a question about some transaction actually IS the same person who sent them the bitcoins, by asking the customer to sign their message using one of the same bitcoin addresses they used to sign the coins.If the "store" is a privacy-focused VPS provider and the question is "Hey, I lost the root password to the virtual server, could you generate a new one and encrypt it with this gpg public key", then tying that message to a bitcoin transactions is extremely useful. When that happens, I think most people using bitcoin will not be running always-connected-to-the-bitcoin-network software.  I think there will be at least three different sets of people:1. People who trust a web site to keep their wallet safe more than they trust themselves.  They'll use sites like MyBitcoin or MtGox, which give them an online wallet.2. People who don't or won't trust anybody to keep their wallets safe, but don't have a high-speed, always-on Internet connection.  They will use a 'payment gateway', where they submit transactions that are signed by their own computer (they don't have to trust the payment gateway to keep their wallet, the gateway just forwards relevant transactions onto the bitcoin network for the user).This doesn't exist yet, but writing the code to support this isn't terribly hard.3. People who DO have always-on high-speed network connections; they'll run bitcoin just like they do today.  But, assuming the volumeof bitcoin transactions continues to increase faster than the cost of network bandwidth declines, that will become increasingly expensive,so I think more and more users will choose option 1 or 2.The current bitcoin doesn't keep all transactions in memory at once--  the blkindex.dat and blk0001.dat files in your bitcoin data directory stores them on disk. With Satoshi's blessing, and with great reluctance, I'm going to start doing more active project management for bitcoin.Everybody please be patient with me; I've had a lot of project management experience at startups, but this is the first open source project of any size I've been involved with.  Anyway, I've created an integration/staging tree at:  https://github.com/bitcoin/bitcoin... and am proposing this for a development process:Straw-man plan for Bitcoin development (open source vets, please slap me around and help make this better):Developers work in their own trees, then submit pull requests when they think their feature is ready.Requests get discussed (where? here in the bitcoin forums?) and if there's broad consensus they're a good thing, well written, match coding style, etc. then they're merged into the 'master' branch.master branch is regularly built and tested (by who? need people willing to be quality assurance testers), and periodically pushed to the subversion repo to become the official, stable, released bitcoin.We'll create feature branches if/when there are major new features being worked on by several people.Discussion, feedback, etc, especially from people with experience leading or working on other open source projects, is very welcome. Umm... there will be no Top Bureaucrat counting votes and telling people what to do.  There will still be plenty of anarchy, I promise!Use the voting system to express what is important to YOU.Or not. I've created an 'official' Bitcoin bug/issue/feature request tracking system at:  https://github.com/bitcoin/bitcoin/issuesThe github issues system has a simple voting system; lets use it!And if you see an issue that you want to work on, use the commenting system to let everybody know you're working on it.  I'd like to be  open about who is working on what, and what features/bugs/issues people think are important.However... we'll still be very conservative about what changes make it into the official bitcoin client.  Bitcoin will be destroyed if people using it lose their trust in it. Feel free to take anything I've written here on the forums or on the wiki and do whatever you like with it.And, for what it is worth, I like the new wiki more than the old wiki; the new one is prettier and more powerful. move is its own category (and may be + or -, never has a txid or fees).  And the output I pasted is what listtransactions does right now (it doesn't report bitcoin addresses).After some private feedback, I'm now leaning towards listtransactions giving multiple category:send entries (with the same txid) for the multisend case.  That matches what is done for the category:receive end.  transaction fee... I think I'll do what is easiest to implement which is repeat it in all of them.So the example would look like this, with three receives and three sends:Code:   {       "account" : "Test3",       "address" : "1aTest3blahblahblah9d87"       "category" : "receive",       "amount" : 3.03000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test3",       "address" : "1aTest3blahblahblah9d87"       "category" : "receive",       "amount" : 3.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test2",       "address" : "1aTest2blahblahblahQ9Qe"       "category" : "receive",       "amount" : 2.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test1",       "address" : "1aTest3blahblahblah9d87"       "category" : "send",       "amount" : -3.03000000,       "fee" : 0.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test1",       "address" : "1aTest3blahblahblah9d87"       "category" : "send",       "amount" : -3.00000000,       "fee" : 0.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test1",       "address" : "1aTest2blahblahblahQ9Qe"       "category" : "send",       "amount" : -2.00000000,       "fee" : 0.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   }, Short answer:  you don't have to worry about it.Long answer:  if you want to worry about being as network-bandwidth-efficient as possible, run one node normally, and run all the rest with the -noirc -connect=IP.AD.DR.SS flags so they connect only to the one 'master' node.  All the network traffic will then go through the master node. We're pretty close to being able to duplicate the bitcoin GUI using the RPC.I think the only thing missing is reporting bitcoin addresses in listtransactions.  That gets a little sticky with multisends (one transactions that sends coins to multiple recipients); here's what I'm thinking of implementing after doing some brainstorming with theymos/jgarzik/nanotube in IRC chat and running a couple of 'multisend' tests on the test network:Code:"category" : "receive","amount" : amount,"address" : "bitcoinaddress"... plus the rest of what is reported now(account/txid/confirmations/time/comment).  That's the "received on"address, of course.On the send side, I'm leaning towards:Code:"category" : "send","amount" : amount,"fee" : fee,"toaddress" : { "address" : amount }  #  or "toaddress" : { "address" : amount, "address" : amount } for a multisend.... plus the rest of what is reported now(account/txid/confirmations/time/comment).I don't like that the common case looks kind of ugly; I'd much preferjust Code:"address" : "bitcoinaddress"That could be done by having listtransactions report multiple category:send entries for a multisend... except it is not obviouswhich one should report the fee, if there is a fee.  First one?  All of them?I'm also a worried that websites might get their accounting wrong if they're not prepared to deal with multisends; making "toaddress" anObject makes it obvious that multisends are possible.  The only way a website would get a multisend would be if they allow users to import keys from their local bitcoin wallet, which nobody is doing... yet.Here's how listtransactions currently reports a complex multisend:Code:   {       "account" : "Test3",       "category" : "receive",       "amount" : 3.03000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test3",       "category" : "receive",       "amount" : 3.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test2",       "category" : "receive",       "amount" : 2.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },   {       "account" : "Test1",       "category" : "send",       "amount" : -8.03000000,       "fee" : 0.00000000,       "confirmations" : 66,       "txid" :"36c86ca499275945a3f1805d6e070ac00b2d32e5e16a4c9cf2c83b189a347d88",       "time" : 1292532062,       "comment" : "multisend, Test1 to Test2 and Test3 twice (same addr)"   },
Works nicely on Linux, and is the recommended way to close dialogs.Anybody able to give it a quick compile and test on Windows? Weird.  Are you on Linux or Mac?  If you are, grab my bitcointools and run  ./dbdump.py --wallet... then look for:nLimitProcessors:  andfGenerateBitcoins: ... and I just noticed an egregious bug:  listtransactions was reporting the receiving address instead of the account name for "receive" transactions.  Fix is svn rev 104.  Please bang on it and let me know if I screwed anything else up.While I was committing, I also added "time" to transaction info output, and fixed a little bug reported a while ago (setgenerate true 0 is now the same as setgenerate false). Just use transactionID+account.You've already got the problem that if a customer sends coins from account A to an address that belongs to account B, that is a single, unique transaction that affects two accounts.listtransactions will Do the Right Thing (generate two entries, different accounts, same transaction id).  And gettransaction won't lie to you (it doesn't say anything about what accounts were involved, on purpose, for exactly this reason). No, only the amount sent to the address associated with the web app's account(s) will be reported in listtransactions.But that's exactly why this is a lot harder than it seems-- we've got to think about weird transactions people might use to try to break websites that use this API. Do you have gen=something in your bitcoin.conf? Outputting the transaction time would be easy."The address that received funds" is not as obvious as you might think.  It is possible to generate transactions that are split and go to several addresses (well, it is possible if you use your own custom client, standard Bitcoin doesn't expose that feature).Some or all of those addresses might be yours, and might be associated with any number of accounts.I see two possible ways of dealing with this:1. Generate multiple entries for a single transaction.  E.g. if you receive a split transactions, where 50 BTC goes to address '1aaa...' and 10 to address '1bbbb...', listtransactions will list that as two separate entries that share the same txid:Code:    {        "category" : "receive",        "amount" : 50.00000000,        "txid" : "2c9d43db0142130a9926ef4b1c58abf17e8b4dfd2148bf2072b0df6d2bac8789",        "toaddress" : "1aaa", ... etc, irrelevant fields omitted...    },    {        "category" : "receive",        "amount" : 10.00000000,        "txid" : "2c9d43db0142130a9926ef4b1c58abf17e8b4dfd2148bf2072b0df6d2bac8789",        "toaddress" : "1bbb", ...    },You can already get two separate entries for one transaction if you send to yourself, so this might be the best answer.  And it makes the common case simpler.2. Or maybe 'toaddress' should be address:amount pairs, like this:Code:    {        "category" : "receive",        "amount" : 60.00000000,        "txid" : "2c9d43db0142130a9926ef4b1c58abf17e8b4dfd2148bf2072b0df6d2bac8789",        "toaddress" : { "1aaa" : 50.000000, "1bbb" : 10.000000 }    },Writing all this down, I'm thinking that listtransactions aught to generate multiple entries, but gettransaction aught to generate address:amount pairs (and still omit category/account, as it does now). move <fromaccount> <toaccount> <amount> [minconf=1] [comment]minconf does what you want (gives an Account has insufficient funds error if not enough funds with minconf confirmations). I just committed svn rev 103.  Changes are:listaccounts :  lists all the accounts in your wallet along with their current balances.listtransactions : call it with no arguments, or give it '*' as the account name, and it lists the last N (default 10, as before) transactions from all accounts.  Part of this change is disallowing '*' as an account name.-rpctimeout : Thanks to Mt`AwAy who pointed out that, if somebody was allowed to connect to the bitcoin rpc port (via -rpcallowip), then they could connect, do nothing, and hang the connection, causing a denial-of-RPC-service.  Now bitcoin's RPC thread will close the connection if it doesn't get the HTTP request within -rpctimeout (default 30) seconds. A big spike 18 hours ago, but then back to pretty much normal. No, implementing it would be easy.  Implement it (don't forget the UI), test it on the test network (where it is pretty trivial to get non-IsStandard stuff into blocks), and then lobby for a new 'standard' transaction type.theymos, please stop acting like the current IsStandard test is set in stone. It is not, and, as Satoshi said, new versions of the client are rapidly adopted by a majority of the network, so introducing a new transaction type will not be a big deal. I deleted two posts-- one from you that was a quote of ByteCoin's simulation results (and nothing else).And a second from ByteCoin (if I recall correctly), saying essentially "what's up with the empty post?" Simplest way:Call getaccountaddress "charity_name"  when you generate the web page.  You'll get the same address over and over, until somebody donates.  Then you'll get a new address.Then periodically call:  getbalance "charity_name"... and if the balance is greater than zero, call:  sendfrom "charity_name" charity_real_bitcoin_address amount... to send the charity the accumulated coins.If you deal with several charities this way, AND you're bundling up several donations before forwarding the coins to the charity, then it'll be hard to connect donors to particular charities. If you're simulating, be sure you're not overlooking the 'opportunity cost' of working on the next-valid-block when you're 'holding back' blocks.Example:Cartel finds block N.  Instead of releasing it right away, Cartel holds it and starts working on block N+1 (trying to get a head start).Before Cartel finds block N+1, somebody else finds an alternate block N and announces it.IF Cartel loses the race to announce, then Cartel has wasted time looking for a block N+1 that will not be accepted.If they simply announce block N right away, they'll never waste time trying to find a block N+1 that has only a 50% chance  of being accepted.Unless the Cartel can propagate their blocks across the network faster than the whole rest of the network, there is never an advantage to holding back blocks. There is something wrong with your simulation.  Proof:Imagine a bitcoin world with two Cartels, each with 50% of the power, each following the strategy you outline.It is obvious that they cannot BOTH get 59% of the blocks. Did you simulate network connectivity at all?  Bitcoin is a semi-randomly connected network, where most of the connections are (I would guess) outbound connections from non-generating nodes who are sitting behind firewalls.  With a typical node having 8 random connections, to different /16 networks, it seems to me it would be pretty tough to get tight-enough control over enough network connections to consistently win the "announce a new block" race.Anybody know how to estimate what percentage of connections the cartel would have to control to only lose the announce-a-block race 15% of the time?  It'll be way more than 15%.... What theymos said.  You're asking for the balance of the account named '1Fs5rqB2sXZ3kax1r3HfuYpK2ksSxLYJT8', and there is no such account.Whether bitcoin should return an error (instead of 0) if you ask for the balance of a non-existant account is debatable... If the hashing algorithms are broken I might be able to generate an ECDSA private/public key pair where the public key hashes to the same bitcoin address as one of your public keys.If I can do that, then I can spend your coins.On my list of things to worry about, this is just below "Asteroid impact destroys the earth" (but above "Aliens invade and make me their slave"). getaccountaddress is designed for exactly this kind of thing-- it will return the same address over and over, until it gets used (until somebody donates).  After that, it returns a different address...Of course, if "the public" is grabbing the donation address off your "Donate to Us" page, they could generate a list of donation addresses, add up the donations received on all those addresses, and figure it out.  Depending on how many donations you're getting that might be easy (scrape the page once per day) or hard (if you're getting dozens of donations per day).You could make it much harder for anybody to figure out how much you're getting in donations by randomly donating to yourself (using the same address returned by getaccountaddress), preferably from a wallet shared by lots of other people (like a MyBitcoin or Mt.Gox account)...   Change "getnewaddress(label)"  to "getaccountaddress(label)" and you'll get the same address over and over, until somebody donates.  Then you'll get a different one.
This thread talks in detail about Bitcoin's use of hashing of ECDSA public keys to generate bitcoin addresses.Executive summary:  bitcoinaddress = RIPEMD-160(SHA-256(publickey))So you'd need to break both RIPEMD-160 and SHA-256 hashing algorithms.  And the RIPEMD break would have to be quite extreme-- more than just "add some random data to force a hash collision" (which is how MD5 is broken), because it is hashing a SHA-256 hash, so you're not able to add some random data to be hashed. I was sent this question in email:Why can't somebody just create a version of the software that gives you extra bitcoins?... and couldn't find a good, non-geeky answer in the FAQs.  So I wrote one:When you spend some bitcoins, the software on your machine has to prove to the software running on everybody else's machine that those bitcoins are valid.How does it do that? Well, it is a little bit complicated; you've got to understand how bitcoins are created, and how they are traded.First, how they're created: 50 bitcoins are created approximately every 10 minutes. Everybody who is trying to create bitcoins is in a race to try to find those 50 bitcoins; they are really hard to find, but, once found, it is easy to verify that, yes, indeed, your bitcoin software found them, so you get to spend them.Second, how they're traded: Imagine you did find 50 bitcoins (well, your computer found them by running the bitcoin software for a few months or a year they are not easy to find, and are harder to find the more people who are looking for them). You trade them to me by sending them to my bitcoin address. Inside the software, a messages is created and then broadcast to everybody that says These 50 bitcoins that we all agree are valid are hereby officially traded to somebody else (me well, one of my bitcoin receiving addresses, actually).Now I've got them. If you try to trade those same 50 bitcoins to somebody else, it won't work everybody running Bitcoin sees all the trades, so if you try to spend the same coins a second time everybody else's software will reject your attempt to cheat.And that's it that's how it works. Bitcoins are scarce because only about 50 are created every ten minutes. And you can't claim to have more than you really have because everybody else can check to see if your coins really were created by the race process, or if they were from valid trades. I'm not the designer of Bitcoin (I am one of the developers), but I have been thinking a lot about what it will take to make it safe(r) for my grandma to use.playanaut, I'd love to hear your suggestions on how to make bitcoin better.  And (shameless plug): I'd also love to know if you think my latest project, ClearCoin, is a step in the right direction. Oh, and RE: privacy:Mixing all of the 'coins' for all of the accounts together is, I think, an overall plus for privacy.  True, you might receive coins from somebody and be able to figure out "Hey, they sent me some of exactly the same coins I deposited in my BigBitBank account yesterday!   They must have an account at BigBitBank, too!"But mixing all the accounts' coins together makes it much more difficult to figure out where any user's coins came from, or, if you know where they came from, where the user is spending their bitcoins.  Unless you can subpeona BigBitBank's records, of course... I wrote all this up (minus the little man) for the wiki:  http://www.bitcoin.org/wiki/doku.php?id=accountsLet me know if it doesn't make sense.  Or, even better, fix it for me! Sorry to send you on a wild goose chase, the problem is NOT CRLF issues.The problem is in your HTTP headers; you're sending the request as:Content-Type: application/x-www-form-urlencodedThe correct Content-Type for JSON-RPC over HTTP is:  Content-Type SHOULD be 'application/json-rpc' but MAY be 'application/json' or 'application/jsonrequest'I'm not sure what .net is doing with the body of the request, but by the time it gets to Bitcoin/PostBin, it has x-www-form-urlencoded it enough to confuse the heck out of them.When you get this working, please update this thread, and for extra positive karma, add a .net section to the Bitcoin JSON-RPC wiki page. Accounts do not affect the previous-transaction-selection algorithm at all; if you sendfrom FOO, bitcoin doesn't make any effort to only use coins that were received by FOO.Think of your wallet as being a big pool of coins.  Coins are not stamped with account names when they go in, instead, there's a little man with a green visor making entries in a ledger.Each receiving address is a pipe that dumps coins into the pool, and the little man knows which pipes are assigned to each account.Every send the little man grabs his shovel and picks a bunch of coins randomly from the pool.  Then debits an account.And for moves, the little man doesn't have to touch the coins in the pool at all, he just adjusts his ledger. You just did raise this as a potential bug, but you need to convince me that Bitcoin is not following the HTTP/1.1 spec, which says:... and, for 'tolerant' applications:What character(s) is JayRock putting between the headers and the body? moves do not touch the block chain, they add accounting entries to your wallet to adjust the balances of the accounts involved. Yes, listtransactions "*" <count> is possible.  The other account routines could return a new "invalid account name" error if given "*".I've got two issues with it, though:1.  listtransactions "*" will have to iterate over every transaction in the wallet (transactions are not indexed by time), which will be slow for large wallets and will get slower over time.  And indexing transactions just so that listtransactions * is fast violates the "an optional feature shouldn't cost anything if it is not used" principle.2. What is the use case for "list the last N transactions across all accounts" ?   The only one I can come up with is developing an alternate GUI that communicates with bitcoind via the JSON-RPC, but to support that at least a couple of other features would have to be added at the same time (e.g. listtransactions would needs to add account and bitcoin address information to the objects it returns....) Actually, thinking about it, are you sending \r\n for newlines?Fricking PC versus Unix versus Mac line-endings will be causing problems until the end of time.... You're missing a blank line between the HTML headers and the HTML body-- PostBin and Bitcoin both think you're sending an empty request.I dunno enough about JayRock to suggest how to fix that... Nightly builds are a great idea; does the build service do an automatic svn update?  Anybody else willing to help get GUI-bitcoin building (or anybody know somebody on the wxWidgets team?) Can you change the username/password in the authentication and then have it POST to:  http://gavinpostbin.appspot.com/pwbba8... so I can see all the headers/etc ?  You're probably not sending what you think you're sending... Quick reaction:  what stops malicious or lazy BitX chain generator from implementing a type of denial-of-service attack against some bit-app they either don't like or don't know about?  If BitX blocks are never rejected for bit-app reasons, then what is the incentive for main-BitX chain generators to include only (or any!) valid bit-app hashes?   What stops me from constantly flooding the BitX network with bogus bit-app hashes and asking them to be included in BitX blocks? Several months ago, around the time when the 0.3.9 bugs were found, I privately told Satoshi that I thought whitelisting acceptable transaction types was a better way to go, rather than blacklisting transaction types that we find out cause problems.The danger is similar websites that try to blacklist <script> tags in HTML entered by users to prevent cross-site-scripting hacks.  See http://ha.ckers.org/xss.html for a nice sampling of how creative hackers can be.I haven't asked Satoshi if the recent discussion of BitDNS putting extra data in the block chain swayed his opinion or if he woke up in the middle of the night and realized that a creative use of OP_SOMETHING might lead to an exploit.  I don't think it matters; I'm still convinced that whitelisting acceptable transaction types is the right thing to do.As for "the above option was thrown out by the developers"  -- nothing has been thrown out!  Again, I haven't talked to Satoshi, but I'm open to the idea of a third 'standard' transaction type that includes extra, arbitrary data.   Lets have that discussion, implement it on the -testnet, poke at it, try to imagine all the possible ways it can be misused, try to estimate the benefits and costs... and if there's general consensus that it is a good idea, roll it into production. There's been exactly one block with non-standard transactions:  http://blockexplorer.com/b/71036... and it contained no fees.HOWEVER:  jgarzik, you're over-reacting, too.  This will not cause a block chain split; all clients will accept blocks containing non-standard transactions as valid.  Most (many?) just won't put non-standard transactions in blocks that they generate, and won't relay them.  There will be no havoc. I'll and add another reason not to have a "list transactions that happened after <txid>" :move "transactions" don't have a transaction id, but they do affect account balances (and are listed in listtransactions).Your code is going to get really messy if you expect to call listtransactions and then squirrel away the txid of the last item returned.  If it was "category":"move",  there WILL be no txid...RE: eliminating polling:  at some point fairly soon, I plan on cleaning up my "monitorreceived" patch, to POST to a URL when transactions come in or blocks are accepted... but I need to do some Deep Thinking to redesign based on lessons learned from 'accounts'.  It might turn into a very minimal API, where the notification is "Hey, txid <123ae4221...> just got to N confirmations, you might want to call gettransaction and getbalance to get up-to-date." Yes, although the first big feature on my ClearCoin TODO list is a reputation/feedback system. Thanks for all the great feedback!Maybe one way to think about ClearCoin is as a tool to help manage risk between buyer and seller.If the buyer completely trusts the seller, then you don't need ClearCoin-- just send bitcoins directly.If the seller completely trusts the buyer, then just send the product first.Usually there's some level of trust/mistrust between buyer and seller.  If you use ClearCoin in creative ways, you should be able to come up with a way of using ClearCoin that balances the risks to both buyers and sellers.To take davout's example:  The person paying could deposit 20% of the funds in a ClearCoin account, then immediately release that 20% as a "good faith payment".  Then they deposit the other 80%.That gives an 80/20 risk split.   "Half now, half on delivery" type arrangements can be done the same way.davidonpda:  You can choose how long your coins will be tied up when you create the escrow account-- one month, six months, or a year.  Of course, the longer they're held the more comfortable the person on the other side of the transaction will be.PS to Vinnie:  ClearWing Software is the company; ClearCoin is the service.
I'm happy to announce ClearCoin, my bitcoin escrow service:  https://clearcoin.appspot.com/It makes bitcoin transactions safer by securely holding coins in escrow until both buyer and seller are satisfied.If you are buying something using bitcoins, it makes the transaction much safer.  If you are unsatisfied, you will eventually get your bitcoins refunded to you-- you can think of ClearCoin as do-it-yourself chargebacks.If you are selling something using bitcoins, ClearCoin is safer than ad-hoc arrangements to reassure reluctant customers (like "I'll ship you the product if you promise to pay within 30 days" or "pay me half now and half on delivery").I'm looking for questions, comments and feedback.  You can give it a try for free-- transactions of less than 100 bitcoins are free, and you can setup an escrow account to yourself just to see how ClearCoin works. Just to close the loop on this:This happened when:  You ran version 0.3.17, and sent/received some coins  You then ran an earlier version, and the coins you sent/received with 0.3.17 were rewriten to the wallet (e.g. you spent them or they got included in a block).  They'd get rewritten incorrectly (marked as version 0.3.17, but missing extra info).  ... and then you upgraded to version 0.3.17 again.   Bitcoin would crash trying to read the extra, missing info.svn r196 fixes the problem, by storing the extra account info in a different way and detecting the badly-written 0.3.17 entries. A transaction that is signed in a way that the standard bitcoin client doesn't understand.For example, there's been some discussion in other threads about using OP_DROP to embed extra data in transactions; doing something like that would create non-standard transactions. I just commited svn r197 (version 0.3.17.05); it is a "prevent possible security problems we haven't thought of" fix.Before this change, you could compile your own version of bitcoin, create nonstandard transactions containing extra information or fancy new payment features, and all the official bitcoin clients on the network would happily include those transactions in the blocks they were generating and would relay them to their peers.After this change, official bitcoin clients will not relay nonstandard transactions or include them in blocks that they create.  They will, however, still accept non-standard transactions that do manage to get included in a generated block.So, what should you do if you had a fantastic scheme for doing something fabulous with bitcoin that relied on the ability to generate nonstandard transactions?1. Implement your fantastic new features.2. Run it on the testnet to test it out.  You can pretty easily generate blocks there, and, as said above, peers will accept your nonstandard transactions in blocks that you generate.3. Convince the rest of us that your idea is great-- or, at least, convince a good percentage of the bitcoin-generating nodes that your idea is great. Yes.The getaccountaddress method will return the same address until it is used (until a payment is received on that address).But getnewaddress always creates, stores, and returns a new address. My private gpg key is kept in my LastPass Vault (as a secure note), along with all of my passwords.I'm a big fan of LastPass; Steve Gibson did a good review of their tech and why it's safe on a Security Now podcast a while back. My automatic backup strategy is:Cron task that runs a shell script twice a day.The shell script does:call bitcoind backupwallet to create a time/date-stamped wallet filegpg encrypt the wallet with my public keycopy the result to an off-machine backup location (I'm using Amazon S3, which is itself redundantly backed up to multiple geographic locations automatically)Shell script looks like:Code:#!/usr/bin/env bashGPGU="Gavin Andresen"TS=$(date "+%Y%m%d-%H-%M")WALLET=/tmp/clearcoinwallet${TS}WALLET_E=/tmp/clearcoinwallet${TS}.crypt~/bin/bitcoind backupwallet $WALLET/usr/bin/gpg -r "$GPGU" --output $WALLET_E --encrypt $WALLET~/bin/s3cmd put $WALLET_E s3://NAME_OF_MY_S3_BUCKETrm $WALLET $WALLET_EI'd suggest doing something similar (replace the s3cmd with an scp to copy somewhere if you're not an S3 user; you could even ftp somewhere, since the wallet is encrypted it doesn't matter if somebody is eavesdropping). Peer into my crystal ball with me as we predict the future....No, seriously, upward compatibility (reading old wallet.dat's into new versions of bitcoin) shouldn't be an issue.And Satoshi and I are discussing possible fixes for the upgrade/downgrade/upgrade scenario that we think is causing this. genjix, you're the third person to run into this problem; I'm looking into it.I suspect the problem is running a later svn version and then running the same wallet with an earlier svn version; the format of wallet transactions changed recently to support the 'accounts' feature.Your bitcoins are still safe in the wallet (all the private keys are still in there).  Stay tuned... Nope, the hard parts aren't parsing the bitcoin: url string (or the file), and once parsed the same code could do the actual request.The hard part:  what happens if I click on a pay-using-bitcoin link and I don't happen to have bitcoin running right now?The browser or OS runs bitcoin and hands it the payment request info.The bitcoin process checks to see if there is already another bitcoin process running.Nope.  Ok, load the wallet.  And then wait until we're caught up fetching the block chain that we missed while we weren't running.  Gotta do that because some of the transactions in my wallet might have been spent (if you copied your wallet somewhere), or you might have received payments while bitcoin wasn't running.And so N minutes after clicking bitcoin is FINALLY ready to send payment.  If N is greater than 1, then that really sucks!---------------I like click-to-pay, and I want it to work; it would work well now for the "I'm running bitcoin and connected to the network 24/7" use case.  But I don't think that will be the common use case (most people probably won't bother generating).So I think we've got to figure out some clever way of making click-to-pay quick-- maybe ask for payment permission and then have bitcoin chug away in the background, popup an alert if there's some problem paying, or just shut itself down after it's caught up with the block chain and has submitted the payment.  Or, assuming you have enough coins in your wallet, maybe just throw the transaction onto the network and let peers tell you if you're accidentally double-spending (that makes me very nervous, though).  Or... I've been lobbying for the mimetype solution.I did a little mockup a while ago of what happens if you click on a link and do NOT have bitcoin installed (which, in my opinion, is the most important case):http://skypaint.com/btcpay/mimepay.html I just checked in a minor bug fix / cleanup.The bug:  boolean options/flags were being treated inconsistently.  If you specified -gen=0, that meant (and still means) "do not generate."  But specifying -testnet=0 did the opposite of what you might expect.Now all boolean flags behave the same way; for example: -gen  : means generate -gen=1  (or gen=1 in bitcoin.conf): means generate -gen=0  (or gen=0 in bitcoin.conf): means do not generate... and if you don't specify the option at all, that means "don't."Check your bitcoin.conf file!  If you are using anything beside "0" and "1" for boolean options, you need to change.  I had:Code:rpcssl=true   # THIS IS WRONG!... in one of my bitcoin.conf files.  The correct syntax is rpcssl=1 Bitcoin contains this magical little piece of code:Code:int64 GetBlockValue(int nHeight, int64 nFees){    int64 nSubsidy = 50 * COIN;    // Subsidy is cut in half every 4 years                                                                                                                                          nSubsidy >>= (nHeight / 210000);    return nSubsidy + nFees;}If you try to create more than GetBlockValue coins (50, right now) when you get lucky and generate a block, all the other clients will reject it.There are a bunch of other checks to prevent cheating (make sure you actually did the work to find a valid hash for the block, make sure all the transactions in the block are valid, etc), but that simple little piece of code is what restricts the supply. I'm mostly libertarian, although I'm sure the more pure libertarians here would call me a fuzzy-headed socialist.Anyway, for seatbelts:Be careful comparing rich, Western countries to poorer countries.  As we get richer we value personal safety more, so we demand things like seat belts and air bags in our cars.I believe that our politicians see that demand, then jump on the bandwagon and pass laws that basically everybody thinks are a Good Idea, and then take credit for making us safer.I'm not 100% certain that is true for seatbelts; I haven't actually looked at the graph of traffic fatalities over time, to see if there is a bend in the curve when seatbelt legislation is passed.For smoking:  we shouldn't be allowed to do things that hurt, or have a "reasonable" chance to hurt, other people.  Personally, I waffle back and forth over whether second-hand smoke imposes an unreasonable chance of harm on others.I've looked at the evidence, and it seems that only people exposed to repeated, long-term secondhand smoke have an increased risk of death.  Like spouses or children of smokers.  And the smoking bans NEVER apply to private residences.  So again, I think politicians may just be jumping on the bandwagon and passing feel-good laws that do no good (although in the last couple of days I read that it looks like grotesque images on cigarette packs ARE measurably effective at reducing smoking).For vaccinations:  "herd immunity" from vaccinations is a true "public good,"  in the strict economic definition of "public good."  I think it is fine and dandy for the government to provide true public goods, either directly or (usually better) by supporting/subsidizing private industry.  Follow this link for a reasonable, very-smart, mostly-libertarian perspective on public goods. The JSON-API wiki page describes all the methods:  http://www.bitcoin.org/wiki/doku.php?id=apiThe wiki needs a good re-organization; anybody want to volunteer to revamp the Start page?RE: comment and comment-to :  they're stored in your wallet along with the transaction, but not sent over the network.  The new gettransaction and listtransactions methods will return them (as "message" and "to"). Excessive, lazy quoting (like this message!) should also be discouraged. I wrote this three years ago, and I'd still like to see something like it implemented.  Now we've got Bitcoin, implementing it might be much easier; I'd love to see a bitcoin bbs/forum that uses these ideas to reward thoughtful, high-quality discussion  (replace "email list" everywhere below with "discussion forum" and I think it all still works):I was listening to "The Ethics of Liberty" yesterday, and it got me thinking about email lists.Most email discussion lists seem to suffer from a Tragedy of the Commons-- there's not a whole lot of motivation for people posting their opinions to think twice about spouting off, or going on and on and on, or otherwise polluting the list with stuff that the subscribers to the list might consider junk.There are a couple of solutions to these kinds of problems. You can try to set up some kind of policing system, with trusted moderators given the power to bless posts, ban people, etc. You need really thick-skinned, generous-hearted, even-tempered moderators for that to work.A solution that works in the real world that hasn't been tried for the email mailing list problem (as far as I know) is some kind of economic system, where the common resource is given a value and anybody wanting to use the resource must pay rent (which is then used to maintain the resource).So, here's a thumbnail sketch of how this might work for an email mailing list:Create an artificial currency. If you have enough of this currency, you're allowed to post messages to the list. Longer posts cost more than shorter posts.Everybody starts with some amount of this currency. Everybody is allowed to use it themselves, give it away, or sell it (for real money!) to people who want to use it to post messages.Every message posted includes ways of:- Tagging the message as "Worthwhile" --> transfers currency from your account to the poster's account.- Tagging the message as "Waste of my Time" --> transfers currency from poster's account to the common pool of currency.The amount of currency in the system is tied to the desired message traffic. We all have a limited attention span; basically, the trick will be to create an artificial economy so that the people who contribute positively are encouraged to contribute more, and people who "pollute" are punished.Currency goes into the system every day (again, based on desired message traffic per day). Some is assigned to new people signing up for the list, and the rest evenly distributed to everybody already on the list."Lurkers" on the list could either hoard their currency, offer to sell it, or give it away to people from whom they want to hear more. Y2K was a non-event exactly because it was predictable and so lots of people did lots of work to make sure nothing terribly bad happened.My point is only that the block #210,000 switchover will, I think, be exactly the same.  An entirely predictable event that people will plan and prepare for.  It will be a significant event only for the very small minority of people who have to do the planning and preparing.RE: complacency:  I think we're a lot better at getting complacent about random events (like earthquakes and hurricanes) than "this is absolutely 100% certain to happen on or around this date" events. You can continue to use accounts as labels, create an each-address-gets-one-label, and map addresses-->user in your database.However, your application will be faster and simpler if you let bitcoin do the addresses-->user mapping (one account per user), and store address-->user-specified-label in your database.The bitcoin 'getaddressesbyaccount' method will give you the addresses-->user relationship, and all the accounting becomes much easier (listtransactions gets you all the transactions associated with a particular user, etc).The label methods still work, call the corresponding account methods (e.g. call setlabel <bitcoinaddress> and it calls setaccount), but are deprecated, so they don't show up in the help and will eventually be removed.The only 'potentially breaking change' is the sendtoaddress function, which now returns a transaction id instead of the word 'sent'. I just browsed back through the git commit history, and I don't see any interim commits of the account code (I was working in local branches, and didn't push interim versions up).davout: You should try dumping your wallet using the latest bitcointools (dbdump.py --wallet), it will tell you if it finds weird key values in there.
The "accounts" feature (to replace "labels") is done for now:  listtransactions and gettransaction are implemented, and move, sendfrom, and getbalance <account> are enabled.This should make implementing web services much easier; you can assign each customer their own 'account' and rely on bitcoin to keep track of exactly how many bitcoins they have, have it return a list of the customer's last N transactions, etc.This is a minimal implementation on purpose-- for example, gettransaction doesn't return every possible bit of information you might want to know about a transaction, and will only return information for transactions in your own wallet.  We are trying to think ahead and not add features that will be broken or taken away when bitcoin supports running in a 'lightweight client' mode, without access to the entire bitcoin transaction history.I've updated the API wiki page with the new methods. I agree with FreeMoney.I think that as long as the generation reward is predictable there will be essentially no problems; people are smart, and will plan ahead.  I predict the 100 blocks after the generation reward gets cut to 25BTC will be generated in the same time as the 100 block generated before the reward cut, within, oh (pulling a number out of my ear) 20% plus or minus.I'm reminded of the Y2K hype back in 2000; that was a predictable event that turned out to be a non-event. ... and the person you hand the keys to will have to trust that you didn't keep a copy of them (or if you did, that you won't spend them before they do). I grabbed the "Digital Coin Technology" pdf file.It looks to me like it fails in the second paragraph:If the DigitalCoin software can read the serial number, then so can other software.  It is simply not true that "The DigitalCoin software alone can ..."Either you have a central server running the DigitalCoin software and you have to trust that the people running that server won't double-spend DigitalCoins.Or... you have Bitcoin, where the "serial numbers" are the public keys of coin generation transactions. From the previous thread:Implementing something that won't even work on our own forums would be a bad idea, in my humble opinion. I haven't tested my 'master' bitcoin-git branch in a while, I wouldn't be surprised if the new 'accounts' code in the subversion tree broke something.Which not-in-subversion features are you using? I saw a version of this at a presentation of a local "time dollars" group... and I think their arguments go wrong at a couple of places.First, wealth creation is limitless (we continue inventing more efficient ways of doing things and new things to spend our time and money on), so it's simply not true that an ever-increasing money supply (created via debt) is unsustainable.  If there was some way of pegging the creation of the 'right' amount of money to the overall amount of wealth being created, then we'd get stable prices and the 'right' level of investment.And second, the argument is that the system is stacked against the borrower-- that it is designed so that there's never enough money for everybody to pay off their debts.  So if I WANT to pay back my debt, I'll find out there's a money shortage, and I won't be able to.That ignores the fact that I can walk away from my debts via bankruptcy.  And the fact that many loans are secured with some form of collateral, which lenders accept in lieu of cash.  Borrowing/lending is not an entirely closed system, and, ideally, lenders have to be smart and fund borrowers who are creating real wealth. So... 8 years ago some bittorrent folks came up with the magnet: URI scheme.And yet I don't run across many magnet links as I browse the web.As I browse the web I run into exactly three URI schemes:  http, https, and mailto.I think a bitcoin mime type will be easier to implement and is likely to be more successful. MrFlibble:  "Fair" is one set of coins (however many the Faucet is giving out at the time-- hopefully, bitcoins will continue to become more valuable, and I'll give out fewer over time...) per person.I like the postcard idea, although I'm not willing to type in bitcoin addresses written on postcards!Hmm... any stamp collectors here?  Paying people bitcoins to send you postcards (with stamps on them) might be really fun...And re: using OpenID instead of a Google Account:  that'd be easy to implement, but way too easy for cheaters (who can just be their own OpenID provider and give themselves as many OpenIDs as they want). Designing and implementing user-friendly wallet backup for the GUI bitcoin seems like it would be a great little project for somebody who knows C++ and knows, or is willing to learn, wxWidgets programming.  The non-GUI code already has the 'backupwallet' RPC method, and 'getinfo' will tell you the age of the oldest key in your keypool.For extra credit, the code could keep track of the last successful backup and warn you that it is time to backup again when the keypool age gets close to the last backup time. What error did you get, farmer_boy?  The only errors I see in the server's logs are "rate limit" errors.The Faucet tries hard to prevent people from cheating and using it more than once; unfortunately, that means if somebody who "looks like you" uses the Faucet before you, you might be prevented from getting your coins.   If that happens, try again a day later.I've been thinking about implementing a two-tiered Faucet:  one that gives out a smaller number of coins and just requires you solve the CAPTCHA (and has all the current anti-cheating measures in place; there are one or two people still people cheating, but they're only able to get a few bit-pennies an hour, and they're going through an amazing amount of trouble to do it).And another that gives out a larger number of coins if you login with a valid Google account.   Getting tens or hundreds of Google accounts is harder than solving CAPTCHAS.But if I did do that... I'd get accused of implementing the Faucet as a sneaky way of stealing Google account email addresses.Sigh. As a veteran of the premature standardization trenches (I wrote most of the ISO/IEC 14772-1 "VRML97" specification before I changed my last name from "Bell" to "Andresen")... I agree with foreverdamaged.  It is too early to try to create a formal specification.However, it think writing informal specifications documenting how bitcoin works right now is a great idea, and will be really helpful when it is time to go through some standardization process. There never was a way to place labels on a per-transaction basis.  It was always a one-label-to-multiple-bitcoin-addresses association.But all of the old label functionality is still there, just renamed.  You should be able to do anything you were doing before.However, you might think you were doing something that you weren't actually doing.  There was no way to label/name particular transactions before (just addresses).RE: the empty string as the default account:   None of this is (or will be) visible to GUI users, and if you're a programmer using the JSON or the command-line interface SURELY you know how to quote strings.RE: hierarchical wallet keys:  Huh?  If you want trivial searching and grouping... then export the info into a database and use SQL. The "" (empty-string-named) account is allowed to have a negative balance.  You can sendtoaddress as long as the entire wallet has enough coins.Accounts (like labels before them) are just a useful accounting mechanism.  The rest of the network doesn't know or care what accounts you have.  And although transactions to and from the wallet are credited or debited to accounts, all of the 'coins' get mixed together in the wallet, there is no notion of "this account received 100 bitcoins in this transaction, so we should use those for that transaction out..."For example:100 bitcoins are sent to an address associated with Account A.  A's balance is now +100.50 bitcoins are sent to an address associated with B.  B's balance is now +50.100 are moved from A to B. A has zero, B has 150.B is allowed to send 150, but it won't necessarily be the 100 originally sent to A and the 50 sent to B; if other accounts have received coins (transactions), those might be sent instead.bitcoin doesn't care (use any valid JSON string for the name), and the rest of the network doesn't care, so use account names that make sense for your application. The send methods don't try to be clever; they always broadcast transactions.If you want that behavior, be clever yourself:  call  getaccount <bitcoinaddress>  before calling send, and then call move instead of send* if you find out the bitcoinaddress is one of yours. I just committed a minimal implementation of "accounts", as discussed a few weeks ago in this thread.If you're using the command-line or JSON APIs, you should be aware of a change that might make your code break:  the sendtoaddress method will return a hexadecimal transaction id (256-bit hash) instead of the string 'sent'.All of the 'label' commands have been renamed; the old names are still supported but are deprecated and may eventually be removed.If you're developing a web service using bitcoin, the new 'sendfrom' and 'move' methods can make it much easier to keep track of customer account balances.  The API is intended to be used like this:Create a new account:  just generate a unique account ID in your application (maybe customer's login name).Get a bitcoin receiving address associated with the account:  getaccountaddress <account_id> Note: multiple bitcoin addresses can be associated with the accountSend bitcoins from the customer's account:  sendfrom <fromaccount> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to] Will fail if <fromaccount> doesn't have enough bitcoins (otherwise returns transaction id)Move bitcoins between accounts:  move <fromaccount> <toaccount> <amount> [minconf=1] [comment] Will fail if <fromaccount> doesn't have enough bitcoinsReport account balance:  getbalance [account] [minconf=1]The empty-string account is a little bit special.  Any coins received on bitcoin addresses not associated with other accounts is credited to it, and coins sent via the (old) sendtoaddress method are debited from it.Coming soon, I hope, will be a gettransaction <txid> method to return details of a transaction that is stored in your wallet (like which account it was to or from and whether or not transaction fees were paid).  And listtransactions, to get an accountant-friendly itemized list of all the transactions that went into any particular account balance. I worry that the correct analogy is:Typing a password every time you use your bitcoin wallet is like putting padding your car's steering wheel instead of wearing a seatbelt.  It might make you feel safer, but it is a false sense of security.Good security is hard.  If you're not computer savvy, then you've probably already got spyware and trojans on your system, and running bitcoin on a system infested with spyware and trojans is a bad idea.  Period.I think an online service that takes care of wallet security for you is a much better solution for non-geeks like my mom.All that said:  As my personal bitcoin wallet gets more valuable, I get more nervous.  I would like to be able to export some of the value in my wallet onto a USB thumb drive and then put that thumb drive in my safe deposit box (along with a backup, gpg-encrypted copy that I'd keep in the fire safe in my basement).Another analogy:  I keep most of my money in the bank; I don't have piles of cash or gold in my house.  I will do the same for my bitcoins, keeping only enough in my online, connected, possible-to-hack wallet to use day-to-day. Wasn't me.  I don't remember Satoshi ever writing something like that, but I'm really good at forgetting things.I agree with ribuck, if we ever need more than 21quadrillion bit-atoms, encoding more using the unused high bits in the 64-bit number will work nicely.That would be a very nice problem to have. The keypool IS used for coin-generation transactions.And the way it is implemented, it should never throw away keys.  If I recall correctly, there is a very small chance if you lose power or bitcoin crashes a key from the keypool could be used twice.  But that has no bad effects, it is just very unusual. Everybody is looking for:h = f(x), where h < TARGETI think you're asking if there is some weakness in SHA256 (or hashing in general) that can make solving that problem trivial.It seems unlikely to me, but I'm not a professional cryptographer.  If TARGET were '4', then the problem is equivalent to:h = f(x) where h = 0 OR h=1 OR h=2 OR h=3Maybe there's some tricky method that reuses work and makes solving the TARGET=4 case more than 4 times easier than solving for TARGET=1 (which is "find this specific hash")... but I just don't see that doing anything more than what has already been pointed out in previous posts:  it is just a quicker way of hashing, so difficulty would go up.
Good article!And good job jgarzik on answering questions! daveout's code isn't quite right (because he based it on an earlier version of my python code).Corrected version of the python code is in this thread. Bitcoins are 50 times more valuable today than when I first heard about them six months ago.  If they just double in the next six months, they'll have risen 100-fold in a year.It seems like a good idea to me to come to a consensus now about when to "move the decimal points" -- when should the Bitcoin program allow you to specify payments with more than two decimal places (e.g. "pay Gavin 0.001 BTC for his thoughts") ?When should the Bitcoin program assume you're entering payments in 'millicoins' or 'microcoins' ?And when should all of the internal minimums (e.g. smallest transaction fee or the trigger for the 'micro-transaction spam prevention') be lowered?Here's a straw-man off the top of my head:When Bitcoins are worth more than about ten dollars (or euros) each, I think it'll be time to allow sub-bit-penny payments.  And I think the "smallest free transaction" limit (and other internal minimums) should move in lock-step with that change.When 1 Bitcoin is worth somewhere around $100 (in 2010 dollars), I think it'll be time for the client to switch to millicoins (e.g. .001 BTC), so if I'm buying a paperback book it costs 50 milliBTC  instead of  .05 BTC. It'd been a while since I shot myself in my foot, so I guess I was overdue.Anyhow, on my third attempt I think I've got it right-- I fixed a bug that was causing Bitcoin to be unusably slow on Macs running FileVault (the built-in filesystem encryption on the Mac).The problem was Bitcoin opening and then closing the debug.log file on every write.  After a couple of "too clever for my own good" solutions that broke, or could break, in interesting ways, the code now opens debug.log and simply keeps it open, constantly appending to it.If you run a bitcoind server, see the "don't forget to rotate your logs" thread for what you need to do for log rotation to work properly. I just committed a change to svn to the way debug.log is written that means you need to change your logrotate configuration.Why the change:  before, bitcoin was opening and closing debug.log on every print.  That caused it to be unusable on Macs running FileVault (and slower than it aught to be on various other systems).After subversion rev 183, bitcoin will keep debug.log open and just append to it.If you're rotating logs using the unix logrotate command, just add 'copytruncate' to its configuration file and the right thing will happen.  I changed the example in my post above. ShadowOfHarbringer:  don't be lazy!  If you want to know if the lockins have been changed, it is easy to find out for yourself.The blockchain checkpoints are in file main.cpp, around line 1,519:Code:    // Check that the block chain matches the known block chain up to a checkpoint                                                                            if (!fTestNet)        if ((nHeight == 11111 && hash != uint256("0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d")) ||            (nHeight == 33333 && hash != uint256("0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6")) ||            (nHeight == 68555 && hash != uint256("0x00000000001e1b4903550a0b96e9a9405c8a95f387162e4944e8d9fbe501cd6a")) ||            (nHeight == 70567 && hash != uint256("0x00000000006a49b14bcf27462068f1264c961f11fa2e0eddd2be0791e1d4124a")) ||            (nHeight == 74000 && hash != uint256("0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20")))            return error("AcceptBlock() : rejected by checkpoint lockin at %d", nHeight);Even if you don't know C++ or don't know how to use subversion, you can check every release here: http://bitcoin.svn.sourceforge.net/viewvc/bitcoin/trunk/ Umm... how would they do that?If even one machine remained connected to both the MiB and the rest of the network, then there will be no split.  Transactions and blocks will continue to flow between them.And if the MiB disconnect themselves from everybody else... then what they do has no effect on anybody else.If the MiB have more than 50% of the block generating power then they can set the rules as you describe (refuse to put transactions with fees into the block chain, etc).  If we didn't like it, we could write code that detected that they were "breaking the rules" (for example, we could reject generated blocks with no or very few free transactions, when we know there are old, free transactions waiting to go into a block), and work on our own "minority" chain.  Convince the merchants and exchanges to run our code instead of the MiB code and the MiB can go play with themselves, we'll all happily continue trading with each other on the minority chain. So....I want to register a new domain name "gavin.bitdns" in this hypothetical bitdns system.How do I do it?  Run a BitX miner and hope that I generate a block sometime in the next week or three?  Ummm... yuck!Or I want to buy a domain from somebody; what does that look like in the bitdns system? Bad idea until we have secure DNS (DNSSEC) everywhere.And maybe even a bad idea then; one slip of the fingers and your bitcoins might go to amazone.com instead of amazon.com. How could I forget good old Berkeley DB?  So old its approach (schemaless key-value store) is back in fashion...So: FOUR other open source projects.  Berkeley DB is also 100% open source. I'm a "bleeding heart libertarian."  When I was young and naive I was "progressive/liberal," but now that I'm old and wise (or maybe just more cynical) I have a much greater respect for the positive incentives built-in to private markets, and the negative incentives built-in to government.So I'm very sympathetic to the "it isn't fair that people with the fastest/most GPUs generate more bitcoins" point of view.I agree that it would be more fair if every person started with an equal number of bitcoins.  Work harder than average or provide a service that people value and you'd end up with more than you started with.  Otherwise, you'd get bitcoin poor.But I don't see a way to do that without some central authority deciding who is, and who is not, a 'person'.  And I'm old and cynical enough to think that if there WAS a central authority making that decision, that central authority would very quickly devolve into a corrupt, favor-granting, power-grabbing institution."Oh, I'm sorry Mr. Andresen, for the Good of the System we are delaying the granting of your second child's Bitcoin Bounty until they have completed the mandatory consumer education classes, registered to vote, and have completed the voluntary 250 hours of America Freedom:Works! projects that they were assigned."If you've got a brilliant, fool-proof, decentralized way of solving the identity problem, speak up!  That'd be an even bigger breakthrough than bitcoin. Probably against all of the credit card companies' terms of service; they don't like you taking money before "shipping the product." Relevant threads from the past:  http://bitcointalk.org/index.php?topic=227.0  http://bitcointalk.org/index.php?topic=1494.0I think a fully licensed online bitcoin exchange to/from US dollars via online credit card transactions (or another really quick, convenient mechanism) is critically needed.Is it worth attempting:  I've been very tempted!  Unfortunately, to do it right and jump through all the legal hoops would require at least posting a $50,000 bond and probably thousands, possibly tens-of-thousands of dollars to hire lawyers to get all the paperwork in order.And then I'd have to figure out how to accept credit card payments for bitcoins in a way that didn't open me up to massive fraud (maybe secondary approval via a phone call or text message).  And convince a merchant account provider that I'd solved that problem and that I was trustworthy (which probably means another infusion of tens of thousands of dollars to cover potential fraud).I think it is a great opportunity for somebody (or some company) who has had prior experience in the currency exchange business.  The business model is clear and proven, and being the first fully licensed bitcoin exchange would have huge potential benefits if Bitcoin turns out to be a really successful. All great ideas that I'm confident will eventually happen... assuming Bitcoin doesn't crash and burn for some reason (yes, I'm working hard on a technology I think has about a 30% chance will be made illegal or won't be "better enough" than alternatives to catch on or will overtaken by something even better or will have its peer-to-peer network overwhelmed with jerks mounting denial-of-service-attacks or will crash and burn for some reason I haven't thought of yet).The "URL shortener" for stock Bitcoin would need to be a plug-in, where you give it one or more websites that provide URL shortening services (to get bitcoin addresses for email addresses or phone numbers or social security numbers (ok, SS#'s would be a bad idea)).  I don't think stock Bitcoin should or could do that, because that service means maintaining a centralized database, and trusting whoever runs that database not to suddenly, one day, decide to redirect all the bitcoins to themself and then retire to Bermuda.  (or trust them not to get hacked so hackers get all those coffee-shop payments...)That'd be another good, standalone project for a good C++ programmer who wanted to do some Bitcoin-related programming...I think the next big step for Bitcoin is a "lightweight client" that doesn't rely on a constant connection to the Bitcoin network, doesn't store the entire block chain, and doesn't try to generate blocks. It is 100% open source.  Bitcoin relies on three other open source projects-- wxWidgets (for the user interface), Boost (for geeky C++ stuff), and OpenSSL (for cryptographic stuff).  Those are all also 100% open source.Improving The Fine Manual (and the website) will be an ongoing project; thanks for your questions. I agree that there is a lot of work to be done on the documentation front.  Like most open source projects, most of us developers find writing code more fun than writing documentation or marketing material.Satoshi is the main developer and person most in control of bitcoin (as said above).  I've been the second-most active developer over the last month or so.PS:  if you have the time and feel like helping out... most of the documentation is in the Wiki, which anybody can edit.  And constructive, specific suggestions for making the main bitcoin.org web page better are welcome, too. With davidonpda's help, I did some testing myself today with Satoshi's latest code changes (setting priority based on transaction age, bitcoin amounts in, and total transaction size in bytes -- svn rev 176).It behaved as expected, putting larger, older transactions ahead of the pennies being flooded into the network, so "normal" transactions will be confirmed promptly even if somebody decides to be a jerk and floods the network with transactions. Computers could get 1 billion times faster and Bitcoin's hashing and elliptic curve digital signatures will still be "safe."2^256 is a really, really big number.2^226 is also a really, really big number.  It is a billion times smaller than 2^256, but still far and away big enough.Even 2^160 (the size of the bitcoin address hash) is big enough.Back-of-the-envelope:Lets say computers in a few years can do a quadrillion hashes per second-- that's about 2^50 hashes/second.  How many seconds to find a SHA-256 hash collision?  2^205 seconds.  That is much longer than the age of the universe.How long to find a bitcoin address hash collision?  2^130 seconds, which is 43,161,132,283,224,056,755,882,116,619,960 years.  Also much, much longer than the age of the universe.(actually, those numbers are the MAXIMUM time.  Divide by two for the average time.  Insanely big divided by two is still insanely big.)You should be worried that some weakness in SHA-256 is found that allows hashes to be cracked other than by brute-force.  And if you're worried about that, then it is dumb to switch to SHA-512 now-- perhaps a flaw will be found in the entire SHA* family of hashing algorithms. If there's a c++ programmer out there looking for a good "get me feet wet" project involving Bitcoin, I think importing/exporting public/private keypairs (in one of OpenSSL's file formats) would be a really good choice.The hard part is importing; you'd have to write code to re-scan the block chain to find transactions to/from the newly imported public/private keys, and add them to the wallet. No, you can't, because every time you send them they become "new", and the priority is age multiplied by amount:Code:// Priority is sum(valuein * age) / txsize  (valuein is the size of the bitcoin input, age is # of blocks deep, and txsize is the number of bytes the transaction takes up)Ummm... the more you mess around with the coins in your wallet, the newer they are, and the lower their priority (relative to everybody else who might want to get their transactions into the next block).  I haven't thought deeply about it, but I bet simply leaving your coins as they are and making change as necessary will work out best.  But please, create your own client and try to break things on the test network! I think it is WAY too early to nail all that down; bugs in that code caused changes just a few months ago.Just write the code, and when core bitcoin changes, be prepared to change your code.  For the specific case we're talking about, you don't need to know all the possible ways scriptSig satisfies scriptPubKey-- you just need to reverse engineer how the standard send-to-bitcoin-address works so you can sign your own send-to-bitcoin-address transactions.
The behind-the-firewall nodes will need the following from an on-the-network bitcoind:1. They need to be able to ask it "tell me about any transactions to these bitcoin addresses..."2. They need to be able to send it a signed transaction and ask "Please broadcast this for me."Item 1 is implemented in my monitorreceived patch ( https://github.com/gavinandresen/bitcoin-git/tree/monitorreceived ).Item 2 would be cool.  Anybody want to design and develop an "accept transaction" patch?All the other functionality needed (like generating public/private keys, generating and signing transactions) could be, and should be, in my opinion, be done as a project separate from bitcoin.  Making the code small and self-contained and as secure as possible would be the goal; it could be re-used to create a type of lightweight client that ran on cell phones in addition to running behind corporate firewalls. But again:  if that clear interface includes a command to "send XYZ bitcoins to some address", then how is the separation making you more secure? I agree-- we're in the Wild West days of open-source currency.  I expect people will get burned by scams, imitators, ponzi schemes and price bubbles..I tend not to worry about things that are out of my control; I don't think there's a whole lot that can be done about scammers, imitators, and ponzi schemes besides warning people to be careful with their money (whether dollars, euros or bitcoins). First: I've reviewed Bitcoin's networking code looking specifically for possible buffer overflow vulnerabilities, and found none.  It is possible I missed something; please help review the code and let me or Satoshi know if you find anything suspicious.Second: I don't think splitting the wallet handling code into a separate process will improve security at all.  If there is code that can send the nicely-compartmentalized wallet handling code a command "Send XYZ bitcoins to address 1ABC...", and that code has a buffer overflow vulnerability in it, then you are just as vulnerable as today.If your PC has been compromised, then you are in trouble; anything you do on your machine may be intercepted by a bad guy.  Log into your bank account website-- the bad guy might hijack your session and transfer money out.  Start up bitcoin-- the bad guy might inject keyboard and mouse events to send coins out.Even if Bitcoin implemented multi-factor authentication before allowing wallet access ("scan your fingerprint and enter your password to send coins"), if your PC is compromised a bad guy could arrange to modify the bitcoin address that you say you want to send coins to, so you think you're authenticating a payment to Wally's Discount Center but you really authenticate payment to Doctor Evil's Empire. The test network (run bitcoin with the -testnet flag) is a different block chain, implemented so that the two chains never get confused.  If anybody wants to start yet another block chain, it isn't technically hard, and won't cause any problems for "real bitcoin".The hard part would be getting anybody to use your alternative; it would have to be better in some way other than just "I started the new chain, so I've got a lot of the easy-to-generate-at-the-beginning-coins." Actually... prioritizing free transactions based on both amount and their "age" should make this attack toothless.The basic idea is that if you're spamming lots of small free transactions, you'll be creating lots of brand-new "pennies" (you'll take an old 50BTC generated transaction, then split off a penny and get a penny and 49.99 change.  Then split that 49.99 to get another penny, and so on and so on).Sorting pending free transactions so that larger-value transactions and free transactions with inputs deep in the block chain ("old money") are given priority would let normal transactions go through.The spammy transactions would still take up network bandwidth and disk space; if that becomes a problem, nodes could just ignore small, new transactions (not relay them) and let the nodes that are doing the spamming queue up and rebroadcast the transactions.  They'd trickle into the network eventually, and in the meantime the spammer's bit-pennies would be tied up. You already did. Hmmm....At some point (bitcoin 0.9?) debug.log should contain only really critical errors/warnings.  Right now it is more of a trace.log.Flushing it after every write is the correct thing to do-- otherwise critical information about what caused a crash could easily be lost.Always closing and re-opening it is darn convenient if you've got a log-rotating script running... but working poorly with FileVault is definitely a bug. That's not right-- the person paying you doesn't know your public key, they just know your bitcoin address (which is a 160-bit hash of your public key).You can (and I have) send bitcoins to ANY 160-bit bitcoin address, whether or not there actually is a public/private keypair corresponding to that address. If Satoshi goes rogue, then the project forks.  He has a very strong incentive (success of the project, growth of the value of the bitcoins he owns) not to do that.If the SVN repo gets hacked, then we back out the hacked changes (that's easy to see; several of us look at every svn commit) and warn people who might have compiled with bad source to recompile.I'm having trouble figuring out exactly what you would like to happen-- is your complaint that you have a different definition of what "open source, peer-to-peer" means than the rest of us? tentative: I don't get it.You seem to be saying that somebody might be secretly working on a longer block chain, and all their hard work will be ruined because they won't be able to replace the block chain everybody else is using non-secretly because the block chain everybody else is using might get locked in.   Ummm... yeah!  Don't work on longer block chains in secret.Either that, or you're saying Satoshi might accidently lock in a shorter block chain, and most people either not noticing or not caring.  Umm... no, I don't see that happening.The block chain lock-in check is only done when new blocks are accepted.  Here is what would happen if Satoshi tried to commit a block lock-in that most of the network thought was shorter:1. Imagine everybody downloads the new client with the bad lock-in.2. Everybody who had the longer chain before ignores the lock-in, and continues to push the longer chain.  (unless the longer chain contains a bad transaction-- the chain is checked for bad transactions on startup, see  CBlock::CheckBlock)3. Newbies who are downloading the chain for the first time will hit the lock-in code, and will be running with a shorter chain.There will be chaos as newbies generate blocks on the shorter chain, which only other newbies will accept.  "oldies" will also continue to generate on the longer chain.  Transactions will get added to both chains... and the "oldies" will beat Satoshi into submission.  Unless there is a legitimate bug (like the overflow bug that inspired the block chain lock-in code in the first place).If I am misunderstanding your concerns, please speak up.  The number one development priority for bitcoin is security.  If you have found a problem, please email or private-message Satoshi, or post here (besides possible network denial-of-service attacks-- only email about those if you have a brilliant idea for how to prevent them...). Ok, looks like two problems-- if rpcallowip=* works, then maybe bitcoin thinks your IP is something else (or maybe there is a bug in the bitcoin rpcallowip code).  Run this on the web server:Code:curl http://www.whatismyip.com/automation/n09230945.aspAs to why the PHP code isn't working-- can you turn on error_reporting and get more information on what isn't working? Does it work if you (temporarily) set rpcallowip=*  ?And are you SURE you're running a bitcoind that supports rpcallowip?  Run bitcoind getinfo, and check the "version" value returned (version 0.3.12 or later, if I'm reading the source correctly). If bitcoin thinks the connection is not allowed, then it just ignores the connection attempt-- nothing is written to debug.log.  That's probably the right thing to do-- otherwise somebody malicious could try to fill up your hard disk by repeatedly attempting to connect to port 8332.If you can recompile bitcoind, the "ClientAllowed" routine in rpc.cpp is where a printf() to log connections could go.  But I'd guess either you misspelled "rpcallowip" (I always type rcp instead of rpc...) or have a firewall blocking connections.If you can ssh into the web server machine (or any other machine, actually), try:  curl http://machine_or_ip:8332/If you get "couldn't connect to host" then it is a firewall problem.If you get "Empty reply from server" then it is an rpcallowip problem.If you get an HTTP "Authorization Required" or "Authorization Failed" reply, then it is a username/password mismatch (those ARE logged in debug.log, though-- grep for ThreadRPC). Looks good to me.Try to connect then look at the end of bitcoin's debug.log; see if it is even getting the connection.Also:  did you restart bitcoind after adding the rpcallowip?  The .conf file is only read at startup. Bitcoin: money For the People, By the People. Not the Elites.(eleven words-- eleven is my favorite number!) If you've got good crypto there's a fifth choice:5. Give them dummy keys that unlock something innocuous.Like a TrueCrypt-encrypted Hidden Volume filesystem. grondilu, I think your premise is flawed-- banishing the words "money" or "currency" will not help avoid future troubles with governments. I wonder if we have already passed the point where a user-typed-in-arbitrary-key can be both secure from brute-force attacks and convenient to use.If you make the key long enough to prevent brute-force try-every-possible-key attacks then typing it in gets really painful.You can add proof-of-work, but attackers tend to have lots of CPU power (think botnets) and lots of time, and if you make the proof-of-work take more than a few seconds per attempt on a low-CPU device it gets really painful again.I'm thinking some variation of wallet-on-a-USB-stick might be a more convenient and practical way of physically exchanging bitcoins.I wonder if Ebay would let you sell USB sticks pre-loaded with Bitcoin, a snapshot of the block chain, and a "starter wallet" with X bitcoins in it... RE: one mandatory account:  yes, the empty-string-named-account will be the "master" account.RE: existing use cases:  you should be able to do everything you can do now... EXCEPT for change the label of bitcoin address after it is created.  Although associating a unique transaction ID to a bitcoin address seems like the wrong thing to do (since the same bitcoin address might be re-used for multiple transactions; your application might not allow that, but the addresses are publicly available in the block chain and you might be opening yourself up to unpleasant hacks if you don't consider what should happen if an old bitcoin address that you THOUGHT would be used only once receives a few bit-pennies....)This morning I thought through what might happen in case of a disaster and a service using accounts had to restore from a wallet backup and some other, alternative source of transaction history (maybe application-specific transaction logs sent to an offsite logging server).Assuming your backup is recent enough for your keypoolsize, no bitcoins will be lost, but account balances will be wrong because any "move", "sendfrom", and associate-bitcoin-address-with-account actions will be lost.I've tweaked the proposed API to make recovery easier; I'm still thinking about "setlabel" -- in the recovery case, you definitely DO want to be able to re-associate bitcoin addresses with accounts...
Here's what could happen if somebody controls 50% of the nodes-that-are-accepting-connections:I join the network with a node behind a firewall (so I only connect out to 8 nodes).  I have a 1-in-256 chance that all my connections are to the cheater's nodes.If I am very unlucky and all of my connections ARE to cheater nodes, then they can:  + refuse to relay my transactions to the rest of the network  + refuse to send me new "block created" messages  + send me only the addresses of other cheater nodesThey could also send me a bogus version of the block chain (well, bogus back to the last compiled-in checkpoint), but that would be easy to detect (number of blocks in the chain would be different from what everybody else sees).They could NOT:  + modify/"damage" transactions  + hurt the vast majority of network nodes that have at least one connection to a non-cheaterI'm glossing over some details and possible attacks (e.g. if the attacker can hijack my internet connections -- maybe I'm using a wireless network at a cafe -- then I'm screwed because they can just redirect all of my connections to cheaters).The bottom line is:  make sure you have the right number of blocks (bitcoinwatch.com, for one, will tell you the block count). Don't do financial transactions on untrusted networks. And if your transactions don't go through after half an hour, restart bitcoin to connect to a new set of peers. Is your Library/Application Data/ directory on a network-mounted volume?Running bitcoin 0.3.13 on my OSX 10.6.4 Mac I'm not seeing any issues (it uses almost zero CPU when it is not generating, and 100%, but nice'ed, when it is).  I don't see any DirectoryService CPU usage.From what you've said, it looks like disk writes are chewing up lots of CPU time for some odd reason. An impromptu brainstorm this morning in IRC chat (thanks everybody!) helped me think through a few issues for an "accounts" API.The big idea:Replace the JSON-RPC "label" API with the notion of "accounts".What is broken about the current API? + you can't get a list of all transactions that make up an account's balance + if your bitcoin service has the notion of maintaining a balance for multiple   customers then you end up mirroring information stored in the bitcoin wallet database.   Mirroring is a problem because if the connection between your service and bitcoin   fails at the wrong time (e.g. between sending a "sendtoaddress" and getting   back "sent") your database can be out of sync with the bitcoin reality.Problems this proposal does NOT tackle: + multiple "wallets" for GUI bitcoin users + improving anonymity by keeping "coins" from different people in different "wallets" + "push" notifications from bitcoin when coins are received (or blocks generated)NEW METHODS:------------getaccountaddress <account>move <fromaccount> <toaccount> <amount>sendfrom <account> <tobitcoinaddress> <amount> [minconf=1] [comment] [comment-to]listtransactions <account> [minconf=1] [count=10] [start=0]CHANGES TO EXISTING METHODS:----------------------------getbalance [account] [minconf=1]listreceivedbyaddress:  return "account" instead of "label" in JSON-RPC resultsendtoaddress:  same API, but debits accounts as described belowMETHODS RENAMED:----------------setlabel --> setaccountgetlabel --> getaccountfromaddressgetaddressesbylabel -> getaddressesbyaccountgetreceivedbylabel -> getreceivedbyaccountlistreceivedbylabel -> listreceivedbyaccount  ... returns "account" instead of "label" in resultMETHODS REMOVED (deprecated):-----------------------------setlabelNOTES:------All existing routines would continue to be supported for a while (e.g. listreceivedbylabel would be kept as a synonym for listreceivedbyaccount, and would return both "account" and "label" in the JSON result).Coins going into or out of the wallet that don't have an associated account will be associated with a default account (named the empty string: ""). So sum(account balances) will always equal server account balance.Generated coins will be assigned to the default account when they mature.sendtoaddress, and the GUI "send" button, will debit accounts starting with the default account (if it has a non-zero balance) and continuing in alphabetical (ascii) order.the default address, which will be allowed to go negative.None of these changes will be visible in the graphical user interface. These changes are for people running bitcoind to support bitcoin-related services, not for end-users.It would be nice to support transactions by batching up several commmands and ensuring that they either all succeed or all fail.  But: this should be useful even without that feature.  The cleanest way of doing that is JSON-RPC-2.0 "batch send", and that all can come in a later version.Why remove setlabel?  Because it is not clear what "setaccount <bitcoinaddrress>" means for old transactions that were received on that address-- do they remain credited to the old account (confusing!) or does history get rewritten so they are credited to the new account (your accountant/auditor will surely protest!).UPDATE: svn rev 188 implements most of this (all but gettransactions).  And due to the disaster recovery scenario described below, 'setlabel' stays as 'setaccount'. I like the Bitcoin = ... ideas.   Focus on the WHY, not the what or the how:   http://www.ted.com/talks/view/id/848 If you're running something like mybitcoin or mtgox or any other site that lets customers keep bitcoins in accounts, then one-customer-per-bitcoin-process isn't at all practical.  To start with, every bitcoin process has a complete copy of the block chain... I spent way too many hours yesterday trying to figure out why my Google App Engine code couldn't urlfetch from my -rpcssl bitcoin process, so I'm posting this to hopefully save somebody else from the frustration.I made Bitcoin's HTTPS-JSON-RPC code fussy about what openssl ciphers it supports on purpose; by default, it doesn't accept SSLV1 connections or older, weaker ciphers or hashing algorithms (like single-DES and MD5).Surprisingly, Google's App Engine urlfetch service currently ONLY supports RC4/DES/MD5/SHA, so, by default, App Engine can't talk via https to Bitcoin.  The workaround is easy (use the -rpcsslciphers= option to override the ciphers bitcoin will accept), and I'll document this on the rpcssl wiki page.And hopefully Google will get with the program and support better encryption... svn rev 172 (bitcoin 0.3.14.01) adds:"testnet" and "keypoololdest" to getinfo output.  testnet will be true if you are running on the test network.keypoololdest is the Unix timestamp of the oldest entry in the keypool.For example:Code:./bitcoind getinfo{    "version" : 31401,    "balance" : 100.63000000,    "blocks" : 86925,    "connections" : 1,    "proxy" : "",    "generate" : true,    "genproclimit" : 1,    "difficulty" : 2149.02181495,    "hashespersec" : 998425,    "testnet" : false,    "keypoololdest" : 1286757166,    "errors" : ""}I also made bitcoin return proper HTTP Date: headers to better follow the HTTP spec. Dhaw generated all of these coins on his (her?) own machines.Unfortunately, either due to a bug or some oddness with Dhaw's network connections they were all generated on an alternate block chain.The Bitcoin client really shouldn't allow coin generation until you have all of the blocks up to the last block checkpoint. I suspect (but am far from certain) that a couple of psychological factors in the average human mind makes deflation worse than inflation.First, we've got an irrational attachment to "free" (see the book Predictably Irrational for experiments that show this).  If money is deflating, I can just let it sit under my mattress for "free" -- and that might be more attractive to me even though I'd get a better return by investing it.  Investing ALWAYS looks like it costs something (brokerage commissions or lawyers fees or...).And second, we've got an irrational aversion to loss and an irrational attachment to stuff that we own.  Investment means opening yourself up to the possiblity of loss AND lending out something you own; I think a little bit of inflation helps overcome that irrationality, by building in a little loss if you stick your money under your mattress.I wonder if somebody could devise a small-scale experiment to figure out if deflation is bad for investment, and/or measure the size of the effect... RE: payment:If you really feel compelled to pay, send coins to the Faucet: 15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC I implemented "validateaddress" in svn r169:$ ./bitcoind validateaddress '1P3rpbSybuGgeL1bRwCJFWbn4yBjRNQrbY'{    "isvalid" : true,    "address" : "1P3rpbSybuGgeL1bRwCJFWbn4yBjRNQrbY",    "ismine" : true}$ ./bitcoind validateaddress '1111111111111111111114oLvT2'{    "isvalid" : true,    "address" : "1111111111111111111114oLvT2",    "ismine" : false}$ ./bitcoind validateaddress 'mwFzbfqePwXUyT28e1kFVVh48uMHDsRzbi'{    "isvalid" : false}No address version number; that wasn't trivial to do, so I didn't do it. Awww, even replacing the lower-case-l's with 1's it ain't right:Code:$ bitcoind validateaddress I11Send1000BTCtoWhoEvrMakesDisAddr{    "isvalid" : false} Ruby (or your Ruby JSON-RPC library) isn't setting the Authorization: HTTP header from the username:password in the URL.I don't know anything about Ruby, but Mr. Google might be able to shed some light-- you need to either set the Authorization: header yourself to do the HTTP Basic authentication (I seem to recall some Ruby code on the Wikipedia page about HTTP Basic Authentication) or, in some languages/frameworks there's a way of setting up a 'context' for HTTP connections so the authentication happens properly. Thanks theymos!  I completely missed the leading-zero-bytes become leading-'1'-chars one-for-one.I fixed the python code in the first message of this thread. RE: what's the use of b58_encode?  It is dead code for this use-- bitcointools (where I first implemented this stuff) uses it to translate from binary hash160 to human-readable bitcoin addresses.RE: 27 character bitcoin addresses:  I'm puzzled.  There's a mismatch between the way bitcoin treats leading zeros (leading 1's when base58 encoded) and the way my python code treats them.ByteCoin: have you dissected the bitcoin code enough to explain how it decides how many leading zeros to add?  According to my code, '14oLvT2' and '11111111111111111111111111114oLvT2' are the same bitcoin address (corresponding to the public key with a hash of all zero bytes).But bitcoin only likes the 27-character '1111111111111111111114oLvT2' version.I'll have to stare at the code some more tomorrow when I'm more awake. Bitcoin version 0.3.13.05 (svn revision 168) adds the -testnet option to bitcoin/bitcoind, for testing or experimentation with worthless bitcoins on the TEST payment network.This version is compatible with my old compile-time test network patch.  Stuff you aught to know as you run this:A -testnet bitcoin will use the same bitcoin.conf file as regular bitcoin (unless overridden with the -conf= switch).The -testnet data directory is a "testnet" subdirectory in the regular data directory.A -testnet bitcoin listens for connections on ports 8333/8332, just like regular bitcoin, so you cannot run both -testnet and regular bitcoin at the same time on one machine.You can get play bitcoins from the TEST faucet at https://freebitcoins.appspot.com/TEST/testnet bitcoin addresses will not work on the regular bitcoin network, so it is impossible to accidently try to send real bitcoins to test address.  However, regular bitcoin addresses are valid testnet addresses; it is possible to try to send testnet bitcoins to a regular bitcoin address (they will effectively be lost if you do that).This will be very useful for anybody creating a web-based bitcoin service.  You should be able to run bitcoind with the -testnet switch and no code changes to test your service with pretend, instead of real, bitcoins. This looks pretty interesting (in the US):  http://www.paynearme.com/Print out a payment slip on a website, walk into a store and finalize payment in cash, website merchant gets immediately notified.From their Terms of Service:  "Please do not confuse our PayNearMe payment service with use of a credit card, debit card or pre-paid/loaded card. There is no extension of credit. And since there is no credit extended, there is no ability to challenge or cancel the transaction through a chargeback procedure." Keys in the keypool store when they're generated (and the oldest are always used first).   Asking "what's the oldest key in the key pool" seems reasonable, and I think it would give you what you want-- you could compare that timestamp to the timestamp of your last backup to see if you're covered.Although if you're going to periodically check to see what the oldest timestamp is (or you're going to periodically check to see if bitcoin has written a new timestamped backup file or periodically check WHATEVER) then it seems simpler to me to just periodically always call backupwallet.  Disk space and bandwidth is cheap these days... nBits is difficulty in 'compact' format?  (if I recall correctly...)It should be reported as floating-point 'difficulty', like you get from the 'getinfo' rpc command.I will add that. Backup every 30 sendtoaddress or generatenewaddress and you'll be fine-- you should always have at least 3 backup copies of all your keys.If you're running a very busy service so backing up every 30 is too often, then run with -keypool=1000 and backup at least every 300 sends/generates.I worry about bitcoin accumulating too many features and not doing any of them very well.  I suppose it wouldn't hurt to add an option so it automatically creates timestamped wallet backups... but should it erase old backups?  (if it doesn't, I KNOW people will forget to erase them and will be upset when their disk fills up with wallet backups and they're left to figure out how to clean up the resulting mess).  Should it encrypt them?  What should it do if an automatic time-stamped wallet backup fails?  When encrypted wallets are implemented, what should happen to old backups if the wallet encryption key is changed?
RE: how many free keys are in the pool:By default, there are at least 100 free keys in the pool, always.When a key is taken out, if the number of free keys drops below 100 (or the -keypool= number) another is generated.Keys are put back if they're unused-- for example, a key is needed for every miner hashing thread, so if you're on a 4-core machine and turn on coin generation and then turn it back off you'll wind up with 104 keys in the free pool.But for most people most of the time there will be exactly 100 free keys. It is pretty darn hard to make a billion dollars of gold (or paper money) virtually theft-proof, especially if you're worried that your government might decided it 'needs' some of it.Assuming bitcoins are eventually worth billions of dollars, it will be easy to make a billion dollars of bitcoins virtually theft-proof.  Heck, you could walk around with a billion dollars worth of bitoins on an encrypted memory stick in your pocket.With a backup in a safe deposit box in Switzerland.  That's MUCH better than gold or paper money.I'm starting to think that bitcoin as a store-of-value might end up being more attractive than bitcoin as a medium-of-exchange. So... have clients send back their best N hashes (and the average should be N times better).RE: detecting server cheating:  Over a very long period of time, clients should be able to figure out approximately how many hash/sec the server's network is generating.  So they should be able to detect blatant cheating.  I should've taken statistics in college, seems like it'd be an interesting problem to work out the chances that a server is lying based on how many blocks it has generated over the last week... Pass "allwallet" to monitoraddress and you'll get all transactions that put coins in your wallet.RE: getting the data POSTed in PHP:  Try:json_string = http_get_request_body();Also, POSTing to www.postbin.org (create a postbin there first) is really useful for debugging. I bet you'd get a good approximation of hash rate if clients submitted their best (highest difficulty) hash every N minutes.  Over a period of a few hours the average of all of those best hashes should be proportional to the client's hash rate (unless a client were somehow repeatedly very lucky or unlucky, but that would be extremely unlikely). svn r167 is a tweaked makefile.unix that Xunie reports allows bitcoind to compile cleanly on Ubuntu 10.04 x86_64.I tested on my Debian box and it does no harm; let me know if it breaks the build on any other unix flavors.Code:Index: makefile.unix===================================================================--- makefile.unix (revision 166)+++ makefile.unix (working copy)@@ -26,7 +26,9 @@    -l ssl \    -l crypto \  -Wl,-Bdynamic \-   -l gthread-2.0+   -l gthread-2.0 \+   -l z \+   -l dl Sure, there are a couple of tables in the back of Satoshi's bitcoin paper that calculate the chances based on what percentage of CPU work you're contributing. I don't know what the issues are-- I do Mac/Linux these days (I don't do Windows).  Does the precompiled fedora mingw32-openssl support ECSDA signatures?  Can you give it a try and let us know if it works?  (just add -DUSE_SSL to the Makefile and link with whatever libssl is called under mingw32) SVN rev 166 (bitcoin version 0.3.13.4) implements secure incoming SSL JSON-RPC connections to bitcoind or bitcoin -server on Linux and OSX.I've created a wiki page with detailed instructions on how to configure bitcoin.conf for SSL JSON-RPC connections.SSL support is enabled at compile time with the USE_SSL #define, and is not enabled in the Windows makefiles because I'm told there are... issues... compiling full OpenSSL libraries on Windows (core bitcoin uses the openssl libcrypto library, this change requires the full libssl library). I automated updating/patching the monitorreceived patch, and just updated to Satoshi's latest:  http://gist.github.com/604574(use the "raw" link there for a link to latest version of the patch)And I fixed the bug reported by doublec. The only think I can think of is that the php fopen() call is timing out.  Are you trying to generate coins?  Does it get better if you stop generating?Are you using PHP5 ?  If you are, try creating a stream_context with a longer timeout  (see http://www.php.net/manual/en/context.http.php ). ByteCoin: cool!  Are you finding alternative public keys for a given ECC private key?  (are there multiple public keys for a given private ECC key???  I know very little about elliptic curve cryptography)And to all:  I couldn't resist, I updated the patch so it can search for a regular expression and so it starts a separate thread and doesn't monopolize the RPC thread.  My machine is busy looking for a bitcoin address that matches '^1Gavin' right now. I'm a happy LastPass subscriber... and I hate to say it, but they're right.  At this point there's no way the average consumer will use Bitcoin, even via a website like mybitcoin.com.I think it will be a few years before bitcoin and bitcoin-related services are reliable and trustworthy enough for the average consumer.  Don't get me wrong, I think bitcoin is a fantastic idea and has a good chance of being Really Important, but it is going to take a long for it to get accepted as a viable alternative to other payment solutions. But if it supported regular expressions "david.*on.*pda" would probably be found in a reasonable amount of time...Of course, if you were unlucky it'd find something like  1davidSpoonLApdaDDY13iu8 (not a real bitcoin address) RE: "wasting" addresses:caveden is right, this patch generates and throws away lots and lots of potential bitcoin addresses.But there are 2^160 possible bitcoin addresses, which is a really, really big number.  The chances of BioMike generating an address that matches my "gavin" address before we're all dead is approximately zero.And davidonpda:  I haven't tried to figure out how long 10 characters would take-- it is exponential in the number of characters, so 10 characters would probably take years... Attached is a little patch that expands the getnewaddress RPC command so it can try to generate a "vanity" bitcoin address.E.g. I told it to generate an address with "gavin" in it, and it chugged away for an hour or two and came up with:  12kUimDnb1a6oAPifgavinAaxMmLe43UR6This is recommended for fun and experimentation only; it takes a long time, and while it is trying to find an address with the right string in it no other RPC commands are accepted.  Including 'stop'.It'd be kinda cool (and would speed it up a lot) to make it case-insensitive.  Or to match to an arbitrary regular expression.  Or to make it spin off a separate thread and just return "working...."  (and have the thread add the address to the wallet when it is finally found, labeled with the vanity string).Maybe we should have a Best Bitcoin Address contest   I updated most of my git branches to svn rev 161 last night, including monitorreceived.  That's easy:   git svn fetch   (but you have to have an "svn-remote" setup in your .git/config)   git merge refs/remotes/svn/trunk    (I could git rebase instead, but merge seems less magical to me)    ... fix any merge conflicts and test then git commit, if needed  (usually there are none)   git push   (to push up to github)Repeated on each branch (I'll try to keep svn, svnTEST and monitorreceived up-to-date).Keeping the patch file up-to-date is another couple of steps, and I could/should automate it.doublec: thanks for the bug report, I'll look into it as soon as I get this machine setup. There's a built-in mechanism for ensuring that this is never a serious problem:  the more coins that are lost, the more valuable the remaining coins become.And the more valuable something is, the more careful people are not to lose it.  So there's a nice feedback loop that should naturally limit the number of coins lost.If Bitcoin becomes the world's stable reserve currency then one bitcoin might end up being worth tens of thousands of dollars and we'll all get much more serious about backing up our wallets and keeping them secure.  Or, I think more likely, most people will use a service that they trust to keep their coins backed up and secure... Today:  a brand-new keypair (address) is created and added to your wallet when you have change.Soon (I hope; I think satoshi is working on it...) bitcoin will pre-generate a bunch of addresses to use for change, and use one of them (and re-generate a bunch when it runs out).I'd kind of like an option to put change back into one of the addresses it came from; that'd be simpler, quicker, and would make your wallet smaller... A half-baked thought that's been bouncing around my head for the last couple of days:One piece of functionality missing from bitcoin is the ability for somebody to prove that they own a certain bitcoin address.I'm thinking that if there was a way to ask bitcoin to:  1) Sign an arbitrary bunch of data with a bitcoin address' private key, and return the signature.  2) Take a bitcoin address and signed data and verify that the signature is valid.... then maybe that could function as the building block allowing webs of trust to develop in an application independent of 'core bitcoin'.And secure, pseudo-anonymous communication between people who know only each other's bitcoin addresses.  And probably a bunch of other interesting things I haven't thought of.
I should have been clear:  this is a patch against the latest 'vanilla' svn. I just updated the code/patch:   monitoraddress allwallet <url>... gets triggered for all transactions that go into your wallet.  That includes 'change' transactions that can occur when you send somebody coins, which I expect will strike some people as a bug and others as an important feature.And I combined the getblockby methods into one.  I know I would've never remembered  "is it getblockybycount or getblockbynumber or getblockbyheight or getblockbydepth" -- I will remember "getblock". Good Idea, and that aught to be easy.I'm thinking it should be:  monitoraddress allwallet <url>... instead of a separate monitor command.Come to think of it, maybe I should combine the getblockby* routines into one; there's no chance of mistaking a 64-character hex block hash for a 5-digit (or, in many years, a six or seven or ten digit) block number. This patch adds the following JSON-RPC commands to bitcoin/bitcoind:monitoraddress <bitcoinaddress> <url> [monitor=true]When coins are sent to <bitcoinaddress> POST JSON transaction info to <url>.If <bitcoinaddress> is 'allwallet' then monitor coins sent to all of your addresses.Pass false as third param to stop monitoring.monitorblocks <url> [monitor=true] [startblockcount=0]POST block information to <url> as blocks are added to the block chain.[monitor] true will start monitoring, false will stop.Pass [startblockcount] to start monitoring at/after block with given blockcount.listmonitoredReturns list describing where blocks and transactions are being POSTed.getblock <hash|number>Returns details of the block with <hash> (hexadecimal) or <number>.gettransaction <hash>Returns details of transaction with <hash> (hexadecimal).This patch also modifies the "sendtoaddress" function so it returns the transaction ID on a successful send (instead of the string "sent").If you use the monitor* functionality to POST information be sure to think through the security of your application.  For example, if you use monitoraddress to get notified of customer payments you should think about whether or not a customer could fake a payment by POSTing bogus information to your web server.Full source code is at: http://github.com/gavinandresen/bitcoin-git/tree/monitorreceivedAs always, bug reports, suggestions for improvement and feedback is welcome.Updated monitoraddress/getblock commands as discussed below blkindex.dat contains all the transactions, in records that look like:  key:  "tx" + HASH_OF_TRANSACTION  value: serialized CTxIndexThe CTxIndex points to a record in one of the blk000n.dat files.That does bring up an interesting point, though:  if lightweight clients are implemented, they wouldn't be able to support an arbitrary 'gettransaction'. I've been working on a "monitoraddress" / "monitorblocks" patch, so bitcoind will POST transaction/block information to an arbitrary URL.And it seems to me "getblock" should be split into "getblockbycount", "getblockbyhash" and "gettransaction".  I also have some suggestions for making the naming more consistent:I'd suggest getblockby* return:Code:{    "hash" : "00000000002d1a4380793affbc610885aa2e0b224eeedd64ffe108044ec7d434",    "blockcount" : 71995,    "version" : 1,    "merkleroot" : "9d436c694968454ea0d17f4aece3b829930027c3cb918e5107a1605aa2eeae33",    "time" : 1280823515,    "nonce" : 2918845955,    "tx" : [  "f85e77e4379694c8d2c1232d6fddfc7792073fb8484bdac37a9ba5ed1d245c57", etc ]}Reasoning:  blockcount instead of 'height' or 'depth' because getinfo returns "blockcount"  getblockbyhash might return a block not on the "best" chain; return blockcount=-1 in that case?  version instead of 'ver' because abbrvs shd b avoided (thy cn b hrd to rd/rmbr)  only return transaction hashes; if you need more transaction details, call gettransaction.  No n_tx (or n_anything) because it is implicit in length of returned array(stuff I'm not sure about:  what is 'bits' in the implemented getblock?  Is that difficulty?  Does anybody really need all the detailed merkle tree info?)I'd suggest gettransaction return:Code:{  "txid" : ...transaction id passed in,  "version" : 1,  "time" : ...transaction time...,  "confirmations" : n,  "block" : "block hash",   #  (if confirmations > 0)  "from" : [ [ "txid", n ], ... ], # Empty if coin generation transaction  "to" : [ [ "address", amount ], ... ],}Reasoning:  Returning the CScript string seems like it is both too much detail AND not very useful (I want the bitcoin addresses, NOT OP_DUP 0xblahblahblah ...)  "from" is just a list of pointers to previous transaction "to"s  confirmations is duplicate info (you could getblockbyhash and then look at its blockcount), but is so useful I think it belongs here. Separate "accounts" (addresses with labels) to accumulate Jackpots is the right idea.  Users buy tickets, bitcoins are moved to the appropriate Jackpot account.  When a Jackpot is won, transactions flow out of its account back to whoever won. The "label" mechanism (setlabel / getreceivedbylabel) is supposed to meet this need, but only solves part of the problem.If the API was extended as I describe below, would it solve the same problems as having multiple wallets?Proposal:+ new send method: send TO a given bitcoin address specifically FROM the bitcoins sent to <label>  (change generated would be automatically tagged with <label>)+ add optional [label] param to getbalance.+ new method: listsentbylabel  (returns array of [ "address" : "bcaddresssentto", "amount" : x.yz, "confirmations": n ]) Each customer "account" would be a bitcoin <label>.  Account handling would look like:Create account / create new address for account:  getnewaddress [account_id_label]   ... tell user "fund your account by sending coins to {the address returned}"Customer withdraws/spends:  sendfrom [account_id_label] [address] [amount]   (FAILS if balance for that account too low)Show customer their balance:  getbalance [account_id_label]Show customer their transactions in/out  listreceivedbylabel [account_id_label]  listsentbylabel [account_id_label]---------Seems to me this would be a much better direction to go in, rather than having separate wallet.dat files for each customer.  At the very least, backing up thousands of customer's wallet files would be inefficient and error-prone, and constantly switching between them would also be incredibly inefficient. An irresponsible central bank.I think that scenario is unlikely for dollars, because the Federal Reserve central bankers already have a lot of dollar-denominated wealth, so have a strong incentive to avoid hyperinflation.Compare that to the Zimbabwe central banker, who is basically under the thumb of a dictator who most likely holds his wealth in foreign currencies.  Their incentive is to squeeze as much wealth out of the economy before it collapses and they're deposed in the next coup. For extra credit, give an Object as the return value:{  'isvalid' : true,  'ismine' : true,  # true if isvalid and you have the private key (can spend coins sent to this address)  'version' : 0,  # ADDRESSVERSION  'address' : '1frt6531....'    # might as well echo back the address...} With just a web browser you can open an account at bitcoinmarket, mybitcoin, or mtgox and send/receive bitcoins.The only thing you're not able to do is try to generate bitcoins, but you said you don't have a computer at home and it sounds like your employer wouldn't be very... uhh, supportive... of you using their electricity to try to generate bitcoins.If they would be supportive (long ago I wrote software at a hardware company where they actually LOOKED FOR CPU-intensive applications to run during system burn-in, so they'd ship fewer dead-shortly-after-arrival units) then they'd probably be happy to open up outbound connections to port 8333. "Mainstream" users want a more-selection, less expensive, just as fast variant of iTunes.  Frankly, I don't think an illegal filesharing site can scratch that itch and stay in business for long (I'm curious to see how long mulve.com lasts).If it could, I think a bitcoin-revenue-sharing business model would work well-- "We'll give you 50% of the revenue from any downloads of stuff you upload"  (and "we" charge x-bitcoins-per-download).But I think even if such a service existed there would still be a bunch of people who refuse to pay a bit-penny for downloads.  But I agree with lfm-- I think many of them would be willing to pay indirectly for downloads; you just have to tell them that they're paying for "X gigbytes of premium bandwidth" or something... I think a big publicity splash should wait until Bitcoin 1.0.  Bitcoin still has way too many rough edges for ordinary folk to use (watch them run away screaming as you try to explain that it is NORMAL for it to take half an hour to download the block chain the first time you start Bitcoin....). I believe that the statement: "bitcoin is new kind of money" passes the duck test.Bitcoins function as money (they're a unit of account, a medium of exchange, and a store of value), and if PayPal started allowing Bitcoin transactions tomorrow I'm certain they'd treat them as Just Another Currency.If you like, call it a commodity, but I think all you'll accomplish is confusing potential users who might think they'll end up getting pork-bellies delivered to their porch if they don't get rid of their bitcoins. I shoulda been more clear:  I've now got a 1.11 payment to {some random address} in Bitcoin; I want to take that {some random address} and give it to MyBitcoin (or you, the merchant) and see what's up with that payment.  Ideally, it would pick up the payment process as if the PAYMENT TIMED OUT never happened.And MadHatter:  keep the change. Hmm...  I guess I was too slow:  "PAYMENT TIMED OUT! We didn't receive a payment from you. Try again."I copied the generated BTC address, but forgot the amount by the time Bitcoin launched, so sent you 1.11 (eleven is my favorite number) bitcoins.Now I didn't get whatever it was I paid for.Definitely cool, but also definitely clunky.  Where this needs to go, in my humble opinion:1. MyBitcoin should get rid of the CAPTCHA for most users (do the Google thing, and only show the CAPTCHA if it detects potential abuse)  (oh, you didn't know Google search does that?  Yup, they do, if you do enough weird-looking searches quickly enough you'll get a CAPTCHA...)2. Bitcoin needs a 'refundtransaction' feature, to get rid of the scary "Do not ever reuse a temporary payment address or your Bitcoins may get lost" warning.  Sending to an old address should just do an immediate refund. 3. I want to be able to put the payment address into MyBitcoin and see the status of my payment.4. Gotta get rid of the "memorize the amount and then copy and paste to Bitcoin" (need a bitcoin-payment-request MIME type, in my humble opinion).5. Gotta improve Bitcoin startup speed; at the very least, make the UI come up quickly while it re-verifies the block chain (I think that's what it is doing...). No, both IP and port are encoded in the #bitcoin IRC usernames (see the EncodeAddress/DecodeAddress routines in irc.cpp).(so mizerydearia:  no need to do what you done did...) RE: hippich XML/JSON:XML ain't gonna happen, and I think JSON is overkill for this.  Using the same format as the bitcoin.conf file is the right answer, I think (easy to implement, human-readable, comments allowed in the file, easy to extend as necessary).  That's what I mocked up at skypaint.com.RE: nimnul http://localhost:.../If you've never installed bitcoin, or bitcoin isn't running already, you get an unhelpful error message.  One advantage of a "payment request file" is many users will understand that you need something called "Bitcoin" to open a "Bitcoin Payment Request" file.RE: mizerydearia Linux support:In my research I briefly an across a reference to a KDE startup file to associate mime types with applications, so I think it would work nicely cross-platform if you've already installed bitcoin. (UPDATE: cross-desktop spec here)RE: nimnul clipboard monitoring:Seems to me that's a feature for geeks, because only geeks would happen to know that if you highlight a bitcoin address when bitcoin was running you could automatically launch bitcoin.  And there's no way that would be turned on by default.  And it also seems to me clipboard monitoring is perfect for a standalone, general-purpose utility ("if selection matches any of THESE regepxs, launch THAT applications with arguments "beginpayment %{address} %{amount}" ... ).RE: mizerydearia portable devices:I've never programmed for Android or iPhone; anybody know how they handle non-standard MIME types?  Can apps register themselves as content handlers?Thinking about actually implementing this, the hard part is getting a running (or just launched) Bitcoin's attention in a cross-platform way.  Using the existing command-line control (which uses JSON-RPC under the covers) would be the most straightforward, but that requires that you set a rpcuser/rpcpassword in the bitcoin.conf file AND run bitcoind or bitcoin -server.  Yuck.I suppose, as a special case, payment request JSON-RPC calls could be allowed with no rpcpassword, and -server could be made the default.  Makes me a little nervous, though.Running  bitcoin /path/to/browser/cache/with/payment_request_file  (which is what the web browsers will do) should: IF bitcoin isn't running:  launch it, and wait until it is ready to receive payment request messages Send running bitcoin (...somehow...) "Hey, we got a payment request here for you to deal with" messgae. bitcointools can tell you all transactions to a particular bitcoin address:Code: dbdump.py --search-blocks=1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM | grep 1HZN | grep TxOut['TxOut: value: 50.00 pubkey: 12pCJJci7fRbr7XDBvrV8awimbPnT6BJZd Script: DUP HASH160 20:13e5...5de5 EQUALVERIFY CHECKSIG', 'TxOut: value: 10000.00 pubkey: 1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM Script: DUP HASH160 20:b5a1...0910 EQUALVERIFY CHECKSIG']['TxOut: value: 45.00 pubkey: 1PQPaGweztcFf1W8TmzEbxMVSdWsE4DKGA Script: 65:0437...3cc6 CHECKSIG', 'TxOut: value: 5.00 pubkey: 1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM Script: DUP HASH160 20:b5a1...0910 EQUALVERIFY CHECKSIG']['TxOut: value: 50.00 pubkey: 1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM Script: DUP HASH160 20:b5a1...0910 EQUALVERIFY CHECKSIG']['TxOut: value: 50.00 pubkey: 1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM Script: DUP HASH160 20:b5a1...0910 EQUALVERIFY CHECKSIG']['TxOut: value: 45.00 pubkey: 1H1isittEm7RqH4ih2Gfhc2cRjBdfsbhFT Script: 65:046c...55cb CHECKSIG', 'TxOut: value: 5.00 pubkey: 1HZNsUqQxKVLmfPfCAzLwrnVDzx8CxwxnM Script: DUP HASH160 20:b5a1...0910 EQUALVERIFY CHECKSIG']... etc...Feed that to a little script that just looks for value: (something) pubkey: 1HZNsUq  and totals up the (somethings) and you can figure it out. I agree with nelisky-- not a bug.  Here's what the unix cat command has to say about "":Code:> cat ""cat: : No such file or directory
The bitoin URI thread has died down, but bitcoinmarket and MtGox's spiffy "click to pay" features prompted me to think some more about payment links on web pages.The problem with the MtGox/Bitcoinmarket solutions is that they still require you to copy&paste an address if you want to pay directly from the bitcoin client running on your machine.  My computer-phobic relatives just won't be able to do that (I can hear them saying "...BUT I DON'T HAVE A COPY BUTTON...").But a bitcoin: URI has problems, too: 1. It is hard to implement-- every browser has a different way of registering protocol handlers. 2. If you don't have the protocol handler installed, clicking on the link doesn't give you any help on what to do to make it work.  (try it here) 3. Looks like some software (like this forum) don't like bitcoin URIs: Donate to the Faucet (that URI is bitcoin:15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsC, the forum software is truncating it and adding http://).Maybe a bitcoin payment request MIME type would work better; you click on a link and the web server returns a little file of type "application/bitcoin-payment-request".  Like this. Or the links on this page.If you're running Firefox, you get this dialog box if it doesn't know about application/bitcoin-payment-requests:On PCs, an app can add stuff to the registry to associate itself with a mime type (anybody know if browsers other than IE pay attention to those registry settings?).Macs are similar (although I don't know the details; gotta set the mime type in the App's Info.plist, I believe...).  Anybody know about Linux?Teaching the Bitcoin application to read the bitcoin-payment-request file would be easy, and it shouldn't be terribly hard to get it to ask an already-running Bitcoin to popup a "Send Payment To..." dialog box with fields filled in (OR get it to start itself running and then popup the dialog box).So: whaddya think? What is the use case for this?Is it just to make it easier to send anonymous donations by typing in Pay To: "redcross.org" instead of copying&pasting a bitcoin address?If something like that were implemented, seems like it would just invite the same kind of abuse we see with misspelled-domain-squatters-- setup a domain record for "redcros.org" pointing to a non-Red Cross bitcoin address and take advantage of people's fat-fingered misspellings.  One big advantage of bitcoin addresses is that they have a built-in checksum, so if you misspell them (or screw up the copy&paste) your attempted transaction will be immediately rejected. I added some information on the "OP_RETURN" bug that triggered the 0.3.5 release (and that we weren't talking about because we didn't want it to get exploited on the main network before people had a chance to upgrade). Picking up from the original thread...Bitcoin-related sites that have self-signed or CACert certificates (like mybitcoin.com) look unprofessional and un-trustworthy to clueless non-techies.I know, I know, a Verisign-certified certificate isn't really any guarantee of security, but that doesn't matter-- if you want ordinary users to start trusting your website, get a certificate that doesn't popup any scary-looking security warnings. Implementation was easy, once I figure out how boost::asio::ssl::stream worked...Anyway, I've created a git branch for anybody who's willing to help test:  http://github.com/gavinandresen/bitcoin-git/tree/jsonhttpsDocumentation for what I done did:Communicating with the Bitcoin JSON-RPC interface over SSL (https)By default, bitcoin allows JSON-RPC commands to be sent tohttp://localhost:8332/, and accepts connections only from the localhost.It can be configured to allow https connections from other hosts;three things must be setup for this to work properly:1. You must setup a server certificate and private key.  A self-signedcertificate will work, you don't need a certificate signed by Verisignor another certificate authority.By default, bitcoin looks for the server's private key file in a"server.pem" in the bitcoin data directory (e.g. ~/.bitcoin/server.pemon unix), and the server certificate file in "server.cert".  Togenerate them using the openssl command-line program, run:  cd ~/.bitcoin  openssl genrsa -out server.pem 2048  openssl req -new -x509 -nodes -sha1 -days 3650 -key server.pem > server.certYou should NOT enter a passphrase.2. Specify the IP addresses of clients that are allowed to connect using"rpcallowip" configuration file options.Edit the bitcoin.conf file (in the bitcoin data directory), and add aline for each IP address allowed to connect:  rpcallowip=10.11.13.15  rpcallowip=10.11.13.16You may also allow connections from any IP address in a subnet using *:  rpcallowip=192.168.1.*  rpcallowip=10.1.*.*You can also specify 'rpcallowip=*' to allow all IP addresses.Connections from the local host (127.0.0.1) are always allowed.3. You must tell bitcoin to use ssl using the "rpcssl" configuration file option.Edit the bitcoin.conf file, and add:  rpcssl=trueRestart bitcoin or bitcoind to make these changes take effect.  Youcan test bitcoin's ssl functionality using the openssl s_client command:  openssl s_client -connect localhost:8332The connection should be successful and you should see the server'scertificate details.  If you press return twice, you should get a'HTTP/1.0 401 Authorization Required' response.Client setupOnce the server is accepting https connections, to be secure you shouldmake sure the client is actually connecting to the bitcoin server andnot an attacker trying to hijack the connection.If you can, you should copy the server.cert certificate chain file tothe client machine and use it to validate the OpenSSL connection.For example, in php you would call stream_context_create() withthe 'verify_peer' and 'ca_file' options and then callstream_context_set_default().If you can't validate using the server certificate, you should connectto the server using its IP address instead of its host name.All HTTPS-JSON-RPC-related bitcoin.conf options:rpcport      : default: 8332  Listen for connections on this portrpcuser      : user for HTTP BASIC authenticationrpcpassword  : password for HTTP BASIC authenticationrpcssl       : Not set by default, if set bitcoin will only accept SSL               connectionsrpcallowip   : Allow a client at this IP address to connect               (may be specified multiple times)rpcsslciphers: default "TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH"               (see the openSSL documentation for syntax)rpcsslcertificatechainfile : default "server.cert"rpcsslprivatekeyfile       : default "server.pem" ... but a payer typically has only the bitcoin address, and not the payee's full public key.  There'd have to be some way to get the full public key for a bitcoin address.I like the idea of being able to send encrypted messages to "whoever has bitcoin address BLAH", but I'm not sure that functionality should be piggybacked on the "send BLAH X.YZ bitcoins".If they were implemented under the covers as separate functions, then a "Send a message along with payment" could easily be implemented as:  1. Send BLAH X.YZ bitcoins, and note the transaction ID.  2. Send BLAH an encrypted message:   "txid:{transaction_id}:Please send the sixteen My Little Pony DVDs to..." This bitcoind address validator is a subclass of the Django forms.CharField class, but could easily be adapted to other frameworks or to be standalone code.It does a "deep" validation, checking that the checksum built into every bitcoin address matches the address. It needs the PyCrypto library for the SHA256 function.I hereby release this code into the public domain, do with it what you will.  And please let me know if you find any bugs in it.BCAddressField.py:Code:## DJango field type for a Bitcoin Address#import refrom django import formsfrom django.forms.util import ValidationErrorfrom Crypto.Hash import SHA256class BCAddressField(forms.CharField):  default_error_messages = {    'invalid': 'Invalid Bitcoin address.',    }  def __init__(self, *args, **kwargs):    super(BCAddressField, self).__init__(*args, **kwargs)  def clean(self, value):    value = value.strip()    if re.match(r"[a-zA-Z1-9]{27,35}$", value) is None:      raise ValidationError(self.error_messages['invalid'])    version = get_bcaddress_version(value)    if version is None:      raise ValidationError(self.error_messages['invalid'])    return valueimport math__b58chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'__b58base = len(__b58chars)def b58encode(v):  """ encode v, which is a string of bytes, to base58.                                                                                                                 """  long_value = 0L  for (i, c) in enumerate(v[::-1]):    long_value += (256**i) * ord(c)  result = ''  while long_value >= __b58base:    div, mod = divmod(long_value, __b58base)    result = __b58chars[mod] + result    long_value = div  result = __b58chars[long_value] + result  # Bitcoin does a little leading-zero-compression:                                                                                                                    # leading 0-bytes in the input become leading-1s                                                                                                                     nPad = 0  for c in v:    if c == '\0': nPad += 1    else: break  return (__b58chars[0]*nPad) + resultdef b58decode(v, length):  """ decode v into a string of len bytes                                                                                                                              """  long_value = 0L  for (i, c) in enumerate(v[::-1]):    long_value += __b58chars.find(c) * (__b58base**i)  result = ''  while long_value >= 256:    div, mod = divmod(long_value, 256)    result = chr(mod) + result    long_value = div  result = chr(long_value) + result  nPad = 0  for c in v:    if c == __b58chars[0]: nPad += 1    else: break  result = chr(0)*nPad + result  if length is not None and len(result) != length:    return None  return resultdef get_bcaddress_version(strAddress):  """ Returns None if strAddress is invalid.  Otherwise returns integer version of address. """  addr = b58decode(strAddress,25)  if addr is None: return None  version = addr[0]  checksum = addr[-4:]  vh160 = addr[:-4] # Version plus hash160 is what is checksummed                                                                                                      h3=SHA256.new(SHA256.new(vh160).digest()).digest()  if h3[0:4] == checksum:    return ord(version)  return NoneOctober 20: Fixed bug with bitcoin addresses with leading-1's. Unlike a public HTTPS web server, which accepts connections from anybody, the bitcoin HTTPS JSON-RPC server will only accept connections from trusted clients, and you'll almost certainly be your own root certificate authority-- there is no reason to pay for a Verisign certificate, you should generate your own and deploy it with the code that is talking JSON-RPC to your server.Or, in other words, since you'll control both ends of the conversation (as opposed to a web server, where you typically control EITHER the server OR the web browser) you can make it completely secure. Speak now about this change or forever hold your peace...  Satoshi will be including this functionality in the next version of Bitcoin (0.3.12).If you use the JSON-RPC api, you should check your error-condition-handling code; again, the changes are that the error member will be an Object (with 'code' and 'message' fields) instead of a String, and the HTTP status code may be 404 instead of 500 for method-not-found. Bear with me, this is a brain dump to try to organize my thoughts on securing the client <--> bitcoin JSON-RPC connection:First: Preventing man-in-the-middle attacks:HTTPS only prevents man-in-the-middle attacks if it is implemented properly by the client.  Example attack scenario against a lazy client:Client connects to "https://bitcoinservice.org:8332/"Attacker intercepts connection (e.g. via a DNS poisoning attack), and connects to the client using it's certificate.Client gets certificate and doesn't bother to verify that the connection certificate is for bitcoinservice.org.  Completes SSL handshake.Client then continues conversation by sending JSON-RPC request containing unencrypted rpcuser/rpcpassword.Attacker now has rpcuser/rpcpassword and can mount a man-in-the-middle attack against the bitcoin server.The "correct" way to prevent this is for clients to properly authenticate the server's certificate, but I don't think that's practical-- the default behavior for most url-opening libraries (used by the various JSON-RPC libraries) is to NOT validate server certificates.  You have to write extra code to install certificate authorities and/or write callbacks to examine the certificate and determine whether or not it is the certificate you expect.I think a more practical way for the client to prevent a man-in-the-middle attack is for the client to hard-code the bitcoin server's IP address and avoid any DNS lookups-- connect to http://111.11.11.111:8332/ (if bitcoinservice.org is at IP 111.11.11.111).  It is much, much harder to successfully IP spoof a TCP connection than it is to successfully poison a DNS cache."Security in depth" is a good idea, and I've thought about layering other mechanisms for making the client->server connection secure, but I think we'd just be duplicating SSL functionality.  For example, I can imagine encrypting the whole JSON-RPC request string with a pre-shared key known to the clients and the server, but that's just a lame version of the strong encryption you get from SSL if the client is properly validating server certificates.  I think the security-in-depth will come from having the server authenticate clients, which brings me to:Second: Authenticating clients:The whole point of implementing HTTPS on the bitcoin JSON-RPC port is to allow connections from IP addresses other than 127.0.0.1.  But the "security-in-depth" idea means we almost certainly don't want to allow just anybody to connect and start sending bitcoins from our wallet.  Even if an attacker manages to steal the rcpuser/rpcpassword, we'd like to prevent them from emptying out our wallet if they try to connect from an unauthorized machine (if they can connect from an authorized machine you're already screwed).Again, the "correct" way to authenticate clients is to do the public-key-infrastructure thing (... create a master bitcoin certificate you'll use as your certificate authority, then create public/private keys and certificates signed by that authority and require the clients and server to accept only connections properly signed with the right keys...).   And I think bitcoin should definitely support validating client certificates (that's just a couple of lines of OpenSSL library calls).But again, I'm worried that some people deploying bitcoin either won't bother or will be using languages/libraries/systems that make it difficult or impossible to send a client certificate when connecting.Hard-coding the IP addresses of clients that are allowed to connect via HTTPS (maybe allowing wild-carding of IP ranges) is a much easier-to-setup, almost-as-secure, way to authenticate clients.So, to summarize my current thoughts on all this:Recommendation for clients will be to:Connect to the bitcoin JSON-RPC port via IP address and/or:Properly validate the bicoin server certificateThe bitcoin JSON-RPC-https server will require:Server private/public keys (generated using openssl, filename/path specified in bitcoin.conf file)IP addresses (or ranges) of clients that are allowed to connect in the bitcoin.conf file(optional)Certificate authority file used to validate clients (they must connect using a certificate signed by that authority)What do y'all think-- sound reasonable? Nobody volunteered, but the boost ssl LOOKS like it will make it easy... so I've started playing around with it.After much wrestling with the (sucky) OpenSSL and boost::asio::ssl docs, I've got a standalone, dumb, Satoshi-style-c++ https server running (code below).Are there any real OpenSSL experts here who can review the code and answer questions like: + I understand the temp Diffie-Hellman file contains large prime numbers used to do public key exchange.  Everything works just fine if I leave out the call to context.use_tmp_dh_file; what are the security implications?  Will it matter for what we'll be doing (securing the JSON-RPC channel from eavesdropping/man-in-the-middle attacks)? + I'm following the advice from here, excluding old, low-security ciphers using:    SSL_CTX_set_cipher_list(context.impl(), "TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH");    Am I correct in assuming that any sane JSON-RPC/HTTP/HTTPS library will support the higher-strength ciphers?  Or does Java on a PC do something braindead and support only DES-MD5?  (and yeah, I'll make this overridable via a config file param, but I want to get the defaults right)+ Oh, and a C++ expert question:  what magic incantation will turn the boost::asio::ssl::stream into an iostream that understands << and >> ?And thumbnail sketch of how I imagine this working with bitcoin:+ config file setting to turn on ssl/tls rpc  ( maybe rpcssl=true ... or should it be rpctls=true ? )+ if turned on, only ssl connections accepted on the rpcport+ if turned on, bitcoin binds rpcport to all addresses (not just 127.0.0.1)Code:#include <boost/asio.hpp> #include <boost/asio/ssl.hpp> #include <boost/foreach.hpp>#include <iostream> #include <sstream>#include <string>using namespace std;using namespace boost;using boost::asio::ip::tcp;typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> ssl_stream;string HTTPReply(int, const string&);int main() {     // Bind to loopback 127.0.0.1 so the socket can only be accessed locally                                                boost::asio::io_service io_service;    tcp::endpoint endpoint(boost::asio::ip::address_v4::loopback(), 1111);    tcp::acceptor acceptor(io_service, endpoint);    boost::asio::ssl::context context(io_service, boost::asio::ssl::context::sslv23);    context.set_options(        boost::asio::ssl::context::default_workarounds        | boost::asio::ssl::context::no_sslv2);    context.use_certificate_chain_file("server.cert");    context.use_private_key_file("server.pem", boost::asio::ssl::context::pem);    context.use_tmp_dh_file("dh512.pem");    SSL_CTX_set_cipher_list(context.impl(), "TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH");    for (;;)    {        // Accept connection                                                                                                    ssl_stream stream(io_service, context);        tcp::endpoint peer_endpoint;        acceptor.accept(stream.lowest_layer(), peer_endpoint);        boost::system::error_code ec;        stream.handshake(boost::asio::ssl::stream_base::server, ec);        if (!ec) {            boost::asio::write(stream, boost::asio::buffer(HTTPReply(200, "Okely-Dokely\n")));        }    }}string HTTPReply(int nStatus, const string& strMsg){    if (nStatus == 401)        return "HTTP/1.0 401 Authorization Required\r\n"            "Server: HTTPd/1.0\r\n"            "Date: Sat, 08 Jul 2006 12:04:08 GMT\r\n"            "WWW-Authenticate: Basic realm=\"jsonrpc\"\r\n"            "Content-Type: text/html\r\n"            "Content-Length: 311\r\n"            "\r\n"            "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\r\n"            "\"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd\">\r\n"            "<HTML>\r\n"            "<HEAD>\r\n"            "<TITLE>Error</TITLE>\r\n"            "<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=ISO-8859-1'>\r\n"            "</HEAD>\r\n"            "<BODY><H1>401 Unauthorized.</H1></BODY>\r\n"            "</HTML>\r\n";    string strStatus;    if (nStatus == 200) strStatus = "OK";    else if (nStatus == 400) strStatus = "Bad Request";    else if (nStatus == 404) strStatus = "Not Found";    else if (nStatus == 500) strStatus = "Internal Server Error";    ostringstream s;    s << "HTTP/1.1 " << nStatus << " " << strStatus << "\r\n"      << "Connection: close\r\n"      << "Content-Length: " << strMsg.size() << "\r\n"      << "Content-Type: application/json\r\n"      << "Date: Sat, 09 Jul 2009 12:04:08 GMT\r\n"      << "Server: json-rpc/1.0\r\n"      << "\r\n"      << strMsg;    return s.str();} It isn't trivial to obtain the secret unless you patch the code to bind to interfaces other than loopback....SSL connections are The Right Answer.If I had any OpenSSL programming experience I'd volunteer to implement it.  Anybody willing and able to teach bitcoin to speak https?And for extra credit, support SSL client certificates for authentication either instead of or in addition to HTTP-Basic... I just submitted a patch to Satoshi to make bitcoin follow the JSON RPC over HTTP spec, and to use the standardized error codes from the JSON-RPC 1.1/2.0 specs.If you talk directly to bitcoin via JSON-RPC calls, you might need to change your code to recognize the new HTTP status codes and the new format for the 'error' member of the JSON response.  For example:BEFORE, send {"id":"123", "method": "nosuchmethod", "params": [] } , get response:Code:HTTP/1.1 500 Internal Server Error...{"result":null,"error":"Method not found.","id":"123"}AFTER:Code:HTTP/1.1 404 ...{"result":null,"error":{"code":-32601,"message":"Method not found"},"id":"123"}I also removed the broken 'Batch' support, to simplify the code.  I had JSON-RPC-2.0 batch support working properly, but backed those changes out because JSON-RPC 2.0 is way too cutting-edge for bitcoin to support right now (none of the JSON-RPC glue libraries support it yet, and the spec is still changing a bit). I wouldn't bother-- HTTP Digest auth is vulnerable to man-in-the-middle attacks, it'd be a lot of work for a probably false sense of security. RE: JSON-RPC error / HTTP status codes:  I'm about to submit a patch to Satoshi so bitcoin better follows the JSON standards.  I'll create a new thread describing the changes.RE: binding to any/all IPs:  DANGER! Make sure you have good firewall rules for port 8332 or you are likely to find yourself with an empty wallet!  Bitcoin is using HTTP BASIC authentication, so anybody who can eavesdrop on the connection between your JSON-RPC client and the bitcoin server can see the password (it is NOT encrypted). Neither of those are feasible-- both App Engine and Javascript don't allow arbitrary socket connections, and a full bitcoin client needs to maintain a persistent connection to at least one other bitcoin client to get transaction messages."Background servers capable of running for longer than 30s" is a feature on Google's roadmap, so maybe a 100% App Engine bitcoin client will be possible in the future. I just want to correct one little thing; excuse me for being nit-picky, I'll shut up after this:Assuming you have enough memory to store all your public keys in a hash table in memory, there is no scaling problem with normal transactions.  Since the TxOut contains the public key (well, the hash of the public key), it is constant time to figure out whether or not the TxOut is your public key.  You do NOT have to loop through all your public keys to see which one matches. RE: could you make through adroit use of the scripting language:  you could hide the receiving address, but not the amount.Bitcoin needs to see TxOut amounts so it can add them up and make sure the transaction includes any necessary fees.And to make sure the transaction is valid, although I suppose it could allow invalid-but-not-yet-decrypted transactions into the block chain, and just not allow them to be ever spent (it'd be a complicated way of deleting BTC).  But that makes me extremely nervous-- it seems to me it just makes things more complicated and more likely to be exploited.Also, this: "All the network nodes try to decrypt the message with each of their public keys" ... won't scale.  Busy nodes will have more and more public keys over time (as they give out different receiving addresses for each purchase transaction), and trying them all whenever an encrypted transaction comes over the wire will take an ever-increasing amount of time. Right, that's my issue with your proposal:  what incentive does the NY vending machine have to be honest?  It can be "dishonest", ignore verifiers all-together, and accept more transactions (better for it) with less work (also better for it). Looks good to me.Can you easily hardcode a check for the bad block's hash at startup and orphan it and subsequent blocks if they're on the best-block chain?It's painful to have to re-download all or most of the chain to fix this...
Until there is a better fix... after a very small amount of testing this seems to work:Code:--- a/main.h+++ b/main.h@@ -473,8 +473,12 @@ public:          // Check for negative values         foreach(const CTxOut& txout, vout)+ {             if (txout.nValue < 0)                 return error("CTransaction::CheckTransaction() : txout.nValue negative");+ if (txout.nValue > 21000000*COIN)+ return error("CTransaction::CheckTransaction() : txout.nValue over-max");+ }          if (IsCoinBase())         {@@ -520,6 +524,8 @@ public:         int64 nValueOut = 0;         foreach(const CTxOut& txout, vout)         {+ if (txout.nValue > 21000000*COIN)+ continue; // ignore over-max-value...             if (txout.nValue < 0)                 throw runtime_error("CTransaction::GetValueOut() : negative value");             nValueOut += txout.nValue;You'll need to re-download the part of the block chain before the bad block-- remove the blkindex.dat and blk0001.dat files.   I started with knightmb's blockchain snapshot. My point is that if there is a lot less cpu power on Mars, then the Mars nodes will ALWAYS lose the "create the longest block chain" race.  So the New York nodes will ALWAYS have the advantage.And it is nice to say the New York vending machine "shouldn't accept a Mars coin within several hours,"  but, in my experience, "shouldn't" doesn't cut it.  If the New York candy machine CAN make the sale and keep the coins, it WILL. I'm better at thinking through things using specific examples, so bear with me:  let's use Mars as the extreme case, and say I'm on Mars and want to double-spend some bitcoins.I talk to my cousin in New York, and send him some coins with the "Mars" locality.  We agree that we'll use the same coins to buy candy bars on January 1, 2040, 10:00:00 UTC, me on Mars and him in New York.So the New York candy machine just rejects my cousin's transaction OR makes him wait the 40 minutes for communication between Earth and Mars?  Wouldn't it be more likely that the New York candy machine just accepts the transaction after seeing no double-spends after, oh, I dunno, maybe two seconds?After all, Bitcoin+ Payment Verification Systems, Incorporated knows it is highly connected into the majority Bitcoin network with very low latency, so it knows that if it blasts a transaction into the network and doesn't see a double-spend after two seconds the chances are very, very, very good that it will be declared the first spend.If the New York payment system accepts the transaction every time, then the Mars verifier will lose every time.  I'm pretty sure the New York folks will tell the Mars folks "tough cookies, you should set up MarsCoin for low-latency transactions up there."I don't know much about high speed trading with millisecond latency, and, frankly, don't care much about high speed trading with millisecond latency.  It wouldn't bother me at all if you can't use Bitcoin for that (and you have to set up a SpeedyCoin system for doing that sort of thing). Your proposal seems needlessly complicated.How about:The vending machine talks to a "Bitcoin+ Payment Verification Systems, Incorporated" server.The Bitcoin+ Payment Verification System is basically just a bitcoin node, with really fast international network connections and a little extra code to detect attempted double-spends.  If it detects a double-spend attempt, it rejects the transaction.  Otherwise, it accepts the transaction and blasts the transaction into the payment network over its really fast, as-low-latency-as-possible connections.If it later turns out that the transaction actually WAS invalid, Bitcoin+ Payment Verification Systems, Incorporated absorbs the cost of the fraud.Bitcoin+ Payment Verification Systems, Incorporated, of course, charges the vending machine merchant a fee for providing such excellent service.  They're constantly competing with their arch-rivals, "Better Merchant Services, Incorporated" to balance latency, fees, and fraud to maximize profit. The naming is getting messy: 'txn_id' and 'tx_time' mismatch for no good reason.tx as short for 'transaction' is fine (bitcoin source uses that abbreviation all over the place), but the rest of the JSON-RPC API doesn't use underscores, so they aught to be txid and txtime. Nah, satoshi uses <foo> to mean "replace this placeholder with the actual thingy."It'd be annoying to constantly strip the < and > from the txid. 1) Have you been using bitcoin for more than two months?Yes, almost 3 months now.2) Are you currently attempting to generate coins?No (well, not on the production network; I am generating blocks on the TEST network)3) If not currently generating, have you attempted in the past? If generating, how long have you been generating?Yes, before the big slashdot interest influx I was generating.4) Have you ever succeeded in generating a block? Many blocks?Probably around 10  blocks while I was generating.5) Why or why not do you generate? I'm a big believer in the power of division of labor and comparative advantage to make the world a better place.  I don't have any particular advantage for mining bitcoins, and I bet people who _do_ (who have access to lots of cheap CPU cycles) will be more efficient at mining than me. I see two fundamental problems with using a Bitcoin-like system to implement a Universal-Dividend-like system:1. How does the system identify "individuals" ?   If you've got a completely automated way of doing that I really want to know about it!  freebitcoins.appspot.com could really use a foolproof system for identifying individuals.2. If everybody gets a dividend, why would anybody bother running a block-generating node?  What is the incentive for doing the work needed to support the system? You'll never hear me argue with "keep it simple."  Patch for that is trivial:Code:diff --git a/rpc.cpp b/rpc.cppindex 920fe90..35a336f 100644--- a/rpc.cpp+++ b/rpc.cpp@@ -364,7 +364,7 @@ Value sendtoaddress(const Array& params, bool fHelp)     string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);     if (strError != "")         throw runtime_error(strError);-    return "sent";+    return wtx.GetHash().ToString(); } A 'gettransaction tx_id' API call is on my short list.What do other folks think; should sendtoaddress .... true   return just the tx_id, and you have to make another API call to get details if you need them?Or should it return an Array? RE: adding a flag:  great idea!If you set the flag, I don't see any reason to prepend 'sent' to the transaction ID; better to just return the transaction ID on successful send.Patches:Code:diff --git a/rpc.cpp b/rpc.cppindex 920fe90..8714b7e 100644--- a/rpc.cpp+++ b/rpc.cpp@@ -342,10 +342,11 @@ Value getaddressesbylabel(const Array& params, bool fHelp)  Value sendtoaddress(const Array& params, bool fHelp) {-    if (fHelp || params.size() < 2 || params.size() > 4)+    if (fHelp || params.size() < 2 || params.size() > 5)         throw runtime_error(-            "sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]\n"-            "<amount> is a real and is rounded to the nearest 0.01");+            "sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to] [return-tx-id-flag]\n"+            "<amount> is a real and is rounded to the nearest 0.01\n"+            "returns string 'sent' if return-tx-id-flag is false (default), otherwise returns transaction id.");      string strAddress = params[0].get_str(); @@ -361,9 +362,15 @@ Value sendtoaddress(const Array& params, bool fHelp)     if (params.size() > 3 && params[3].type() != null_type && !params[3].get_str().empty())         wtx.mapValue["to"]      = params[3].get_str(); +    bool fReturnTxID = false;+    if (params.size() > 4)+        fReturnTxID = params[4].get_bool();+     string strError = SendMoneyToBitcoinAddress(strAddress, nAmount, wtx);     if (strError != "")         throw runtime_error(strError);+    if (fReturnTxID)+        return wtx.GetHash().ToString();     return "sent"; } @@ -1103,6 +1110,7 @@ int CommandLineRPC(int argc, char *argv[])         if (strMethod == "setgenerate"            && n > 0) ConvertTo<bool>(params[0]);         if (strMethod == "setgenerate"            && n > 1) ConvertTo<boost::int64_t>(params[1]);         if (strMethod == "sendtoaddress"          && n > 1) ConvertTo<double>(params[1]);+        if (strMethod == "sendtoaddress"          && n > 4) ConvertTo<bool>(params[4]);         if (strMethod == "listtransactions"       && n > 0) ConvertTo<boost::int64_t>(params[0]);         if (strMethod == "listtransactions"       && n > 1) ConvertTo<bool>(params[1]);         if (strMethod == "getamountreceived"      && n > 1) ConvertTo<boost::int64_t>(params[1]); // deprecated I'm proposing one small change to Bitcoin's JSON-RPC api:  return a transaction ID when Bitcoins are successfully sent.Why?  Because I want to keep a complete audit trail for any coins going into or coming out of my application's wallet; I want to keep track of the particular transactions in the bitcoin network that correspond to actions my application takes.  The alternative is to call sendtoaddress and then call listtransactions, but that won't work properly if two similar transactions (same amount to same address) occur at about the same time.So I propose doing the simplest thing possible: modify the JSON-RPC sendtoaddress call so it returns the string 'sent:' followed by the 256-bit-hexadecimal transactions id.This could break any applications that look for exactly the string 'sent' (which is what sendtoaddress does now).  The fix would be to modify the apps to see if the string began with 'sent'.Alternatives I thought about but think I don't like: + make it a new api call so old apps do not break (sendtoaddress2 ? yuck) + return just the transaction id on successful send instead of 'sent:...' + return an array with more information (maybe [ "tx_id": "...", "fee" : 0.0 ] )Comments/criticisms? Very quick reply, I should be going to sleep:I think it would be helpful to describe how much anonymity you can expect based on what you expect from a potential attacker.There's a big difference between "I'm worried about somebody tracing transactions back to me by looking through the block chain" (easy solution: mix up your coins by sending them to and from a mybitcoin.com account a couple of times over a couple of days; send them in batches over time to be really safe) and "I'm worried about somebody tracing the transactions I'm making by watching all of the IP traffic coming from my machine (much, much harder to guard against). I was actually thinking of a minute or three of proof-of-work on initial connection, not when submitting a transaction, but requiring some proof-of-work for every transaction submitted into the network IS a very interesting idea!  Should be straightforward to implement, too (add a nonce and either a full or partial hash to the transaction)... Bitcoin's p2p network is subject to various kinds of denial of service attacks.There, I said it.Do you have constructive suggestions for how to fix it, or are you the kind of person who just enjoys breaking things because you can?Ideas that have been bouncing around my head that may or may not work:+ have clients tell each other how many transactions per unit of time they're willing to accept.  If a client sends you more (within some fuzz factor), drop it.  Compile in a default that's based on estimated number of transactions for a typical user and estimate on the number of current users.+ require some proof-of-work as part of the client-to-client connection process (helps prevent 'Sybil' attacks).This is an active area of research; see, for example: http://scholar.google.com/scholar?q=ddos+attacks+by+subverting+membership Right, but every TxIn has to have a corresponding TxOut (except for GENERATE/coinbase transactions, but those have their own rules).  So if you want a 0 BTC TxIn, you've gotta first pay yourself with a 0BTC TxOut and that'll trigger the fee.  TxIns don't contain a value, the value is in the corresponding TxOut...But you agree that it wouldn't be OK for a 'refundtransaction' API call to make it easy to do that, right? If they are (I didn't see anything preventing them after a quick reading of the code), then they trigger the 0.01BTC micro-transaction fee.I'll be doing a lot of experimenting (on the TEST network, of course) with refunding transactions over the next few weeks.  I think the UI issue can be resolved (it should be pretty straightforward to teach the UI to recognize refund transactions and show them as "refund from BLAH", where BLAH is either a BC address or a label from your address book.I've already implemented a "refundtransaction" api call, but it still needs work before it would be ready for standard bitcoin.  In particular, it shouldn't be possible to create infinite 'refundtransaction' loops (where you accidentally or purposely refundtransaction a refunded transaction, probably triggering another refund, etc).And refunding a transaction should, ideally, use the same "coins" (... should have the same ancestor transactions, for anybody who's going to get all pedantic on me) as the original transaction, if possible, so if that original transaction is exactly as valid as the original transaction.  Otherwise it might be possible to generate a bad transaction, send it somewhere you know it will get refunded immediately with different, valid transactions, and so "launder" your bad bitcoins for good. Eventually the largest merchants and money exchangers will control what is "standard" bitcoin.Take the "50-coiners" scenario, and imagine that they manage to get 75% of the CPU power on their side.But imagine that the biggest merchants and money exchangers are more conservative, and are in the 25% minority.  I think they will be-- I don't think they'll be the ones in the business of generating coins (they'll be busy selling products or doing the exchange thing).What happens?Well, the block chain splits.  Transactions using coins minted before the split will get added to both block chains, and accepted by everybody.Transactions involving "50-coins" (generated after the split) will be accepted on the 50-coin chain, rejected on the 25-coin chain.  And vice-versa."50-coiners" would quickly find out that they couldn't get rid of their newly minted money because who wants bitcoins that are rejected by the biggest money exchangers or merchants?If the big merchants and money exchangers disagreed, I bet you'd see Bitcoin clients that ONLY accepted pre-split coins and did no coin generation (since those transactions would be accepted by everybody).  If it was never resolved, I think the number of Bitcoins at the time of the split would become "the number of Bitcoins, period,"  because most people will not want to use money that is accepted some places and not others. Sure, in exactly the same way the existence of credit cards motivates behavior of stealing credit card numbers from innocent credit card users.Or the existence of bank accounts motivates hackers to try to break into your system to find out your bank account number.Or the existence of cars motivates some people to steal gasoline from innocent service station owners.I believe the benefits of Bitcoin will outweigh the harm, and I further believe that I am capable of making that moral judgment.  I might be wrong, and I might regret I ever got involved, but if I only ever did things that I was 100% certain were going to work out for the best I would never accomplish anything new and interesting. No, not at all.  Like I said when I jumped into this thread, I think using a DHT network to somehow distribute the work is a very interesting idea, it just seems to me any solution that partitions the network will be more vulnerable to attacks that insert malicious nodes.  I think it would be fantastic to come up with less resource-intensive solution that actually works.How does Freenet generate node IDs?  The only info I see in the latest Freenet paper is:.... and:...which doesn't sound like it would work very well for Bitcoin.
Now I'm confused again.  I thought your scheme didn't have blocks, just transactions.  What do you mean, whoever solves "the block" first?But standard DHTs are typically used to store chunks of MP3s or movies, indexed by a torrent file that has the hash for every piece.  So it is easy for me to tell whether or not I'm getting bad data from any particular DHT node.  I don't have to trust them.Huh?  Lets say the network has 10,000 nodes in it.  I query the network to find the network node closest to a transaction that I want to double-spend.So I generate a private key.  It has about a 1 in 10,000 chance of being closer than the current closest node.  So I keep generating private keys until I have 5 that are closer.  It's too late for me to figure out the odds, but lets say I generate 100,000 private keys, I'm pretty darn likely to find 5.  My wimpy laptop can generate at LEAST 100 ECC keys/second, so in under 20 minutes it could generate 100,000.I create 5 nodes with those keys (telling the rest of the network "honest, folks, I chose those keys RANDOMLY...") and I've won.I'm not trying to generate a transaction with a particular hash, I'm trying to generate node ids that are "closer" to that transaction's hash than any other node currently on the network.  That's much easier. What happens when they disagree about which transaction happened first?  Majority rule?  Who decides what the majority is, and can it change if 4 of the five nodes leave the network and are replaced by another 5 nodes?And if I know that I'm going to create a large transaction, can I do some work precomputing node IDs such that the transaction (which I haven't yet sent out) will hash to nodes that I control?   If I control all the nodes storing the transaction, then I can just answer "yes, absolutely, that transaction is valid and hasn't been double-spent..."The brilliant insight behind bitcoin is the distributed timestamping mechanism; everybody agrees on an order of transactions.  I don't see how your scheme solves that problem. Some random Friday afternoon brainstorming: could you print out bitcoins to function as user-created paper money?QR code could be used to encode a transaction hash and a transaction signature on a piece of paper (along with a human-readable amount).  A bitcoin client could print out coins that are in your wallet and marks them as "PRINTED" (so you don't accidentally spend them-- there would probably be a way of recovering them in case the paper versions were lost or stolen, and they'd automatically get removed when the paper versions were spent).Give that piece of paper to a merchant connected to the Bitcoin network and they can scan it and transfer the coins into their wallet.  They should then destroy the paper, because that transaction is spent.Double-spending would be nearly impossible, because once you give the paper to the merchant you lose control over exactly when they submit it to the network to be verified.The only problem I see is how the merchant gives you your change.  The merchant could print out the change, but you'd have to trust that they were giving you valid, unspent coins, unless you have a device connected to the network that could verify them (but that's dumb, because if you do have such a device why bother with paper bitcoins?).  We trust merchants not to give us counterfeit dollars... I wonder if fear of loss of reputation would be enough to keep them honest when giving paper bitcoins as change... Interesting idea.So, lets see, I create a transaction to pay you (say) 100 of my newly minted bitcoins.That'll be a transaction with two 50BTC TxIns (signed by me, pointing to two mature GENERATE transactions somewhere in the block chain) and one 100BTC TxOuts.You want to make sure I haven't double-spent those TxIns, so instead of flooding the network with that transaction you find the hash of the two GENERATE transactions and send two queries down into the DHT network:  "Hey, here's a transaction, tell me if it is valid."  They say "yup", and then... what?  Include it in any blocks they're lucky enough to generate?  Broadcast it to everybody (which'd be no better than the current scheme) or some subset of the DHT network (what subset?)?How do you know that you won't get a different answer to "is this transaction valid" if you ask again in 10 minutes when the network topology might have changed?I don't know much about DHT networks and how they manage to keep reliable information when nodes may be coming and going (or buggy or malicious).  How would it work? I'm thoroughly confused on what, exactly, you're proposing.I want to make a 100 Bitcoin transaction to you.You're proposing that I need to pay a "transmit fee" ... which is paid to who and does what, exactly?If I pay it to A, B, and C, does that mean they rebroadcast the transaction to everybody they're connected to?  Do they, in turn, pay transmit fees to the nodes they're rebroadcast it to?  What stops them from saying "Thank you very much for the transmit fee" and cheating (drop my transaction on the floor)?Satoshi's proposal that all transaction carry a minimum fee to cover network overhead makes sense; whoever generates the block with the transaction gets the fee. Ummm, the command-line RPC is implemented on top of the JSON-RPC mechanism.So if the command-line RPC is working on your machine, then the JSON-RPC is, too. Hah!  While I was typing this, Kiba said essentially the same thing...We are all rich because we have computers and the Internet and Wikipedia and other wonders the world has never seen before.There is absolute wealth.  We are healthier and wealthier and live longer than any previous generation, and that's a wonderful thing. Yeah, I shoulda anticipated problems when Bitcoins went from 0.005 USD each to 0.06 each.  If it takes somebody two minutes to go through the "get a new IP, get a new BC address, solve the captcha" process then they'd make 5*30=150 bitcoins an hour, which is $9 USD an hour, which, if you're unemployed, bored, and/or 13 years old is easy money. Thanks for all the ideas!First: I'm definitely going to drop from 5 BTC; I think I'll go all the way down to 0.50 BTC (rather than do 1 or 2).  Giving away a percentage of how much the faucet has is an interesting idea, but I want it to be as simple as possible.Second: I really don't want to make getting coins from the Faucet a whole heavy-weight "register and check your email and yada yada yada."But I do like the idea of adding an extra hurdle for 'suspicious-looking' behavior.  So I'm leaning towards doing some fuzzy browser fingerprinting combined with rate-limiting and, if you look suspicious or the fountain has been giving away a larger-than-usual number of coins, require that you login with your google account before getting any coins.  No google account: no coins.It is hard to create lots of google accounts; they're requiring either phone or SMS account verification these days... I just shut down freebitcoins.appspot.com; it looks like somebody in Spain is being a jerk and getting a new IP address, bitcoin address, and solving the captcha.  Over and over and over again:Code:79.154.133.217 - - [04/Aug/2010:12:46:55 -0700]"POST / HTTP/1.1" 200 1294 "https://freebitcoins.appspot.com/""Opera/9.80 (Windows NT 6.0; U; es-LA) Presto/2.6.30 Version/10.60,gzip(gfe)"79.146.112.13 - - [04/Aug/2010:12:45:20 -0700]"POST / HTTP/1.1" 200 1294 "https://freebitcoins.appspot.com/""Opera/9.80 (Windows NT 6.0; U; es-LA) Presto/2.6.30 Version/10.60,gzip(gfe)"81.44.159.81 - - [04/Aug/2010:12:42:20 -0700]"POST / HTTP/1.1" 200 1294 "https://freebitcoins.appspot.com/""Opera/9.80 (Windows NT 6.0; U; es-LA) Presto/2.6.30 Version/10.60,gzip(gfe)" Those IP addresses all map to Telefonica de Espana.  If it was you:  give them back, please: 15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsCNow that 5 bitcoins is worth a fair bit, I'm thinking I need more cheating countermeasures.  I can think of four things to try:1. Rate limit based on the first byte of the IP address (79. or 81. in this case).2. Rate limit based on the USER-AGENT string ("Opera/9.8..." in this case).3. Rate limit based on last two domains of reverse DNS lookup of the IP address (rima-tde.net in this case).4. Make the standard amount given away 0.5 Bitcoins (Bitcoins have gone up 10 times in value since I started the Faucet).If you get rate limited, you'll get a message that asks you to try again tomorrow.BitcoinFX: thanks again for the donation to the faucet; I'm going to drain the Faucet below 500 coins temporarily, and will refill it with your donation after the new cheating countermeasures are in place. The rule is "if any TxOut (output) has a value of less than 0.01 bitcoins, charge a 0.01 fee":Code:main.h:foreach(const CTxOut& txout, vout)  if (txout.nValue < CENT)    nMinFee = CENT; ... unless B started with zero bitcoins.  Then B is stuck; she can't send 1.0 back, because doing that would cause a 0.00000001 bitcoin 'change' transaction, which would trigger the 0.01BTC fee, which they can't pay (because they only have 1.0000000001). Perl's LWP module definitely sets the Content-Length header.  I would've been surprised if it didn't, since it is required by HTTP 1.0 and the HTTP 1.1 spec says clients 'SHOULD' set it.After some struggle, I got the first JSON::RPC library at CPAN to work:Code:use JSON::RPC::Client;use Data::Dumper; my $client = new JSON::RPC::Client;$client->ua->credentials(   'localhost:8332', 'jsonrpc', 'my rpcusername' => 'my rpcpassword'   # Replace with real user/pass    );my @foo = $client->ua->credentials('localhost:8332', 'jsonrpc');print "@foo\n";my $uri = 'http://localhost:8332/';my $obj = {    method  => 'getinfo',    params  => [], }; my $res = $client->call( $uri, $obj ); if($res){    if ($res->is_error) {        print "Error : ", $res->error_message;    }    else {        print Dumper($res->result);    }}else {    print $client->status_line;}The struggle was setting the realm to 'jsonrpc' (it is fussy about that).  I'll document that on the wiki. Can you be more specific about which JSON libraries don't provide Content-Length ?  It'd be nice to document that. Transactions won't disappear if they're valid.  They'll just move to the longer block chain.Invalid transactions would be somebody trying to double-spend across the split chains (which would be tricky-- you'd have to run a modified client, or copy your wallet to a machine working on the other block chain).Or if the split lasted long enough (more than 100 blocks), transactions that involve generated coins on the shorter chain would be invalid at the merge.For shorter splits, immature generated coins on the shorter chain will disappear when the chains merge, but that would be about the worst consequences for honest users (unless you were unlucky enough to get an invalid coin from somebody trying to cheat). I don't think you need scripts to do something like that.Just send a bitcoin to yourself, and then declare that transaction is the "root transaction for My Valuable Asset." You'd need a custom client that only accepted or spent transactions that could be entirely traced back to that Root Transaction (not hard, all transactions can be tracked back).  And shows fractions of that coin as units of your custom currency.  And you'd probably want to make some other changes so your users didn't accidently (or purposely) mix Your Valuable Asset coin with regular bitcoins (like a custom wallet and different scheme for generating payment addresses). Yep, you're right.  The good fork is longer than the bad one now; the last ORPHAN BLOCK my TEST bitcoind got was about 20 hours ago. svnTEST branch is up on github.I also uploaded just the production-bitcoin-to-TEST-network-bitcoin patches to github, at: http://gist.github.com/502460... so:Code:curl http://gist.github.com/raw/502460/2182724de9ef2d6721bf0e0962cc6a6895bcbee4 | patch -l... should patch production network source code to TEST network.  And:Code:curl http://gist.github.com/raw/502460/2182724de9ef2d6721bf0e0962cc6a6895bcbee4 | patch -l --reverse... will go the other way. That IS part of the new -port / -rpcport code (I use boost::interprocess::file_lock to make sure bitcoins running on different ports don't try to use the same wallet/blkindex/etc files).I'll create an svnTEST branch that omits those changes, and will always be just a TEST-network version of the latest svn trunk. Cool!  Hope you don't mind, I added it to my github network as a 'feature' branch.
Can you be more specific about where your build fails?  Is it in the new code to support the -port / -rpcport options (which I should have put on a different git branch) ? It's pretty common to turn maps into objects, so you can use syntax like:  foo.tx_id... instead of foo['tx_id'].  Especially if you're doing something like passing the data into a templating system (which may ONLY understand the object.field syntax).And foo.class just doesn't work out nicely. I just updated my git "svn" branch with r116-119, and also merged it against 'master'.The git network diagram showing what I done did is kinda pretty. The good news is the TEST network is doing its job-- the problem patched by the 0.3.6 release (invalid transactions accepted as valid) was implemented and demonstrated on the TEST network.The bad news is that means the TEST network block chain split yesterday.  If you are, or were, running a release prior to 0.3.6 on the TEST network, you've got bad blocks in your blkindex.dat and blk0001.dat files.So, you need to:1. Shut down bitcoin or bitcoind2. Remove the blkindex.dat and blk0001.dat (in ~/.bitcoinTEST or ~/Library/Application Support/BitcoinTEST or %APPDATA%\BitcoinTEST) files.3. Be sure you're upgraded to 0.3.64. Run bitcoin/bitcoind, and you'll download the "good" block chain.Any blocks you generated after the bad blocks are invalid, so if you were busily generating blocks on the TEST network in the last couple of days... sorry, that play money is gone.Transactions that you made may or may not make it to the new block chain, depending on whether or not they originated from invalid coins (any coins generated after the bad blocks are invalid). Speaking of the network...... is there any really robust, generic, low-latency, open source p2p network "middleware" out there?I think using protocol buffers as the serialization format is a good idea, but I don't think just switching to protocol buffers "buys" enough to be worth the effort (at least not now, when transaction volume is low).I'd like to see some experimenting with running bitcoin on top of a different networking layer (and use protocol buffers, too).  Is there a p2p network that is designed to be extremely highly reliable and difficult to infiltrate or attack with malicious nodes? Couple of quick suggestions:Using the key name "class" will cause problems for, at least, JavaScript, and probably other languages where "class" is a reserved word.  "type" or "variety" or some other synonym will cause fewer problems later.Or, maybe better, get rid of that field and just report credits as positive numbers and debits as negative.  And add a separate "generated" field (boolean true or false).Since each entry refers to a transaction, I'd suggest adding a "tx_id" SHA256 hex-encoded transaction id.  Then listtransactions would play nicely with the refundtransaction JSON-RPC extension (and maybe a future gettransactiondetails that let you get transaction parents, which block the transaction was in, and so on).Code to get that would look something like:Code:            uint256 tx_hash = transaction.GetHash();            string tx_id = tx_hash.GetHex();            mapJSONResponse.push_back(Pair("tx_id", tx_id)); That second ./bitcoind getinfo has to be:Code: ./bitcoind -datadir=/home/theymos/bitcoin -conf=/home/theymos/bitcoin/bitcoin.conf getinfo... otherwise it will use the default config file and datadir. He/she/they want an easier way for The Crowd to control The Policy-- right now, if you know enough C++ to modify and compile your own version of Bitcoin and can convince enough other people to use your version, then you can change Policy.Allowing everybody to tweak Policy and having some sort of mechanism that figures out what "everybody" wants to do is an interesting idea.  I have no idea how you could actually make it work, and it would open up a whole other can of potential security problems (what if somebody controls a bunch of IP addresses and decides to "vote" for a policy that benefits them?  or can you tie the policy changes to proof-of-work somehow?  How do you aggregate what "everybody" thinks in a non-spoofable way? etc etc etc)... Are you still downloading the block chain?  If you don't already have all 70,000+ blocks in the block chain, then you transaction won't show up as confirmed until you catch up. I built a TEST-network bitcoind with the SVN r115 changes merged in, and yes, after that one change it's been happily generating coins all afternoon.I don't use the stock makefile.osx, though-- I setup the dependency directory structure a little differently (for no really good reason). If you include a double-spent transaction in a block you generate, then that block will be rejected and you don't get your 50BTC reward. I get:Code:/var/folders/n7/n7Do3Krz2RWPeE+1YxvhUU+++TM/-Tmp-//cc8PgHsQ.s:879:suffix or operands invalid for `call'... compiling cryptopp/sha.cpp (latest SVN source) on my Mac (gcc version 4.2.1).I fixed it by adding -DCRYPTOPP_DISABLE_ASM  to my makefile; perhaps somebody with more experience compiling C++ on a Mac can figure out a better fix. Does it work if you specify the full path?  e.g. -datadir=/home/psyvenrix/datadir2  ? Before the last two difficulty adjustments it took my (4-year-old) mac laptop two weeks to generate any bitcoin.So after the adjustments, I estimate it could take it 1-2 months to generate any. I've been working on adding -port= / -rpcport=  command line / config file options to bitcoin.  The idea is to let you run multiple copies of bitcoind on one machine; I need this because I'm planning on having at least two Bitcoin-related web services (the Bitcoin Faucet and a service to be named later), I want them to have completely separate wallets, but I don't want to rent multiple servers to host them.Usage looks like this:Code:$ ./bitcoind getbalance  # The TEST network Faucet bitcoind40616.66159265000$ ./bitcoind -datadir=/home/bitcoin/.bitcoinTEST2 getbalance1000.000000000000$ cat /home/bitcoin/.bitcoinTEST2/bitcoin.confrpcpassword=.....port=18666rpcport=18665Satoshi pointed out that allowing bitcoin/bitcoind to run on a non-standard port could be dangerous, because if misconfigured two bitcoins might both open and write to the same database.  To prevent that, the <datadir>/db.log file is used as a lock so only one bitcoin can access the same datadir at a time (uses boost::interprocess::file_lock, which is purported to be cross-platform and well-behaved, even if bitcoin crashes).Issues that came up as I was doing this:I left a call to wxSingleInstanceChecker in the Windows GUI code, so no multiple-gui-bitcoins-listening-on-different-ports on Windows.  I don't do Windows...I didn't bother making the error handling graceful if you point two bitcoins at the same datadir (you get a runtime exception "Cannot lock db.log, is bitcoin already running?").Patches are at http://pastebin.com/2e4hfXSS; I've only tested on Linux so far, anybody willing to try this on Windows? I've been tempted... but no, I'm more interested in doing web-based Bitcoin apps, and extending the existing C++ implementation's JSON-RPC API is a whole lot less work than re-implementing the whole shebang. Great catch!  Simpler fix is to specify the BIO_FLAGS_BASE64_NO_NL in the rpc.cpp/EncodeBase64 function:Code:diff --git a/rpc.cpp b/rpc.cppindex 72bdc50..703b757 100644--- a/rpc.cpp+++ b/rpc.cpp@@ -765,13 +765,14 @@ string EncodeBase64(string s)     BUF_MEM *bptr;      b64 = BIO_new(BIO_f_base64());+    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);     bmem = BIO_new(BIO_s_mem());     b64 = BIO_push(b64, bmem);     BIO_write(b64, s.c_str(), s.size());     BIO_flush(b64);     BIO_get_mem_ptr(b64, &bptr); -    string result(bptr->data, bptr->length-1);+    string result(bptr->data, bptr->length);     BIO_free_all(b64);      return result; Well, at least do it on the TEST network FIRST!If you manage to break the TEST network, it's a pretty good bet that you'll be able to break the production network.  If it doesn't break the TEST network, then I'd say go ahead and run against the production network to look for "scaling up" problems. Answering my own questions:  Project using CMakeI looked at 'weechat'; they're migrating from gnu autotools to cmake (still support both, but recommend cmake).So another +1 for cmake. Is there something simpler than CMake that would work?cmake-2.8.2.tar.gz - 5.1MBcmake-2.8.2-Darwin-universal.dmg - 27.2 MBAdding Yet Another Multi-Megabyte Dependency to build bitcoind seems like a backwards step to me.What's the most popular build solution for other small-ish, successful open source projects?
They key bits of code are:Code:fileout << FLATDATA(pchMessageStart) << nSize;...fileout << *this;pchMessageStart are the four magic bytes, and those are written with FLATDATA.The CBlock itself is written by << *this, and that's done by the IMPLEMENT_SERIALIZE in main.h:Code:    IMPLEMENT_SERIALIZE    (        READWRITE(this->nVersion);        nVersion = this->nVersion;        READWRITE(hashPrevBlock);        READWRITE(hashMerkleRoot);        READWRITE(nTime);        READWRITE(nBits);        READWRITE(nNonce);        // ConnectBlock depends on vtx being last so it can calculate offset                                                     if (!(nType & (SER_GETHASH|SER_BLOCKHEADERONLY)))            READWRITE(vtx);        else if (fRead)            const_cast<CBlock*>(this)->vtx.clear();    )The READWRITE macros Do The Right Thing, reading in or writing out the members in a machine-independent way.See http://github.com/gavinandresen/bitcointools for simplified Python code that can dump out transactions and blocks. If a philanthropist wants to give away bitcoins to the bitcoin community, I'd be happy to reset the Bitcoin Faucet rules to whatever the philanthropist would like.Could be:  donate 10,000 Bitcoins and then have the Faucet distribute 10 per IP address (regardless of whether or not they got coins from the Faucet before) until they're gone. Yes, that's right, rpcpassword is only required if you use -server or -daemon or bitcoind (I just tested to be sure).RE: what if the programmer can't figure out how to make their legacy COBOL code do HTTP authentication?Then I think another config file setting to explicitly turn off RPC authentication would be better than a magical "if you set a blank rpcpassword then that turns off authentication."   But I wouldn't implement that until somebody really does have a problem or until we have more than one way of doing the authentication (maybe https someday...).lachesis: is supporting HTTP Basic Authentication a problem for you? What's funny?A server lying about whether or not your transactions are valid would be like your ISP lying about whether or not your HTTP requests are valid or not.If they lie, you'll very quickly find another service provider (or download a Bitcoin iPhone app that doesn't suck and say that your transactions are invalid). I strongly disagree; software should be secure by default, and running bitcoind without a password (or bitcoin -server) is definitely NOT secure.I just don't see somebody saying "Man, Bitcoin sucks because I have to add a password to a configuration file before running it as a daemon."  I can see somebody saying "Man, Bitcoin sucks because I accidently ran it with the -server switch and somebody stole all my money." OK, I did Python and PHP, and I added what I know about Java.  Can somebody who has used Java JSON-RPC update the wiki page with a working example? I've updated the RPC wiki page for how the password stuff will work in Bitcoin 0.3.3.One nice side effect: you can prepare for the changes now; create a bitcoin.conf file with a username and password and modify your JSON-RPC code to do the HTTP Basic Authentication thing.  Old code will just ignore the .conf file and the Authorization: HTTP header.Question for everybody:  should I add a section to the wiki page describing, in detail, how to do HTTP Basic authentication?  PHP and Python make is really easy-- just use the http://user:pass@host:port/ URL syntax.  I don't want to just duplicate the HTTP Basic authentication Wikipedia page. TxIn: prev(82df...6428:1) means the second TxOut of transaction 82df...something...6428  (it abbreviates the full 256-bit transaction hash and starts counting at zero).To see that transaction:Code:gavin$ dbdump.py --transaction=82df...64281 tx in, 2 out['TxIn: prev(bfb0...cd16:1) pubkey: 17muZqKMEFqzefsqYhR9vqBjz1jNVcDcbh sig: 71:3044...0201 65:0480...af42']['TxOut: value: 0.05 pubkey: 1GVgigFDZ9pPLyYwxboEoaSDMDbsBQPVMx Script: DUP HASH160 20:a9f6...9268 EQUALVERIFY CHECKSIG', 'TxOut: value: 66.07 pubkey: 1LsvDRhoMmH5YeZDAxaP5rqwNTp3xFCF3Q Script: DUP HASH160 20:da0b...a345 EQUALVERIFY CHECKSIG']This looks like bitnickels coins coming out of the Bitcoin Faucet.  The transaction before THAT is:Code:gavin$ dbdump.py --transaction=bfb0...cd161 tx in, 2 out['TxIn: prev(b1dd...5cd9:1) pubkey: 1MQNsNwRHTu7MWPgFRGRRZfo58jU3RGxJv sig: 73:3046...8501 65:041b...6624']['TxOut: value: 0.05 pubkey: 1GVgigFDZ9pPLyYwxboEoaSDMDbsBQPVMx Script: DUP HASH160 20:a9f6...9268 EQUALVERIFY CHECKSIG', 'TxOut: value: 66.12 pubkey: 17muZqKMEFqzefsqYhR9vqBjz1jNVcDcbh Script: DUP HASH160 20:4a4e...e0c3 EQUALVERIFY CHECKSIG']To compute the net transaction value, just add up the values of all the TxOuts; they have to equal the sum of all the TxIns (well, unless there are transaction fees).  So for that first transaction, 66.07+0.05 = 66.12 (which is, indeed, bfb0...cd16:1) I think this won't work because there is not a one-to-one relationship between "unspent transactions" and public keys.Example:  I start with 0 BTC.  Two people each send me 50, to the same receiving address "GavinPubKey".Balance Sheet:  GavinPubKey: 100I spend the first one:Balance Sheet:  GavinPubKey: 50If I'm dishonest, what stops me from waiting a few months and then spending that first 50 again instead of spending that second 50?  Double-spending that first 50 will look like a perfectly valid transaction to any nodes using the balance sheet method who weren't around to see the first time I spent it. I've implemented it so that all the command-line options can also be specified in the bitcoin.conf file.Options given on the command line override options in the conf file.  But I need to do more testing, especially with the "multiargs" options like "addnode". I volunteered to implement this, and made good progress today.  Satoshi: I should have patches for you tomorrow.Done: teach Bitcoin to read settings from {BITCOIN_DIR}/bitcoin.conf file, and added -conf=path_to_config_file.conf command-line option.  Done: teach Bitcoin RPC to require HTTP Basic authentication, and reject requests with the wrong username/password.TODO: teach Bitcoin command-line RPC to add the Authorization: header.  You won't have to give the username/password when controlling bitcoin from the command line, it'll read them from the bitcoin.conf file and Do the Right Thing.TODO: dialog box or debug.log warning if no rpc.user/rpc.password is set, explaining how to set.TODO: limit password guessing attempts if the rpc.password is < 15 characters long.TODO: update the JSON-RPC wiki pageAfter all that is done and I've sent patches to Satoshi, I'm going to add a couple more things to bitcoin.conf :port=   # to set the listen port (override default 8333)rpc.port= # to set the JSON-RPC port (override default 8332)With the existing -datadir option, that'll make it easier for me to run multiple bitcoins on one box. chroot: won't protect you.Running as a separate VM:  I think will protect you.  But I thought browsers wouldn't allow XMLHTTPRequests to "localhost" from web pages fetched from the web, so my advice would be to test it.  See if you can talk to the Bitcoin daemon from another VM on the same machine by running "bitcoind getinfo" or "bitcoin getinfo" on the non-bitcoin-vm. You can still generate bitcoins, just don't run bitcoind or bitcoin -server or bitcoin -daemon on machine that you use to browse the Web.As sirius says, if you do you could browse to a website that empties your Bitcoin wallet without your knowledge or permission. I sent him 10 Bitcoins, and my hair grew back!So I sent him 20 Bitcoins, and I won the lottery!No Joke!!!!  Now I'm hairy and rich!!!! I think there's no such thing a a "typical" settings file on Linux!I just did a quick survey of 20 .conf files in /etc on my debian system, and found: 1 file used "key value" 5 used "key=value"  (actually, a couple were  "key = value", allowing whitespace around the "=") 14 did their own thing.The 14 that did their own thing were all over the map; from one-value-per-line to "key:value" to full-blown XML.  # isthe universal comment character in the Linux world.My vote would be for:# commentkey1=value1 I'm not personally notified, no...     But if I have a Bitcoin client connected to the network then yes, it (along with all the other connected clients) should be sent every transaction shortly after they happen.  It has to-- it might be generating blocks, and the whole point of block generation is to record the valid transactions the client has seen that haven't been included in a previous block.There's a discussion in this thread of how likely it is that an attacker could "split the network" to successfully double-spend coins. See the "Bitcoin snack machine" discussion.Real-world, ordinary-sized transactions should wait a few seconds for the transaction to propagate across the network. There are already a few places in the source code where that is done.I think Satoshi's done a darn good job of anticipating future needs.  The wire protocol and database serialization formats both have version numbers, as do bitcoin addresses.  The core transaction mechanism is very flexible (I worry that it might be too flexible, but that's why we've got the TEST network to see if we can break it).I can't think of anything simple that would make it more future-proof.  If you're worried about SHA256 getting broken or the 21quadrillion Bittiestcoins not being enough... then you worry too much.  Stop worrying, you'll just suffer from analysis paralysis and get nothing done. You ask hard questions!  Most common: probably Windows INI files, because Windows is most common OS.I'd lobby for using JSON; it's (mostly) a subset of YAML (which is a common choice for config files), so any JSON or YAML parser will read it.I think the only big advantage is that it keeps authentication where it belongs in the transport layer, so if, in the future, you do want to go with full-fledged HTTPS with certificates the API doesn't have to change.No, I just confused "command" with "parameter", and did this:Code:> bitcoind helperror: First parameter must be the password.> bitcoind <my password> helperror: unknown command: <my password>>bitcoind help <my password> ... that works. I think that's a politically correct way of saying "we accept food stamps."   Try going in with a fistful of Euros and see what happens.
After further research...  I think the Transmission approach, combined with the existing "only allow connections from 127.0.0.1" is a good short/medium-term solution.Putting the username:password in a settings.json file in the Bitcoin directory aught to work nicely (since Bitcoin can already parse JSON).  And keeping the authentication stuff off the command line and in the HTTP headers instead of the JSON request params is nice and clean.Long term, the "right" way to do authenticated, secure JSON-RPC is with client-side certificates and https.    But that looks like it would be a lot of work to implement and a big learning curve for users to figure out how to generate client-side certificates and how to get both sides of the JSON-RPC connection using them.   And I'm not even certain a full-blown client certificate solution would solve the problem of malicious Javascript making JSON-RPC requests via XMLHttpRequests to localhost; if the user installed the client certificate in the browser (because maybe there was a nifty JSON-RPC-powered web front-end to controlling Bitcoin), would the browser automatically send the client certificate if a malicious website made requests? The Transmission BitTorrent client does authenticated JSON-RPC; see "Remote Control" section of: https://trac.transmissionbt.com/wiki/ConfigurationParametersE.g. setting.json file might look like:Code:{    "rpc-enabled":1    "rpc-authentication-required": 1,    "rpc-password": "xxxxxxxxxx",    "rpc-port": 9091,    "rpc-username": "xxxxxxxxxx",    "rpc-whitelist-enabled":1    "rpc-whitelist":"127.0.0.1,192.168.*.*"}It uses HTTP 'basic' authentication (Authorization: basic base64(username:password) in the HTTP headers). The Bitcoin Faucets (production and TEST) are now running with this change.I was confused for a bit because the password is given LAST on the command line, but FIRST in the JSON-RPC params list.  I agree that reading the command-line password from a file would be more convenient and more secure.I'll try to do some research on how other projects tackle JSON-RPC authentication. A few things make those 31.42BTC transactions unique:+ The timestamps in them will be different.+ The input transactions will be different (you can think of those as being different 'coins' going in to make the payment).+ And if the input transactions don't add up to exactly 31.42 (and they probably won't), they'll have different output transactions for returning any change to Alice.By the way: all that stuff is hashed together to give each transaction a unique 256-bit transaction ID (which you never see, but is used internally so Bitcoin can quickly figure out if it has already seen this transaction before). Yes.  Whoever has the private key that can create that last signature can spend the coin-- he or she (or them-- eventually maybe as bitcoin clients add features) are the owner.The transaction history isn't exactly a "chain" -- multiple coins can get combined as input to a transaction (they're all "spent"), and multiple coins can get produced from a transaction (they're all "unspent" until they're used as the input to another transaction), so it's a more complicated network (I think of a chain as one link followed by another in a straight line).  But it will all trace back to one or more 50 Bitcoin GENERATE transactions. Y'all know about http://twollars.com/? If that coin is one of the inputs to a later valid transaction, then it is spent and cannot be spent again.That later transaction is the record that somebody spent the coin; it is signed with the private key, and that key (which Bitcoin keeps for you in your wallet) should be known only to the owner. Here's how you can lose coins by backing up and restoring your wallet file:Lets say you have one shiny 1,000 Bitcoin coin in your wallet (it's actually just a transaction for 1,000 bitcoins paid to a public key that's stored in your wallet).You backup that file.Now you spend 1 Bitcoin.  Your shiny 1,000 BTC coin is broken into 1BTC, plus 999BTC in change.  That change is given a new, different public key.Now if you restore your wallet file, Bitcoin sees that the 1,000BTC coin has been spent-- 1BTC was sent somewhere, and the other 999BTC was sent somewhere else.  Because you don't have the key for the 999BTC, it has no idea that those coins belong to you.So they're lost.Trying out alternative policies for handling change on the TEST network would be a good idea, in my opinion.Maybe change transactions should always get signed with the same public key, so you wouldn't lose coins when restoring your wallet... although that would give you less privacy because it would tend to tie all your transactions together.Maybe your wallet should get initially populated with 100 "change" addresses, with one randomly chosen as needed.  And some super-geeky way of replacing them with another, new, 100 addresses.Maybe there's an even better way of handling the "I lost BTC when I restored my wallet" problem; ideas? TESTcoins are maturing, and the TEST Faucet is open and giving out 50 TESTcoins per visit:  https://freebitcoins.appspot.com/TEST/Feel free to grab some play money any time; there's no coins-per-IP-address limit, but you will have to solve the CAPTCHA if you revisit. Unix and Mac and Windows all have ways of scheduling recurring tasks (Linux: crontab, Mac: crontab, or I think iCal can do it, Windows... I dunno).So if you're a little bit geeky, you could arrange for "bitcoin sendtoaddress 1mJMYFAVORITECHARITY9R4 amount" to get run once a month.  (just run bitcoin with the -server flag). The TEST Faucet will be running on host:  li133-197.members.linode.com(starting tomorrow, if all goes as planned).  You can connect to it to bootstrap. I know EricJ2190 tried out the test network today-- Eric (and anybody else who might have compiled and run) you need to git pull, recompile, and nuke your ~/.bitcoinTEST directory.  The client was generating blocks WAY too fast.That'll teach me to go messing with code I don't really understand (on the bright side, I now know what the OpenSSL BN_bn2mpi() routine does).Oh, and Eric:  I added your pnSeed fix to my git branch. Every generated coin gets a unique address, so you until they get bundled together and sent somewhere you don't know to whom ("whom" as in "which Bitcoin Address") they belong.You can get the top 10 addresses that have received the most coins (and could figure out how many have gone back out), but there will probably be a lot of generated coins that have never been spent which will just look like little 50-coin islands.Yes; the BitFountain BitTap BitFaucet donation address doesn't change, so you can see how many bitcoins have gone in. That's like saying: "Gold atoms are unstable because quantum mechanics tells us that there is a >0 possibility that they will spontaneously decay."Yes, in the very very very long run the universe will suffer heat death and there will be no gold (or any other atoms) left.If the probability of bank runs is very small, then fractional reserve banking works.  Or, in other words, if banks can establish and maintain trust in their ability to repay deposits they'll be stable even if they practice fractional reserve banking.I hope we'll eventually find out the hard way if, or which, Bitcoin banks can establish and maintain trust. That's right.One of Bitcoin's big advantages is that you can be your own bank; you don't have to trust a government-backed fractional reserve bank to keep your extra cash safe.If you WANT to trust a fractional-reserve Bitcoin Bank, feel free.  But don't go crying to your congressman if you lose all your money, please. It's ALIVE!Source on git now has:+ different genesis block+ ridiculously easy minimum proof of work threshold+ protocol message header bytes are { 0xfa, 0xbf, 0xb5, 0xda } instead of { 0xf9, 0xbe, 0xb4, 0xd9 }If you compile and connect and turn on coin generation you'll generate a lot of play money quickly...(I've turned off generation, but will keep my three clients -- two Linux, one Mac -- connected) There's a stackoverflow question about double hashing, by the way.  Consensus is that it's not less secure.  It's too late for my brain to process the nuances of hashing... Very good point about the genesis block.Unfortunately, I'm not exactly sure HOW to generate a valid genesis block; I can tweak the data but need to generate a valid block hash... hmm, I see some time in gdb in my near future...RE: changing the protocol version:  Good Idea, too.  Every wire protocol message starts with the bytes '{ 0xf9, 0xbe, 0xb4, 0xd9 }', I'll tweak that in the TEST code so TEST and production clients can't talk to each other even if they manage to get connected. Yep, Americans have been getting a really sweet deal from the Chinese for a while now-- we send them pieces of paper with dead presidents on them (well, the electronic equivalent) and they send us all sorts of useful stuff. If I understand correctly, you've got two chances to find a collision instead of one.So this decreases the security of SHA256 by a factor of 2... which is just Not a Big Deal.  Bitcoin is using, essentially SHA255 instead of SHA256.  It'll still take longer than forever to find a collision...
I went ahead and created a modified Bitcoin client with a brand-new block chain and a few other changes (detailed below) that will make it independent of the "production" Bitcoin network.I intend to use it to test out some code I'm writing for my next project; I don't want to accidentally break (or slowdown or otherwise interfere with) the real Bitcoin network.  It should also be useful for anybody who wants to see if they can purposely break Bitcoin (for the purposes of a security audit).Code is hosted at github: http://github.com/gavinandresen/bitcoin-gitPatches to go from 'production' bitcoin to 'TEST network' bitcoin are also at github: http://gist.github.com/502460... so go nuts and start hacking.Changes are:+ Listen port is 18333 (instead of 8333).  Uses 18332 for JSON-RPC (instead of 8332).+ Uses irc.lfnet.org channel #bitcoinTEST  for bootstrapping.+ Never tries to connect to "well known" nodes for bootstrapping.+ Uses bitcoinTEST for the default data directory (e.g. ~/.bitcoinTEST on Linux, %APPDATA%/BitcoinTEST on Windows, etc)+ Uses a different ADDRESSVERSION for Bitcoin Addresses (0xff instead of 0x0), so you can't screw up copying and pasting Bitcoin addresses (if you try to use a TEST address on the production system it will tell you it's invalid; you can, however, lose TESTcoins by trying to send them to a valid production address)++ Has a brand-new block chain (with a different genesis block)++ Initial difficulty is 4 times easier than production Bitcoin++ protocol message header bytes are { 0xfa, 0xbf, 0xb5, 0xda } instead of { 0xf9, 0xbe, 0xb4, 0xd9 }(16 July: "++" stuff added in response to the suggestions below in this thread)A very generous TEST Bitcoin Faucet is running at: https://freebitcoins.appspot.com/TEST/I think the TEST and production GUIs don't play well with each other; at least on my Mac, I have to quit the "real" bitcoin before running TEST.  That's probably an easy fix, I just need to figure out how... Ok.As long as I get eleven.(it's my favorite number) So about two hours ago (8AM EST, 24 July) I see a big spike in traffic to the Bitcoin Faucet:What's up with that?  The slashdot effect was just tapering off... Thanks Xavier!To everyone else:  the Faucet is now giving out bit-nickels; it just went under 500 BTC.  I've got just under 2,000 BTC left to refill it, but I think I'll start letting it drain a nickel-at-a-time and keep it above zero for as long as I can (refilling it to just under 500 if it gets near zero). 5 lots (25 BTC) on 011 please.Eleven is my favorite number. My point was that if "they" mount an attack, I think they're unlikely to do something subtle like try to mess with the block chain.If "they" want to mess with the network, it would be far easier to do something like what China's doing with its Great Wall-- forcing connections they don't like to be dropped.  Or what botnets do now:  mount a denial-of-service attack by flooding the network.Much more likely:  "they" will catch you for tax evasion when you convert your bitcoins to your local fiat currency and buy that fancy sports car you've always wanted. Making it easier for merchants to accept bitcoins, and users to pay using them, aught to be priority number 1.There's a great talk by the CTO of Facebook available on Youtube, and I think he gave the right advice on scaling:Don't worry much about it until just before it becomes a problem.  Don't overengineer, because you're likely to waste time doing something that turns out to be irrelevant.I think Satoshi has done an amazingly fantastic job; over the last two days of Bitcoin being "slashdotted" I haven't heard of ANY problems with Bitcoin transactions getting lost, or of the network crashing due to the load, or any problem at all with the core functionality.Yes, it's annoying to have to wait for the block chain to download (especially with the Microsoft Security Essentials weirdness), and yes it would be nice if all the pieces of Bitcoin functionality were already nicely separated and ready to be rearranged and extended in all the ways we all want to rearrange and extend it.  But I've been poking at the Bitcoin code for over a month now, and the more I learn the more impressed I become at the thought that's gone into it.This quote seems appropriate:"We reject: kings, presidents and voting.We believe in: rough consensus and running code."  -- David D. Clark Yeah, that would be a good problem to have.Why would they mess around with the block chain, though?  Are you imagining the men in black double-spending enough Bitcoins to make merchants think it is untrustworthy? ("I shipped 100 computers to Langley, Virginia when the transaction had six confirmations, and now there's a new block chain that says those coins were paid to somebody else!!!") I'm imagining:A lightweight client would have a wallet with coins in it (public+private key pairs).And a secure way of sending messages to, and getting messages from, any of the ultra-fast, always-connected heavyweight nodes.The lightweight client sends money by:  creating a transaction (signing coins with the private key)  sending the signed transaction securely to the ultra-fast server, which puts it on the network.  receiving confirmation that the transaction was valid and sent, and updating its wallet (marks coins as spent)   (or getting a "you already spent those coins" error from the server)The lightweight client receives money by:  Either polling the server every once in a while, asking "Any payments to these BC addresses that I have in my wallet?"   ... or asking the server to tell it whenever it sees a transaction to a list of BC addresses (or maybe when it sees    a relevant transaction with N confirmations)  When transactions occur, the lightweight client updates its wallet (adds the coins).You don't have to trust the server; it never has your private keys.Well, you do have to trust that the server doesn't lie about whether your transactions are valid or not, but why would the server lie about that? No, actually, in the current source code it never gets lowered:Code:    // Retarget    CBigNum bnNew;    bnNew.SetCompact(pindexLast->nBits);    bnNew *= nActualTimespan;    bnNew /= nTargetTimespan;    if (bnNew > bnProofOfWorkLimit)        bnNew = bnProofOfWorkLimit;    /// debug print    printf("GetNextWorkRequired RETARGET\n");There's no "else if (bnNew < ...something)"UPDATE:  rodin is right, I'm wrong.  bnProofOfWorkLimit is a constant, and this code just make sure the proof of work never gets too easy. That sounds about right.So a million transactions a day would be 600 million bytes.  600 megabytes a day, 18 GB a month.That's not bad.  Actual network bandwidth will be higher (the way the network is connected you get the same transaction multiple times from your peers).  You won't be running an always-connected-network node on your iPhone, but any low-cost server will give you twenty times that bandwidth per month.  And 18GB isn't much disk space in these days of terabyte hard drives.A million transactions per day is a LOT!  For comparison, in 2006 there were about 60 million credit card transactions per day in the US.Eventually, if Bitcoin survives and gets as popular as credit cards for paying for stuff I expect somebody will create a compatible version with a more efficient network structure (maybe by that time there will be some fancy IPV6 multicast protocol or something).  And they'll implement a couple of gateway nodes (running on really fast connections) that shuttle transaction and block traffic from the current Bitcoin network into the super-efficient network.  And I expect most of us will be running lightweight clients that just keep our wallets, sign transactions, and send and receive transactions to the ultra-fast nodes that ARE looking at every transaction.You know, kind of like how we have those Big Routers in the Sky that handle Internet backbone traffic (or the ultra-fast DNS root servers).  The Internet didn't start out with astoundingly fast routers zinging packets around. ... like how the RIAA screws around trying to disrupt BitTorrent swarms...Umm, good luck with that.  I'm betting The Swarm will win most of the battles. After he's downloaded all 66,312 blocks and is up-to-date, transactions are very fast. Thanks for the donations... whoever you are who donated!The Faucet has about 2,000 coins in it at the moment; I just deployed a new version that will automatically start giving out bit-nickels if the balance falls below 500 (but allows anybody who gets a bit-nickel to come back later and get the 5 bitcoins "they deserve" if/when the Faucet is refilled). Yeah, I could, but it seemed like more trouble than it was worth; if you got coins from the Faucet into a non-empty wallet and then donated them back there's no guarantee that the donation back would be the SAME coins.  I just don't want to deal with a lot of "I got five coins and then sent back ten but I still can't get more from the Faucet...." Transactions with "0 confirmations" are transactions that your client has seen, but haven't been put into a block yet.Here's what happened when you bought the bitcoins:Seller:  "Hey Bitcoin Network!  These here Bitcoins are getting sent to that there Bitcoin Address!"Your client, listening in on all the payment network messages:  "Wow, spiffy, that's one of MY Bicoin Addresses!  I'll add that transaction to my wallet, and show that transaction as 0/unconfirmed in the UI."Then your client goes on its merry way downloading the 66,241 blocks in the block chain.In the meantime, some lucky soul generates block number 66,242, and includes your transaction in that block.  When your client connects that block up to the block chain (which it won't do until it gets all 64,241 previous blocks), it'll show it as "1/unconfirmed"Then 2 confirmations when block 66,243 gets generated, etc.Wonky things can happen if two nodes generate a different block 66,241 (especially if one of them included your transaction and one of them didn't, you can go from 1/unconfirmed back to 0/unconfirmed for a little while), but after a couple more blocks get generated everything sorts itself out. First: it looks like we're in the middle of our first Bitcoin Bubble.  Price today went from about 0.8 US cents to 1.4 US cents on the Bitcoin Market.  Maybe the price won't crash back down... will be interesting to see what happens.Second, RE: lending:  I think it's going to be really hard to establish enough trust to create a lending bitcoin bank.  I base that on my experiences dabbling as a Prosper.com lender; when hard times hit, repaying your Bitcoin debts will be WAAAAY down on the priority list.Instead, I think we'll see Ponzi schemes masquerading as lending banks.  Buyer beware! That's when I sleep!  Meeting whenever is most convenient for Satoshi makes sense to me. Sure, you could build specialized hardware that computed SHA256 hashes faster than ANYBODY!And then you'd be able to generate most of the bitcoins.So:  how much would it cost you, in dollars or euros-- and don't forget to pay yourself for the time needed to design and build such a system?Because you'd be able to generate, at most, 50 bitcoins every 10 minutes or so.  Soon after you started generating, all the other nodes on the network notice that bitcoins are being generated quicker than normal and increase the difficulty of the problem being solved (you've gotta twiddle the block header more times to find SHA256Hash(block_header) < target_value ).If Bitcoins become even more wildly popular, then maybe people will think they can profit by building or renting specialized hardware.  That would be a very good problem for Bitcoin to have. The Bitcoin Faucet is handling the slashdotting really well... except that I'm running out of coins to give away.  over 5,000 have flowed out of the Faucet since I refilled it last night.Any of you early adopters who generated tens of thousands of coins back in the early days, are you willing to send a few to the Faucet to be given away so more people can try out Bitcoin?  I know that most of them are likely to be lost (I suspect there a lot of slashdot lookey-loos who won't stick around long enough to spend their 5 bitcoins), but if that's the case then that'll just increase the value of your other bitcoins, anyway...Fountain donation address is:  15VjRaDX9zpbA8LVnbrCAFzrVzN7ixHNsCDepending on donations and how long the slashdotting lasts, I might have to start giving away bitnickels...
Reminder to anybody running a bitcoind server:   be sure the debug.log isn't filling up your server's disk.  With the slashdotting, now might be a good time to setup a debug.log housekeeping system.I'm doing this on my Debian server:My crontab:Code:# Rotate bitcoin logs0 8 * * * /usr/sbin/logrotate --state /home/gavin/.bitcoin/logrotate.state /home/gavin/bc_logrotate.confMy bc_logrotate.conf file:Code:# # Rotate the bitcoin debug.log file## This should be added to crontab to be run every day:#  /usr/sbin/logrotate /path/to/bc_logrotate.conf#compresscopytruncate/home/gavin/.bitcoin/debug.log { rotate 5} The fee is paid to whoever generates the block that the transactions are in, and that's random.Your friend could run a node that refunds the fee, but unless your friend can convince a lot of other people to run nodes that do the same thing you're almost certainly going to end up paying the fee.Remember that all transactions (even payments from you to your friend) are broadcast across the payment network; they HAVE to be, because if they weren't you could spend the same coins twice without getting caught. But how would you distinguish between a legitimate micropayment-processing IP and a spammy "I want to make Bitcoin use so much bandwidth nobody is willing to run it any more" IP?Really small micropayments seem to me to be a really hard problem, and I don't think Bitcoin should try to solve too many very hard problems all at once. If you have finished downloading the "block chain" (the history of previous transactions) then you'll get your bitcoins right away.If you haven't finished that initial download (if the "blocks" number at the bottom of Bitcoin is less than 65-thousand-something), then you'll get your free bitcoins as soon as you download the block containing that 5-bitcoin transaction. By the time Bitcoins replace the Euro   I think most people will be running lightweight clients on wireless smartcards in their (physical) wallet that don't pay attention to every single transaction.But that's WAAAY down the road.  And who knows, by then maybe we'll all have a hundred-gigabits of bandwidth in our pants. From the source code:Code:main.h:        // To limit dust spam, require a 0.01 fee if any output is less than 0.01 It's a bad idea to try to break the "in-production" bitcoin network.If anybody is starting serious work on either extending Bitcoin or developing compatible implementations or trying to break it by creating bad transactions, I think creating a "parallel universe" test network with its own block chain, data directory, etc makes sense.Satoshi:  would you be open to a --testnetwork (or something) flag to bitcoin that swapped to an alternate genesis block, data directory, listen port and IRC channel?  Maybe with a really short average block generation time, too (like once per minute instead of once per 10 minutes) so everything happens ten times a fast to make testing quicker.  In a thread in the Bitcoin Discussion forum, dwdollar says:I think it will be impossible to tell if a bubble&crash is "natural" or "the men in black helicopters manipulating the system."Bitcoin will get mentioned someplace with lots of readers, a bunch of those readers will like the idea and try to buy Bitcoins, their price will rise which will draw even more people to "invest", which will drive the price up even more... until people decide that the price isn't going to rise any more and everybody rushes to sell before the price drops.  I predict there will be between one and five Bitcoin bubbles (price will double or more and then crash back down below the starting price) in the next four years .What do you all think-- are bubbles and crashes a natural emergent property of markets, or would Bitcoin be immune if nobody were trying to cause a bubble? I'm sure somebody somewhere would/will be happy to sell you bitcoins anonymously; just put cash and a bitcoin receiving address in an envelope and mail it.  The exchange (who you'd have to trust to actually send you the coins) takes the cash and send coins to the address.  They have no idea who you are, and your identity isn't linked to the coins.Well, it isn't linked to the coins until you forget to turn on TOR or I2P before spending coins on something illegal.  Or you remain completely and utterly anonymous right up until you spend coins on something physical and have it shipped to your home address.  Or you arrange to have contraband "dead dropped" somewhere, and you get arrested when you go to pick it up.None of which have anything to do with Bitcoins, and all of which seem to me to be more likely ways of getting into trouble than somebody managing to figure out that "transaction for purchase of illegal stuff" is linked to "Gavin purchased a bunch of Bitcoins from Bobby's Discount Bitcoin Emporium" last year. Would the transactions on the other block chain be lost?I thought they'd just be re-integrated into the new-best-chain (if they were valid), just starting with '1 confirmation' again... Whatever mechanism is chosen, it had better not significantly slow down the network or client unless strong anonymity is required/requested.I've tried I2P and Tor, and, for me, super-strong privacy isn't worth the performance cost.Also, regarding forking the block chain by a network split:It's only "really bad" if I can get away with double-spending some coins before the network merges again.If I'm buying valuable stuff, then the merchants will likely require 6 confirmations before releasing the goods, so I'd have to be able to keep the network split for an hour or more.Merchants will likely have very-well-connected, long-running nodes.  For example, the Bitcoin Faucet has 66 connections right now.  If I wanted to try to implement a "fork the block chain attack" I'd have to somehow manage to insert my "cancer nodes" in between two merchants that I want to rip off (I'll end up ripping off one of the two, because eventually one of the two double-spend transactions will "win").I don't know enough about network analysis to figure out how many cancer nodes you'd need to have a significant chance of getting in between two merchants with 60+ connections in a network of (say) 1,000 non-cancerous nodes, but I bet it is a very large number. The "scripting language" ("expression evaluator" would be more accurate) is a little stack-based intepreter that looks at lot like Forth.So, for example, here's an example of a GENERATED coin getting spent:TxIn:          73:3046...0f01Prev.TxOut: 65:046d...bb9c CHECKSIGThat's intepreted as:  PUSH a 73 byte value onto the stack  PUSH a 65 byte value onto the stack  call CHECKSIG.  CHECKSIG pops two values off the stack (public key and digital signature), then does the digital signature thing using the OpenSSL ECDSA_Verify() function. An example of how bitcoin works on a bit-level:  Ok, I'll give it a shot.Here's what the current best-block (according to my bitcoin client) looks like, dumped in a geek-readable format:BLOCK 68fa61ac1f55a5787dfa0c75bc83e67376ae8356e6887a2ab74cdb0900000000Next block: 0000000000000000000000000000000000000000000000000000000000000000Time: Mon Jul  5 15:51:22 2010Previous block: c18adb50289393b5a995b3506f039ac75e8de79f5115154488115102000000003 transactions:1 tx in, 1 out['TxIn: COIN GENERATED coinbase:0442310d1c029c00']['TxOut: value: 50.00 pubkey: 17sdrb1X7qpjPMJortqaNwWtBbtouSoJn2 Script: 65:046d...bb9c CHECKSIG']1 tx in, 1 out['TxIn: prev(580a...e82e:0) pubkey: (None) sig: 71:3044...db01']['TxOut: value: 50.00 pubkey: 1FeFgJRvCYUTCBj1u696eL23xpAdNB4B8p Script: DUP HASH160 20:a09d...6d81 EQUALVERIFY CHECKSIG']3 tx in, 1 out['TxIn: prev(c0a0...6bc3:0) pubkey: (None) sig: 73:3046...0f01', 'TxIn: prev(f909...2493:0) pubkey: (None) sig: 73:3046...1601', 'TxIn: prev(bc0a...fe64:0) pubkey: (None) sig: 72:3045...6201']['TxOut: value: 150.00 pubkey: 1BHxjkqPmtNdmJxLZgneijvGszRxM9hPkz Script: 65:04ee...1d02 CHECKSIG']So:  that big long string of hex at the top is the block header's hash value.  Note that it ends with 8 zeroes; that's the proof-of-work  (my utility for dumping blocks doesn't bother dumping the Nonce values).What's hashed in the block header?  The Nonce.  The block's generation time.  The previous block's hash.  And a hash of all the transactions in the block. (and probably some stuff I'm forgetting).This block has three transactions in it.  The first is the 50.00 (which is really 5,000,000,000 of the smallest possible units) reward for finding/creating the block.  It can only be spent by whoever has the private key that matches the public key in the TxOut  (17sdrb1X7qpjPMJortqaNwWtBbtouSoJn2 -- you can think of public keys and bitcoin addresses as equivalent), which will be whoever generated the block.The second is a payment of 50.0 from.... somebody... to... somebody.   How does Bitcoin know that transaction is valid?  Well, it: + Looks up the previous transaction.  That's the TxIn: prev(580a...e82e:0)  stuff-- fetch TxOut zero (which will be a coin generated txn) from previous transaction 580a.... + EVALUATE(TxIn.pubkey + previous transaction TxOut.pubkey) and make sure it evaluates to true.  This is where the cryptography happens; the receiver uses the private key known only to them and provides a correct digital signature.The third is a payment of 150.0 (three 50.0-value in, one 150.0-value out).Clear as mud? I've started reverse-engineering and documenting the wallet and block databases, and have written some Python code that deserializes many of the Bitcoin data structures.  I was going to let it ferment a little more before announcing, but Mr. Google will surely find and index it soon, and it should be a good head start for anybody who wants to start a Python bitcoin client.Open source, MIT license, at:  https://code.google.com/p/bitcointools/  MOVED TO git:  http://github.com/gavinandresen/bitcointools If you're worried about elliptic curve cryptography being broken, then don't store any significant wealth in Bitcoin.   Just like if you're worried about your (real, physical) wallet being stolen don't hold more cash than you need to get through a couple of days of purchases.By the way: I think an economical method for separating gold atoms from seawater will be found before elliptic curve cryptography is broken (and I think both are unlikely in the next 25 years). ... or, in other words:  have you thought about what will happen when somebody buys a bunch of bitcoins from you and then disputes the charge on their credit card?Or worse:  buys a bunch from you, turns around and sells them to you.  Waits a day.  Does it again.And then disputes all the charges at the end of the month... I am not a lawyer.But if you generated bitcoins and then sold them I'd think you'd only done something illegal when you fail to declare that income on your income tax return.  Just like if you grew tomatoes in your back yard and sold them to somebody.  You aren't likely to get into any trouble until you make a lot of money on tomatoes and then fail to report that income to the IRS (or you get shut down for farming in a residential zone or something).I think that applies to what madhatter is doing (taking payment for bitcoins through the mail).  But again, I am not a lawyer. I am not a lawyer.But it looks to me like No, just running Bitcoin doesn't make you a "money transmitting business."  To be a "business" you have to be charging people for your service.If you're running Bitcoin to buy or sell goods or services in exchange for bitcoins, I'd say you're not in the money transmitting business.However, if I were to start a company in the business of buying and selling Bitcoins, or that was a Bitcoin payment processing intermediary that took a percentage of transactions between buyers and sellers, I'd talk to a lawyer and jump through all the legal hoops (looks like here in Massachusetts I'd need a license and would have to post a $50,000 bond).Or to put it in more concrete terms:  I am not a money transmitting business when I use my credit card to pay for something from Amazon.com.And Amazon.com is not a money transmitting business just because they accept payments.However, Amazon Payments, Inc. (Amazon's Paypal competitor) is licensed as a money service business in a bunch of US states. I think bittorrent would be a really good model to follow.But it's not the only path to success; Perl is a good example of a successful technology with One True implementation and no specification beyond the One True implementation.Then again, development of Perl 6 seems to be going really slowly.And I think breaking up the functionality is a really good idea.  For example, if the algorithm for signing transactions and the format for public and private keys were standardized it would be possible to create a Bitcoin iPhone app that stored the private keys (wallet) on the phone and submitted signed transactions to a proxy that was connected to the p2p network.I see the functionality broken out into these pieces:1. p2p nodes that are constantly connected and relay blocks and transactions2. transaction monitoring ("tell me when there are new transactions that match some set of criteria")3. new block monitoring ("tell me when there are new blocks that match some set of criteria")4. transaction validation (answers question "is this transaction valid, and how many validations does it have?")5. block validation ("is this block valid, and how many validations does it have?")6. bitcoin mining: race to generate a new block and earn ฿7. wallet storage (generate new addresses, and store their public/private keys and any transactions that correspond to them)8. generate new transactions (sign ฿ with private key(s) and submit to p2p network) I did some research into money exchanging and money transfer regulations in the U.S.The raw legal code is online at:  http://www.access.gpo.gov/nara/cfr/waisidx_08/31cfr103_08.htmlI am not a lawyer; trying to understand legalese is just an odd hobby of mine.  From my reading of the regulations, if you exchange less than $1,000.USD worth of Bitcoin per day you don't have to worry:It looks to me like if you exchanged more than $1,000.USD per day a good lawyer might be able to argue that Bitcoins do not meet the legal definition of "currency":Then again, if Bitcoins are not legally "currency" then it might be left up to a Court to decide what, exactly, they are, and the result might be really unpleasant (if a judge decided that they're like stocks and are therefore subject to regulation by the Security and Exchange Commision you might find yourself in jail for being an unlicensed stock broker).I think Bitcoin needs some licensed, regulated exchanges that abide by all the regulations, treating Bitcoins just like another foreign currency, and make it really easy to buy or sell a few hundred dollars worth of Bitcoins.  The regulations are not as onerous as I expected; basically you just have to get identification from customers that make large transactions and report them.
There has been quite a lot of scholarly research on reputation system in the last 10 or 15 years; see http://scholar.google.com/scholar?q=reputation+system.This article looks particularly relevant for Bitcoin:Reputation Systems for Anonymous NetworksElli Androulaki, Seung Geol Choi, Steven M. Bellovin, and Tal Malkin Department of Computer Science, Columbia University{elli,sgchoi,smb,tal}@cs.columbia.edu Hmm, yeah, it's probably normal; I THOUGHT the default address was given an empty label; I'm wrong, they're given the label "Your Address".So:  Code:./bitcoind getaddressesbylabel "Your Address" should work.Or just generate a new address, either with or without a label:Code:./bitcoind getnewaddress You can talk to the running bitcoind either by: 1. sending JSON-RPC calls; see http://www.bitcoin.org/wiki/doku.php?id=api for more details. 2. re-running bitcoind and giving it extra arguments; it will figure out that there's already a bitcoind running and will pass along the commands.For example, running "bitcoind help" gives you the list of commands it understands:Code:bitcoind helpgetaddressesbylabel <label>listreceivedbyaddress [minconf=1] [includeempty=false]getreceivedbyaddress <bitcoinaddress> [minconf=1]getbalancegetblockcountgetblocknumbergetconnectioncountgetdifficultygetgenerategetinfogetlabel <bitcoinaddress>getnewaddress [label]getreceivedbyaddress <bitcoinaddress> [minconf=1]getreceivedbylabel <label> [minconf=1]helplistreceivedbyaddress [minconf=1] [includeempty=false]listreceivedbylabel [minconf=1] [includeempty=false]listtransactions [count=10] [includegenerated=false]sendtoaddress <bitcoinaddress> <amount> [comment] [comment-to]setgenerate <generate> [genproclimit]setlabel <bitcoinaddress> <label>stopTo figure out what your bitcoin address is, run:bitcoind getaddressesbylabel ""(your default address has the empty string as its label).Code: bitcoind getaddressesbylabel "Your Address" To figure out how many coins you have, run:Code: bitcoind getbalance orCode: bitcoind getinfo Regarding running headless:  the non-daemon bitcoin will run via remote (e.g. ssh forwarded) X-windows, if you install the necessary X11-client stuff on your server. Turning on the CAPTCHA for everybody has slowed the flow of coins from the faucet to a very manageable trickle.Oh, and regarding anonymity versus non-anonymity:  I was careful not to tie IP addresses to Bitcoin addresses when implementing the Bitcoin Faucet.  So I remember that somebody at IP address 96.240.216.119 received bitcoins at 12:30pm today.  And I remember that somebody with Bitcoin address 1P3rpbSybuGgeL1bRwCJFWbn4yBjRNQrbY Scheduling should be easy; on Linux, just run a couple of 'at' jobs that either talk to Bitcoin via bitcoind command-line arguments or use curl to turn on/off coin generation.Windows and Mac have similar, built-in abilities to schedule commands.I think less time, effort, and attention should be paid to coin generation, and more to making bitcoin as easy to use as possible for trading. I want to write an application that does stuff whenever bitcoins are sent to a particular Bitcoin address.Actually, that feature would be useful for the Bitcoin Faucet (it could monitor the donation address and keep it's display of how many bitcoins are available more up-to-date; currently I memcache the balance and only update it every 10 minutes or so).I want this new JSON-RPC call:monitorreceivedbyaddress(address, nConfirmations, url) address:  bitcoin address to monitor nConfirmations: send notification after this many transaction confirmations url: POST detail of the transaction to this url (after nConfirmations)I'm thinking the POST data would look like:Code:{"tx_id" : "...transaction id, maybe encoded into hex",  "address" : bitcoin address being monitored  "label" : label (if any) of the bitcoin address being monitored  "amount" : amount being paid to address  "confirmations" : number of confirmations  "from" : [ "address" , "address" ]  # Sending address(es)}I don't think teaching the bitcoin client to do HTTP POSTs would be horribly hard; I might take a whack at implementing this myself... Copy the wallet.dat file somewhere safe and secure.To be 100% belt-and-suspenders safe, shut down Bitcoin before doing the copy.wallet.dat is:  Linux/unix:  ~/.bitcoin/wallet.dat  Windows: %APPDATA%\Bitcoin\wallet.dat  (I think; I don't run Windows)  Mac: ~/Library/Application Support/Bitcoin/wallet.dat It is easy to generate them automatically (it is easy to write code that asks the Bitcoin program to generate and return a new address). "flawed" ??I've been telling people it is a half-baked, I've-lost-my-friggin-mind idea!So far, I count it as a big success-- I've learned a lot that will help me with my next Bitcoin-related project, I've made a bunch of people a teeny-tiny bit happier, and I've personally invested just under $1.00 worth of bitcoins over the last two weeks.I did throw in the towel today and turned on reCAPTCHA for everybody getting bitcoins (it looks like somebody DID bother to write a robot to harvest coins through proxies).  It was fun trying to come up with new, creative ways of detecting cheating, but I have more important things to work on. Money can be used as both a means of exchange and a store of value.I plan on using Bitcoins as a convenient, very-low-cost means of exchange.I don't plan on saving a significant number of Bitcoins as a store of value.  I like to invest in people who are doing productive things that grow our economy and make the world a better place, so when Bitcoins replace dollars    I'll lend them to people by buying bonds or stocks.If you only use Bitcoins as a means of exchange, then you don't have to worry much about a sudden loss of faith in the system.If you use Bitcoins as a store of value... well, then you're a currency speculator, which can be highly profitable but is also highly risky.  Whether you're hoarding dollars or euros or yen or Bitcoins... So I've been watching the IP addresses of people getting 5 free bitcoins from the Bitcoin Faucet ( https://freebitcoins.appspot.com/ ).And I see some... uh, interesting patterns.  Like these successful requests for coins:Code:79.117.152.158 - - [21/Jun/2010:12:17:02 -0700] "POST / HTTP/1.1" 200 1234 79.117.159.197 - - [21/Jun/2010:12:16:24 -0700] "POST / HTTP/1.1" 200 1234 79.117.135.236 - - [21/Jun/2010:12:10:23 -0700] "POST / HTTP/1.1" 200 123479.117.163.238 - - [21/Jun/2010:12:08:50 -0700] "POST / HTTP/1.1" 200 123479.117.155.23 - - [21/Jun/2010:12:08:07 -0700] "POST / HTTP/1.1" 200 1234 My apologies if there actually are a bunch of new bitcoin users using IP addresses in the 79.117 range...  but I'm guessing somebody there is getting more than their fair share of free bitcoins.There are several suspicious requests from the 192.38.95.* address block, too.So I've made some changes to the Faucet.  You won't notice them unless you try to cheat; if you do try to cheat, you'll have to solve a CAPTCHA to get coins.If that doesn't discourage cheating, I'll modify the code so that if it think you're trying to cheat it requires a CAPTCHA and only gives out a bitcoin nickel (0.05 bitcoins)... I just finished creating a clean Amazon EC2 debian 5.0 machine image with everything I needed to compile bitcoind, and it compiled (using a variation of Laszlo's makefile.unix) and is running fine (just finished downloading the block chain).  I'll let you know if it misbehaves.I had trouble compiling the gtk version, but I think that's because I did something wrong compiling wxWidgets.  I don't need no stinkin' graphics (and am not a wxWidgets expert), so I'm not going to bother trying to fix that. I say keep it simple; more choices isn't always better, it just makes it overwhelming and confusing for most users. I misunderstood the problem.  I hadn't noticed that bitcoin addresses could be either 33 or 34 characters long, which is why the Faucet thought your initial address was invalid.I've fixed it. But remember that each bitcoins can be divided into 100 million pieces, as needed.And the more valuable they become, the more careful people will be not to lose them. That's caused by a bug in one of the technologies I'm using behind the scenes (Google's App Engine).  If you try again the problem should go away.I've got a couple of ideas on how to make it more reliable, but I'm still hoping Google finds and fixes the underlying problem... If it was oil, then it seems to me the country with the largest oil reserves would be the world's reserve currency.It might be the biggest army, but I think the dollar is the world's reserve currency because the US has the largest productive economy in the world backing it.Unfortunately, we might be subject to a natural experiment in the next couple of decades that will show us the right answer; I can imagine that in 20 years the US still has the world's biggest army but some other nation has the world's largest economy.It would be really cool if Bitcoin Nation were the world's largest economy by then... Thanks!  I'll add the donation address to the bottom of the page.I'm thinking of keeping the donation address the same, so donations to the Faucet are transparent to anybody who wants to see.  I WANT donations to, and payments from, the Bitcoin Faucet to be NON-anonymous, so anybody can audit that address and see the flow of bitcoins through the Faucet.(by the way, if anybody is looking for an interesting bitcoin-related coding project I think a website where you enter a Bitcoin address and it shows you a visualization of all the transactions that went to/from that address would be cool... extra credit if it let you browse the web of transactions...  I'd be really curious to see what percentage of bitcoins withdrawn from the Faucet end up donated right back into it...) Good idea or not, SOMEBODY will try to mess up the network (or co-opt it for their own use) sooner or later.  They'll either hack the existing code or write their own version, and will be a menace to the network.I admire the flexibility of the scripts-in-a-transaction scheme, but my evil little mind immediately starts to think of ways I might abuse it.  I could encode all sorts of interesting information in the TxOut script, and if non-hacked clients validated-and-then-ignored those transactions it would be a useful covert broadcast communication channel.That's a cool feature until it gets popular and somebody decides it would be fun to flood the payment network with millions of transactions to transfer the latest Lady Gaga video to all their friends... So I'm writing a little tool that dissects the Bitcoin wallet.dat, mainly because I want to understand better exactly how Bitcoin works.And I see that the outputs of transactions have a value (number of bitcoins) and a bunch of bytes that are run through the little Forth-like scripting language built in to bitcoin.  E.g.:['TxOut: value: 100.00 Script: DUP HASH160 6fad...ab90 EQUALVERIFY CHECKSIG']First: it make me a little nervous that bitcoin has a scripting language in it, even though it is a really simple scripting language (no loops, no pointers, nothing but math and crypto).  It makes me nervous because it is more complicated, and complication is the enemy of security.  It also makes it harder to create a second, compatible implementation.  But I think I can get over that.Looking at the code, new transactions are verified by pushing the signature an then public key on the interpreter's stack and then running the TxOut script (did I get that right?).Could I write code to create transactions with any valid script in the TxOut?E.g. could I create a TxOut with a script of:   OP_2DROP OP_TRUE... to create a coin that could be spent by anybody?And is flexibility in the types of coins created the reason it is coded this way?
