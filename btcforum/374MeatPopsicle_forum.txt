Brainflayer is meant to go the other way. Check a bunch of passwords against a list of addresses. Unlike bitcoin there isn't a reliable away to have split secrets with key generation so there's no guarantee you wont steal the domains back at any point. If worst comes to worst could you throw together a short docu on how the server components fit together? Trying to piece together how and with what each of them talk to by digging through the C code is less than optimal. Ah, thanks, missed that somehow. Code:[2016-03-09 19:23:25] GPU #1: aes_cpu_init invalid device symbol[2016-03-09 19:23:25] GPU #3: aes_cpu_init invalid device symbol[2016-03-09 19:23:25] GPU #2: aes_cpu_init invalid device symbol[2016-03-09 19:23:25] GPU #0: aes_cpu_init invalid device symbol[2016-03-09 19:23:26] GPU #1: aes_cpu_init invalid device symbol[2016-03-09 19:23:26] GPU #3: aes_cpu_init invalid device symbol[2016-03-09 19:23:26] GPU #2: aes_cpu_init invalid device symbol[2016-03-09 19:23:26] GPU #0: aes_cpu_init invalid device symbol[2016-03-09 19:23:27] GPU #1: quark_blake512_cpu_setBlock_80:318 invalid device symbolCuda error in func 'cuda_check_cpu_setTarget' at line 41 : invalid device symbol.Any ideas? You mean the 4 year old OP whose account holder hasn't logged in in over 3 years? lol. Domain got squatted, simple 'nuff. I want to link my Bitcointalk name with BTCJam's. Verification code: 6629795f-0136-460c-980c-0d39786acc8f I know it's probably for security reasons. But an API call to handle moving money between wallets would be nice. ITT: People who have money on Gox and are upset. Stupid question, but how do you keep it up to date? Surely there's a better way then having to continuously run it with --no-serve. They also disabled renewals. So even if you had a subscription you're SOL. Everybody should stop using cryptotrader if this is how they're going to handle paid subscriptions. Wasn't paying attention to deadline timezone :|Here's my result: https://cryptotrader.org/backtests/Wuz7Tgstb3XNqezjq appears to be back up again You're trying to use logic and bitcoins in the same sentence. Still waiting on my withdrawal from Mtgox from last week They said the exact same thing aboutmyspacelivejournalgreenbucksegoldstormpayetcetcetc Need to borrow a shovel? How'd you figure out the functions that were causing it to crash? No its not.  The whole point of the testnet in a box, is that it's self contained. Anything done in an TIAB would not appear on blockexplorer. And they spent most of their money again so everything is good with the world:Code:      First Bet      |      Last Bet       |     bets     |   winnings   |   profit---------------------+---------------------+--------------+--------------+------------ 2013-03-19 00:55:02 | 2013-04-07 22:35:38 | 253.85541248 | 263.44254937 | 9.58713689
Any of the TLA agencies have plenty of EEs on call who could whip up an ASIC in no time flat. The only thing preventing this, is that bitcoin is a drop in the bucket monetarily wise.  Code:      First Bet      |      Last Bet       |     bets     |  winnings   |    profit---------------------+---------------------+--------------+-------------+--------------- 2013-03-19 00:55:02 | 2013-04-07 09:03:55 | 189.69558100 | 42.93611902 | -146.75946198Wish I had $20k to blow playing SD.I take that back, looks like they won one:Code:      First Bet      |      Last Bet       |     bets     |   winnings   |   profit---------------------+---------------------+--------------+--------------+------------- 2013-03-19 00:55:02 | 2013-04-07 09:08:53 | 192.72208100 | 242.83605152 | 50.11397052199.88505000 BTC on a .05 lessthan 16 bet. When I didn't have any blockchain files it would crash on unmapping somewhere in cleanMaps, but with blockchain data it dies on:Code:while(i!=e) totalSize += (i++)->size;in initHashtables.Code:ovrlrdq@thedarkcitadel:/tmp/blockparser$ ./parser statsinfo: starting command "simpleStats"Segmentation fault (core dumped)ovrlrdq@thedarkcitadel:/tmp/blockparser$ gdb parser coreGNU gdb (GDB) 7.4.1-debianCopyright (C) 2012 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-linux-gnu".For bug reporting instructions, please see:<http://www.gnu.org/software/gdb/bugs/>...Reading symbols from /tmp/blockparser/parser...done.[New LWP 20039]warning: Can't read pathname for load map: Input/output error.warning: no loadable sections found in added symbol-file system-supplied DSO at 0x7fffb238a000Core was generated by `./parser stats'.Program terminated with signal 11, Segmentation fault.#0  0x000000000044f2d3 in google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::dense_hashtable(google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > > const&, unsigned long) ()(gdb) bt#0  0x000000000044f2d3 in google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::dense_hashtable(google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > > const&, unsigned long) ()#1  0x000000000044b8fc in initHashtables() ()#2  0x0000000000404c4c in main ()Valgrind output:Code:info: starting command "simpleStats"==22223== Invalid write of size 8==22223==    at 0x44EA23: google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::dense_hashtable(google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const,unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > > const&, unsigned long) (in /tmp/blockparser/parser)==22223==    by 0x44B76D: initHashtables() (in /tmp/blockparser/parser)==22223==    by 0x404C4B: main (in /tmp/blockparser/parser)==22223==  Address 0x10 is not stack'd, malloc'd or (recently) free'd==22223====22223====22223== Process terminating with default action of signal 11 (SIGSEGV): dumping core==22223==  Access not within mapped region at address 0x10==22223==    at 0x44EA23: google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::dense_hashtable(google::dense_hashtable<std::pair<unsigned char const* const, unsigned char const*>, unsigned char const*, Hash256Hasher, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const,unsigned char const*> > >::SelectKey, google::dense_hash_map<unsigned char const*, unsigned char const*, Hash256Hasher, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > >::SetKey, Hash256Equal, google::libc_allocator_with_realloc<std::pair<unsigned char const* const, unsigned char const*> > > const&, unsigned long) (in /tmp/blockparser/parser)==22223==    by 0x44B76D: initHashtables() (in /tmp/blockparser/parser)==22223==    by 0x404C4B: main (in /tmp/blockparser/parser) ext3, and pretty sure it's crashing from a null ptr. Always dies once you try to operate on the last element in vecMap.  Compiles fine but then segafaults.There's logic issues with the mmap'ing. Fiat money is evil . . . lets copy every idea they've tried. Looks like 1PVkEnfTXD5uHeWZSGeXqGdTZ44KAeZsgV is the new guy to watch, doing mass 20x bet txns all over the board. For those too lazy to dig:Code:      First Bet      |      Last Bet       |     bets      |   winnings    |    profit---------------------+---------------------+---------------+---------------+-------------- 2013-03-28 19:11:46 | 2013-03-29 11:20:48 | 2394.00000000 | 2757.05458660 | 363.05458660    Yea, processing seems to be going pretty slow, only maybe 10-15 bets a minute. From my limited dataset, I show that address up 727.34528992 on 1856.81 of bets.  Yes, and those are the people who play it for fun.  There is a reason they call the lottery a 'stupid tax', the only people that play are those that are too stupid to realize how slim their chances are, and those who do it for fun. For the latter, who cares, it's their money. For the former, well, you can't fix stupid. So in other words if people who didn't know (or thought they knew) statistics would bet on lessthan 2 and lessthan 8 because they're 'due' to win since their payouts is <1% and ~1% respectively. What's the RTP column again? If they were sane, they wouldn't keep that much online, I'd imagine for all payments greater then $foo there's probably some oversight. But yes, there's no reason it shouldn't have been sent by now. Just like every other system out there, it can do good, but it can also lose you lots of money as well. If I had to take a stab it would be what volume is available at those prices to arb.  rHZngUum2dT7CcsuUzLNFAtRo3oaUa56fg Well in most cases the hashrate your card is doing can fluctuate. There may be stale work and other factors so usually the pools display an average over the last $foo minutes. However, that wouldn't explain quite that large of a discrepancy that I can think of Yet another one of these?
