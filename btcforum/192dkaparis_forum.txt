The dynamic pricing feature does not take into account the currency used (e.g. the USD exchange rate is still used with EUR offers). I've been playing with the site for several days, and there is definitely some problem with withdrawals, as others have already pointed in this thread.I requested a withdrawal of 0.1 BTC from my account.My BTCJAM account was debited 0.0955 BTCOn my address I received 0.095 BTCThe transaction has a 0.0005 BTC network fee, which was obviously deducted from the debited amount, before sending to my address.Why debit 0.0955 BTC instead of 0.1 BTC in the first place, which was the amount requested? I want to link my Bitcointalk name with BTCJam's. Verification code: c14aaf01-bd28-4783-bca7-bb127ec9390d Anyone has any idea what's happened to bitcoingadgets.com? I've been trying to open it for the last several days, but it appears to be down. Is the thing still operational?I signed up with facebook, but I'm unable to add my details to the map - when I enter my address, the save button only places a blue pin on the map and subsequently my profile remains empty. It's a great online password manager I've been using a lot - check it out at http://www.clipperz.com/They got everything I need - locally encrypted database, one-time passes to login without risk of compromising your master password, offline backups (fully encrypted). Their "Zero-knowledge web applications" concept is of particular interest.The service is free, they're running off donations, so I talked them into accepting bitcoin as well - here is the donations page, listing the address: http://www.clipperz.com/donationsI'm not affiliated with them, just a satisfied user. True, just like if only 1 per cent of miners accept your fee, this will just double the time to get 100 confirmations.I fail to see what's so interesting about the number 6, or 100, though, apart from the analysis that for higher number of confirmations you require, you should pay a lower fee. Incorrect. With 1/6 of miners accepting your fee, there is 1/6 chance your transaction will be included in the next block, thus on average your transactions will be 6 times slower. How are these CD-keys acquired and how can you guarantee their unhindered use? Reposted with updated prices! Posted on bidding pond, http://www.biddingpond.com/item.php?id=512 and http://www.biddingpond.com/item.php?id=513.Taking place 7-10 July in Novi Sad, Serbia, see http://eng.exitfest.org/See the items description for more details.BTW, I'm going there too. Is it possible that you used (accidentally or otherwise) the same address you used with the stranger for any other transaction (e.g. mtgox withdrawals), before or afterwards? Did you specifically generate a new address for that transaction (deal with the stranger), and have you ever used that same address to receive bitcoins before or afterwards? How exactly did mtgox refer to the 9000$ BTC in question, in their inquiry? After the deal with the stranger, have you done any BTC deposits to your mtgox account? Nothing of the sort, since one can legally implement an abusive client from scratch. I have a CMake-integrated branch here, that I keep in synch with the official repository. I've tested it on Windows (MSVC++ 8 and 9) and FreeBSD (without GUI).There's also this hsoft's clone of mine that has added support of OS X and is cleaning up the code. Interesting. You have your db headers installed in db4.7, while on my FreeBSD installation it's db47. I think it should work if you use my FindBerkeleyDB module and set DB_VERSION to 4.7, instead of 47. Anyway at least with the REQUIRED flag, the CMake configuration will bail out as it should, if it's unable to find the headers. Seems the the db include directory was not set correctly. Can you search your system for db_cxx.h and db.h and post the results? I'll try to look at it when I have time. The unqualified bind references in main.cpp and util.cpp are ambiguous for newer compilers that implement the upcoming ISO standard: there is a collision between boost::bind and std::(tr1::)::bind. This breaks the build under, e.g. VC++ 2010.I've qualified the offending references and fixed the build here, but this is precisely the reason why using-directives in header files are widely considered a bad practice. Better to do away with the using-directives in headers.h and either qualify all references, or judiciously use typedefs and/or using-declarations throughout the sources. If Satoshi gives a green light for this, I'd make another patch along these lines.
headers.h defines _WIN32_WINNT as 0x400 (targeting Windows 98?). This hits various problems with recent boost and windows SDK versions, namely 'InitializeCriticalSectionAndSpinCount' definition errors and this problem with boost filesystem. Does anyone really need bitcoin on win98? (I doubt it'd even run there due to other dependencies). I have modified the definition to 0x500 in my repository (targeting Windows 2000 and later) and suggest the change be applied upstream. The changeset is here: https://bitbucket.org/dkaparis/bitcoin-cmake/changeset/0f2875f92c12Regards,Dimitri My CMake version at http://bitbucket.org/dkaparis/bitcoin-cmake/ can build on windows using MSVC, both IDE project and command line nmake. You'll only need CMake. Do you believe there are any matters that should be left to people's own discretion, without deferring to your wisdom? Whom I or anyone else chooses to trust or not trust, is not for you to decide.Look here, I can give you my reasons for trusting anyone in particular, should I choose to do so. But I don't get to demand other people's reasons, and neither do you. Thanks, I'll add the change. I remember just copying the lib names straight from the original makefile, I suspected not all are used.It's also worth noticing it can build bitcoind (the headless version) without any wxWidgets libraries at all (in fact I did that on my FreeBSD system). Incorporated into the CMake tree. No problems on Windows and FreeBSD. Don't know if Mac OS X is technically a BSD and I don't have access to a Mac, maybe someone else may test it.If there are other Mac (and not BSD) specialties, then we'd need to check both for __WXMAC_OSX__ and BSD or detect these in some other way altogether. There is this piece of code in headers.h:#ifdef __WXMAC_OSX__#define __WXMAC__ 1#define __WXOSX__ 1#define __BSD__ 1#endif#endifIn my testing it's not caught on FreeBSD 8.1I propose it be changed to:#if (defined(__unix__) || defined(unix)) && !defined(USG)#include <sys/param.h>#endifAnd then checks for BSD should be#ifdef BSDThis is the recommended way of detecting BSD in the FreeBSD Porter's Handbook.This change is already done in my CMake tree. It now builds on FreeBSD. Tested on 8.1 x64. I have no graphical environment on my test machine, so I haven't tested with wxWidgets. Volunteers are welcome.Provided you set up all dependencies from the ports tree and have CMake installed, building Bitcoind should take only this:hg clone https://dkaparis@bitbucket.org/dkaparis/bitcoin-cmakecd bitcoin-cmakemkdir buildcd buildcmake ..makeHaven't tested on Linux yet, but it should be virtually the same. Again, volunteers are welcome.Cheers. Try my CMake integration. You'll need to set up the prerequisites yourself and set the respective CMake properties for locating them, but should be easier than setting up the project from scratch.It's still rough at the edges and it won't yet work out of the box for anything besides windows, but I'm actively working on it. Yes, but better have that specified in the makefile. That way anyone who doesn't care for old CPU's can compile with SSE2 support by removing the flag, without fiddling with the source.I can also add a CMake property for that in the CMake build. From what I understand, removing the offending define is required only for 64-bit builds and 64-bit architectures are already guaranteed to support SSE2 instructions. 32-bit builds can retain the flag and thus continue to disable SSE2 instructions and remain compatible with older computers. It's a fact.I intend to eventually sort out all building hassles and have a reliable build procedure across all win/unix 32/64-bit platform combinations.On that note, I'm currently tackling x64 build for windows and notice that for 64-bit MSVC, the X86_SHA256_HashBlocks function is deferred to an external definition that is not present in the project. In the original CryptoPP library it seems to be in a separate asm module. I wonder how are people building x64 on windows, are they setting defines to use the C-source sha version? Greetings,I have set up a mirror hg repository over at bitbucket for integrating the CMake build system:http://bitbucket.org/dkaparis/bitcoin-cmake/It's based on latest SVN and I'm regularly updating. My modifications are addition of build files and the fix for MSVC non-debug runtime compiling of the secure_allocator class I posted some time ago.See the included build_cmake.txt file for more details.Currently it's tested and works for Visual C++ 2008, both IDE and command-line builds.Still not tested: MSVC x64, MinGW and UNIX builds.Use it as you deem fit. Contributions are welcomed. I recently also made an attempt to use Crypto++ 5.6.0 (as an external library) instead of the old integrated code, with the same result - it crashed on the first invocation of CryptoPP::SHA256::Transform. Only I built everything with VC++ 2008. I haven't investigated in depth, but someone mentioned Crypto++'s routine required aligned input - maybe that's the reason, or we may have other bug we don't figure. Excellent work.Can you provide patches against current SVN? Yes, see here: http://www.cmake.org/Wiki/CmakeMingwOther than that, CMake can generate the following (taken from documentation):Borland MakefilesMSYS MakefilesMinGW MakefilesNMake MakefilesUnix MakefilesVisual Studio 10Visual Studio 10 Win64Visual Studio 6Visual Studio 7Visual Studio 7 .NET 2003Visual Studio 8 2005Visual Studio 8 2005 Win64Visual Studio 9 2008Visual Studio 9 2008 Win64Watcom WMakeCodeBlocks - MinGW MakefilesCodeBlocks - NMake MakefilesCodeBlocks - Unix MakefilesEclipse CDT4 - MinGW MakefilesEclipse CDT4 - NMake MakefilesEclipse CDT4 - Unix Makefiles Having being tinkering with the bundled makefiles for some time now, I'd suggest we convert the build system to CMake (http://www.cmake.org/).It's a cross-platform build system that generates build files for the platform's native tools (makefiles, MSVC project files, etc.).The benefits:- no need to maintain makefiles for all platforms, just one set of CMake files that will support any platform that CMake is available on.- simplified build procedure - instead of tinkering with the bundled makefiles, run CMake to generate makefiles ready to build on your platform. Additionally, CMake can automatically detect installations of required libraries with specially written modules. For popular libraries, such modules are available with CMake installation and others can be written.I've already used CMake for a bunch of projects and it does deliver. I can make the conversion. Any interest? Found the culprit. I had left in theÂ  /Ob0 option from the original makefile, which obviously led to the abysmal performance I was getting. With proper settings, the VC++ build is really faster. This tinkering with makefiles is a major hassle, I'm going to suggest converting to CMake in another post.Regarding the SHA-256 function, we can:1) leave it as it is - requires no effort, but it seems other solutions provide significant performance benefits;2) adopt the SHA-256 code from later releases of Crypto++; an asm version is currently available; we have the option to either extract the functionality from modules and integrate it into bitcoin source as currently done, which would not be trivial for all SHA module dependencies, or use the complete Crypto++ library as a dependency. No one has done either yet as far as I know, so it is not clear how much faster will it be. More interestingly, I've skimmed the change logs and there are various fixes in Crypto++'s sha module as well. I'm not certain if there are any serious problems with the code bitcoin is currently using though.3) Integrate code from PolarSSL, like BlackEye did. He claims a 50% khash/s increase with that code.If we choose either of the last two options, we need to take great care that the hashing functionality is preserved without change or breaking anything. Unit tests would greatly help here, but for that the sha-invoking code in bitcoin would need to be extracted to a separate unit which can be tested.I could do that refactoring, create unit tests for the hashing and provide patches. Then we can more freely experiment with upgrading the sha implementation. Satoshi and/or anyone interested, post your thoughts. It's baffling. Do you mind posting the makefile/project you used to build the original source?
