The encryption algorithm used in bitcoin is ECDSA which does not encrypt text, it's just a signature algorithm.So, Alice could sign some text with her bitcoin address and Bob would know that it came from her (which would be a rather useful thing to be able to do with transactions). One way to overcome that problem would be for miners to accept these transactions into blocks for free, simply because they're providing a useful service. However, then smaller exchanges will probably get very "patchy" updates sent out for pricing since only a few pools would be accepting their transactions for free, which kinda sucks  Apologies for the double post.It occurred to me this morning, would there be transaction fees for these transactions to self? In which case broadcasting the exchange rate could become rather costly! I believe blocks are spread in time to ensure that any messages will propagate across the entire network in the duration of a block, 10 minutes being a rather pessimistic view of how long it could take for a message to propagate.The thing is, faster blocks would take less effort to generate, so to get the same level of security as you currently get by waiting 30 mins for three blocks, you'd have to wait 30 mins for 15 blocks. So, nothing would go faster, you'd just be consuming more traffic spamming the network with more blocks. That's a good idea, which doesn't require any changes to the protocol, which is always a good thing Of course you do have to trust the exchange, but such is the nature of a centralised exchange  I've recently been in another discussion which led to talking about broadcasting exchange rates through the network (which reduces the load on exchanges).I know bitcoin has some kind of alert built in but what are the restrictions on it? Specifically, what would need to be changed to allow addressed to broadcast exchange rates and then clients to pick this data up and display it in client? What would be the scalability implications of this?The biggest problem I can see is that if anyone is allowed to broadcast then people can flood the network. I think this is easily solvable by having nodes only retransmit messages from sources they recognise, and then allowing users to add a set of public keys to verify sources. This way the network as a whole decides which messages are valid to retransmit, simply by if enough peers add the public key as a valid broadcast source. Exchanges could broadcast a message to the network, signed with their private key to ensure authenticity. That way clients which are interested just listen for broadcast messages and display the values contained within, if I remember correctly there is already support within the protocol for broadcasts but only the dev team can send them, so with only a little modification it should be possible to modify it so that anyone can send them. Trying writing a program that aggregates streams of bitcoin financial data using Rx and then selects "interesting" things out of the combinations of these different data streams. That's how I learnt Rx  I learnt haskell in the 48 hours before my exam, which was apparently a very hard exam and I achieved the top classification in I learnt python in a week when I wanted to build a site for appengine.I learnt every nook and cranny of java (shudder) in a 12 week group software development coursework project at uni.The point here is the language that had the most impact was haskell, even though I learnt it the fastest - once I understood the concept the remaining two weeks *after* the exam I spent playing with it taught me very little beyond the precious "aha" moment when I suddenly "got it". The point of 7 languages in 7 weeks is to throw a load of different concepts at you so they all mix together in your head and you're comfortable using the best tool for the job. If you spend several years learning how to use a language and a paradigm you become extremely attached to both of them and start using it for jobs which it isn't ideally suited for.Obviously once the seven weeks are up you should spend more time learning the languages and paradigms you like in detail, but the important thing is understanding the concepts behind the paradigms (maximising the "aha" moments) not the exact syntax of each language.What's the use of learning the basics of a load of languages you'll never use any more? Well For example, I no longer use Haskell but still consider it one of my favourite languages because I use LINQ every day, I only love LINQ so much because of what Haskell taught me about the power of that kind of thing. I also develop a lot of networking stuff, and what I learnt from fiddling with erlang for about 12 hours (I never even really wrote a program in it, I just read a lot of the documentation and understood the concept) has a huge influence on that. I quite like the idea of what 7 languages in 7 weeks tries to do, although I wouldn't have picked those seven languages they're a pretty good selection.My personal pick for a language a week would be (in order):PythonC#HaskellC# (LINQ)ErlangC# (Rx)LuaPython is a nice simple language to start with, it introduces object orientation, first class methods and a load of the functional things which are increasingly popular these days.Then you've got C# which is something of the core to this whole thing, mostly for LINQ and Rx which are used as demonstrations of other things (I'll get to that later). Make sure to cover generics since they're pretty vital to both Rx and LINQ (and the entire of C# in general)Haskell is a beautiful language, it's a bit of a pain to learn if you try and come at it from a "normal programming language, you'll wonder why it can't do the simplest things like loops and assignment. But trust me, once you get the hang of Haskell you'll love it, and it will influence how you program in many other languages.C# (LINQ), LINQ is Language INtegrated Query in C#, it allows you to do functional style programming with C# objects. It's sort of like using Haskell in C# code with C# objects - it's a nice demonstration of how functional paradigms can fit wonderfully into more classic languages.Erlang is a wonderful language for concurrency and distributed processing, everything is based around concurrent processes and message passing (which, of course, works rather well over a distributed system exchanging packets (messages).C# (Rx), Reactive eXtensions is a library for C# which builds upon LINQ to provide filtered message streams... just like concurrent processes passing messages. Once again as with LINQ this is a nice demonstration of how a concept like erlang can be made to work well with more classical languages.Lua, this is a bit of a curveball. Lua is a weird language, it's pretty much paradigmless, you can do pretty much anything you've done in the previous languages in Lua... but you'll have to write the *paradigm* first. This makes it a great way to understand those little niggling details of the things. Try implementing an enumeration and query framework like LINQ/haskell in Lua and I guarantee you'll learn something As for *how* to learn these languages, well I'm really not sure what to recommend, perhaps trawl project euler for suitable problems for each paradigm. I usually just pick up a language and start using it when I need it - so although I only *know* 4 or 5 languages really well, I'm confident in having a toolkit of 10 or 20 languages which I can pick up when I need them. Hopefully this 7 languages in 7 weeks thing will give you the same confidence just to pick up a language to use it. Personally I use britcoin when I do occasional trading, simply because it's the easiest to exchange between GBP<->BTCIf I'm interested in the current price, I take a glance at mtgox and tradehill and take an average.I will *not* use mtgox again for any actual transactions, they've had terrible security since the start and evidently have no idea what they're doing when it comes to security. Email sent, finally a properly secure bitcoin exchange  Bitcoin would collapse under the load far before the entire US economy changed over to bitcoin, let alone the entire world economy.https://en.bitcoin.it/wiki/ScalabilityAnd, assuming we did somehow make bitcoin about 100x more scalable than it is, sometime before the entire US economy transferred over to it we'd have bitcoin heists which made the recent mtgox hack look like pocket change.Quoted for truth That's a pretty good idea, so long as it was very well marked on the price graph when the circuit breaker came into operation.Why? Nothing could have stopped the selloff except an automated circuit breaker. MagicalTux has to sleep sometime, so operator warnings won't work, confirmation only works if the confirmation is secure, since the accounts were hacked we could assume the confirmation mechanism would have been broken too.Maybe my numbers were too conservative, cut off the exchange until human intervention in the event of a 50% fall in value in less than half an hour. I think that's quite unlikely, and as far as I can tell from a very quick skim of prices hasn't happened (and gets less likely to happen the bigger the bitcoin economy becomes). Do you also dislike accounts being hacked and a good chunk of the bitcoin economy being sold off in five minutes? Which one do you dislike more, because a circuit breaker that automatically stops trading if the market moves by, e.g. more than 5% in 30 minutes (which has probably never happened except yesterday) would have stopped this whole fandango after just a few thousand dollars worth of coins were sold, instead of millions."avoid using the MD5 algorithm in any capacity. As previous research has demonstrated, it should be considered cryptographically broken and unsuitable for further use" [US-CERT]. Salted MD5 is as close to useless as unsalted, using md5 for password hashes on a large banking site handling millions of dollars of other peoples money is incredibly negligent and utterly incompetant.I had to include Caps, punctuation, a number, and make it almost 20 characters long before mtgox accepted my new password. Mtgox has been shoddily programmed since the start (unsalted md5 passwords, seriously? Md5 was showing signs of being broken 15 years ago), and there were a whole load of basic things that they could have done to prevented this hack having such a huge impact (eg. Circuit breakers anyone?).I'm lucky enough to have taken all my money out of mtgox a few weeks ago, and I shan't be tradin with them again. I fail to understand why *anyone* would wish to trade with them again. If Kevin wanted, and as I'm sure a few other people have done, he could have purchased those coins, withdrawn every single one of them by exploiting the bug he identified, and then stayed quiet. Kevin, who is doing the right thing, will have 250k coins taken off him in the rollback, and would probably return those 600 coins if asked, other shadier people will have got away with some money, will stay quiet about it, and will get to keep it.I think we're rewarding the wrong people here! Wow, my trust for mtgox just went a little lower, didn't know that was even possible any more.Any news from Baron on if he ever got his money back? I'll tell you what causes a loss of confidence: an exchange that takes arbitrary actions which it never specified in its user agreement to protect itself.I got all of my dollars and bitcoins of of mtgox a few weeks ago. I've been generally unimpressed by the standard of mtgox software ever since it was first released, and this whole hacking fandango came as no surprise to me unfortunately.What's with so many people loving mtgox? they have "some responsibility" for writing crappy software, getting hacked via a dodgy auditor and getting the entire contents of the exchange sold off in 5 minutes? You're right, they do have the tiniest smidgeon of responsibility there...
It's also a good way to distribute free content, or large content, or to get a copy of paid content which isn't crippled by DRM.This system could be made to work, but you need a significant number of bittorrent peers/tor nodes accepting payments before it would make any noticeable difference. As with bitcoin itself, adoption is probably the main hurdle.Also, paying peers (in bittorrent) to preferentially send you content wouldn't actually speed up the network, it would slow it down overall. For one, you often only receive a block of content when you've uploaded some yourself, so this ensures that most peers at least upload something if you circumvent that some peers will spend their bitcoins to leech off the network. Secondly, and more spychologically instead of technologically, if people are paying for their bittorrent downloads they're probably going to leech; "I've paid for this", they think, "So I don't need to donate bandwidth and get a good seeding ration too". Immediate collapse to almost zero, followed by a bubble up to $30 again as buyers get excited.So, after 2 hours I bet $22.03 Absolutely!I have absolutely zero interest in drugs, I even don't smoke, but I would fight for Silk Roads right to have a thread on this forum just like any other. Welcome to the internet...Rubbish! Economics is fascinating, if you don't think it is you're on the wrong forum involved with the wrong project! How odd, I checked more closely and noticed that my client hasn't been downloading new blocks for quite a while.Thanks for checking blockexplorer bitcoin0918, I should have thought of that myself   I mined on the eligius pool a little bit a couple of weeks back, using this address to check my stats:http://eligius.st/~artefact2/eu/1DP5XtbkwF3xVoijHXfnq6RQ3fxYKrEp49Now, I go there and it says no stats because I haven't mined for over a week, that's fair enough but shouldn't I have received any coins I mined by now? I've made the suggestions of protocol buffers before, I still consider a non hand crafted binary serialisation protocol almost vital for bitcoins to really take off.Satoshi wasn't a fan of the idea, I wonder what the new development team thinks? One link added to my signature Please pay me with this address rather than the one in my signature: 1Dxs6Foj1wvi6n1vnj6Dx44tjhJtxKG5MX Britcoin is great. My bank payment went through as soon as it was a working day, and the trade went through just fine.It's a great exchange, and right now is the easiest way for brits to buy coins imo QFTI was laughing all the way through that I prefer my suggestion of a request packet which the client can send at any time to request the complete depth state, and then relative +volume -volume stream continues from there.We need as many digits as people can specify, which as far as I know is an unlimited amount. Well the CAP doesn't really apply to the p2p network since the network doesn't have any state (except the blockchain) :/ Bitcoin gets Partition Tolerance, davout was right in saying bitcoin doesn't get consistency.In the event of a partition both halves will continue working separately (and thus the state is inconsistent in those two halves). Then when the two halves connect the partition is sorted out (arguably not in the best way possible, but it does restore the system to a sensible state). Here you go:http://martindevans.appspot.com/file/Bitcoin_Market_Monitor.rar?agxtYXJ0aW5kZXZhbnNyEAsSCEJsb2JGaWxlGPW_JAwA quick overview:djangoContains django templates used for pages, currently just the one template for the market history graph (which is broken, and I don't intend to fix it anytime soon)javascriptContains the scripts needed for the history graphStylesheetsCSS files__init.py__Indicates that this folder is a python module which can be importedcron.yamlDefines to appengine the cron jobs I want to runindex.yamlDescribes to appengine the indices to build from my datastoremain.pyNothing important, I should have deleted this really. It's just a dummy handler (literally "hello world") I used when setting everything up.market_data.pyThis is the interesting one, it contains the cron job which collects data, the handler which returns data when you access /market_data and the handler which returns the history graph which is broken at market-history.trading.pyI initially hoped to build some functionality to automatically trade coins between markets as the prices moved. I haven't really got around to that yet, so this just contains a few data models, and a handler which just prints "foo" when trading should occur.If you have any specific questions feel free to ask  Appengine only offers Python, java and go. So I'm using python, I can release the source if you really like, it's nothing special though - I'm no python expert.This new change has exposed something of an issue in the new system: in the last 5 days I have consumed 50% of my datastore, where I consumed 25% in the previous 6 months - the depth table is a *lot* more information than the ticker. I'm going to have to store the data more compactly, and every time the datastore starts getting full pack it up into a prerendered json document and store it somewhere else.nb. I'll try to get around to writing a data dump cron job tomorrow, but if I don't get around to it there may be a day or two break in the data (which of course no one would know since I haven't got around to writing an API yet, I'll try to get round to that tomorrow too) Ah excellent, any information on the form of this new system? I've been playing around a bit with this webcosket feed in C#, and I'm not sure if I'm doing things wrong or the feed is slightly broken.Every time I receive a depth update I check the volume, if it's positive I add it to my local depth table, if it's negative I search the table for an exact matching depth entry, and remove it. After a while, this ends up with sell prices being less than buy prices - which is clearly wrong. Should this work, or am I missing something?w.r.t all the people saying that sending the complete depth table on connection would be useful, I agree. It seems vital for the client to be able to request depth data, I would implement it as the client sending a request message for depth data, something like:{ "op":"request-depth" }And then the socket sends back the *complete* depth data in a *single message* in the same form that the web API currently returns it. In this way, once you receive the complete table you know you have a reliable dataset to perform updates to as they arrive.The obvious caveat of this is that once you send the complete depth data, it must act as a "barrier", you can't send the complete state, and then an update to a stale state. (does this make sense?) Hey Ben, sorry for the slow response. It's been a busy month!"fetch_all" isn't an option the site understands, instead you should use fetch=N to select a certain amount of values. N can be arbitrarily large, but if it's too big you'll get an error instead of useful data (because appengine has a hard limit on the time a page can take to load).To load all data I suggest you fetch 1000 or so points, and fetch data in batches. Use end=Y-M-D, set that to the last value you got in the last batch, and fetch another 1000 and so on. Like this you can walk over the complete data set.Announcing a change to data collectedpreviously, the site has collected the mtgox (and other sites) ticker data, this is nice but not terribly detailed. I recently switched the service over to gathering the complete mtgox depth table (currently no other exchanges). Currently this data can't be downloaded, I'll be working on a way to retrieve a history of the depth table sometime soon, it's a bit of a headache trying to find a reasonable way to publish such a massive dataset. If anyone is particularly interested in this data throw me a PM and I'll see what I can do about hurrying up development a little.The current dataset is likely to stay up indefinitely, in its current form, but no more data will be added to it. Once an API is online for the depth data, there will be an overlap of the two sets, so there will be no gap in the data. I'm only doing very occasional mining on my gaming machine when I'm bored, so I'd rather not change the system around. I have a nice quiet computer at the moment. It just happens that right now the side of my case is off and I have a massive desk fan pointed right at the graphics card - so I doubt any heat is getting trapped at the moment Is this any documentation on the -F switch anywhere? I suspect I should be making this change m0mchil as it's a miner feature, but I thought I'd ask here first.Is there any way to artificially limit the hashrate? If so, can it be tied to the card temperature to reduce the target hashrate as the temperature rises?My HD5770 keeps running up to 95 degress, which is not a good temperature!
I found that telling my friends that my $50 investment has multiplied to well over $1000 in under a year turned them from "It's a scam" to "How to I buy these things again?" a rather effective approach  All I get when I run this is "Could not connect to mtgox servers".I'm running it on an Android 2.2 Samsung Galaxy S You can pull raw data from my monitor here:http://bitcointalk.org/index.php?topic=3313.msg90683#msg90683This has been running for quite a while, pulling minutely data from mtgox (and some other markets). Since mtgox doesn't ever close (afaik) I'm not sure which price you'd want. Maybe take the midday GMT price every day as your day price.If you specify fetch=N it will only fetch N datapoints, i you do not specify fetch it will fetch the latest 1000 points. I suggest you set fetch=1000, then find the last date in that set, and now fetch=1000&start=YYYY-MM-DD, this way you can page through the data for as long as you like. That's odd, what error do you get for this link:http://nosoperor-internal.appspot.com/market_data?start=2011-1-1It works perfectly for me, and I get a screen of JSON spam.As for the other link:http://nosoperor-internal.appspot.com/market_data?fetch=60&market=mtgoxI had forgotten to deploy the correct kind of index, sorry. This link should now work too. I've already developed an application which monitors bitcoin market prices and makes the raw data available.http://nosoperor-internal.appspot.com/market_datalists all the market data since I started gathering it, quite a few months ago. Recently (last couple of months) it has been pulling and storing data at 1 minute intervals. I've just added some new querying capabilities which allows you to fetch a limited number of data points, limit by start and end date, and filter by market. See details here:http://bitcointalk.org/index.php?topic=3313.msg90683#msg90683 I've added some new query capabilities to the JSON data side of this:Raw data:http://nosoperor-internal.appspot.com/market_dataFetch N datapoints. This fetches the first N datapoints ordered by date descendingfetch=NSet start date:start=Y-M-DSet end date:end=Y-M-Dfilter by market ("mtgox", "bitcoin market" or "britcoin", I can add more if people wish)market=Meg: latest hour of mtgox data:http://nosoperor-internal.appspot.com/market_data?fetch=60&market=mtgoxeg: all data this year:http://nosoperor-internal.appspot.com/market_data?start=2011-1-1As ever, requests welcome. And donations even more so  The bitcoin.org frontpage links directly to the sourceforge binary, which almost certainly accounts for that. Any chance of a computer readable way of pulling your orderbook? Uh, yeah, I should probably have mentioned that I haven't put any kind of limitson the data displayed on the graph. It tends to kill things if you try to select a large data set. That's next on my list to do!@boomboxThe graph you see is generated by Raphael js already, it's just not very pretty because it's a little overcrowded at the moment. I intend to use different data sets for different time periods, with different densities of points.As for the raw JSON, I guess I could return the last day of data points, offset by a count for how many days into the past you wish to fetch the data. I threw this little market monitor together a while ago, mostly for fun and as an exercise in learning a bit more about google appengine. I guess it might come in handy to someone. This application has been monitoring prices on mtgox and bitcoin market for the last few months, at 1 hour intervals. I recently updated it to check every minute, it has all of this data stored and available to download, you can view a graph of the last 10000 data points here (ignore the weird web address, it was just an address i happened to have spare on appengine from an old project):http://nosoperor-internal.appspot.com/market-historyIf anyone wants to download the raw data, you can pull the market data in JSON format here:http://nosoperor-internal.appspot.com/market_dataBy default, this will return only the last 10000 data points, if you set the option fetchall=true then it will fetch every single data point ever collected.So, it's got some basic functionality at the moment. It would be cool to add some more stuff, feel free to make suggestions of things which would be useful and I'll probably implement them  The best place to find out the latest status of the project is the IRC channel. There's something of a power struggle going on between the developers who started the project and control the wiki, and the developers who joined the project and hold a lot of sway in IRC.Guess which group I'm in?  There are some big discussions going on in IRC and etherpad, designing a decentralised DNS right now. Some of you may be interested in joining in and promoting bitcoin as a solution to soe of the problems http://dot-p2p.org/index.php?title=Main_Page LobsterMan what the hell kind of graphics card are you running to get those numbers?   Homomorphic Encryption is what you're describing. Unfortunately homomorphic encryption is pretty much theoretical at this point (it's been shown possible with certain restrictions, but no practical systems exist to implement it yet) Anyone fancy building a 64bit windows build of bitcoin suitable for the OpenCL miner? It may be worth some bitcoins  Any chance of a 64 bit windows build?  I'm in the same position. All I need is the patch compiled into the client and I should be ready to go :/ To break PGP you have pretty much no time limit, you can keep chugging away until you crack the encryption. To break bitcoin you have to do it before the next block is generated, because once it is then you need to crack the new block before you can break this one. No, it's incompatible if just a few people change their behaviour. To roll out a change to the network you need to get most of the clients understanding both the old and the new protocol, and then when you have a majority you turn on the new protocol. I doubt there is a technical limit, I can't see any reason there should be such a limit (besides, as already mentioned, protecting from DoS attacks).That means that if the limited block size becomes a problem, it can be scaled up at such a time. Which also means we probably don't need to worry about it at the moment.
Where does the 1Mb limit come from? Is it a technical limit, or simply hardcoded to save bandwidth? SHA is easy to calculate, but it's difficult to calculate a piece of data which will generate a given hash (which is [almost] what bitcoindoes). The proof of work must be difficult to calculate but easy to prove, which SHA is Wow, given this that I saw yesterday I'm very glad I'm not a US citizen!Would modifying DNS records actually work? COuldn't people just start using overseas DNSes? Banks and governments are unlikely to take serious action against bitcoin until it's already large and successful, at which point destabilising it would be incredibly difficult. She clearly has a different definition of strong encryption to me... I get about 5500 on an idle i5, I assume "over 5000" is on a busy i7, not a fully idle one? My 1000khash laptop which I have sitting in a corner burning some hashes picked up two blocks in the past couple of days, wheras my PC which is on pretty much exactly the same amount of time as my laptop (slightly less) churning away 5000khash hasn't had a block for weeks :/ The game is cancelled. I received no communication from the wolves overnight, and not enough people voted during the day for me to really warrant taking any other measures like replacing the wolves.Money entered into the prize pot shall be returned shortly. I believe you would need a client which understood the old time format and the new one. At a certain block number all clients would switch over to the new timestamp system, old blocks would stay as they are, people with old versions of the software would suddenly find that they could not submit any transactions or create any blocks. I have not received PMs from the wolve(s). The game will have to be cancelled if you don't vote soon. I kept getting them mixed up in code, and came to the same method of thinking as you.Bid is the amount someone is "bidding" for coins, and ask is how much they're "asking", makes perfect sense, for some reason I still get them mixed up :/ No, non voters will not be killed overnight, but they will start to suffer a series of highly unfortunate accidents after several days quiet. I will also accept requests from non players to replace absent players.It is now dusk, no voting while I count the votes.The crowd argues back and forth, many remaining quiet - no doubt still shocked by what happened to Satoshi - Eventually they turn against Quantumplation. They descend upon him, shouting about government agencies and corrupt fiat currencies, and lock him in the hotel safe with no food or water, but plenty of the traditional money he murdered for. Satisfied that justice has been served, they drift back to their roomsIt is now night, wolve(s) and special(s) please send your votes. The day will end in approximately four hours I thought that was what you meant, but I wanted to make sure, thanks. Is this back to front? buy is the selling price and sell is the buying price? Of course, that's fairly obvious when you say it >< Thanks Kiba.Presumably Last will always belower than or equal to Buy? I've been looking at the markets for Bitcoin recently (specifically MtGox, but I suspect this applies to all markets) and I've been a little confused by the terminology. I can take guesses at what most of the terms means, but I'd like to be certain.The MtGox ticker shows six pieces of information, what do they all mean?highlowvolbuyselllast Exactly. As we lose players I'll start making days shorter.I guess this "day" will end tomorrow evening, and will be the longest day of them all. I was hoping that all the playerswould call in on day one to confirm that they know the game ahs started :/
You can vote for No kill, however, this is usually a bad idea since if there enough votes for no kill then no one will die (which just donates the wolves a free night of killing) No, that was just jotting notes off the top of my head to make sure I have all the details straight. A script will be far better thought out  Is the x64 version 0.3.8, if not, could we have a new build please? Just to get this straight before I go off and do any script writing Everyone has a balance stored in their wallet which it how much money they have, much like when you log into internet banking with any other currency. This balance can be changed by sending and receiving money in transactions. A transaction, just like normal, is money changing hands. To keep people honest and stop them spending money they don't have is the real cleverness of bitcoin. When you make a transaction you announce it to the rest of the network. They all check that this transaction is valid. In this way, the amount of money that anyone has is know by the network, and you can't spend money that you don't have (because the network would know and would deny the trasnaction). When you submit a transaction to be verified by the network not everyone can take a vote on if it is a valid transaction, that would make the system too easy to fool with a large amount of nodes all broadcasting that a fake transaction was real, instead nodes do some very difficult computational work (generating blocks), when they complete it that seals the transaction as valid. Other nodes verify this work is correct and in this way votes are limited by CPU power (which is much harder to accumulate large amounts of). Each new block buries old blocks deeper to form a chain of blocks, this makes changing older transactions even harder, so transactions become more certain as time passes. A fraud can only be carried out by generating blocks faster than the rest of the entire network and building a longer chain. When you first join the network (or after rejoining the network) you must download all the blocks generated since you left, once this is done your node can verify new blocks against the rest of the block chain. Thanks Nu Angel, very kind of you There *is* a way to determine the value of something generated like this - it's what people will pay for it. In that respect bitcoin is largely the same as "real" monetary systems. Bitcoin isn't about generating coins. It's about trading coins for stuff, so offer some stuff for sale and get some bitcoins that way  Sign ups are now closed, I shall be sending roles via PM shortly and then the game will begin.The sun rose above the horizon, silhouetting the city skyline and waking Kiba from his sleep. He squinted at the light, and stumbled across the room for a drink of water before heading out of his room to see if breakfast was available yet. As he walked down the corridoor he saw the door to Satoshis' rooom was slightly ajar, he knocked and poked his head around the door. Kibas shouts of horror soon summoned the rest of the group. They were the only people in the hotel tonight, it must have been one of them who was a government agent who had murdered Satoshi to stop the release of Bitcoin, a mob formed in the corridoor of the hotel, regarding one another suspiciously...It is now DAY, start voting. Indeed, I would tend to trust a library many people use over something I myself wrote. Maybe I shall start working on a patch to try and include protobuffers as a first try mechanism (send a protobuf, if the remote end responds with confusion, send a standard packet instead) I don't really know much about the scripts, this sounds like a good point. Are the scripts turing complete? If not, how powerful are they? From what I've heard elsewhere it sounds like a pushdown automata.That's a good point, I guess you should use XML for the wallet file export.In fact, surely you should use xml for the wallet file all the time? Then again you need a serialisation library for XML, so maybe that answers that question :/ I'm going to start the game by the end of today. If anyone wants to enter the prize fund now is the time to do it. I will acceptno entries once I have sent PMs detailing your role in the game. To be honest, I'd be more confident using a library written by google and used by thousands than I would a library written by myself. But that's just me The main advantage of protocol buffers was forwards compatibility (which you say we have, how is that supported currently) and cross compatibility between languages, which is important for bitcoin to develop in my opinion. How easy would it be to read the current structure from another language?Would you consider including an option to write the wallet file out in protocol buffer format instead of the custom format? That way the default can be the custom format which you trust more, and users can export their wallet to protobuf format if they want to move to a new client. *calls a moderator*Check out this guys past posts, he looks very spambotty. I would think the way to do it would be for you to accept certificates off people, and then only accept messages from people whose certificates you have - classic web of trust. Satoshi gets no special powers that way.I wonder if you could replace certificates with bitcoin addresses, and make them serve a dual purpose? That's a very good idea, and I would say it's the way to go with this.Since it's a non breaking change, it should be done as soon as possible in my opinion, for those very reasons.The question remains, is anyone willing to help implement it? I'm an experience programmer but I have no C++ experience unfortunately, so I'm gonna need a little help if I try to do this myself  Excellent, just one more player required now.Come on people, fill that last slot! If you had such a signed broadcast system, you could even distribute updates via it, and possibly get clients to auto update. Which would be cool. Supporting multiple platforms may be difficult though... Oops I think the best way to phase in protocol bufferswould to avoid breaking changes to start with, instead start with protocol buffers for the local files (like the wallet), which would gain us a little bit of size on disk, ease of reading the wallet file in other software, and get some experience using protocol buffers. Then is the time to start phasing in protocol buffers for networking in my opinion.Does the current version of bitcoin have any handling for ignoring chunks of a packet? If so, phasing in protocol buffers could be as simple as writing the current packet AND writing the protocol buffer (as an ignored field for older clients), then once enough people have upgraded get rid of the old encoding. They're not always bad. However, if you put in so much effort that your hand built packet was smaller than a protocol buffer then you're probably putting too much effort into a micro optimisation I'll be happy to help anyone catch up with the protocol buffers. If someone is willing to work with me I'd even work on a patch, I have very little C++ experience so I can't do it alone unfortunately.I would disagree, protocol buffers are smaller which is nice, but it's not their main advantage - they're forwards compatible which is a hugely important thing in a p2p network, they're also something which can easily be used in many languages, which make implementing new clients in new languages easier, which in my opinion is vital for bitcoin.Indeed, but the version packet is probably the smallest packet of all the ones sent, so we'll gain more elsewhere. Also, keep an eye on the main point. The fact that protocol buffers are smaller is a nice aside to the fact that they're Forwards compatible and make bitcoin portable between languages. I used the above protocol buffer (as I said before, it's probably not optimal) and data obtained via http://www.alloscomp.com/bitcoin/version.pys as test data.The encoded protocol buffer is just 55 bytes, wheras the bitcoin version is 85 0x00 sets (each one representing 2 bytes each I assume). This means that my badly designed protocol buffer is over half the size of the hand built layout! One possibility would be to ask a algorithmically selected node from the network as intermediary. It would be possible, I suspect, to make the system work in such a way that nobody can get the money unless the two parties and the intermediary cooperate (so the intermediary cannot steal the money)
That too, although the counter argument people always make to that is that we could do away with reserved bytes anyway. No matter how impractical that would be :/I was hoping for a transaction packet or something, but I'll give it a go with that for now. I could also test with the wallet file if anyone has decoded that?Addendum:Ok, Working from this summary of the version packet layout:I created this protocol buffer definition:Does that look correct? The only changes I've made are that the indented things in the bullet point list are nested message types, and I've completely dropped the 12 bytes of reserved ipv6 space (since that can easily be added in later, which is the point of protocol buffers). I should point out that I probbaly haven't picked the best encoding types for all these fields, that depends upon the values they're likely to store, so in practice the packet will probably be a little smaller than my tests indicate There has been a discussion going on elsewhere about using protocol buffers for bitcoin. To summarise the advantages:-> Small encoding-> Very fast-> Implementations in loads of languages (So writing new clients become a lot simpler)-> Forwards compatible (indeed, this is most of the point of protocol buffers)-> Extremely simpleto use in codeSo initially I would suggest storing the wallet file using protocol buffers, this isn't a breaking change and immediately makes the wallet file easier for other programs to parse. Eventually I would hope that bitcoin could use protocol buffers for networking.Some people have been suggesting that protocol buffers might be larger than the custom written packet layout. I suspect that actually it would be *smaller* due to some of the clever encoding used in protocol buffers. To resolve this, I think a test is in order, I shall encode a wallet file/network packet using protocol buffers and compare the size the packets in the current scheme. However, I have no idea what's in a packet, what data is stored in a packet, and in what format? Just saw the alert telling us to upgrade to 0.3.5, is the x64 build a build of 0.3.5? I've shut down my generation until I know it is. I wouldn't have used XML as a good indicator of performance personally, however it's the only numbers presented on the protobuf website. I might throw together a test using the C# implementation of protocol buffers to get some numbers for protocol buffers vs hardcoded binary packets. However, I suspect speed isn't *really* a problem here, the serialisation time is on the scale of hundreds of nanoseconds - not a problem!As for size, I suspect protocol buffers are going to be smaller than a handwritten packet layout by satoshi for a couple of reasons:1) Bitcoin includes reserved fields for forwards compatibility, ptocol buffers don't2) Protocol buffers include complex things like variable length encoding etc, which would be a silly micro optimisation for Satoshi to include, but comes for free with protocol buffers (and can significantly decrease the size of a packet)3) Losing a couple of bytes on the size of a packet (if, indeed packets do get bigger, I suspect they won't) but gaining cross language compatibility, standardisation of the packet layout, significant ease of use in code AND forwards compatibility is a *very* good tradeoff. Come on people, only 2 more slots to fill!Wave would be a pretty awesome way to play TWG actually, we should try it sometime Why would I care about the USA? I can drink in the UK, and that's what's important  Gah, I hate those bloody anti-teenager devices. I'm 20 and I can hear them better than most of my younger friends, *grumble grumble* I don't understand what you'resaying about speed, protocol buffers were designed by google to satisfy three requirements:1) Forwards compatibility (Google changes their protocols all the time, protocol buffers allow them to do this with ease)2) Speed (every millisecond matters, and protocol buffers are around the fastest serialisation method out there, the documentations says "are 20 to 100 times faster [than XML]")3) Size (Protocol buffers are tiny, the documentation says "are 3 to 10 times smaller [than XML]")Protocol buffers were designed almost for the exact problem bitcoin is facing.Addendum: If you want to know how they work, have fun Nope, the standard implementation of protocol buffers is under the new BSD license. Furthermore, there are loads of versions of protocol buffers in many different languages all published under a variety of licenses. Some people have even written entire probuf parsers in 100 lines, so if we really wanted bitcoin could have its own implementation of a protobuf parser and that code is entirely ours. However, the standard implementation is just fine  I don't know much about the scripts, but if you're right and this is what scripts were designed to address then I'd push for protocol buffers, they're designed and built by google so (no offence to satoshi) they're probably better Also, the fact that protocol buffer are supported by lots of other languages would make building clients (without generation) in other languages (with protobuffer support) absolutely trivial.Edit:: Changing the packet structure to use protocol buffers would be difficult to do, although I would still highly recommend it. However, changing the structure of the local files to use protocol buffers isn't a breaking change, which means that it would be an excellent idea to do in my opinion (smaller, faster, neater code, easier to parse in other languages etc etc) Making forward compatible protocols is something I've been trying to tackle for my Computer science final year project, the solution I came up with was protocol buffers, it just struck me that they're perfect for bitcoin for a whole load of reasons:-> Small (suitable for entworking and hard disk storage)-> Very fast-> Implementations in loads of languages (So writing new clients become a lot simpler)-> Forwards compatible (indeed, this is most of the point of protocol buffers)-> Dead simple to use in code-> Support for custom fields in packets (so, for example, a new client could start embedding messages in packets, and all the other clients would silently ignore this field)So I guess the most important change to bitcoin for me is to start using protocol buffers for networking and saving the wallet file I'll spend 10 coins on 91-100 (inclusive) I have to agree with Quantumplation on this one, more honest nodes trying hashes makes the network secure because you need an equivalent amount of processing power to reach a reasonable probability of generating a dishonest block. More honest nodes trying to verify means a higher percentage chance an honest block will be generated Front end and back end seaprate to allow for different clients to be written without rewriting the backend stuff is the one single most important change for me.  Parrots? Actually, distributed name resolution (and thus bootstrapping without a central authority) is possible How did you tell how much money was changed was in this block? Ok, for 1 fakecoin I guess 50 I believe it's otherwise known as Mafia, every forum I've seen it played it's been called "the wolf game" though.Is anyone interested in staking some coins to become eligable for the prize fund? There has been some discussion about building a game which uses bitcoins as an in game currency. The current directions the designs are taking is a version of the good old forum game "The wolf game". I thought it would be fun to play some game, so here goes:This is the wolf game!The year is 2024. A group of bitcoin users has gathered together to celebrate, tonight Satoshi releases Bitcoin 10.4 which will be adopted as the official currency of 3 countries. A huge party is had, everyone has fun. However, government agents have infiltrated the celebrations and will stop at nothing, during the night Satoshi is murdered! A mob gathers in the hotel foyer, regarding one another suspiciously...The aim of the game is simpleSome players are "wolves", every night they send votes to the GM (me) on who they want to murder this night (only humans can be murdered). Wolves all know who each other are.During the day the mob discusses who the murderer(s) is(are), the wolves pretend to be innocent humans and try to accuse other innocents - at the end of the day the vote is tallied up and the someone is lynched.If you are a wolf, you must try and steer the daytime voting to get innocent humans killed.If you are a human, you must try and deduce who is a wolf (bear in mind, people killed during the night must be human - that's the only solid information you have)Special RolesThere are 4 special roles:The Medic can autopsy a body that has been lynched and find out if they were human or wolf.The Guardian Angel can guard one player every night, if the wolves try and murder that person they will fail. The angel may guard themselves.The Seer will be told the identity of one wolf at the start of the game.The Moderator is a well respected member of the forums and thus his votes can count double on one single day of his choice.Special roles are revealed privately to players, the GM will never confirm any player as a special role publicly.GameplayThe game starts during the day, players can post and vote on who to kill, votes should be in BOLD AND GREEN, if you changed your mind and make another vote, then please go back and remove the first vote (make it normal text and I'll ignore it). Obviously voting will go back and forth, I will post warnings when the day is ending. One game day will be a couple of real days to allow everyone in different time zones to post.The game then swaps over to the night, wolves and specials should send their actions to the GM (me) by PM, at the end of the night (when I've received votes off everyone, or when I don't have the patience to wait any long) the day will start with a big post by me explaining the events of the night.Other rules1. Private messaging is allowed between living players2. Private messaging from dead people is NOT allowed, please report it to me and ignore that PM.3. Dead people should make only one post after they die, and it should not reveal *anything* relevant to the game, it is merely for role-playing an impressive death4. No posts should be made by anyone during the night. Anyone breaking this rule risks getting struck by lightening when out on the hotel roof having a sneaky cigarette Wink5. In the event of a tie during the wolf voting then I will choose a random one to kill6. In the event of a tie during the human voting then NO ONE is killed during that day7. Any player inactive for too long will be replaced or killed8. Sharing PMs from the GM is strictly NOT ALLOWED. If someone sneds you a copy of any GM message, then please tell me - they will be punished but you might get a reward Wink9. Any rules may change slightly as the game progresses (special powers especially may be modified to be slightly more or less powerful) - you won't be punished for rules that didn't exist when you broke them.Prize FundWe are playing for a 13.5 Btc prize fundSurviving playersmizerydeariaEricJ2190KibaFreemoneyBrreawwrightrokhDead playersSatoshi - Assassinated by government agents night 0Quantumplation - sleeping with the money day 1
Do you want to start a new thread on that? I've played the wolf game with people on forums, and a facebook version of the game seems like a genuinely good idea, I might get involved with developing that  Out of those options Satoshi presented, I'd go with the self parsed file with the key/value separator character being a space like lachesis suggested, especially if that's the typical format for at least one OS. Actually, quantum entangelement can't transport information at superluminal speeds, don't ask me why, I tried to ask my brother who has a degree in physics and he rapidly lost me into quantum weirdness  You could do worse than using yaml for the settings It's not a scam, I decided to install it and see. Unless it's a very complex scam which waits for a while before stealing my coins This version has between 200-700 more khash per second on my machine. Ah ok, it sounds like it's quite flexible then I wasn't suggesting that those two things were vitally important that we fix them now, but they're just good ways to illustrate potentially "breaking" changes which need to be made, it's good to know that the code is flexible enough to handle such changes. I've seen a few topics recently (arbitrary precision bitcoins, breaking of SHA256) which would require a large change to how bitcoin works. What kind of upgrade path is in place for these sorts of things?For a gradual change I suppose a client could be released which understand both the old and new ways, but only uses the old way, then after some time (perhaps take some measurements and estimate what perentage of the network is running the new version) release a version which uses only the new version, and all the old versions would get kicked off the network?Are there any small changes which could be made to the client to make it more change proof, would they be worth considering implementing? This is a UI problem, and it can be solved form the UI - if transactions start getting small the UI can simply have fields for sending Bitcoins, millicoins, nanocoins etc. My final year project for my computer science degree is a peer to peer service host, you write scripts for it and they are run in a distributed fashion across the network, scripts can be anything you like, and a blogging site is certainly possible. Maybe after this year at uni I'll release it and see if it catches on  Arbitrary precision mathematics seems like the perfect solution to me, since we are in fact after arbitrary precsion! I guess you could say the clue is in the name  I'm afraid I have to agree with laszlo here, using a certificate/keyfile would be far more secure. Saying that, thanks for adding some security to the JSON api  Well what I'm proposing is basically a html bitcoin interface, eventually it should be built into the bitcoin client and there would be no difference at all between using the bitcoin interface and the web interface except that you don't need to leave the browser. Arbitrary precision arithmetic isn't particularly difficult, using a system like that with variable length integer encoding could result in a fairly efficient packet layout. Actually implementing an arbitrary size decimal number class isn't that difficult, I wouldn't be surprised if there already is one for C++ which could just be picked up and used.As for increasing packet size, that's not a problem either, if you use a single variable length encoded integer to indicate how many bytes the number consists of, and then that many bytes, you're not going to increase packet sizes much - in fact for small transactions (ones transferring < 255 butcoins), only 2 bytes will be used, which makes some packets smaller I imagine!The main concern, I suspect, is that such a change will be difficult to implement without breaking the network into 2 - the old fixed precision part and the new arbitrary precision part. This may or may not be a problem (I imagine all the new style transactions would be rejected, until a majority of the network ran the new version, at which point all old style transactions would be rejected). You want to check out this thread by Satoshihttp://bitcointalk.org/index.php?topic=417.0 Hi nieke, I sent you a private message about getting a bitthanks link but you never replied, any chance of still getting one? Nope, because mybitcoin requires that you trust the website, which partly defeats the point of bitcoin in the first place - every node is a bank, I'm trying to build a convenient interface for you to use your coins directly from a web interface. Thanks Satoshi, I found those threads. However, those threads seem to be addressing the server side as far as I can see. I'm trying to address the client side of the problem by presenting a webpage to the user with a simple confirm or cancel button like paypal, that way the user doesn't have to switch to the bitcoin client to send payment.Is there any chance of adding some extra security to the JSON API? A simple password is all that's needed for now I should think (and possibly a check to make sure that the API can be connected to from the localhost)? Absolutely, I realised a while after posting that you can simply have a unique address per transaction.It is, I hope that ultimately this is just a proof of concept, and once it's shown to work it can be integrated into the client (using the same port and URLs). I'm not certain how paypal is integrated into your site, but it should be fairly easy - simply direct the user to the payment address, then wait for them to come back to your site and when they do check that you've received payment off them.The current problem I'm facing is that there is no way to identify who a transaction came from (and, in fact, there is no way to even get a list of transactions in json at the moment), this makes it very difficult to confirm that a person actually sent the payment - which is of course completely u nacceptable for acommerce application. If I can't find a solution to this I'll have to make some requests to satoshi and wait until he updates the client with some new features.It's terrible, I know, but the only other option is to request changes to the client and wait until they get implemented.Edit: Anyone out there any good at doing stylesheets? I can make them, but I'm not great at it
