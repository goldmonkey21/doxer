Well sorry but it wasn't all that clear to me. A new address version would seem to need a lot more code than just <= version and it is a hypothetical future use as opposed to the implemented current use of the version byteI understand how you can just switch wallets around to retrieve the "lost" coins but if the sent to address isn't yours it may not be as easy as you make it sound.True they're "just" testnet coins lost, no big deal I suppose but I still found it inconvenient and it just seems like a simple fix and the objections are rather abstract/hypothetical. I understand that, I don't understand why this behavior is useful or desirable in any way. Couldn't we just say when running i testnet mode you need to use the 111 tagged version of the address. The others will generate an error. It seems to me it would prevent some mistakes sending testnet coins to limbo when we think we are sending mainnet coins. I find it is inexplicable and inconvenient to an extreme that the client running testnet accepts mainnet addresses. Could we please fix this. It is just a one line fix.in base58.h: change line:     return (nVersion <= ADDRESSVERSION);to:     return (nVersion == ADDRESSVERSION);I don't see any practical reason for it to be the way it is. It is only an historical accident that it was named a version byte. It is not a version byte and has never been a version byte. If some day we do need/want to use it as a version byte we will need to rewrite the code in question anyway as I see it.Meanwhile it is used as a net id byte for addresses and I think it is a mistake to use addresses from another net and the net id byte can be used to detect when you are trying to use an address with the wrong net and prevent your mistake.Thank you. A FULL client on a mobile device seems unlikely for now for a few reasons.1 communication costs. bitcoin is steadily sending and receiving data updates. It seems the mobile companies around here are going for higher data costs and fewer unlimited data plans (or none).2 memory costs. the Satoshi bitcoin takes over 600 mb to run. Perhaps bitcoinj based client would be better, but how much better?3 storage costs. Full block chain is currently 340mb, block chain index is another 150mb. wallet is variable size depending on activity. (I have one wallet over 1 gb.) Phones memory card or usb drive support make this go away but that leaves out a lot of phones.4 battery life. with the constant communications related to point 1.Of course all these are subject to change. in as little as 6 months it could all be a different story half rejected is indeed bad. can you update more often perhaps. I suspect that is a bug in that new terminal window. I get it on many different programs. It only one block (#124724) that doesn't balance this way so far. He was intending to throw away 0.00000001 BTC but accidentally also dropped a fee of 0.01 BTC so he made 0.01000001 BTC in all disappear. Of course its not really any different effect than someone losing their wallet.dat file. The value is gone either way.For reporting purposes it could be credited to a special "lost" account address. Almost any ordinary typo will be caught by the checksum in the address. The biggest danger in that vain would be copy and paste copying the wrong address from a list. I don't think mybitcoin.com really works the way you think it does. I think it actually is just one big pool so far as bitcoin is concerned. mybitcoin.com then keeps its own database of accounts. afaik Name is not important, just lfm if you insist. Main point is to fix it. Interesting changes for "coding standards". I am not real good at following other people's styles that way. Diki was having trouble figuring out what target hex string to use to set up a giving difficulty for shares on his pool so I wrote this little difficulty calculator for him:  bitcoin difficulty calculator  accepts floating poind difficulty or  hexadecimal target in either the long 256 bit form or  the short compressed nBits form and  displays the result in all three formats download portable C source and linux executable from :  http://www3.telus.net/millerlf/diffcalc.tgzhave fun Attached file is a diff -c patch for the loss of accuracy in the difficulty calculation. For instance any nBits compressed value from 0x1a44b800 thru 0x1a44b9ff will show as difficulty 244139.4816. This patch will more accurately convert the nBits compressed values to the double difficulty.This will display any of the recent difficulty levels slightly differently though. Early difficulties and testnet difficulties are not large enough to trigger this bug.None of the actual targets or compressed targets are changed, only the conversion to the floating point difficulty is changed and afaik it is only ever displayed, never converted back so the patch does not effect the target calculations, binary files, databases nor the binary protocol. only programs which use the floating point displayed value of the difficulty might be effected. (pools? I don't think so, but they may need a heads up about the change)Code:*** bitcoin-0.3.21/src/rpc.cpp  2011-04-20 16:08:01.000000000 -0600--- bitcoin-0.3.21-test/src/rpc.cpp     2011-05-25 18:20:48.000000000 -0600****************** 199,208 ****      // minimum difficulty = 1.0.      if (pindexBest == NULL)          return 1.0;!     int nShift = 256 - 32 - 31; // to fit in a uint!     double dMinimum = (CBigNum().SetCompact(bnProofOfWorkLimit.GetCompact()) >> nShift).getuint();!     double dCurrently = (CBigNum().SetCompact(pindexBest->nBits) >> nShift).getuint();!     return dMinimum / dCurrently;  }    Value getdifficulty(const Array& params, bool fHelp)--- 199,220 ----      // minimum difficulty = 1.0.      if (pindexBest == NULL)          return 1.0;!     int shift = (pindexBest->nBits >> 24) & 0xff;!     double diff =!         (double)0x0000ffff / (double)(pindexBest->nBits & 0x00ffffff);! !     if (shift < 29)!         while (shift < 29) {!           diff *= 256.0;!           shift++;!         }!     else!         while (shift > 29) {!           diff /= 256.0;!           shift--;!         }! !     return diff;  }    Value getdifficulty(const Array& params, bool fHelp) I dont see what this has to do with bitcoin, in fact it looks nothing like bitcoin. should just use strftime() instead! something like :     strftime(f, len, "[%F %T]", &tm); the "-algo cryptopp_asm32" just seg faults for me on linux 32bit, via C7 cpu.It seems it dosen't even build on linux64 (hence the name)Has anyone run this algo successfully?   try "-a 4way" command line switch It would be a large problem to port to this machine due to it being big endian. afaik bitocin has never been ported to big endian and I think Satoshi said some time ago that the bitcoin client was highly dependent on little endian architecture and unlikely to ever work on big endian.Prehaps the java bitcoinj is better base to start with, not sure.Not trying to start another flame war about what is better, just another design decision from early days of bitcoin that is a problem for you now. the sha256 instruction will automaticlly restart after an interrupt much like any rep instruction. I am quite sure it is correct as is You would need to get the hash of the current "top" block and compare it to prev-hash in the getwork block.
Can we make it easier to create multi-output txn for peole like slush to distribute to large lists? That could save a lot of bytes both network and disk in the long run. pudinpop had custom ways of making them in his miner. I just made this today as an exercise. It is primarily a single bash script with a few small C utilities. It is primarily intended as a reference implementation to teach how getwork mining is done. It can do 50 hash/sec/core!check it out at:http://www3.telus.net/millerlf/bashhashminer.tar.gzHave fun. Seems like it just should be simpler so the strategies for dealing with it could be seen by everyone and dealt with behaviourly instead of with software patches. Like fifo for free txn with priority for fee txn and a way to add a fee to your txn. I see no conflict. GPUs are used for purposes other than bitcoin you know. 5970s are is demand for many things besides bitcoin, not the least of which is games. If someone want to try to guess the secret key for an address, they can try 1111111111111111111114oLvT2 Which is the zero address. I sent a bitcent to it once just to see what would happen. the net accepted it, so that bitcent is now "lost" unless someone can fine a key for it.If you want to add to the reward for finding this key you can send bitcoin to that address too. Good luck! They will upgrade to PCs! grin Nice talk. Good overview of cryptography without too much technical detail to scare civilians off. One problem is it isn't always obvious what is and is not "dust" or "spam". Consider the following:1. a NEW wallet receives a txn for 1.0001 BTC. This would have been created by some modified or custom client. It is currently accepted and propagated without problems by all nodes. It may or may be displayed as 1.00 in the receiver's UI or it may be correctly displayed a 1.0001. It depends exactly how it is viewed.2. the user wishes to spend 1.00 BTC and tries to send it off.3. this creates a txn with one input which is a reference to the old 1.0001 value and TWO outputs, the 1.00 that the user specified and the remaining 0.0001 as change. The two output are indistinguishable by any outside party including miners and could just as easily be a "dust" transaction sending 0.0001BTC and keeping the 1.00 as change for more dust or whatever.4.The client will TRY to treat this as a regular dust txn and try to charge the "standard" 0.01 fee but there is no way in this case to perform that operation so it falls through to discarding the 0.0001 by throwing it away as a txn fee which only passes on the problem to the miner who collects the fee. There are some non standard txn created by modified clients already which produce variations on these rules.5 the TXN is then sent out on the net for the miners to decide if they want to accept it or not. Currently I think most miner will only accept it if it includes some fee, even a factional cent fee. There is at least one current miner which is modified to accept such txn even without the fee now so the txn is not consigned to an infinite limbo.  Once a miner creates/finds a block with the txn included the block is sent out on the net.6  currently any node will accept all transactions included in a block so long as they are not totally illegal/fraudulent.I may have got some of this wrong but I think it is pretty close. I suppose I don't have to tell you to feel free to post your "corrections"each of the steps 3, 4, and 5 would need some changes for this proposal. One thing I have found is do not do "apt-get upgrade" on ubuntu 10-10! My ati 10-12 drivers quit working and X will no longer start if I apply all the current upgrades. I am not sure which patch(es) actually cause the trouble but this is the only way I can keep the drivers running on my systems.  If they could do this then they could steal any bitcoins they wanted to. and make sure your gpu fan is still working right. like cash destroyed in a fire with no record of serial numbers.backup is kinda like a record of serial numbers, if you can somehow prove it was destroyed the central bank might accept your record and recompense you. (might think your lying and trying to double spend too which is not like btc backup) If ALL miners quit then there would be no confirmations but YOU could turn on generation and confirm your own txn eventually. If they all quit very suddenly then it might take a fairly long time for the next difficulty adjustment to come around (something like what has recently happened on testnet). There could be a considerable period while till the next adjustment (months) that the confirmation rate would be very slow. The solution is of course to get more people back to mining. Frankly tho it seems like it would be extraordinary if all the miners quit at once. I don't think it would really happen.If the miners quit more gradually then we would see the difficulty dropping (to keep the block rate up to 10 blocks/hour) and eventually the lower difficulty would motivate new miners to start up. If testnet has different rules it looses some of its value as a testbed since you are not testing the production rules any more. Assuming it is working as designed. Bugs throw out all bets.Hashes are 256 bits. The odds of finding two random hashes the same would be much less than the odds of getting struck by lightning on the same day you buy a single ticket and win the lottery. I call that never. False. there are zillions of possible blocks/hashes to find and no one ever duplicates any searches.the advantage of pools is you get smaller rewards more frequently. the total rewards are on the average almost identical. add " --quiet >>miner.log 2>&1 & " onto your start command and it will run in background just fine try the threads option only usable in-game. there is no converting back to actual currency. its a black hole currency wise did you remember ldconfig ?
nope, this is all correct. The line:52a65c69ea7bfda3788ee2337f9bece38dbdc6d918c4e16c05f567b700000000is actually the same value as the line:  hash: 0000000005f567b718c4e16c8dbdc6d97f9bece3788ee233ea7bfda352a65c69which looks like a 32 bit word swap but the byteswap involved is hiddenIf this was not done right you would not have gotten the 50.00 btc at the end. One option is the VIA C7 and the VIA Nano CPUs. They have built-in firmware/hardware instructions to perform the hashing used in bitcoin.I run one currently although it is not really profitable in the current bitcoin environment.It is a VIA C7 1.8 Ghz cpu. It gets about 1500 khash/s currently using the cpuminer client on Linux (32 bit). The whole system it is mounted in including disk and ram but no monitor draws about 27 watts. That makes it one of the most power efficient CPUs for bitcoin mining and is also pretty nice from the total cost point of view.Unfortunately the hi end ATI GPUs are still more efficient. I suspect it would be best to set the screensaver to a blank screen also so you dont waste cycles on cute displays Ya, just if your account is sub-penny the fractions get carried over to the next round as far as I know 2.2 and 2.3 still dont quite work as well as 2.1 for mining. good luck the main problem is bitcoin seems to require non-standard conflicting version of wxwidgets. can we use gcc's __builtin_bswap32()?ie in miner.h#define swab32(x) __builtin_bswap32(x)then it can compile to a single instruction in most casesshould work ok for anything gcc supportsit helps via a fair bit ignore the midstate and only use the first 80 bytes of the data if you are using a standard sha256 library. I have used the libgcrypt this way also (it is slow tho). You can also ignore the hash/hash1 fields passed, just use your own. Then return the data with your nonce inserted if you find a candidate hash.Using standard sha256 libraries you will probably also need to undo the byte swaps on the data field. And reswap the data to return it. Standard hash routines would add another 64 bytes then. It is not just padding, it is a length value and a terminator bit. Satoshi defined it in the original implementation, yes. sha256(sha256(block header))Well it is offset 12 to the second part of the first hash, ya. offset 76 out of 80 in the block header.Yes it will always be 32 bits. I got a (yay!!) block on testnet with 0.3.2. I think we can declare it works. For via C7. Can someone else try Nano? I think the problem for via is we have to move the (byte swapped) nonce back into the data_in parameter to return it.yes now I get proof-of-work check FAILED...  hash: 00000000b91b13334f2636c2e0350bcb9592884ffe5af36e1f13a49e16f081fatarget: 0000000045120800000000000000000000000000000000000000000000000000withDBG: found zeroes in hash:16f081fa1f13a49efe5af36e9592884fe0350bcb4f2636c2b91b133300000000which matches correctly now when you do the byte swaps and all makes sense ok it seems the via c7 hash is NOT working right. the bitcoin patch puts out this: proof-of-work check FAILED...  hash: 0690332bc5f9d16e9071934f5bccdb1a1b9a7265a2cdfc2a59bd9f72c6e137a5target: 0000000045120800000000000000000000000000000000000000000000000000which doest match the minerd:DBG: found zeroes in hash:ca71e510100ee12f70ff852e168f332cf155c60fc8eac979d5080c3600000000at all.Im not sure if its one of the byteswap loops or the asm() compiling wrong or what. Ill try to figure it out. I dont think it supports 64 bit mode, it is only coded for the via c7 atm. the C7 doesnt have 64 bit support. It should work compiled for 32 bit mode on the nano even if it is a 64 bit os. If you want to get involved, the nano has some extended hash instructions that would be usefull I think to speed it up on the nano. Make a separate sha256_nano module, keep the sha256_via separate for the c7 I think would be best for now.There may be still some problem with the sha256_via even on the c7 in 32 bit mode. Not sure yet. I am doing a testnet run but no results for certain yet. This would be normal. Only 1/difficulty (1 in 12253) of the initial proof of work gets a yay, the rest get boo. another fix for Via padlock, the 64 byte offset to the data parameter in the sha256 calls should not be used for via or it should be subtracted back out in the sha256_via.c You can simply estimate for each block at the specified difficulty results in the estimated total net hashing rate and you get a graph like this:http://www3.telus.net/millerlf/hashes.png On a via C7 at 1.8 ghz I get 1418 khash/sec on linux$ cat /proc/cpuinfoprocessor       : 0vendor_id       : CentaurHaulscpu family      : 6model           : 13model name      : VIA C7-D Processor 1800MHzstepping        : 0cpu MHz         : 1800.000cache size      : 128 KB When I can buy a million megabytes (1tb) for $50 (on sale), I fail to see why I should worry about 56 megabytes or twice that much or 10 times that much. It is a non issue. Well, it IS NOT infinite! It is continuously increasing. It is, and will continue to be, quite finite and seems manageable for the foreseeable future as far as I can tell. Casandras to the contrary.If you don't think you can handle the load of the chain on your disk space or think the network load is too much for your system you can always fall back to some service like mybitcoin.com or a mtgox account to store your BTC for you.
The reason the mainline bitcoin only tests 15 bits is to support testnet where difficulty can be less than 1.00. 32 zero bits corresponds to difficulty 1.00. It isn't. "runaway disk space" seems like an exaggeration to me. The most free "spam" anyone can send currently is 50kB per block. Anyone who want priority over the spam can send a fee. No matter how small the fee it will give those transactions priority over the spam. I figure 0.01 btc would currently pay for about 50MB of disk space. Do you still think we need to worry? note if you wanted to do a full difficulty test rather than returning the preliminary "proof of work" to the server, its not hard, I think this would work:Code:/* do full difficulty test of hash */#define OFF 75int fulltest(void * block, void *hash){  unsigned char *blk = block;  // 80 bytes  unsigned char *hsh = hash;   // 32 bytes  int i;  int shift = blk[OFF] - 2;  for (i = 31; i > shift && i >= 0; i--)    if (hsh[i] != 0)      return 0;  if (shift < 32)    for (i = 0; i < 3 && shift >= i; i++) {      if (hsh[shift - i] > blk[OFF - 1 - i])        return 0;      if (hsh[shift - i] < blk[OFF - 1 - i])        return 1;    }  return 1;} ok in sha256_via.c  also align tmp_hash1 to 128 to avoid stack clobber.btw I am on a via-c7 which is less capable than the via nano (eg no sse2 or 64 bit but also lesser padlock support)There was another problem in the compiling the sha256_4way.c on my system I had disable some headers that errored when I had no sse support in the compiler thus:Code:#include <string.h>#include <assert.h>#ifdef WANT_SSE2_4WAY#include <xmmintrin.h>#include <stdint.h>#include <stdio.h>#include "miner.h"#define NPAR 32but I got it working eventually about the same speed as my old version of the main prog and easier to support jgarzik:trying your cpu-miner on via:bug in main pprogram segment violation:  needs extra NULL check for sparse array in parse argCode:                       if (algo_names[i] != NULL &&                            !strcmp(arg, algo_names[i])) {  now it is reporting stack clobbered but I havnt found that yet Nope, not all orphan block / forks are the same. Indeed the block chain does lead there. There were some steps in between that would, I think, need to be confirmed before a final conclusion could be reached. You should probably have some test cases both good and bad with multiple leading "1"s. They are valid and part of the error checking in some cases.for instance :11111111111111111111114oLvT2 bad1111111111111111111114oLvT2 good111111111111111111114oLvT2 bad For fees to be reasonable you should figure out your costs first and adjust your fee correspondingly. Currently the whole .bitcoin directory tree seems to be about 227mb (on one of my machines). I recently got a 1tb drive for about $50 so the bitcoin database including log files and all costs me about $0.01135. Current BTC are worth about $0.25 so this disk space costs about 0.0028375 BTCSo if you generate even one block and get NO fees, just the 50BTC standard reward you have paid for a LOT of disk space.Take 0.01 BTC out of that for disk space and the other 49.99 BTC to pay for the electricity and depreciation on your system and whatever other expenses you have and decide if it is worthwhile for you to try for another block. If not then QUIT!You DO NOT need to run a node to play with bitcoin. There are services such as mybitcoin.com that will allow you to keep track of your coins for free! (just the cost of your internet connection).I don't think we need to worry about free transactions for a long time yet. Not even the spam/spew transactions. You need exactly the right revision of the bitcoin sources to use the patch. Most of the patch versions I have seen are for the "svn" development revisions of bitcoin. I think the top few lines of the patch should have a svn revision number that you can use to get the right revision of the source using a svn command.svn -r {num} http:....have fun. This is not a good idea.1. You can't ban the most accurate words for describing the thing you want to talk about.2. Even if you did, it wouldn't fool anyone, you still be obligated to pay the taxes on your bitcoins profits. Just because you think you are covering your trail with digital tricks or whatever is no excuse if they do track you down and demand taxes. Barter nets have found this out to their dismay.3. Its silly to invent new euphamisms and rationalizations for what it is. Its a currency for exchanging value. The fact that there are fairly direct paths for trading bitcoin for us$ and euros proves the point. Why limit it. There are plenty for everyone. Its not like you'll run out.Ya the main effect is they lose what privacy they could have with multiple addresses. It's not a matter of someone accidently discovering the address. It's that anyone they want payment from will need to have it and thus will have access to the full list of transactions on that address. BTW if you are getting a nano it supports more than the C7 with respect to breaking up the hash operations into separate steps. The C7 code should work but you can do better with the nano. you can try http://www3.telus.net/millerlf/bitcoin-c7.tar.gz too.Have fun. Well if the average Joe wants me to back up their wallet for them, I'll do it. Keep it nice and safe right here in my pocket. I promise! :-) Code:(    while sleep 60    do        a=`../bin/bitcoind getbalance`        if [ 0 -ne `echo "$a * 100 / 1" | bc` ]        then            ../bin/bitcoind sendtoaddress \                      1LcDW5G7YfayfGJtGAqc7D3DGXThnnqJ5R  $a        fi    done) &just change the address for your own central machine or you will be sending your bitcoins to me. I think I have the newest stuff. Ill just have to wait for the next version by the looks of it. Maybe give up on it and find an ATI card. ok, I'm really new at this GPGPU stuff, I got this message when I try to run the thing:Traceback (most recent call last):  File "poclbm.py", line 28, in <module>    miner = cl.Program(context, kernelFile.read()).build()  File "/usr/lib/pymodules/python2.6/pyopencl/__init__.py", line 138, in program_build    "Build on %s:\n\n%s" % (dev, log) for dev, log in build_logs))pyopencl.RuntimeError: clBuildProgram failed: build program failureBuild on <pyopencl.Device 'GeForce 8400 GS' at 0xf16c40>:Error: Code selection failed to select: 0x138fdc0: i32 = bswap 0x138fbc0-------------------This is on Linux 64 bit, does the "i32 = bswap" mean it wants linux 32?btw I know the 8400 GS is slow, you don't have to tell me. try :  svn co -r 161 https://bitcoin.svn.sourceforge.net/svnroot/bitcoinIt seems any other revision fails the patch.
I now see 37 blocks with the 5.00 BTC going to this address. It seems there are still people running the old proprietary version. Still negligible tho.That latest was Block #84274 at 2010-10-09 20:29:52 You're both right in a way. The number of mined coins is divided in half about every four years (210000 blocks). this means the current 50.00000000 BTC will actually hit zero in about 150 years. Note it gets pretty small, less than 0.01 BTC in only 50 years or so. It actually hits zero instead of just getting continually smaller because it is fixed integer computer arithmetic and not mathematically theoretical numbers which could get infinitely small. gflops is not really relevant to bitcoin mining since gflops is measure of floating point and bitcoin mining is fixed point. It think fixed point is relatively good to ati and hard for nvidia.If you have an app that uses floating point more than fixed point the the disparity might vanish or at least diminish. Well a thief only needs a copy of your wallet file. It does not normally have any pass-phrase or any actual encryption. If he transfers the coins before you become aware of the copy you have lost them.Yes, stuff can be added to try to prevent it but it is not anything inherent in bitcoin that makes them theft-proof. You neglect the fact that the difficulty is adjusted every 2016 blocks. You cant really average more than 1 block per 10 min over a long run.Also you cannot stop other people from getting some blocks no matter how fast or big you are, if they are running they have a chance of finding "winning" hashes. Your participation does not effect that except indirectly when the difficulty changes for everyone. How many BTC do you have? The truth is we don't really know for sure and even if we did know I think we wouldn't be allowed to tell you. Of course there is no limit to the speculation.All we can really do is proceed with what we do know and hope the secret organizations are not too far ahead. We can only take some consolation that the secret groups do not really have unlimited resources, they are constrained by finite (tho perhaps large by our standards) budgets, time and personnel. The command line switches are listed in "bitcoind -?" instead of "bitcoind help". You are still right tho, those options are missing from "-?" too. Old AMD Sempron 64 does not have the good sse2 speed.  This one should stay with -4way=0CPUID 444d4163 family 15, model 44, stepping 2, fUseSSE2=0 Actually the current client considers regular transactions as "unconfirmed" for just 6 blocks (nominally 1 hour). You can still spend them before they are confirmed and if there is a problem then your dependent transactions will remain unconfirmed too.The special transactions for newly generated 50 coin creation transactions are held back for 120 blocks (20 hours). You cannot spend these till they are released. I think most of your objections could be overcome with a simple shell that handled the "just open this file" case and could simplify the command line for stupid^h^h^h^h^h^h non technical users who can't be bothered to figure out a shell command. I guess one way to do this would be use the -datadir=<dir>  command line arg to specify a data directory (other than the default "$(HOME)/.bitcoin/"). You would only run the client on one directory at a time. (Note the directory is relative to the current directory for the SERVER bitcoind. Its safest to specify a fully qualified directory starting at the root.) Also of course the client does not need to be running  on any specific directory nor running at all to receive payments to addresses in any/all of the wallets. If you wanted to do this without any need to change the current software at all, you would :1: create a new wallet directory2: create a new receive address for that wallet.3: send your amount to that wallet4: publish the whole wallet.dat file as an attached file or whatever.the person who wanted to try to recover the amount would then put that wallet in a new .bitcoin directory and send the amount wanted from it to a new bitcoin address in their regular wallet. (if they were first they would then own the whole amount  and if they didn't want the whole amount they would have to republish the new resultant wallet file with the "change" left over in it.) Yes, simply when you start to download a file you either randomly pay one of or split the payment among the feeds. Then if/when you become a feed you get at least a chance of getting paid back if the file is downloaded further.Feeds have could have the option of whether they don't want to feed freeloaders or just give priority to paying down loaders.Maybe paying smaller payments for partial files down to single blocks would be better, then cheaters would get less and be easier to detect and control. (Cheating feeders could take your payment then not feed you. Cheating freeloaders might promise to pay at the end of the download then not do so) Bitcoin is designed with the ability to forget old transactions as you describe, just it isn't implemented yet. Its only intended to save disk space and maybe some bandwidth though I believe.It could help mask coin tracks from someone new to bitcoin but if they are monitoring the net they are not obligated to erase old transactions. They could build up historical records if they want. Note who gets and loses freedom in each case. The GPL restricts the freedom of the developer and maintains the freedom of the user to modify the system. BSD/MIT gives the developer the freedom to restrict the freedom of the user to do such modifications. Which license you like can depend on who you are.Of course most of us are really both here. It is really interesting to note how the gcc (GNU compiler) remains under the GPL, where the programmers are the users, and is even used on many BSD operating systems. (Yes I know there are efforts to change that.) Unless he already sold them. I wonder if we could get the VIA C7 code included with an autodetect in the standard clients? Or is this just too rare a beast to trouble the main code over? The C7 does work with the standard clients with regular pentium or sse2 code albeit slower. If you WANT to start paying the transaction fees now you can with the -paytxfee=0.01 (beta?) command line switch. If more people use this switch then it might help discourage others from requiring compulsory fees. Most of those power calculators will show you only the peak power needed which is generally at startup time, not at full load running. This is good for selecting the power supply you need but not so good for estimating the power costs over the long run. Unless this 6 socket beast is seriously different from smaller systems in that way.
Well if you look at the start of THIS thread you will see a different reason for THIS thread. If you want to send a message with the coin(s) use the ip-address payment system. For some ip-addresses to leave messages to see the other thread here. http://bitcointalk.org/index.php?topic=59.0Only those who either open their firewall/router for the bitcoin port 8333 or have no firewall can receive this way but we can all send messages to them.If you're too lazy to look up addresses in the other thread you can try my ip address: 75.158.131.108if you leave a note mentioning "pay it forward" then Ill know what its for.If you'd rather just do it the regular way here is another regular bitcoin address:1Ai3wNTYpmojwcS9pi31h4fRQhMqKuYLY9This address has a label so I know what its for without a note. I don't have free electricity but I am running a number of electric heaters that look like computers.The bits produced are a by-product. The power to the screen gets converted to heat too, even the light produced would get converted to heat. I eventually got it and was able to play, it worked well after that. Not sure about the refresh thing. My Pentium-D died but it was generally just two P4s in one package and probably will do bitcoin like that. Yes it was terribly power hungry. The 4way code doesn't do very well on P4s in general. I only get about 900 khash/s on a 3.4ghz P4 without -4way. With -4way its in the 600s. before and after? theres several ByteReverse calls that probably need removal for the nonce ant the timestamp also.in fact you may be able to do away completely with the temp block header thats mostly just there so it can be ByteReversed. I tried to transfer 2.00 btc to the game but they never showed up in the balance on the poker site.https is good In block #72785 with timestamp 2010-08-07 04:53:03:If the block genenerated 50 BTC is transaction #0 of block #72785 then transaction #3 is kinda odd. It takes an input of 5.00 BTC and splits it to two outputs of value 1.8585 BTC and 3.1415 BTC. I think it is the only transaction that is not an even number of bitcents. There is no fee associated.Is there any serious consequences to this transaction?Was it necessary to use a customized client to produce this transaction?So far as I can figure it is harmless but I thought I might bring it up here anyway. I think this is a known problem with the Linux kernel. I believe something similar was a problem with the GIMPS (Mersenne prime search) project. So long as it is open source you don't have to trust it. You can see what it is doing, If you don't like it you can change it. If you can't program, you can learn. If you don't want to learn, you can hire someone you do trust to make the effort for you. You have options. It doesn't require a lot of effort if its a simple option,either in a config file or a command line switch. It might not even be a default, could be opt-in. Some people would welcome it as insurance that they will not be causing problems in an emergency. No.Anything is possible but the current client is a long ways from it.For people who really want to participate with such devices they are restricted to using their browser to access "banks" such as www.mybitcoin.com. Sorry, what are you proposing beyond what is already done? Seems like you were not paying attention. Block generation is already a background task on CPUs which would be idle otherwise.If you wish to change the steady 6 blocks / hour production of the block chain you should consider all the implications carefully.If you just want to have faster transactions consider something like www.mybitcoins.com banks which can allow instant transactions between members.Sorry, what "other" Internets are you thinking of? Seems to me that tcp/ip is ubiquitous.Maybe the reason it got so little attention was people did not understand what it was getting at. Yet that is where the complaints are coming from I think.I think your points are Centos/RedHat specific. People working with Debian/Ubuntu have much greater trouble with wx 2.9 than boost or openssl which work fine in their standard packages (for recent enough releases at least).Not that your points are at all wrong or misleading, just those problems may not be as widespread as you think. It is up at (v 0.3.10) http://75.149.150.33/bitcoin-c7.tar.gzhave fun. It's open source! If you don't trust Satoshi or think he is going to be coerced, replace his key with your own so only you have the power to shutdown your nodes. The C7 version of bitcoin should work well on the Nano even if it is just a 32 bit mode, not 64. You might recompile it for 64 bit on a Nano and see if it still works right. Did you consider turning off block generation? You must have, why did you decide not to include it? I measured my VIA-C7 at the plug at 27 watts including 2 hard drives. With the SHA256 instruction support (I added) in bitcoin it gets 1430 khash/s @1.8 GHz so it seems like a pretty good improvement in power efficiency.
Are you saying the daemon should have a different separate version number which maybe is not labled Beta while the GUI full program remains version 0.x.x Beta? I was unaware of OpenSSL support. I don't think I have it being used yet. At least I don't see any speed changes no matter what I have tried.On my VIA C7 1.8 ghz I currently getCode:type             16 bytes     64 bytes    256 bytes   1024 bytes   8192 bytessha256            3379.47k     8061.39k    14412.11k    18119.94k    19447.70kso its still kinda slow. I can't tell if this is with VIA support enabled or not.Trying to figure out OpenSSL support for VIA padlock functions seems like a quagmire from what I see so far surfing the net. Ok, I got a version 0.3.10 bitcoin running on a C7. It does about 1430 khash/s currently on a 1.8 ghz VIA C7.It's not clear yet if  we can get it optimized to do the 2 block hash (1 block pre-hashed) instead of the 3 block hash per nonce-attempt. We'll be investigating that. I just got the VIA-C7 code running in bitcoin 0.3.10 today. I think sgtstein will be putting it up in a public download site real soon now. If you can't wait I guess I can send you a copy. Just ask.It is verified to generate blocks in a closed 2 node new chain system but I haven't had any luck generating blocks in the public chain yet. In the long run most of us will generate fewer and fewer coins assuming more and more people join in and the difficulty keeps going up. Also the "every 4 year, half reward" thing kicks in in the long run. Seems to me it is a good reason to leave Bitcoin as Beta status until this is resolved. Either wx 2.9 becomes easier to install or Bitcoin converts to something else. Almost any software is possible,You just have to find someone to do it. Not me. I don't think you'd want to generate blocks with it tho. check the return values from the open. is it NULL? Note you can get a new motherboard with the VIA C7 CPU included for $65 or less (I got mine from newegg online). Just add memory and you might need a newer power supply to get the right connectors and you'd have a nice upgrade from that old P3. It runs at 1.8Ghz and Ubuntu works fine too.I am working to get bitcoin software working with the built in SHA instructions for the C7 but I can't seem to get it quite right quite yet. Soon tho and it should then be available to anyone. Do the arithmetic. 1BTC / day for 7 weeks = 49 BTC. This whole thing is set up for people who would rather have 49 BTC than 50!I wonder who is pocketing the extra 1BTC. So what do you mean the gui and the daemon should be separated? They already are. You can build the separate daemon. Do you need a separate build of only the gui? I can't see why. I think this shows what you want. This is the total difficulty per day. to get total hashes /day multiply by 2^32. Ya, I am doing that now. There are some problems with the posed code. It doesn't produce acceptable block hashes ye. The speed should still be the same when I get it working right I think. Sorry, afraid I corrected this after you quoted it. The correct calculation would be 0.27 Mhash/s.Excuse me but you need to be more explicit. First does it need a "talented programmer" or is it "child's play"?I understand you are excited about the possibilities but you are making grandiose claims without evidence, nor even concrete estimates of the performance you expect. How bout some actual numbers? How many SHA256 hashes can you really do in parallel on your FPGA? Please state the actual model number of the FPGA you expect to use. What actual data rates are expected?Beyond that is the price of the chips, the price of the developer environment and the power requirements. Any of these can be very significant barriers to this idea.Peace. ...A lot of hand waving there. For some concrete numbers it quotes 53 MB/s and since we only hash 192 bytes at a time, you might think it would do 0.27 mhash/s (but it probably would be less) which is actually within the range of a desktop.Ya, someone might! They measure out about 1.5 mhash/s. There are many ordinary Intel or AMD CPUs can do much better than that (with a little more electric power input tho). This is just what one should naturally expect. Some people have more tolerance for the cost of mining than others.I'd guess both. There is Art with his GPUs who claims to have about %10 of the generating power.Then I see about 850 connections to the IRC channel. Not sure what its been like historically. It's not clear that two or more signature verifications are more than decrypting one message.It's not clear that any conceivable number of transactions received would constitute a scaling problem.Note many people running block generation now verify all the transaction input signatures on all received blocks and transactions. They still have plenty of time left to mine for more blocks at rates of millions of tries per second. The whole process continues even when the net is tossing transactions at them as fast as they can generate them. I don't think we know for sure where the first scaling bottlenecks will be but my bet is it won't be CPU time. I am pretty sure Bitcoin is the first full implementation of the distributed authority model.The mining/generation/confirmation sure seems unique to me too.I guess the two are kinda intertwined. Consider the alternative of mybitcoin.com. It is a client portable to any web browser. You could keep the account/password in your head instead of on a stick. If you want to transact with another mybitcoin account the transaction is immediate too. Not really any different from the classified ad.
This all seems like overkill. If you need quick transactions you can always use something like mybitcoin.com where transfers between two members are instant. If you don't like mybitcoin then start your own.If you cant agree with your customers on one to trust then your issues are such that you should, I think, just put up with the delays of the main bitcoin system. Any trust - verification system will impose delays I think. Consider when the store clerk has to phone VISA for a suspicious credit card. These are simply good reasons for not starting your own little separate independent bitcoin chain. For the best security stay with the main big chain. Instances such as yesterday's should be so rare you don't need to worry about them. The problem of being out powered by some other big entity is well understood and is minimized by staying with the biggest bitcoin chain there is.Note that the current bitcoin net is still tiny and you shouldn't really rely on it yet for anything serious in my opinion. model name      : Intel(R) Core(TM)2 Quad  CPU   Q9450  @ 2.66GHz,   linux 64no difference at about 4950 khash/s model name      : AMD Phenom(tm) II X4 940 Processor  at 3.0 ghz  linux 64with -4way     "hashespersec" : 11132770without      "hashespersec" : 5877668 Im speculating here somewhat but from what I can see someone has generated a transaction, probably using a custom modification of the software to generate a transaction which exploits a weakness in the code. The code check each transaction output for negative numbers individually (up to ver 0.3.8 at least) but forgot to check that the sum of two outputs (where you have the normal output of a transaction and the "change" leftover amount returned to the sender) is negative. So if you put two large but positive values in the transaction the overflow is then only checked that it is less than or equal to the inputs.Normally the inputs are equal to the outputs of a transaction. The exception is when there is a "fee" charged for the transaction. The net allows anyone to voluntarily pay any amout for a fee. SO when the sum was negative the difference from the input looked like a fee. It slipped thru all the checks. Her is some of the details: out Value 1:92233720368.54(7ffffffffff85ee0) out Value 2:92233720368.54(7ffffffffff85ee0)the sum would make -0.01 BTCgenerated transaction "reward" including 51 bitcent "fee" out Value:50.51(000000012d1024c0)that implies the input value was 0.50 BTC seems a block at height 74638 has expoited a bug in the net. It uses an integer overflow to make a negative total transaction. The two transaction outputs are:  out Value:92233720368.54(7ffffffffff85ee0) out Value:92233720368.54(7ffffffffff85ee0)We need a fix asapEdit: (satoshi)0.3.10 patch download links here:http://bitcointalk.org/index.php?topic=827.0 The sum of the two outputs overflows to a negative. Its a bug in the transaction checks which did not reject it, then someone noticed and exploited it. Presumably a new version will be able to reject it and start a new valid fork. meanwhile should probablt shut down whatever you can and by no means make nor accept any transactions. I suppose this might be a good reason to make www.mybitcoin.com or an equivalent your primary bitcoin account/wallet. All you need for it is a browser. It hasn't actually generated any blocks for me yet, so I'm not absolutely certain its working right.I have the Biostar VIOTECH 3100+ motherboard. I don't think that "peering dispute" would have bothered Bitcoin networking really. Only direct connections between the two "warring" factions were cut. Indirect connections through one or more nodes not in either of the disputed territories could still link to both sides. (Both sides kept their connections to Google and Microsoft and so on.) Or they could both get mybitcoins.com accounts and make the transaction immediate for free! The x86 is not of course optimal for much of anything. The reason it is so attractive is obvious tho. Its already out there in huge numbers and since it is in general underutilized we get the cycles VERY cheap.Your custom chip will need a PC anyway to be useful for bitcoins to handle the rest of the process, the networking, storage and even the GUI/UI to set up and control the system. So you actually are not saving money, you're spending more. Its actually really hard to compete with money already spent and people have already spent the money to buy the PC so they can do email and facebook and warcraft and so on. You want them to spend more money on hardware only useful for bitcoins? Its pretty hard to say exactly what "the average Joe" will have in terms of processing power, storage space and bandwidth in 5 or 15 years but I think most estimates would easily cover what bitcoin would take. Its not zero, sure, but its not terrible either. Note significant clues were also supplied by lechesis and tcatm if you're feeling generous. :-) Well, have you tried? It works now if you try it. Send coins to address while no internet. Wait arbitrary length of time then connect and poof there they go! Yes, he can login on a serial line and run the command line bitcoind commands, no problem. What happens if the game matches the spread? The house wins? here: 1HKXYYPCzQptzJsaq2nt8xUgsWNVFRfJWDor here:  75.158.131.108Ya a couple "test vectors" at runtime might be nice but then again if they're hacking they might hack out the test vectors cuz "they just slow ya down!" (logical or not)If there was a well defined hook for the SHA variants it might make it less likely the test code would get hacked out. Not exactly sure how a hook should be designed to work for all the players out there. Stuff like GPU codes and SSE codes where several nonces might be tried in parallel need to be supported. main.cpp:                unsigned int nTime;in the block headers. Thats 32 bits if you don't know. Yes, the Atom, blush.I looked for a Nano in a comparable motherboard package but couldn't find one in the places I looked. It may be more expensive too. I have the Biostar VIOTECH 3100+.
Here is a new plot of the difficulty since the start:note the log vertical axis, don't be misled, the recent increases are bigger than they may look. I just run a simple script once per minute if the balance is above zero send the balance to my central wallet/machine. works fine. The 32 bit Linux build seems ok for those who don't care to try to build it themselves. It's only a few percent slower than the 64 when built right.I guess that flag was put in for old 32 bit machines that might not have sse2. Unfortunatly there is no such thing as a 64 bit x86_64 without sse2 so the conditional compilation produced an empty body which did exactly nothing. It seems to run on 27 watts. Thats including 1 gB ram and actually two hard drives and keyboard and mouse but not including the monitor. Not sure off hand what the power supply is but I think its just a cheap one, not an ultra-efficient one. It is running at 1.8 GHz.By comparison I have a couple quad core intel systems that take 135 to 200 watts.The 27 watts is measured from the UPS LED display (geek squad 1500).When not running anything special (idle loop) the UPS watt meter goes right to zero watts! I guess is like less than 1 watt (it displays 1 watt increments) although I'm not certain of the accuracy. The UPS is probably using more to keep the UPS battery charged than the computer is using on idle. The VIA C7 is a little x86 type CPU sorta intended to compete with the Intel Nano I think except it has some special builtin crypto features including SHA256 instructions.So I hacked up Satoshi's code and got it to do the mining using the buil;tin instructions. It went from 293 Khash/s to 1590 Khash/s.This on a motherboard with the cpu included costing $65 (you can prolly find it for less too). It should be real good on power consumption too. That seems to be the root of the problem. I think even the bundled binary for Linux 64 in 0.3.8 was compiled wrong then. This seems to be a different problem. The blocks do not seem to be "stuck" on my systems. The getinfo shows them up to dateIt seems the sha256 code is not getting built right for linux 64. Not sure if/how it could work on some and not on others. Ok chatting with lachesis in irc he tried this and I get the same result: We added some prints in main.cpp at the SHA calls like so :Code:        loop        {            SHA256Transform(&tmp.hash1, (char*)&tmp.block + 64, &midstate);            printf("mid hash =\n");            for (int i = 0; i < 8; i++)              printf(" %08x", ((unsigned *)&tmp.hash1)[i]);            printf("\n");            SHA256Transform(&hash, &tmp.hash1, pSHA256InitState);            printf("full hash =\n");            for (int i = 0; i < 8; i++)              printf(" %08x", ((unsigned *)&hash)[i]);            printf("\n");            if (((unsigned short*)&hash)[14] == 0)and then in the log we get:mid hash = 6a09e667 bb67ae85 3c6ef372 a54ff53a 510e527f 9b05688c 1f83d9ab 5be0cd19full hash = 6a09e667 bb67ae85 3c6ef372 a54ff53a 510e527f 9b05688c 1f83d9ab 5be0cd19mid hash = 6a09e667 bb67ae85 3c6ef372 a54ff53a 510e527f 9b05688c 1f83d9ab 5be0cd19full hash = 6a09e667 bb67ae85 3c6ef372 a54ff53a 510e527f 9b05688c 1f83d9ab 5be0cd19repeating! The hash call isn't doing anything!(he maybe got a different repeating value, I don't know) I am wondering if its something odd in the way I have my systems set up or  just various plain ubuntu installs so far as I know. I guess I want to know how long I need to run 8000 khash/s at difficulty 1.0 to have any reasonable evidence of a problem. ArtForz said it should tell me in an hour or so.  maybe only a problem with 64 bit linux or something This is on an isolated test net with just two machines, connections = 1, difficulty = 1 I was starting to wonder when my systems seemed to quit generating coins if there was something going on. They went from about 1 block / day to none in a week.ArtForz in irc suggested I run a test isolated net with two nodes only connected to each other with empty wallet dir. I took a couple of quad core systems and set them up. they have produced no blocks in about 90 minutes now while hashing at a combined rate of over 8000 khash/sec. Is this evidence of a problem yet or is it more bad luck?The systems are Linux 64 bit one Intel quad q6600 and one AMD quad phenom II 940. I don't think you understood, it's nothing to do with the size of the transaction. it's the way transactions get split up. If you start with 1 BTC and send 100 x 0.01 transactions to your friend thats 100 transaction chains one step long. He may or may not combine them back together into a single 1BTC transaction but untill he does the net must keep all 100 transactions stored.If you start with the same 1BTC or 0.01BTC or any single amount and pass it back and forth to your friend 100 times. Its a similar amount of traffic and storage at first but once the last one gets deeply confirmed (ie 6 blocks/1 hr later) you can forget/delete from your disk database all the transactions but the last one. It's the Merkle hash tree pruning stuff in the white paper. I was thinking of some sort of simple donations accepted sort of site where you just say send your bitcoin donations to ip address, put your name and email address in the message and we will email you a receipt if you desire one. Or leave your name and address in the message if you want to be added to our mailing list or whatever. You don't always want to generate a full bitcoin receive address just on spec that they will send a donation.Maybe not the best thought out idea but thats what I was thinking. Note that it would actually be very hard to keep them separate in such a situation. It only takes one rogue node to connect the two and keep them in sync. I'd think there would be someone in some 3rd country who would act as go between (maybe somewhat like Switzerland did in WW2). It would seem probable to me there would even be many connections no matter how hard some authorities might wish to separate them. There could even be certain parties within the warring governments who would reconnect them for their own reasons (bankrolling spies?). ok if a and b both start out with 1 BTC and agree to transfer 0.0001 using two inputs and two outputs on a single transaction can change a to 0.9999 and b to 1.0001. The rest of the network it would seem would accept the transaction.The only stumbling block is whoever creates the transaction needs the private keys for both inputs which would come from different wallets normally. The one who creates the transaction could cheat. Sending 1 BTC back and forth a million times creates a single transaction chain, sending a million transactions of 0.000001 BTC makes a million nearly independant transactions which all must be remembered. Due to the way bitcoin can drop old deeply confirmed transactions the first is far less overhead than the second in the long run. There may be similar network cost but the disk space cost can be greatly reduced for the single chain. Only if the "dust" is combined back together and confirmed deeply enough again only then can the dust space be dropped. I cant figure out how to send a transaction to an ip address from bitcoind command line interface. Has the function been implemented yet? (linux 64 if it matters) I presume mainly just to bring up an alert that an incompatible change is running on some nodes, weather it is a new version from Satoshi or someone else is trying to change something either way it'll be nice to know.
