The source that Hazard posted contained the old, pre-release genesis block, the only difference in main.cpp from what I got off of github yesterday was this:diff ../../elacoin-hazard/src/main.cpp main.cpp 887c887<       diff = GetDifficulty2(FindBlockByHeight(nHeight-1));--->       GetDifficulty2(FindBlockByHeight(nHeight));(Granted, I downloaded it about 20 pages after he posted it so I have no way of knowing if released the source with the real genesis block then changed it later) Fun watching the debug log as the blocks come in.  Looks like there is 1 or 2 a second.  Also seeing lots of long block chain re-orgs:REORGANIZE: Disconnect 6 blocks; 42f941a6031dc3b41af2..cc03f278f04afbde208aREORGANIZE: Connect 7 blocks; 42f941a6031dc3b41af2..0c8845a4d9d15e7a7507REORGANIZE: Disconnect 5 blocks; 42f941a6031dc3b41af2..40341ca5c6965be3481eREORGANIZE: Connect 6 blocks; 42f941a6031dc3b41af2..cc03f278f04afbde208aREORGANIZE: Disconnect 4 blocks; 42f941a6031dc3b41af2..4acdf17c62282444c8f8REORGANIZE: Connect 5 blocks; 42f941a6031dc3b41af2..40341ca5c6965be3481eAnd the longest I've seen:REORGANIZE: Disconnect 13 blocks; f243992c9eda69cee1e7..71117064476dd175253fREORGANIZE: Connect 14 blocks; f243992c9eda69cee1e7..311620c256d3b658ff55and REORGANIZE: Disconnect 15 blocks; 651da75d037edf65f818..6788c730fb52a72f2a41REORGANIZE: Connect 16 blocks; 651da75d037edf65f818..c9039814ed1318c2e2ce I agree.  History has now shown that starting an alt coin that uses the same hashing algorithm as an existing, strong, coin is a bad choice.  We now have had several examples of this.The first was Namecoin, where the difficulty went way up then mining power left and it was stuck for several months at super-high difficulty.The next was CoildCoin (CLC).  It had merged-mining right from the start in an attempt to have a higher hashrate. However, Luke-Jr (who controled the Elgius pool at the time) set the pool to merge-mine it and not allow anyone elses blocks or allow any transactions in his blocks.  Since Elgius had a much higher hashrate then the rest of the network, he was successful and the network stalled.For Terracoin (TRC) a single person with a bitcoin ASIC starts mining and causes the difficulty to fluctuate wildly (first difficulty calculation method) or causes it to go up and stay up (second difficulty calculation method).  That person had over 50% of the hashpower and could have done much more damage (and still can if they want to).  They could mine their blocks exclusively, ignoreing any blocks found by anyone else, thus getting all the block rewards, excluding others transactions, and doing double spends at will.re-using the same hashing algorithm sounds like a good idea, it takes less effort, you don't have to worry about introducing new bugs, and you can take advantage of all the optimized software/hardware to get your hashrate up.  However, an attacker has access to the same software/hardware that you do, may already have a lot of it, and, often has a vested interest in a different coin succeeding so have a reason to use those resources to attack a new chain.This is certainly true for sha256 and is mostly likely true for scrypt now (if not, certainly when scrypt fpga's come out it will by). So this means that there is going to be another mandatory update sometime in the near future with yet another difficulty adjustment algorithm? I like the idea, but have a couple of commentswhitepaper: "BLAKE512, SKEIN512, SHA3-512 (KECCAK512), and SHA2-512 are incorporated with both Salsa20 and Chacha20 stream ciphers."I like how this makes fpga's and asics harder, but it also means that if there is a flaw in any one of these hashes or stream ciphers then the coin fails.  Is there any other way to achieve this goal?whitepaper:  "Transactions will largely stay the same as in BTC; coin age will be calculated from the the timestamp of the block in which it appears."Why calculate from the timestamp and not the block height?  timestamps can be incorrect, the block height can't be. They both give estimates since the block height to time calculation is based on the target block time that isn't always met, but it is good to base as much as possible on truths inherent to the blockchain. You should try Tenebrix: https://bitcointalk.org/index.php?topic=45667.0Should be done "real soon now"  The poster was probably alluding to an article like this one: http://www.usnews.com/news/articles/2012/03/14/pilfered-tide-detergent-new-drug-currencyAuthorities say a bottle of Tide detergent is relatively easy to steal, hard to track, and can fetch anywhere between $5 to $10 on the black market. Normal retail prices range from $10 to $20. I like that you are hosting multiple faucets, thanks.If these are funded by advertising revenue, how are you going to allocate the revenue between them?  Are you tracking which page/faucet the click came from, dividing it equally, dividing it based on number of faucet requests, or something else? Yes please: 1M7pkz73gX4vkeUACGQaTtgf9T6XyRiXV8 I'd have the structure be like this:# Alternative Monetary Systems   # Crypto Currencies      # Bitcoin      # Litecoin      # ...   # Local Currency SystemsI wouldn't put 'market' under data either.  Solidcoin does this (or did this, with the last change I'm not sure it still does).I think a better way to capture changes in demand would be to base the reward on  the rate of change of the difficulty instead of the absolute value of the difficulty.  If the difficulty is rising rapidly, the block reward goes up.  If the difficulty isn't changing, the block reward goes back to the standard 50 coins per block.  For example, if the difficulty re-targets from 1,000 to 1,500 then the amount of coins per block goes to 75, if, at the next retarget the difficulty stays at 1,500 then the reward goes back to 50, if it jumps to 3,000 then the reward would go to 100.  This keeps technological breakthroughs from having a permanent effect.  The exact percentage to raise it, and how long to keep it raised would have to be determined. But it would take hours, if not days for enough people to notice and start ignoring you.  In that time a lot of damage would be done. These things are very complicated and take a long time to understand, I doubt there are more than a few people in the bitcoin community that really understand them. I'm not even sure these things belong in the block chain instead of being handled outside of it (via Open Transactions or something similar).Extending the single-purpose bitcoin infrastructures (exchanges and block explorers and mining pool software and etc.) to be multi-coin is a real accomplishment.  Sites like allchains.info, blockexplorer.sytes.net, and the multi-coin exchanges are a big improvement over having lots of coin-specific sites.  You might not consider them innovative, but you aren't giving them enough credit.Most of attacks on the alt-chains were possible against bitcoin too, bitcoin was just lucky that no one attacked when it was young and didn't have the value it has now.  Even so, a well-funded adversary could easily spam the bitcoin block chain.  Be glad that these issues are being worked out on the alt-chains where the stakes aren't as high.There has also been a lot of experimentation with the fundamental economic models.  No one knows if  a coin should be deflationary, inflationary, or stable-value, nor do they know the best way to accomplish the goal.  Pre-mining to provide funding for improvements versus no premine and no funding for improvements has been another area of experimentation (it looks like pre-mining lost). The economic basis for a coin can't be changed easily (if at all) so it isn't surprising that is the first area that is worked on.Merged-mining is pretty innovative, as is namecoin,  both were developed this year.I think you are trying to get people riled up so that they try and prove you wrong.Your probably right on this.  It is very hard to make substantial changes to an existing block chain. That's an impressive improvement.  It doubled my hash power with a small decrease in power consumption.  My spidey sense is tingling, there will be a big jump in difficulty soon.On the old miner I found that I'd get a small increase in hash power by running more threads than cores, for this one there isn't any advantage to extra threads.  The purpose of the Internet Archive isn't to publicize bitcoin, it is "universal access to all knowledge".  Their accepting bitcoin is great, breaking your pledge because they don't position it as prominently as paypal seems rather petty. I'm going to come back to the newbie forum and post on random threads. I won't be taking over, but since I have been digging around the litecoin code recently I decided to see how hard it would be to port my changes to fairbrix.  If people are really still interested in fairbrix they should put together a bounty pool to pay for future updates.I made changes in line with what coblee did for litecoin, but modified them some to take into account the differing block times and current value of a coin.  I've also put in some other changes that I think will help fairbrix resist attack in the future.  All the changes I made relate to spam transactions being included or relayed by honest nodes.  If an attacker controls a significant portion of the hash power (a real possibility in fairbrix) he can bypass these checks and write 1,000,000 byte blocks.You can get the source from: https://github.com/beecee1/Fairbrix   sorry, no pre-compiled binaries.If you like what I have done, you can donate: fVQZtuBPRdVjbNskqHLB4e75Uq64dM9vWNHere is a description of all the changes I made (and, you have the source code so you can verify it yourself).In main.h:From:static const unsigned int MAX_BLOCK_SIZE_GEN = MAX_BLOCK_SIZE/2;To 125,000 bytes:static const unsigned int MAX_BLOCK_SIZE_GEN = MAX_BLOCK_SIZE/8;Why: reduces the size of a block that an unmodified client will generate, helps protect against block-chain growth attacksFrom:static const int64 CENT = 1000000;To:static const int64 CENT = COIN/100;Why: easier to read, no real changeFrom:static const int64 MIN_TX_FEE = 50000;static const int64 MIN_RELAY_TX_FEE = 10000;To:static const int64 MIN_TX_FEE = 1000000;static const int64 MIN_RELAY_TX_FEE = MIN_TX_FEE;Why: increase the minimum fee (when fees apply) to 0.01.  This is less than litecoins so you that the fee isn't quite so large when you send an output that is nearly a cent.  However, there is code elsewhere that will increase this fee for very small outputs.From:int64 nMinFee = (1 + (int64)nBytes / 1000) * nBaseFee;To:int64 nMinFee = (1 + (int64)nBytes / 500) * nBaseFee;Why: This makes large sized transactions cost a more than before.From:if (nNewBlockSize < 27000)To:if (nNewBlockSize < 12000)Why: since blocks are faster than in bitcoin, reserve less space for free transactions.From:        if (nMinFee < nBaseFee)            BOOST_FOREACH(const CTxOut& txout, vout)                if (txout.nValue < CENT)                    nMinFee = nBaseFee;To:        BOOST_FOREACH(const CTxOut& txout, vout) {            if (txout.nValue < CENT/10) { // outputs smaller than 0.0001                nMinFee += nBaseFee * 10; // fee of 1                smallTxOutCount++;            }            else if ((txout.nValue < CENT)) {                nMinFee += nBaseFee;                smallTxOutCount++;            }        }Also add:        if(smallTxOutCount > 15)            nMinFee = MAX_MONEY;Why:  This is the core change to limit dust spam.  Instead of a flat fee for small outputs charge a fee for each small output.  If there are more than 15 small outputs than don't allow the transaction at all.In main.cppFrom:if (dFreeCount > GetArg("-limitfreerelay", 15)*10*1000 && !IsFromMe(*this))To:                dFreeRelay = GetArg("-limitfreerelay", 5)*10*1000;                dPartialRelay = dFreeRelay * 0.75;                dNewFreeCount = dFreeCount + nSize;                if( !( dNewFreeCount <= dFreeRelay                    || dFreeCount < dPartialRelay                    || IsFromMe(*this)                  )                )Why: another spam attack mitigation. Don't relay more than (on average) 5000 bytes of free transactions a minute.  This is roughly equivilant to 20 normal sized transactions per minute, which is far in excess of the current volume.Add:        (nHeight == 15000 && hash != uint256("0x7c7fc755c19616fd3eb156b53dae2bbf058972e0731f3d0ee54785cc222f4bbf")))Why:  add a checkpoint lockin at block 15000From:bool fAllowFree = (nBlockSize + nTxSize < 4000 || CTransaction::AllowFree(dPriority));To:bool fAllowFree = (nBlockSize + nTxSize < 1800 || CTransaction::AllowFree(dPriority));Why:  Since blocks are faster in Fairbrix, don't allow as many exempted free transactions. (But they are slower than Litecoin's so allow more than that).In wallet.cpp:From:int64 nPayFee = nTransactionFee * (1 + (int64)nBytes / 1000);To:int64 nPayFee = nTransactionFee * (1 + (int64)nBytes / 500);Why: matching a change made in main.h I have a minute or so of delay between when the splash screen goes away and the gui shows up.  How long have you waited?  If you have tons of spam transactions it could be a while.Check the debug.log, I'm not sure where it is under windows but look in the same directory as the wallet.dat file.  If it is still getting written to then the process is still working and hasn't gotten around to showing the window. It is really just an acknowledgment that my imagination is limited and other people might be able to come up with something useful that wouldn't be possible with higher fees. Pay per share mining is one possible example, but I haven't every joined a pay per share pool so I don't know what they do when someone is due a very small payout.  I'm also thinking that if someone started trying to spam with >= 0.001 ltc then it would quickly add up to a useful amount of ltc.  Dust spam would still be prohibitively expensive though.It isn't quite the same since we use nBaseFee other places, like in the small transaction case.  If it is too hard to change then it might not be worth it.I like your concept of auto-scaling the definition of spam.  Much better than requiring periodic intervention. I like the idea of charging higher fees for lots of small outputs, however, we risk capturing small-but-useful transactions in the mix.  I also want to have fee formulas we can keep instead of temporarily changing them and planning on changing them back.  Instead of two tiers we could have three with only the lowest tier getting charged per-output feeslarge value = no feesmall value = .1 fee per transactionvery small value = .1 fee per outputMake "very small" be 10% of small and all these too small to be useful even when aggregated transactions are really expensive, but leaves open the possibility of small but potentially useful transactions (like paypershare mining)If we are making the fees additive, we'd want to remove the "if (nMinFee < nBaseFee)" check so people can't escape the per txout fee by making the block larger.We can also have a higher fee for large-sized transactions.From:        int64 nMinFee = (1 + (int64)nBytes / 1000) * nBaseFee;To:          int64 nMinFee = (1 + (int64)nBytes /  500) * nBaseFee;That would only have an effect on blocks larger than 27000 bytes (but we could make that smaller too).Code:            BOOST_FOREACH(const CTxOut& txout, vout) {                if (txout.nValue < (CENT/10))                    nMinFee += nBaseFee;                else if ((txout.nValue < CENT) && (nMinFee < nBaseFee))                    nMinFee = nBaseFee;            }This would be independent of any nMinFee scaling that was done based on difficulty.
I thought there was only 500 bytes of space allocated for free transactions, that block has over 3k and there aren't even any paid transactions. That would probably be ok, however, you can't choose which coins to use so if you had a bunch of older coins and one new one which was exactly the size you want, I think the client would choose that one.  We'd need to combine it with a tweak to the coin selection algorithm.I posted a thread on liteco.in earlier with some suggestions for rate-limiting.  I think if we changed that we could reduce the number of spam transactions that get through. (since we have more frequent blocks and less space reserved for free transactions we should have a lower rate limit). http://liteco.in/threads/rate-limiting-to-prevent-flood-attacks.43/ Your ssl certificate expired a few days ago,  I now get a security warning when I go to https://lc.ozco.in/ for bitcoin there is the list of Incidents  but it would be nice to have a cross-coin list. He is probably going to figure out what types of transactions get in the block chain for free then try to send a bunch of those, pushing out genuine free transactions.  This will make litecoin less inviting to newbies which is bad.I think we should come up with several algorithms for deciding which transactions are free and let miners decide which one to use (via a config file option)It would also be good to let miners configure a blacklist of addresses that they don't want included in blocks.  I wouldn't want it populated by default, but if a user wanted to they could add addresses to it themselves and those wouldn't go in blocks or be broadcast to other connecting clients. I'm not sure about when bitcoin first came out, but the minimum fee was 0.01 back when bitcoins went for around $0.10.I also think a 0.01 fee for litecoin would be better than 0.1.  Are you going to open up a thread on liteco.in to discuss this? I don't expect people to make changes blindly.  The more people who look at the change and post what they think about it the better.Wow, you're really pouring on the FUD.   Yes, it is easy to see what it does.  Litecoin behaves the same way as bitcoin when faced with transactions with too small a fee, it doesn't broadcast the transactions to peers, it doesn't insert them into a block if it is mining.  It does keep them and if a block shows up with them in it it will accept the block.So no, there aren't any forking issues, I'm not rejecting those blocks, and I'm not going to be an outcast from the block chain.Several sites seem to have had problems with this torrent of transactions, maybe it was insufficient hardware, maybe it was something else.  Everyone should think about the value they get out of a block chain and its cost to them.  Since litecoin is very new, the value it provides is still low so if they have to have more powerful machines and dedicate more disk space to it some people will decide it isn't worth it.  Years from now, if litecoin proves to be durable this volume of transactions won't be an issue since the value people get from litecoin will be higher.  Today, it is an issue.I know these points are moot since coblee has released an updated client, but I wanted to address your issues. 1 LTC seems a pretty steep fee.  I took out a zero in a couple of places to make the fee 0.1 when I recompiled, but I think 0.01 would be sufficient.The good thing about this is that all these spam transactions now put a message in the log:ERROR: AcceptToMemoryPool() : not enough feesIf everyone made these modifications the spam 0.00000001 transactions wouldn't propagate. If you simply mine every other difficulty adjustment period you won't be taking advantage of the asymmetric difficulty adjustment.  You'd just be sending a big pulse of mining power for one period when difficulty is low then going away the next one when it is high.  You can do this on any blockchain out there.  This happened to NameCoin earlier this summer before merged mining, lots of people left which caused a huge difficulty drop then everyone rushed back in and completed two weeks worth of blocks in less than two days.Now that there are lots of block chains out there someone is sure to come up with a script (or a pool) that switches to the most profitable one at any given time, be it bitcoin, litecoin, or solid coin.  They may stay for one (power)block or they may stay for weeks.  Lots of people will use scripts/pools with similar rules so you'll see large pulses of mining power jump among the systems. Pulsed mining will soon be taken for granted.Where solid coin's asymmetric difficulty adjustment comes in is when 1) you have over 14% of the mining power, and 2) even after an adjustment it is still more profitable than other chains.   Number 2 is more likely with solidcoin than other blockchains since the difficulty doesn't adjust up as fast.  This happened right when it launched when there was a huge influx of miners and difficulty didn't adjust up very fast. He's not talking about mining every other block, hes suggesting mining every other difficulty adjustment period.  So you mine the user blocks for one 360 block period then you go away for the next 360 block period.  If over 14% of the mining power does this you will come out ahead (on a per cpu cycle spent mining solidcoin) of where you would be if you mined solidcoin full time. Interesting, you'd effectively be slowing the velocity of money.  I'd hate it if I really needed to spend that money, and it would create some odd change transactions.  Instead of freezing a percent of all coins, you could increase the waiting period before transactions are confirmed.  If value goes down, a coinbase transaction doesn't mature for 240 or more blocks, a normal transaction doesn't get confirmed until 12 blocks have passed.  I wonder how long you could freeze the funds before it had a negative impact.  I know you're thinking of enCoin which has different mechanics, but I think it would apply to either (with some variation). Explain why this is dangerous.  The way I see it a miner creates a transaction with a huge fee but doesn't propagate it unless/until they mine a block.   If they succeed they get lower fees, if they fail, they flush the transaction.  It seems like it has no downside.If you only include transactions that have the minimal fee you eliminate the ability for someone to pay extra to get priority service (only really important if block sizes are nearing the maximum).  You also penalize transactions that are using a different algorithm that happens to be more generous, that seems like an odd thing to do. The current block being a Power Block depends on both the last trusted block and the last user block:    if(trustedcount>=128 && usercount>=239) return true;        //1 in 16 chance for user, 1 in 2 for trusted, = 1 in 32 totalAs of now, there is only one control node generating trusted blocks at a time.  This control node can effectively "turn off" power blocks entirely, or double the probability of one occurring, or anything in between.When a control node generates a block it can count up the bits, if they are >= 128, it could discard the block and generate another one instead of transmitting it.  It could be a bit more clever by checking if the prior user block was >=239 before deciding if it should discard the block it just generated, this would minimize the impact on the network.A control node could increase the probability of a power block in a similar way.  It could discard blocks it generates unless they meet the criteria for power blocks ( bits >=128 ) this would make the power blocks be entirely depended on the prior user block, gving it a 1 in 16 chance. I think Microsoft's assumption of a directed graph oversimplifies things to the extent that in invalidates their research.  In short, a node always has an incentive to try and follow the chain back towards the source to insert themselves higher in the chain and to shorten it.  This gives them a larger reward.Acording to their  paper, each node in the chain up to a depth of 'H' gets a reward B.  The node that solves the block gets a fixed reward plus some additonal reward based on how much shorter than H the chain was "1+(H-L+1)B"  This means the shorter the chain is, the greater the reward that goes to  the miner.  For simplicity, lets take H to be 4 and a chain of the full length:NodeANodeBNodeCNodeDNodeD solves the transaction so gets a reward of 1+(4-4+1)*B = 1+B. The total reward would be B for NodeA, NodeB, and NodeC and 2B for NodeD for a total of 1+4B.  However, if NodeD were able to contact NodeA directly the chain would be:NodeANodeDNode D again solves the transaction but this time its reward is 1+(4-2+1)*B = 1+3B with nodeA getting the remaining B, the total reward is still 1+4B.Initially NodeD doesn't know how to contact NodeA, it only has a public key not an IP address, however, over time, as NodeD sees more transactions it will be able to associate particular keys with particular IP addresss.  For instance, in the first example, NodeD learned what NodeC's ip address is since it got the transaction directly from it.  In the event that NodeD didn't know how to contact any other nodes in the chain, it would be to its advantage to contact every node it knows and ask for the transaction in the hopes that one peer would be part of a shorter chain, this could greatly increase the amount of traffic that goes over the network.The stated goal of the paper was to incentivise forwarding of transactions by paying intermediate nodes.  Intermediate nodes, however, would be cut out of the chain fairly quickly so would have the same incentive they have today (which is none, but that may not stop them from forwarding).This scheme could have a perverse effect though.  Right now you can't gain any real advantage by trying to monopolize the connections a node has.  Under this proposal you would.  If all the nodes connected to a particular originating node were controlled by you, you couldn't be cut out of the chain since no one would know how to contact the originating node.  Instead of encouraging more peers by providing them with fees, it would encourage more centralization. Taking advantage of SoldCoin's PowerBlock weakness is easy.  All you have to do is modify the get_work function to return an error unless the current block being mined is a power block.  Even when you are solo mining you still go through the rpc interface for getting work.  This won't work if you are using someone else s pool because the check is done in the server before get_work returns, however, if you have several computers you can set them all to mine against a single solid coin instance and have your own mini-pool.Here's all you need to do:Open  rpc.cppafter line 2106: "BLOCK_DATA blk;" add the line:int isPowerBlock = 0;after line 2153: "blk=pBlock->blk;" add the line:if(pBlock->m_bPower) isPowerBlock = 1;before line 2174: "return result'" add the lineif(!isPowerBlock) throw JSONRPCError(-10, "This is not a Power Block...");Recompile, restart solidcoin, and start solo mining.  Your Hash Rate will be at zero and you'll see a steady stream of messages:sc_getwork error: This is not a Power Block...When it is time to mine a power block your Hash Rate will go above zero until the block is solved (by you or someone else) then it will go back down to zero as it waits for another power block.If you are mining other coins at the same time, you'll want to 'nice' them so that solid coin gets most of the cpu when it is running.  (you should nice them anyway so mining doesn't slow down the rest of the stuff running on the computer.)  You can start your miners niced by putting "nice +19" in front of your minerd command like so:nice +19 minerd --url http://example.com ---userpass greater:foolYou wouldn't want to 'nice' solidcoin so it gets more of the cpu when it is running. Modifying the built-in miner to do exactly this is incredibly easy. According to SolidCoin, there is a 1 in 32 chance that a block is a PowerBlock, the number of coins you generate in a power block is double a normal block.You can't use a random function to determine if a block is a powerblock because other clients wouldn't be able to verify it.  You also can't use information in the block being generated because a miner could manipulate it to make every block a power block.  The only thing you can use is the block chain since that's the only state that all clients share, and, that is what solidcoin does.Here's the code that determines if a block is a power block:bool Block_IsPowerBlock(const uint256 &trustedhash,const uint256 &userhash){    unsigned char trustedcount=trustedhash.SumOfBytes();    unsigned char usercount=userhash.SumOfBytes();    if(trustedcount>=128 && usercount>=239) return true;        //1 in 16 chance for user, 1 in 2 for trusted, = 1 in 32 total    return false;}It is called with the two previous block's hashes as arguments.Since you can tell if a block is a power block just by looking at the hashes of two prior blocks, you can decide if you want to mine the block or not. You can choose to only mine power blocks.I don't think this works out to exactly 1 in 32 blocks in practice since a good hash has to have some number of leading zero bits, as the difficulty gets higher the chance of a block being a power block goes down slightly.  Although this is unintended, it probably isn't bad.If you only mine powerblocks, you'll get a higher payout for your cpu cycles. Most of the time (about 56 minutes per hour) you'll be idle. During the down times you can mine some other coin (like litecoin, or another cpu-friendly coin). People have talked about using "balance sheets" to do exactly this.  See https://bitcointalk.org/?topic=473.0 and https://bitcointalk.org/?topic=505.0 for a more complete discussion. If you got the note from someone else, how would you know if one of the prior owners was colluding with the bank?  Let's say your employer pays you with bit notes.  Unknown to you, your employer didn't get them directly by depositing money in the bank but bought them on the secondary market.  What if the bank was selling it's own notes on the secondary market (and your employer bought them from that bank without knowning it), ie, the bank was one of the prior owners?  Then it would have everything needed to spend the money on deposit.I think on each transfer you would have to not only get a new secret from the bank, but generate a new private key, which means you'd have to have a bitcoin transaction, which is what you were trying to avoid. Now it is up to around 15, right around half the network.  And all of it in the "other" category, not in one of the pools.  It could be an attack, or it could be a user with a lot of cpu's.  Should make for an interesting couple of hourse.
As someone already pointed out, the number of coins is near-constant, so you will have little, if any, effect on the rate of inflation.You will eat some sell orders, however, the coins you would have mined will now go to someone else who will probably put them on the exchange, so you aren't affecting things as much as you think.By lowering the difficulty of mining you are weakening the network.  Not by very much, but it does make it slightly easier to attack. The average person doesn't know or care the details about cpu vs gpu, but that doesn't make it immaterial.  If someone hears about bitcoin and looks into it, they will quickly realize that mining is impossible, they have no choice but to go to the exchanges.  A cpu friendly coin will allow more people to be able to actually mine coins.  It is much better for someone who is just learning about a currency to be able to play with it for just a few cents in electricity. It won't surpass Bitcoin, it is too similar.  It might be able to co-exist though.  The only real advantage is that people without super graphics cards can get coins,  if there are enough people in that situation it should be ok. Having different rules make it seem more like an entirely different network than a testnet, it also makes it less effective as a test platform.  Would it be possible to automatically reset it once a week? At least he used descriptive variable names. Which brings us back to the original question,  how come litecoin doesn't scale the processing power and memory usage over time. GPU's already have 1 to 2 gigs of memory on the card, and they are very good at streaming data.  Yes, scrypt uses random access to limit the benefit of the streaming memory, but that really only adds latency.  Even if GPU alus don't get enough cache in the future, threading would let you hide the latency by having more processes.Take the extreme case, lets say litecoin is around in 15 or 20 years, are you really convinced that GPU's won't get cache or threading in that time? scrypt is designed to scale in both processing difficulty and memory use,however, litecoin doesn't seem to have any way to change either. This seems like a big oversight, in a few years it won't be so gpu unfriendly.For the salsa 20 hash, litecoin uses the 8 iteration version.  There have been identified attacks for 7 rounds, this doesn't leave much margin of error.  The 12 round variant seems much safer.Anyone know why these choices were made?  Are they just copied from tenebrix? Thanks.  I that clears up a lot.  Can you change the outputs or are they required to be the same? They seem to have the same list to me.  Newer versions have additional entries but once on the list they don't seem to changeList from 0.3.19:nHeight1111133333685557056774000List from 0.3.23:nHeight1111133333685557056774000105000118000 I think I'm beginning to understand this, tell me if I have it right.  A output can only be spent once, thus, if two transactions spend the same output (as one of their inputs) then they count as the same transaction. So if you had two transactions:T1:Input1,Input2 -> Output1T2:Input1,Input3 -> Output2They would both be considered different versions of the same transaction since the both share Input1.If you had a transactionT3:Input1 -> Output1 with a lock time that was non-zero and greater than the current block number then that transaction then that transaction is still open, you would be able to broadcast a replacement transaction (with a higher sequence number) and change the output or the script  (or both) to whatever you wanted, but you couldn't change the input.(I realize this isn't all implemented in the client, I'm just trying to figure out how it will be done when devs get to it.) Coins get created with new blocks, not new transactions.  They can even be created with no transactions (except the coin generating one) in it.  The only thing miners get that is associated with a transaction is the fee and that fee comes from the person sending the bitcoins (the borrower in this case).  Sorry, no free lunch. They really are a type of currency, people don't think of them as such because they aren't freely convertable, you're pretty much stuck using them on airfare or some fairly limited catalog of products, but companies (like credit card companies) buy them from airlines to give out as rewards.Amazon could start a new blockchain then give the coins out as rewards points.  You could then redeem them for money off on your purchase. They could also sell them to other web sites, you buy an airline ticket and get X amazonRewardPoints.  Since it is based on the blockchain, any partner could verify the number of points out there.  Also, they could accept points knowing they were free to re-distribute them and that Amazon was effectively fixing their value.  Pretty soon you'd have a large network of merchants both giving out and accepting points without having to trust each other not to create an arbitrary amount of points. I doubt you'd ever see a government agency using it to record legal records.  You might be able to use it for contracts though.  You could encode the contract conditions right in the message. (I know there is a thread about contracts going on now for regular bitcoin but I think it requires you to specify the contract out-of-band). Lots of questions here."Why would they need to know?":  There is a field in the transaction to say it is an updated transaction.  If that is to be useful, you have to know what transaction is being updated."If you changed everything in the transaction, what difference does it make whether it's updated or new?" If it is updated then the old transaction wouldn't go through, if it is new then the old transaction  could go through too.  I wouldn't expect people to change everything , even if they changed one of them how would you tell that it is updated?For example:You change the output: how do you distinguish it from a double spend attempt.You change the input(s): how do you distinguish it from a second transaction to the same output? I don't think so.  Namecoin doesn't include the suffix, .bit is just a convention.  Of course, since it can store arbitrary key value pairs and the key portion has a specifier you could create a new, slightly different DNS that did have suffixes.  That would probably cause more confusion than it is worth though. Nothing prevents other virtual currencies from coming up.  There will probably be multiple ones based on bitcoin.  Bitcoin has first-mover advantage but if a new one comes along with a large enough advantage over bitcoin then it could take over. The protocol https://en.bitcoin.it/wiki/Protocol_specification includes a lock_time field for transaction (bitcoin doesn't currently implement it), the description from the wiki: "The block number or timestamp at which this transaction is locked, or 0 if the transaction is always locked. A non-locked transaction must not be included in blocks, and it can be modified by broadcasting a new version before the time has expired"  Then in TXIn there is a field for sequence, describe as: "Transaction version as defined by the sender. Intended for "replacement" of transactions when information is updated before inclusion into a block."What is unclear to me is what changes to a transaction would be acceptable in an update, could you change the source coins, the destination address, the script?  And, if they are changed, how would miners determine that this is an updated transaction and not a new, totally different one? You seem to think that you are using a currency system with a contract that states the rules are fixed and will never change.You should re-read the rules of bitcoin because you have missed a big one.  The rules are set by a majority of the miners (with the consent of the majority of people sending/receiving transactions).  If the majority of users vote to change the rules (by using software that implements new rules) then the rules are changed.  You know (or should know) this and implicitly agreed to it (by using bitcoins), it is part of the system and has been from day one.  Your bearer certificate example is simply not relevant. Just to be clear, Namecoin has the features of bitcoin (since it is a fork of bitcoin) plus the distributed data store, you wouldn't back bitcoin with namecoins, you would use namecoins instead of bitcoins.It wouldn't completely solve the liquidity problem but it would help,  if you want something other than names, like food, and if you were having problems getting people to accept namecoin for food, you could sell it to someone who does want the naming feature and buy food with the proceeds.
I think you pretty much answered your own question here.There are some people who like backed money (money that has a applications outside of its use as currency, like gold/silver) and some people who are ok with unbacked fiat (like USD), It was probably a mistake for me to list USD as one of things that could be used to back an electronic currency.  The point I was trying to make was that NameCoin has the features of Bitcoin plus it has utility, that may make it acceptable to people who wouldn't be interested bitcoin. If your document happens to hash to a valid bitcoin address.Since your keys have to be in a particular format you are pretty limited, namecoin has a more flexible way of storing data which makes it suitable for a larger number uses.   I just re-read the thread and I don't see the place where he asked for me or anyone else to reimburse him.I look at it this way, if 1 of your neighbors says "I had the house locked and someone still broke in" I'll be more careful,  If 5 of them say it I'll be even more careful (like change my locks), each report I hear I'll increase my vigilance.  It is very useful to hear about them to get an idea of the magnitude of the problem.  If, after all that, I still get my house broken into, I'll tell my neighbors and it is still the thief's fault. There are regular threads here about how bitcoin isn't backed by anything, generally followed by a plan to back it with gold or silver or dollars, however, every one of those plans relies on a central authority.  This doesn't work since that central authority is subject to bankruptcy, corruption, and government influence.In order to keep the distributed nature of bitcoin you would have to back it by something that is itself virtual.  That got me thinking that maybe Namecoin is really a backed virtual currency.  Even if the dollar/bitcoin/whatever value of namecoin went to zero, you'd still be able to use it for something. Currently, that something is registering domains but it is set up to allow you to store name/value pairs.  This makes NameCoin a currency that is backed by the right to use a distributed data store, pretty interesting. Yeah, and if a thief breaks into your house, you can't really blame the thief because you know that locks can be picked, it's partly your fault for not staying in your house all the time with an automatic weapon. Satoshi's solution was a centralized payment processor (albeit one that commits transactions to the block chain immediately, not one with an alternative currency that is pegged to bitcoin).  He thought it would still take 5-10 or seconds, not microseconds. He is also depending on conventions of the client (that the first transaction seen is the only one kept/propagated) that could be changed without requiring any consensus (if some clients changed it and some didn't everything would still be interoperable).  There is also the risk that a malicious double-spender would be able to identify the payment processor's nodes and prevent them from seeing the other transaction even though miners were incorporating it into a block.Then there is the issue of transaction volume, there are other threads talking about the amount of disk space and bandwidth required to handle 2,000 transactions a second (its a lot, the average user wouldn't be able to handle it), if we had fast transactions and if all the snack machines were connected you'd have a couple of orders of magnitude more transactions.I don't think that anyone has come up with a good solution to the fast transaction (and high volume) problem within the current bitcoin blockchain.  The pool owner could return a block with a pool address when getfullwork was called and a private address when getwork was called, you'd be none the wiser.  You'd have to call getwork then be able to pass that block header back to the server and request the full block that matches it. I think this proposal has a lot of promise.  I doubt that it would get incorporated into this version of the block chain but maybe a competing chain will pop up with it.Markets work best when all participants have access to the same information and the more complete the information is, the better markets are at setting an accurate price.  Having coins that could be lost or could be being hoarded adds uncertainty which negativily affects the price.  If one trader knows that a certain set of coins is lost when everyone else thinks they are hoarded he has an advantage in the market.  Letting everyone be certain that lost coins will eventually be recovered makes pricing more accurate in the same way that letting everyone know that there will be at most 21 million bitcoins makes the pricing more accurate.There are also sound technical reasons to do this.  There is no agreed upon way to switch hashes or encryption keys even though at some point we will need to.  After switching, current clients and miners will still have to be able to process new transactions signed with old keys which means that code will have to be kept around forever.  Code that is old, rarely used and poorly maintained is a prime place for a hacker to look for weaknesses.  If we could say with certainty, after block number XXX there will be no more transactions using old coins we could then remove that code. Maybe it is just randomness, time will tell.  That is some odd clustering of times the blocks were found, 6 in 6 minutes, a dry spell of 15 minutes then 7 in one 10 minute interval.  Never a dull moment in bitcoinland. That's some serious hash power that came online.  it was under 10 Thash last time I looked.  Blocks are coming at the rate of 13.5 an hour. You should update the text of the website to make it clear you are getting data from TradeHill.  It currently states "Prices represent four hours of live trade data at Mt. Gox." That's a great idea, I'm surprise no one thought of that before now.*shakes head in disbelief* The OP said: "some of his coding seems ad hoc and arbitrary"  The choice of 2016 instead of some other number appears to be arbitrary.  You also seem to agree with me, sayng "I guess a 1008 block size would still be fine". I think it is still the default.  with data=ordered, the data is written to the filesystem but the metadata is journaled, fsck only has to replay the journal.  If you use data=journal then the data, as well as the metadata, is written to the journal. You're probably right.  If the whole machine was compromised they could have taken the wallet file, no need to transfer coins out, no need to crash the market, and they would have gotten all the coins in it.I wonder how many bitcoins Mt. Gox keeps in the online wallet and how many they keep offline.  There was that 400k transfer a week ago that everyone assumes was Mt. Gox transferring coins from the online to the offline wallet, hope that is really the case, but the idea that Mt. Gox would have 400k online to transfer all at once is pretty scary too. Not sure it is a "Mega-Hack" but it certainly is about bitcoin.There is some pretty poor research in this article though.  After providing a link to the password file, they go on to report that they don't know if the salt was per-user or site wide.  It is pretty easy to figure that out.  Here's one entry:$1$yHWqORNr$rRF7U59c9UY9utiW/ZnF..The stuff between the second and third $ is the salt, "yHWqORNr".  Here's another entry$1$eVe/yQrF$HNws4a6lsEuUCvvUHZPil/See how the salt is different?  "eVe/yQrF" so there were per account salts. That's a good bit of information, thanks for sharing it.  Now we know that this list was posted less than 24 hours after it was retrieved, and, either the account compromises from 3 days ago were unrelated, or this file was retrieved on multiple occasions.  That's ok, the irony is that while I was writing that someone else posted the moving average idea and I inadvertently repeated it.  I guess these ideas aren't as novel as we think they are. I wish I'd thought of that.  Oh wait, I did. http://forum.bitcoin.org/index.php?topic=19672.msg246725#msg246725  (Not sure that you read that post though.)  Clearly, that $1,000 withdraw limit for bitcoins should use some sort of moving average price, maybe over 7 days or so. I don't they'll open on the 20th, no way they can really be confident they have secured their system by then.  If they do open, I won't eat my hat, but I'd be very concerned that they'd get hacked again.A bank run will probably happen but it shouldn't be a problem, Mt Gox doesn't do loans and should have bitcoins to back every one on deposit, except possibly for ones in the online wallet which might have been stolen or transfered out.  Hopefully they have kept some of their commission in bitcoins and that will be enough to cover losses.
I'd like to know when people with the highest numbers registered, that would help determine when the file was retrieved.  I only signed up a couple of days ago and there are almost a thousand accounts after mine. i) what makes you think they would accept your requestii) If they do accept, what makes you think they wouldn't just say "nope, no problems" wait till people start using it then attack it, that would be lulzy Google has what, a billion users?  Mt Gox has 60k of which only 21k used gmail addresses.  Do you really think Google would force every single user of theirs to change passwords because of this? I think MTG said they transferred $1000 US worth of bitcoin out which makes me wonder if they transferred $1000 worth of $17 a coin bitcoins (about 60) or if they transferred $1000 worth of $0.01 a coin bitcoins out.  I could see an attacker selling enough bitcoins to drive the price way down in order to do a large bitcoin transfer out. The MH/watt should be much better than GPUs, especially for the mobile version.  I'd like to see one with 2x the shaders and half the cpu cores. I think the difficulty adjustment is pretty clever and is often misunderstood. An encrypted, distributed social network is a neat idea, however, bitcoin relies on broadcasting all data to all clients so everyone would end up with every single post, picture, and video on their computer.  They wouldn't be able to access them without the key, but the amount of data would be staggering.  Nice idea, but unworkable with a bitcoinesque network. I've never done this but take a look at: http://www.linuxquestions.org/questions/linux-software-2/gcc-compile-static-and-so-537575/One of the answers suggests you need .a (archive) versions of the libraries. If you're using a solid state disk, even FAT or ext2 won't make shred useful.  SSD's do lots of stuff underneath the filesystem to speed things up and for wear leveling, so even if the filesystem things it is overwriting the file it probably isn't.  (On the bright side, many SSD's are agressive about reclaiming deleted blocks, so if your OS deletes it instead of moving it to a trash directory, it will get overwritten quickly.) 3.  the two week difficulty reset. There are a number of things that may cause a large advance, not sure if it will be as major as CPU to GPU but maybe. * Webpage based miners, there is even one based on webCL.  Individually they may not be that powerful but if a large website gave the option of not seeing ads or some other premium in return for mining then it could really add up. * ASICs (but that has been pretty well covered) * SHA specific instructions.  New Intel cpus have support for AES and can do one round of it per clock cycle.  If similar support were added for SHA-256 you could see some dramatic speedups. * Lower power parts. Raw speed is only half the equation, power usage is also important. AMD released a cpu/gpu combo that has 400 stream processors and 4 cpu cores all with a 35 watt TDP.  If this same process were used on graphics cards you would see a significant reduction in power usage which would allow significantly more stream processors on the graphics card. * openCL compute cards.  AMD and NVidia have both been pushing the compute aspect of their graphics cards, bitcoin is just one of many applications.  If they came out with compute cards which had lots of stream processors, no support for video (no silicon for it, no connectors, less memory and lower clocked memory) it would have lower power requirements and better airflow. This sounds like a strawman to me, I don't recall hearing it and I doubt "many" people suggest it.  MtGox is an unregulated exchange and bitcoin trades relatively low volumes (far less than a million coins) a day.  It would be easy for someone to game it, they'd just have to have a sufficient number of dollars or bitcoins. (as the price and volumes go up the definition of sufficient goes up too). If you're worried about heirs stealing from each other you could make multiple wallet files and give each of them one encrypted wallet prior to your death, then put the passwords in the safe/safety deposit box (or vise-versa). Since each heir would only have their password they can't steal from each other. You can keep all the wallets zipped up and encrypted with a password that only you know so you can access them if needed.If you stick with a single wallet, you could keep it encrypted in your safe then put the password in the safety deposit box.  You still have access to it for your spending needs when alive but your heirs get access when you die.  You could also put an unencrypted copy of the wallet in the safety deposit box but you'd have to make sure you update it occasionally so it doesn't run out of the pre-generated supply of keys. I agree w/ one of the other posters that you'd also want to give them written instructions about how to access it, how to sell them, etc. I believe this would be in the context of the snack machine and fast payment processor.  Since there is only a few (~15) second window for double-spend you don't dispense the sugary snack until that amount of time has passed.  If you do detect a double spend you block the coin and don't dispense the healthy/sugary snack, no one but the malicious owner is affected.I'm sure a payment processor could block the coin within it's own network, but it could still get in someone else's block later.  If everyone blocked it then in the case you're speaking of, outside of the snack machine context, both recipients would get screwed. Bitmunchies is an awesome idea, however, I'd really like to be able to find out the shipping costs without creating an account. Please let us know how this experiment goes. A bank might not, but a system of banks might.  In the latter case there may not be a trusted third party,  would Wells Fargo trust Wachovia to be in sole control of the money supply?  Extending it to the super-national level would Greece trust Portugal to control the money supply?I don't really expect banks to suddenly switch over to bitcoin, but you do sometimes read "wouldn't it be great if Amazon, Ebay, and Walmart took bitcoin?"  Well, it would be, but they are so much larger than the current bitcoin economy that they could easily just start their own block chain.   I don't pretend to know what is going on in markm's head, however, it did get me thinking about something that may or may not be related to his post.Imagine you had several companies working on massively multiplayer games that wanted to have the in-game currency convertible between them but they don't fully trust each other not to create lots of extra in-game money.  They could use bit coin but then they have to spend their own money buying enough bitcoins to get this going.  Or, they could start a new block chain, maybe with new rules like the first block generates 5 million coins which gets divided among the companies, subsequent blocks generate just a few coins.  If these games become popular, they could start allowing out-of-game transactions and leverage their version of bitcoin into a real online currency, to the detriment of holders of coin in the current block chain.You could also see a case where banks decide bitcoin is a good reserve currency, but instead of using the current block chain they start their own, again, providing initial capital (and an advantage) to the banks by having early blocks generate large numbers of coins (this is possible because the number of coins generated per block is just an agreement enforced by code, they control the code and the block chain so they make whatever rules they want).  They may even allow payment processors to join and generate blocks (after paying a yearly fee of course).  Again, this leaves holders of current block chain coins out of the loop. Another interesting block was found today at 2011-03-01 14:34:41.  Block 111222 with 12 transactions in it.http://blockexplorer.com/b/111222Now I will patiently wait for block 112233. Here's a couple more transactions of the same nature:http://blockexplorer.com/t/9Z4YgzGqgT   IN: 0.5 and 0.5 OUT: 0.5 and 0.5 (block 109801)http://blockexplorer.com/t/4B3i2NQWNM  IN: 0.02 and 1.02 OUT: 0.02 and 1.02 (block 109779) I was looking on block explorer and I saw this:http://blockexplorer.com/tx/1dc3384e7ffedf0036b0fd269f3fe46fb08e8c1436bb11f9d083e236cd0f620fTwo inputs, one 5.87BTC and one 10BTC.  Then, two outputs, one for  10BTC and one for 5.87BTC.  Obviously, this transaction could have been a single input and a single output.  Is there any reason why it would be better to have two inputs instead of one, or is it just a bit of brain-deadness on the part of bitcoin?
