Think I may need to make some more adjustments at this level before going higher.  I noticed that those large wins take quite a while for it to generate the payout transactions, think I either need to adjust the coin selection algorithm or get the wallet access there threaded better so it doesn't hold up everything else quite so much when generating large payouts if it's going to happen often. Since the game has now handled over 11,000 bets and seems to be running fairly stable I have bumped the max bet limit up to 50 TRC. Identicons for bitcoin addresses have been discussed before:https://bitcointalk.org/index.php?topic=122240.0In short it works fairly well as an extra checksum but it has much less entropy than the full address so matching the first few address characters and the icon is not that hard.  It depends on your use case how useful it really is, it can help with easily identifying mistyping of addresses (but so can the built-in checksum), but doesn't necessarily prevent spoofing one address with another similar one. I suppose I should try and take the effort to rebase it off a current vanitygen.  Was kind of hoping to get more familiar with github at some point and do it as a proper branch/pull request for vanitygen but it never really happened and I guess no one else picked it up and ran with it either. The oclvanitygen I'm currently using checks both the uncompressed and the positive and negative compressed versions of each key it computes.  Since the majority of the processing time is getting the keys to check this results in about 3x the addresses checked for the same amount of processing power.  At some point a while back I posted the .cl file I was using in the vanitygen thread but I never did completely modify oclvanitygen to do the rest of the calculations properly, I just run it in verbose mode with hardware error checking disabled and use a helper script to pull out the proper keys.Those GPU numbers were measured at the original clockrate (725 core, 1000 mem) although usually I run it slightly underclocked for efficiency.  I generally point it at one of the vanity pools (vanitypool.thruhere.net which accepts compressed solutions or vanitypool.appspot.com which doesn't but sometimes has more work) when there is work that is worth more than bitcoin mining. You don't necessarily need the whole pool software to do it manually, just need to pass a base public key into oclvanitygen (at least I think that works with the current version, mine is somewhat modified currently)Each extra character makes it take ~58 times longer to find.  I'm getting ~100MK/s with a somewhat modified oclvanitygen and a 5970, been pushing extra keys that it spits out that I'm not really looking for into my keypool, makes following transactions more interesting to read    http://www.cryptocoinexplorer.com:3750/tx/408371594efb4b9ab448a622eb7e4a423a2daf919de31743da689fa591594906 You might want to look into split vanity address generation so that any buyers you find can be sure that you don't know/can't share the private key for the address you generate.Also might want to rethink or add a disclaimer on that 15 character length, getting >10 characters for a specific name is not fast.  I've been waiting about a week now on a set of trcDice addresses and that's only matching 8 characters (granted the bounty on them is low enough that I may be the only one working on mining them) Not sure I see why it would make any difference.  The number can be chosen so the odds are exactly equal with a "more than" or a "less than" bet.  Since the lucky hash creation includes the output number it's not like any bets even in the same transaction will share a hash (thus allowing betting in a given range).  At a first glance it just seems like it would make the calculation/verification more complicated without really adding any value.  Is there some other reason for the request or is it just cosmetic? Yeah, found another small problem, those payouts are on their way.  Coin selector was running short on inputs that passed the double-spend protection rules and gave up, I've adjusted it to keep retrying in that particular case now so there might be a little delay but not more than a couple minutes.  Will also get better as the change transaction sizes even out and it has more to work with, right now the wallet is the main bottleneck in payout speeds that can't be threaded well without more coins for the coin selector. Yeah, it won't have a page for any affiliate address until it's finished processing the first bet through it, just to avoid cluttering up the server too much with addresses that don't get used. Ah, that's a good point as well, that sort of statistics is something else that affiliates can use to add value to their own particular play addresses beyond just look/marketing.  Generally I would prefer to concentrate on keeping things running smoothly and leave the marketing to the affiliate system for affiliates to earn their share.  I do like the way that page is looking so far, perhaps for now I'll stick with just basic information that can't be calculated otherwise on the output pages and if you come up with something that can't be figured out with the existing data given I can see about adding it to the output across the board. Stats as in aggregate stats like the Satoshi Dice thread in the technical section here or more a list like on the Satoshi Dice site itself?  The recent bets would be the list it shows now, I could add lists for recent big/rare wins fairly easily.  I suppose aggregate stats wouldn't be too hard either, the only thing I would worry about there would be if/how to include affiliate addresses. Yes it will, but more slowly on that one than on most since the winning payout is that much bigger. Is the key it doesn't like in hex format or a wallet format?  I've tested more extensively with the hex format, I know it's somewhat picky about it being the right length and needs to be padded with 0s if it's short. Sorry all, it does appear my local terracoind added me to its ban list.  I'm adjusting its parameters and restarting it, should get payouts moving again shortly. If you take a look at the details page for any of the bets you can see how the outcome is calculated.  The bets from yesterday (like http://greenishblue.info/terradice/8b94569a6e5d2d94d8e4b81e791445b8db6e6ecfb3f92596f70d5a834a685660-1.html) will have the secret revealed so that the outcome can be verified while ones from today will just have {secret} displayed until the day is over and it moves on to the next secret in the list.Note that while writing this I attempted to verify that bet and found there is an extra newline in the middle of the hash that makes it somewhat more difficult to calculate/check.  I have adjusted that so it will be a single line in future bets, but when checking older ones you will have to insert a newline between the secret and the ":" to get the same hash.  This doesn't affect the randomness, just makes it somewhat harder to verify the fairness of the results. Well if the tx was accepted by the pool in the first place it would have to be running some custom software.  I assume it would try and relay it normally but it would only be accepted by peers that were following the same relaxed rules as itself.  I have played with nonstandard transactions in the past sending them through Eligius to get mined and it does seem that though they are accepted and eventually end up in a block that I do not see them get propagated very far elsewhere on the network before being mined.  I assume that it would work fairly similarly for transactions with fees below minimum. It uses the same method as Satoshi Dice to determine the payout address, so as long as the transaction(s) that are being used in the bet payment come from an address in the wallet it should work.  If it's a group wallet though it is possible (or even likely) that payouts will end up somewhere else.  I don't see any missing payouts right now, you can track them in the block explorer and see where the payout ended up, it always includes the bet transaction as part of it (to protect against double-spends).  It also supports sending to another address similar to Satoshi Dice, if you include a payment of exactly 0.0054321 to another address in the same transaction as the bet any winnings will be sent to that address as well.Any payments to 1H95NEPFHYHmehBCqpoF2QY7ytmBEsZXMz will go directly into the game and bump up the max bet amounts (which are based on available funds), for now I have it capped at 20 TRC but it seems to be running happily so far. Unfortunately I don't have a bugfix for bad luck... I just added TRC to the LiteDice list, you can find TerraDice at http://greenishblue.info/terradice and make your own affiliate with the same rules as the LiteDice ones at https://litedice.greenishblue.info.  I am still doing some testing, the maximum bets will stay fairly low until it has gotten some more testing volume through it but it should be stable enough to try out and play with in small amounts.  The play addresses will probably be replaced with more standard ones once they finish generating (although the current set is kind of fun) but these ones will continue to payout (at least for a while) even if they disappear from the list.  Any problems with lost payments just drop me a PM (so as to not completely hijack this thread).
It seems possible that A' was submitted first (directly to any miner that would accept it) and didn't propagate over the rest of the network because of the lack of fee.  Then A and B could be submitted normally and make it to the rest of the network (except for any miners that already had the conflicting transaction).  The tricky part would be trying to affect who found the next block after seeing the bet outcome.  With enough hashing power you could point at one pool or another you could push the odds around somewhat but it would seem to be far from a sure thing, it wouldn't however necessarily require collusion from any mining pools directly. Well I had come up with answers a while back but never got them to work out together and had basically given up on it.  So I just went back over my list and switched some 'u's and 'v's, added a few 'e's and out popped an answer.Spoiler warning if you want to finish it yourself, couldn't find a style to black it out completely though:carpenter cubite treasures pleasing delusion eleven fire boastings Dagon vnsearchable sharpe kniues pruning hookes dominion vapour perditionNow if I could just figure out how to narrow down the answers in that crossword somewhat (I have found quite a few 6-letter places in Norway and towns in New Jersey with the right crossing letters) It doesn't seem to handle short patterns like that too well, I wasn't around to watch it at the time but my logs show that my machines alone sent a couple hundred solutions in during the time it was up.  Seem to recall the same thing happened last time there was a very short pattern as well, kind of acting like a load issue but you'd think if it accepted the first one properly and removed it from the work list it wouldn't be a problem. This is all EC math, so multiplying a public key by a number is somewhat more complicated than just simple math, but nothing that couldn't be implemented in any language of choice fairly quickly without depending on more than a bignum library.  For the private key it is just simple math (with bignums), the result is modulo n (the constant for the bitcoin EC curve) so it is always less than 256 bits. Oops, off by one (<9 instead of <=9 to append the 0).  If anyone is interested here is the code, it just grabs the latest secret as needed and calculates others.Code:#!/usr/bin/perluse Math::BigInt;use Date::Calc qw(:all);use Digest::SHA;$year=shift(@ARGV);$mon=shift(@ARGV);$day=shift(@ARGV);$hour=shift(@ARGV);$file="/home/mskwik/lbaat.secret";($d,$h,$m,$s)=Delta_DHMS(2000,1,1,0,0,0,$year,$mon,$day,$hour,0,0);$h+=$d*24;($at,$bsec)=readpipe("cat $file");chomp($at);chomp($bsec);if($h>$at){  ($s,$m,$hh,$dd,$mm,$yy,@x)=gmtime();$yy+=1900;$mm++;  ($ddd,$hhh,$mmm,$sss)=Delta_DHMS(2000,1,1,0,0,0,$yy,$mm,$dd,$hh,0,0);$hhh+=$ddd*24;  if($mm<=9){$mm="0".$mm;}if($dd<=9){$dd="0".$dd;}if($hh<=9){$hh="0".$hh;}  $tp=$yy.$mm.$dd.':'.$hh;  $data=readpipe("curl -k -L -m 20 -s \"https://lbaat.net/getSecret.json?timepoint=$tp\"");  $_=$data;s/[\r\n\t" ]//ig;  if(/priv:([0-9a-f]*)}/ig){$bsec=$1;$at=$hhh;    open(OUT, ">$file");print OUT "$at\n$bsec\n";close(OUT);  }}while($at>$h){  $bsec=Digest::SHA::sha256_hex($bsec);$at--;}if($h==$at){print $bsec."\n";} It's also fairly simple to generate one private key p which you keep safe offline and its associated public key P which is on the webserver.  You can then get unique payment addresses by generating some 256 bit x (Usually from a hash of the cart transaction id or such, doesn't need to be secret) and multiplying it by P.Offline you can then get the private key by multiplying p by that same x (which your customer can give you the data to generate even if your web server gets nuked or such) I think another major issue people have with it is how do you know that the "lost" coins are really lost.  I could make a paper wallet and give it to my grandfather (who knows nothing about computer security) and if he locked the paper away and just sent coins to that address in 50 years they would still be there and usable with that paper.  If they had to be moved every couple years then I wouldn't be expecting any bitcoins in my inheritance.  Something like the physical Casascius coins have a similar use case, they could be traded around as much as you want and (assuming the tamperproofing holds up) 50 years later the coins backing them will still be there in the blockchain unmoved (despite however many hands the physical coin may have gone through). I know I CPU-mined a couple blocks to get the initial coins for bitcoindarts, this was when mining was all in the official client rather than separate miners.  Ran it for maybe 2 weeks and picked up 4 blocks before stopping, wasn't really worth it at that point (could have bought them instead at $3/block) but there was a lack of useful exchanges at that point so was easier to mine for the startup capital. For practical mining values I find http://fizzisist.com/mining-value/ to be more useful.  At this point it isn't worth pushing any mining power at the vanity pool.  I have miners checking for work but not actually doing any hashing unless it is worth more than other mining and I would guess there is a decent number of others doing the same given how quickly work gets solved when it is worth working on.  Right now even if the pool started accepting compressed solutions it would just barely have an income equivalent to bitcoin mining, without higher valued names requested you're better off elsewhere. Fair enough, guess I'm just used to translating technical language for not quite as technical people and that was what jumped out at me as being what someone might not realize at first glance. Do be aware that the script signatures on the nonstandard transactions discussed so far are not based on signing the whole transaction however so posting a raw transaction without getting it on the network first could allow someone to replace your output address with their own before forwarding it. This is where that mythical decentralized reputation/identity system would be useful.  I see that bitcoin-otc identities already (at least many of them) have bitcoin addresses associated with them so tipping based on otc usernames would be trivial.  Is there anywhere that is linking forum names and otc names together already (decentralized or not)?  Of course that still requires setting up another account to receive tips and/or holding unclaimed tips somewhere temporarily for users without an account. Wouldn't necessarily have to be too bad, use a little logo/emote as part of the tip command and it could zero in on just the pages it needs to check.  Would have to think through the details but with a well-crafted javascript bookmarklet you may even be able to sign an image url and have the tipping bot work almost completely passively from the image hits.  (And if you figure out how the recipient gets specified/detected it could potentially work on any page anywhere) I would also suggest that the software handle compressed keys properly.  I see your pool is still rejecting compressed solutions for now but once that hits the normal vanitygen there will be a lot more hashing power available to pools using it. Length alone doesn't necessarily make an address that hard to find if you aren't as picky about what exactly makes up that length.  Noticed that one of my machines spit out 1MAG1CALTUXueDaGWq8ozLGL5sutu6DxFq yesterday while it had switched to vanitygen mining for a little while (not that it does me much good).  From recent observations 9 digits is fairly common and even 10 not that unusual when searching against a large enough dictionary, it's when you're looking for something more specific that difficulty starts to get higher. You need the openssl headers installed, depending on the distro it would normally be a package like "openssl-dev" or "libssl-dev" Ah, also not tested from anything besides raw nc, probably some extra \r in there it didn't like, try again now.!!INPT is followed by a input length(or range) and then valid characters for that input, the idea being that even the simplest bot could choose from the valid characters randomly up to the required range for any input requests it didn't recognize and have a reasonable chance of getting somewhere with it.I do see that you seem to be trying to head the same direction with the CoffeeMUD (although it's apparently not something that can be tried out currently), just not really clear whether it's attempting to do work that is "useful" or where it is coming from.  From what is written it appears that it doesn't attempt to keep a closed economy (even within the whole scale of worlds available).  What I am trying is to reduce the server requirements by offloading the "work" generation/checking to what is essentially another player class that acts as the producers for the world economy with enough balancing that nothing is ever just created. Code:new JProperty("vout", 0),I would guess this is at least part of the issue, from listunspent you need to use the vout actually returned and can't assume it's always 0 (at least not if some of those came from other people) and getrawtransaction returns the entire transaction, you need to choose the vout that you are actually interested in (which again is not necessarily the first). Well I must say I've always enjoyed writing bots for games, usually sticking with games where it isn't specifically listed as being against the rules.  I have in the past considered designing something specifically for play by bots but at the time there were enough issues (and not a very big potential userbase) that I decided to shelve the idea.  So after reading this thread and pondering it for a day or so (or maybe it came to me in a dream last night) I have come to the conclusion that bitcoin (and the related tech/community) may solve many of those issues.So here's the basic idea, instead of the normal account time limits that mean nothing for a computer that can run thousands of players at once we take the bitcoin mining model and require some processing power to back up each account.  If done carefully that processing power can be used to generate a steady income stream for the game server (ie as a replacement for the ads that would be shown to human players).  Taking it a step further you could also base/back the in-game economy with cryptocurrency and you could end up with something that looks similar to a (slightly inefficient) mining pool except that earnings would be based on how well your bot plays the game and not just processing power.And so since it all seemed to mesh together nicely I started writing some code for a basic MUD for bots.  The basic idea is that users are given some small (15-30 seconds of processing time) question to answer between different moves and any amounts that can be collected by the server for that work are converted into in-game items distributed to the monsters that are spawned.  In-game currencies (I'm thinking based on various gems) correspond to different cryptocurrencies and can be traded with other players or NPCs (evenly, no NPCs creating money out of thin air) and can also be deposited/withdrawn through transactions on their corresponding blockchains at any point (with some sort of banking system in-game to allow keeping currency safe to be auto-withdrawn on death without spamming blockchains with many tiny txs).  So now I seem to have ended up with a small collection of servers that form what I would consider a basic proof of concept (ie you can create a character and walk around) that will accept connections from players, work providers, and NPCs and my more practical side is telling me that I should stop and see if anyone besides me would actually use such a thing before putting more than a days worth of time into it.  (I will temporarily open an endpoint to telnet://greenishblue.info:31173 if anyone is curious, try not to break anything) Hmm, I normally keep my debug.log symlinked to /dev/null so not sure how much shows up there.  My normal method for listening in on communications between 2 programs would be nc with some plumbing but not sure there is an easy equivalent on windows...  Anyone know if fiddler can be used to debug bitcoin RPC communications?
Any way to get the rest of that error message?  The bitcoin RPC does return a 500 on input errors, but also returns a more detailed error message in the bodyFor example the inputCode:{"method": "sendrawtransaction", "params": ["00000001"], "id":0}ReturnsCode:HTTP/1.1 500 Internal Server ErrorDate: Wed, 05 Dec 2012 15:24:32 +0000Connection: closeContent-Length: 73Content-Type: application/jsonServer: bitcoin-json-rpc/v0.7.0-beta{"result":null,"error":{"code":-22,"message":"TX decode failed"},"id":0} My vanitypool code uses something like this to check the required network byte for a given prefix and will return an error to the submitter if the network byte specified doesn't match.  Not sure it's the most elegant way to do it and there may be some strange edge cases for very short prefixes but in general it does what it is supposed to.Code:sub prefix_version{my $x=shift(@_);  @bb=(1..9,'A'..'H','J'..'N','P'..'Z','a'..'k','m'..'z');  while(length($x)<34){$x.="2";}  my $ox=$x;my $n=Math::BigInt->new(0);  my $i=Math::BigInt->new(0);while($x){my $c=chop($x);    my $cp=0;while($bb[$cp] ne $c && $cp<=$#bb){$cp++;}    $n+=$cp*(58**$i);$i++;  }$i=$n->as_hex();$i=substr($i,2);  $x=reverse($ox);my $c=chop($x);while($c eq '1'){$c=chop($x);$i="00".$i;}  if(length($i)%2==1){$i="0".$i;}  my $ver=substr($i,0,2);return hex($ver);}Code:mskwik@mskwik ~/script/bitcoin $ perlprint prefix_version('NPhaux')."\n";53 Correct, namecoin addresses have a network byte of 52, just as bitcoin addresses have a network byte of 0, that was just a demonstration that it's not that vanitygen won't give that prefix, just that it isn't possible with that network byte. According to my work checker NPhaux is only a valid prefix with a network byte of 53, and it does seem to solve that way:Code:mskwik@mskwik ~/script/bitcoin/vanitygen $ ./oclvanitygen -X 53 -p 0 -P 0435518A6E54753DF8397AD915EBB5449026EE170481C65FB515D8D2015DC80EC9EF401771BAE9F6278A474C03F23978BCB0A54E5211612029115277C5B5549781 NPhauxPattern: NPhauxAddress: NPhauxDmxGJfKSAJmAnZBLH9mhrKY5BALvPrivkey: 75y4T2rk3nbUipwcMzmeUcwwEzy3fhgdhvWVf6DhRM6CR9jWnSpLooks like a bug in the input verification for the pool server. What you are describing is basically a hardware wallet except running on a phone instead of custom hardware.  See https://bitcointalk.org/index.php?topic=122438.0 for the discussion on the protocol and vendor software needed. Here http://www.bitbin.it/TCUrsCoR is what mine looks like in its entirety, not sure how close to the current one with vanitygen the base was when I started, my whole vanitygen directory has been rather heavily modified and I haven't had a chance to try and rebase against the current version to get a clean patch.Also note that changing the .cl file alone will just give what appear to be a bunch of hardware errors when it finds a compressed solution.  For testing purposes on mine I have just disabled the hardware error checking completely (which is a bad idea, I did purposely leave off detailed instructions on doing it because if you can't figure out how you probably shouldn't be playing with it), but basically it involves replacing the memcmp after the "/* Make sure the GPU produced the expected hash */" comment with a memcpy and adjusting the logic in oclvanitygen.c and recompiling (unless there's some switch to disable it now, again this is based off an older version). It's not necessarily a point of it being incorrect, yes it does still prove ownership of the associated private key when put together properly but if it is handled differently than the satoshi client it could cause problems.  Here's a raw TX example which is not validated by the default client but seems (if I did the manipulation right by hand) like it should get past your code.0100000002979bf5e04fb980f214c7b8f3ca28ebd1526fde456953210532e42246843e199f2f000 0008b48304502210081eaa77b0dcef66c0d0e62dafe932503cd8ab8bd83e4d132c9b42fd5a5be90 4202204a281c9c320f60b4a11bd7f162d8296d8246a13a43bc9e5e6fe831e8587bd8d9014104c55 f8edc724bc89b356bc1280f720b27e62839743e549d51bd9d537bd168b3b36f655b87f5aa492c15 eec23120f87abe36693830608a0f91b325a4f76570daf1ffffffffb1d3647334b5531f4831a48e1 fdda96472bd11b95140f0baf7fca5836854d45f2f0000008b49304502210081eaa77b0dcef66c0d 0e62dafe932503cd8ab8bd83e4d132c9b42fd5a5be904202204a281c9c320f60b4a11bd7f162d82 96d8246a13a43bc9e5e6fe831e8587bd8d9010440c55f8edc724bc89b356bc1280f720b27e62839 743e549d51bd9d537bd168b3b36f655b87f5aa492c15eec23120f87abe36693830608a0f91b325a 4f76570daf1ffffffff010d787000000000001976a914fe9c3e50dd8a5263571764dfa9e80300d1 5f612188ac00000000 Ok, actually went and found the code in question.  Yes it does appear that the hash is the same because it is generated from the tx to sign, not the full tx.  So no the attack will not work as described, but it does seem that one could get it to accept an invalid transaction such that the first signature in the transaction was correct but a later input with the same key could have an invalid signature like the one described in the original post and still get accepted due to the cache. Doesn't changing the length of the sig and pubkey also change the hash? Yes, working with the strange endian-ness of the various numbers is one of the "interesting" challenges in working with bitcoin code.  A quick test suggests you should get something like this with that particular test data:Code:mskwik@mskwik ~ $ perluse Digest::SHA;$hash="00000002fc517a2df2b283474b135215a00604af276318262f5eebc00000043100000000db9fcfcc3781c1342c2750214e46407286cbf29985e688d0392e6b8005c4c8245032580a1a07a85e"."8e631c12";while($hash){$xx=substr($hash,0,8);$xx=reverse(pack('H*',$xx));$fixedhash.=$xx;$hash=substr($hash,8);}$solution=Digest::SHA::sha256_hex(Digest::SHA::sha256($fixedhash));print $solution."\n";$fixedsol=reverse(unpack('h*',pack('H*',$solution)));print $fixedsol."\n";3246917b692937fbceb2376ba36a8f97794d33784a0472ae8a37061900000000000000001906378aae72044a78334d79978f6aa36b37b2cefb3729697b914632 So I saw a comment a while back about checking the compressed versions of the keys generated as well as the uncompressed versions and I've been playing with it a bit.  It gives me a roughly 80-90% speed increase in both vanitygen and oclvanitygen and so far I haven't found any problems with the addresses generated, the only difference is needing to import them as compressed (not that I've done a lot of testing with them outside of plugging them into bitaddress.org).  I did update vanitypool.thruhere.net to accept them as valid solutions (and promptly solved all the remaining work there) so unless someone submits more it isn't particularly useful for pool mining ATM (still getting half my work rejected by vanitypool.appspot.com but all the ones I have checked are correct, just compressed solutions it doesn't like).  It does however seem to be quite useful if you are searching for your own vanity addresses.So what I have now is a very much hacked together version that works but is not particularly user-friendly (as in  I commented out most of the error-checking code to get it to return all the results from the GPU and you then have to take the private key and convert to the compressed address manually) but for anyone capable of working with that here is the changes I made to calc_addrs.cl to make it work (notice I only changed the CL prefix checker, not the return for regex)Code:1209c1209< hash_ec_point(uint *hash_out, __global bn_word *xy, __global bn_word *zip)---> hash_ec_point(uint *hash_out, uint *chash_out, __global bn_word *xy, __global bn_word *zip)1211c1211<       uint hash1[16], hash2[16];--->       uint hash1[16], hash2[16], hash3[16], hash4[16];1262a1263,1283> >       hash4[0] = hash1[0] ^ 0x06000000;>       if(wh & 0x01){ hash4[0] ^= 0x01000000; }>       hash4[1] = hash1[1];>       hash4[2] = hash1[2];>       hash4[3] = hash1[3];>       hash4[4] = hash1[4];>       hash4[5] = hash1[5];>       hash4[6] = hash1[6];>       hash4[7] = hash1[7];>       hash4[8] = (hash1[8] & 0xff000000) | 0x800000;>       hash4[9] = 0;>       hash4[10] = 0;>       hash4[11] = 0;>       hash4[12] = 0;>       hash4[13] = 0;>       hash4[14] = 0;>       hash4[15] = 33 * 8;>       sha2_256_init(hash3);>       sha2_256_block(hash3, hash4);> 1300a1322,1326> #define chash_ec_point_inner_6(i)             \>       hash3[i] = bswap32(hash3[i]);> >       hash256_unroll(chash_ec_point_inner_6);> 1310a1337,1347> >       hash3[8] = bswap32(0x80000000);>       hash3[9] = 0;>       hash3[10] = 0;>       hash3[11] = 0;>       hash3[12] = 0;>       hash3[13] = 0;>       hash3[14] = 32 * 8;>       hash3[15] = 0;>       ripemd160_init(chash_out);>       ripemd160_block(chash_out, hash3);1318c1355<       uint hash[5];--->       uint hash[5], chash[5];1331c1368<       hash_ec_point(hash, points_in, z_heap);--->       hash_ec_point(hash, chash, points_in, z_heap);1376c1413<       uint hash[5];--->       uint hash[5], chash[5];1389c1426<       hash_ec_point(hash, points_in, z_heap);--->       hash_ec_point(hash, chash, points_in, z_heap);1417a1455,1480>                       high = -1;>               }>       }> > #define chash_ec_point_search_prefix_inner_1(i)       \>       chash[i] = bswap32(chash[i]);> >       hash160_unroll(chash_ec_point_search_prefix_inner_1);> >       /* Binary-search the target table for the hash we just computed */>       for (high = ntargets - 1, low = 0, i = high >> 1;>            high >= low;>            i = low + ((high - low) >> 1)) {>               p = hash160_ucmp_g(chash, &target_table[10*i]);>               low = (p > 0) ? (i + 1) : low;>               high = (p < 0) ? (i - 1) : high;>               if (p == 0) {>                       /* For debugging purposes, write the hash value */>                       found[0] = ((get_global_id(1) * get_global_size(0)) +>                                   get_global_id(0));>                       found[1] = i;> > #define chash_ec_point_search_prefix_inner_2(i)       \>                       found[i+2] = load_be32(chash[i]);> >                       hash160_unroll(chash_ec_point_search_prefix_inner_2); It is a much easier sell though if it can be merge-mined alongside bitcoin rather than taking hashing power away from somewhere else.  Just look at the current difficulties on Namecoin/Devcoin/ixcoin etc, despite being worth fairly minimal amounts they have a good amount of hash power pointed at them (making them that much harder to attack) just because the extra effort to merge-mine them is also minimal. Here is a (mostly complete) example of creating and signing a raw transaction, it is only part of a larger project that takes requests from elsewhere but it should be enough to see the transaction handling code.  Not exactly commented but hopefully the inputs are named well enough that you can tell what they are supposed to be, if not just ask.And the usual disclaimer to check any generated transactions very carefully before letting them loose on the main network.  It is also very possible that there are some calls in here that are too long to work with large amounts on a 32 bit system, I know I've replaced some calls in other scripts but not sure this one has ever been run except on 64-bit systems so make sure your test cases include large amounts at some point.Code:#!/usr/bin/perluse Digest::SHA;require("functions.inc");$req=shift(@ARGV);@r=split(/,/,$req);foreach $r(@r){@rr=split(/:/,$r,2);$req{$rr[0]}=$rr[1];}$total=0;$onum=1;$sout='';undef %out;@o=split(/-/,$req{'output'});foreach $o(@o){@oo=split(/=/,$o,2);  ($net,$key)=decode_b58($oo[0]);  if($oo[1]>0 && $net==0 && $key ne ''){$out{$oo[0]}+=$oo[1];$total+=$oo[1];$onum++;    $a=sprintf('%x',$oo[1]);while(length($a)<16){$a="0".$a;}    $a=reverse($a);$sout.=pack('h*',$a);    $ss=pack('H*','76a914'.$key.'88ac');    $a=sprintf('%x',length($ss));if(length($a)<2){$a="0".$a;}    $sout.=pack('H*',$a).$ss;  }}$have=0;$inum=0;@o=split(/-/,$req{'input'});foreach $o(@o){($id,$cc,$amt,$addr)=split(/:/,$o,4);  $in{"$id:$cc"}=$addr;$have+=$amt;$inum++;}$fee=fee($onum,$inum);if($total+$fee>$have){die("Insufficient Funds");}$change=$have-$total-$fee;if($change>0){  $out{$req{'change'}}=$change;$total+=$change;  $a=sprintf('%x',$change);while(length($a)<16){$a="0".$a;}  $a=reverse($a);$sout.=pack('h*',$a);  ($net,$key)=decode_b58($req{'change'});  $ss=pack('H*','76a914'.$key.'88ac');  $a=sprintf('%x',length($ss));if(length($a)<2){$a="0".$a;}  $sout.=pack('H*',$a).$ss;}$send=sprintf('%x',$onum);if($onum<16){$send="0".$send;}$send=pack('H*',$send).$sout."\x00\x00\x00\x00";$start=sprintf('%x',1);while(length($start)<8){$start="0".$start;}$start=reverse($start);$start=pack('h*',$start);$c=sprintf('%x',$inum);if($inum<16){$c="0".$c;}$start.=pack('H*',$c);$xx=0;for my $x(keys %in){$a=$in{$x};$inlist.=$x.",";  ($ptx,$oid)=split(/:/,$x);$idtx[$xx]=$x;  $ptx=reverse($ptx);$btx[$xx]=pack('h*',$ptx);  $c=sprintf('%x',$oid);while(length($c)<8){$c="0".$c;}  $c=reverse($c);$btx[$xx].=pack('h*',$c);  $btx[$xx].="\x00\xff\xff\xff\xff";  $xx++;}chop($inlist);$xx=0;while($xx<$inum){$tmp=$btx[$xx];  ($ptx,$oid)=split(/:/,$idtx[$xx]);$a=$in{$idtx[$xx]};  $btx[$xx]=substr($btx[$xx],0,-5);  ($net,$key)=decode_b58($a);$ss=pack('H*','76a914'.$key.'88ac');  $l=sprintf('%x',length($ss));if(length($l)<2){$l="0".$l;}  $btx[$xx].=pack('H*',$l).$ss."\xff\xff\xff\xff";  $pkey=addrprivkey($a);if($pkey eq ''){error("No private key found for $a");}  $tx=$start.join('',@btx).$send."\x01\x00\x00\x00";  $tx=Digest::SHA::sha256(Digest::SHA::sha256($tx));  $tx=unpack('H*',$tx);$ftx[$xx]=substr($tmp,0,-5);  $sig=signtx($tx,$pkey);  $l=sprintf('%x',length($sig)+1);if(length($l)<2){$l="0".$l;}  $sig=pack('H*',$l).$sig."\x01";  $pk=addrpubkey($a);$pk=pack('H*',$pk);  $l=sprintf('%x',length($pk));if(length($l)<2){$l="0".$l;}  $sig.=pack('H*',$l).$pk;  $l=sprintf('%x',length($sig));if(length($l)<2){$l="0".$l;}  $ftx[$xx].=pack('H*',$l).$sig."\xff\xff\xff\xff";  $btx[$xx]=$tmp;$xx++;}$dec=$start.join('',@ftx).$send;$hex=unpack('H*',$dec);$h=Digest::SHA::sha256(Digest::SHA::sha256($dec));$hash=reverse(unpack('h*',$h));print "Raw Transaction: $hex\nTransaction ID: $hash\n";sub fee{my $o=shift(@_);my $i=shift(@_);my $f=0;  my $s=size($o,$i);my $pp=int($s/1024)+1;  if($req{'priority'}>=0){    $f+=10000*$pp;  }if($req{'priority'}>=1){    $f+=40000*$pp;  }if($req{'priority'}>=2){    $f+=$s;  }return $f;}sub size{my $o=shift(@_);my $i=shift(@_);  return 10+(180*$i)+(34*$o);}sub addrprivkey{my $a=shift(@_);  my $u=$db->prepare(qq{select privkey from address where address='$a'});  $u->execute();my $ep;if($ep=$u->fetchrow_array()){    return unpack('H*',$cipher->decrypt_hex($ep));  }}sub addrpubkey{my $a=shift(@_);  my $u=$db->prepare(qq{select pubkey from address where address='$a'});  $u->execute();my $ep=$u->fetchrow_array();return $ep;}And here is the functions.inc that it references:Code:use Digest::SHA qw(sha256 sha256_hex);use Crypt::RIPEMD160;use Math::BigInt lib => 'GMP';@bb=(1..9,'A'..'H','J'..'N','P'..'Z','a'..'k','m'..'z');sub decode_b58{my $x=shift(@_);  $x=~s/[0O]/o/g;$x=~s/[Il]/1/g;  my $ox=$x;my $n=Math::BigInt->new(0);  $i=Math::BigInt->new(0);while($x){my $c=chop($x);    my $cp=0;while($bb[$cp] ne $c && $cp<=$#bb){$cp++;}    $n+=$cp*(58**$i);$i++;  }$i=$n->as_hex();$i=substr($i,2);  $x=reverse($ox);my $c=chop($x);while($c eq '1'){$c=chop($x);$i="00".$i;}  if(length($i)%2==1){$i="0".$i;}  my $ver=substr($i,0,2);my $chk=substr($i,-8);  $i=substr($i,2,-8);  $n=pack('H*',$ver.$i);  my $h=Digest::SHA::sha256(Digest::SHA::sha256($n));  $c=substr(unpack('H*',$h),0,8);  $ver=hex($ver);  if($chk eq $c){return ($ver,$i);}  return ('','');}sub ecadd{my $a=shift(@_);my $b=shift(@_);  my $p=Math::BigInt->new('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');  my $ax=Math::BigInt->new('0x'.substr($a,2,64));  my $ay=Math::BigInt->new('0x'.substr($a,66));  my $bx=Math::BigInt->new('0x'.substr($b,2,64));  my $by=Math::BigInt->new('0x'.substr($b,66));  if($by eq ''){return $a;}  if($ay eq ''){return $b;}  if($ax==$bx){    if(($ay+$by)%$p==0){      return '';    }else{      my ($rx,$ry)=ecdouble($ax,$ay);      return('04'.substr($rx->as_hex(),2).substr($ry->as_hex(),2));    }  }  my $x=$bx-$ax;$x->bmodinv($p);  my $xx=(($by-$ay)*$x)%$p;  my $rx=($xx*$xx-$ax-$bx)%$p;  my $ry=($xx*($ax-$rx)-$ay)%$p;  $rx=substr($rx->as_hex(),2);$ry=substr($ry->as_hex(),2);  while(length($rx)<64){$rx="0".$rx;}while(length($ry)<64){$ry="0".$ry;}  return "04".$rx.$ry;}sub ecaddnum{my $ax=shift(@_);my $ay=shift(@_);my $bx=shift(@_);my $by=shift(@_);  my $p=Math::BigInt->new('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');  if($by eq ''){return($ax,$ay);}  if($ay eq ''){return($bx,$by);}  if($ax==$bx){    if(($ay+$by)%$p==0){      return('','');    }else{      return ecdouble($ax,$ay);    }  }  my $x=$bx-$ax;$x->bmodinv($p);  my $xx=(($by-$ay)*$x)%$p;  my $rx=($xx*$xx-$ax-$bx)%$p;  my $ry=($xx*($ax-$rx)-$ay)%$p;  return($rx,$ry);}sub ecmult{my $pb=shift(@_);my $p=shift(@_);  my $x=Math::BigInt->new('0x'.substr($pb,2,64));  my $y=Math::BigInt->new('0x'.substr($pb,66));  my $n=Math::BigInt->new('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');  if($p==0){return '';}  if($y eq ''){return '';}  $p=$p%$n;$pp=$p*3;  my $i=Math::BigInt->new('1');  while($i<=$pp){$i=$i*2;}$i=$i/4;  my $rx=$x->copy();my $ry=$y->copy();  while($i>1){    ($rx,$ry)=ecdouble($rx,$ry);    my $e=$pp->copy();$e->band($i);my $ee=$p->copy();$ee->band($i);    if($e!=0 && $ee==0){($rx,$ry)=ecaddnum($rx,$ry,$x,$y);}    if($e==0 && $ee!=0){($rx,$ry)=ecaddnum($rx,$ry,$x,-$y);}    $i=$i/2;  }  $rx=substr($rx->as_hex(),2);$ry=substr($ry->as_hex(),2);  while(length($rx)<64){$rx="0".$rx;}while(length($ry)<64){$ry="0".$ry;}  return "04".$rx.$ry;}sub ecdouble{my $x=shift(@_);my $y=shift(@_);  my $p=Math::BigInt->new('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');  my $l=2*$y;$l->bmodinv($p);  $l=($l*3*$x*$x)%$p;  my $xx=($l*$l-2*$x)%$p;  my $yy=($l*($x-$xx)-$y)%$p;  return($xx,$yy);}sub signtx{my $m=shift(@_);my $k=shift(@_);  my $mm=Math::BigInt->new('0x'.$m);  my $pk=Math::BigInt->new('0x'.$k);  my $n=Math::BigInt->new('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141');  my @chars=('a'..'f', 0..9);my $rr=join '',map {$chars[rand @chars]} 1..64;  my $r=Math::BigInt->new('0x'.$rr);  my $k=$r%$n;  my $p=ecmult('0479BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',$k);  $r=Math::BigInt->new('0x'.substr($p,2,64));  my $s=$k->copy();$s->bmodinv($n);  $s=$s*($mm+($pk*$r)%$n)%$n;  $r=substr($r->as_hex(),2);$s=substr($s->as_hex(),2);  if(length($r)%2==1){$r="0".$r;}if(length($s)%2==1){$s="0".$s;}  $k=substr($r,0,1);if($k>7 || ($k==0 && $k ne '0')){$r="00".$r;}  $k=substr($s,0,1);if($k>7 || ($k==0 && $k ne '0')){$s="00".$s;}  $r=pack('H*',$r);$s=pack('H*',$s);  my $lr=sprintf('%x',length($r));if(length($lr)<2){$lr="0".$lr;}  my $ls=sprintf('%x',length($s));if(length($ls)<2){$ls="0".$ls;}  $rs="\x02".pack('H*',$lr).$r."\x02".pack('H*',$ls).$s;  my $l=sprintf('%x',length($rs));if(length($l)<2){$l="0".$l;}  return("\x30".pack('H*',$l).$rs);}sub hashtoaddr{my $nb=shift(@_);my $x=shift(@_);  my $nbh=sprintf('%x',$nb);while(length($nbh)<2){$nbh="0".$nbh;}  $x=pack('H*',$nbh.$x);  my $addr=unpack('H*',$x);$x=Digest::SHA::sha256(Digest::SHA::sha256($x));  $addr.=substr(unpack('H*',$x),0,8);  my $out='';while(substr($addr,0,2) eq '00'){$out.="1";$addr=substr($addr,2);}  my $a=Math::BigInt->new('0x'.$addr);my $o='';  while($a>58){$o=$bb[$a%58].$o;$a=$a/58;}  $o=$bb[$a].$o;  return $out.$o;}sub pkeytoaddr{my $nb=shift(@_);my $x=shift(@_);  $x=pack('H*',$x);$x=Digest::SHA::sha256($x);  my $nbh=sprintf('%x',$nb);while(length($nbh)<2){$nbh="0".$nbh;}  $x=pack('H*',$nbh).Crypt::RIPEMD160->hash($x);  my $addr=unpack('H*',$x);$x=Digest::SHA::sha256(Digest::SHA::sha256($x));  $addr.=substr(unpack('H*',$x),0,8);  my $out='';while(substr($addr,0,2) eq '00'){$out.="1";$addr=substr($addr,2);}  my $a=Math::BigInt->new('0x'.$addr);my $o='';  while($a>58){$o=$bb[$a%58].$o;$a=$a/58;}  $o=$bb[$a].$o;  return $out.$o;}1; Yeah, you can even do the signing in perl without bitcoind at all if you have the private key(s), I've been crafting/signing raw transactions that way for a while, can probably come up with some sample code if you want.  The harder part is finding the transaction inputs for the address... Here's a basic sample of connecting to the P2P interface in Perl, this just connects and spits out any new blocks in raw format on STDOUT and debug information about the connection on STDERR but once you've got the connection running you can send any commands through it, just need to be careful about the network byte orders that bitcoin uses.Code:#!/usr/bin/perluse IO::Socket;use IO::Select;use Digest::SHA;$|=1;$btc=IO::Socket::INET->new(PeerAddr=>"localhost",PeerPort=>'8333',Proto=>'tcp') or die "Socket";$sel=IO::Select->new();$sel->add($btc);$p="\x2c\x7e\x00\x00"; # Version$p.="\x01\x00\x00\x00\x00\x00\x00\x00"; # Services$h=sprintf('%x',time());while(length($h)<16){$h="0".$h;}$h=reverse($h);$p.=pack('h*',$h); # Unix Timestamp$p.="\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF"; # To IP$p.="\x7f\x00\x00\x01\x20\x8d"; # 127.0.0.1 - Port 8333$p.="\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF"; # From IP$p.="\x00\x00\x00\x00\x20\x8d"; # 0.0.0.0 - Port 8333@chars=('a'..'f', 0..9);$rr=join '',map {$chars[rand @chars]} 1..16;$p.=pack('H*',$rr); # Random Unique ID$p.="\x00\x00\x00\x00\x00"; # No UA/Blockssendpacket('version',$p);while($gotver==0){  ($c,$p)=readpacket();  if($c eq 'version'){$gotver=1;}sleep(1);}sendpacket('verack','');while(1){  ($c,$p)=readpacket();  if($c eq 'inv'){    sendpacket('getdata',$p);  }  if($c eq 'block'){    $blk=unpack('H*',$p);print $blk."\n";  }sleep(1);}close($btc);sub sendpacket{my $c=shift(@_);my $p=shift(@_);  my $o="\xf9\xbe\xb4\xd9"; # Magic for main network  while(length($c)<12){$c.="\x00";}$o.=$c; #Command  my $h=sprintf('%x',length($p));while(length($h)<8){$h="0".$h;}  $h=reverse($h);$o.=pack('h*',$h); # Payload length  $h=Digest::SHA::sha256(Digest::SHA::sha256($p));  $h=unpack('H*',$h);$o.=pack('H*',substr($h,0,8)); # Checksum  $o.=$p; # Payload  print $btc $o;print STDERR "Sent $c (".length($p)." byte payload)\n";}sub readpacket{  if(!$sel->can_read(1)){return 0;}  my @x;my $x;while(1){read($btc,$x,1);$x=unpack('H*',$x);    push(@x,$x);if($#x>3){shift(@x);}    if(join('.',@x) eq "f9.be.b4.d9"){      my $cmd;my $len;      read($btc,$cmd,12);read($btc,$len,4);read($btc,$x,4);      $x=unpack('h*',$len);$x=reverse($x);$len=hex($x);      $x=chop($cmd);while($x eq "\x00"){$x=chop($cmd);}$cmd.=$x;      print STDERR "Read $cmd ($len byte payload)\n";      if($len>0){read($btc,$x,$len);return ($cmd,$x);}      else{return ($cmd,'');}    }  }} Hmm, perhaps I didn't look at the output I got quite close enough.  Sorry about that, I've been using the "getrawtransaction" in 0.7+ which was upgraded to provide information whether the transaction in on an address in your wallet or not, when "listunspent" gave me information that looked approximately right I assumed it had been updated as well.  That's too bad, I had been planning on updating another script of mine to use that instead of an external service one of these days, guess I'll have to come up with another way as well. Seems to me you should be able to do this pretty easily with the "listunspent" RPC call in version 0.7+ of the standard client, I can confirm on mine that it works for any address whether it is in the wallet or not and gives enough information to check balances on an address and craft transactions that can be passed back in to "sendrawtransaction". Not too many with actual bounties listed but I went through and gave a few of them a try.  As far as I can tell http://www.hashbounty.net/download?id=35001 seems to be solvable with the password "pingpong" but the site says it is an invalid solution.  Can someone verify if I'm doing something wrong or if it's a problem with the site checking? Ah, very nice.  I've been using the P2P interface to get raw block data since before the getblock RPC calls were standard (seemed preferable to vetting various getblock patches and keeping up with changing arguments for them) and even in fairly recent releases the performance seems to be much better connecting that way, but I will admit I haven't tried it again that recently. That is correct, as far as I know there isn't any way to get multiple blocks out of the RPC interface (unless that has changed in recent versions) but if you connect via the P2P interface it will spit out a list fairly quickly.  Depends on your application which is easier and the original question wasn't very specific.
https://en.bitcoin.it/wiki/Protocol_specification#getblocksNot really set up to give a certain number, you just give it the hash for the last block you have (or a couple of the latest) and it will send a list of anything newer (up to 500 blocks). Like the other data+checksum addresses it is theoretically possible but very unlikely to find a valid private/public keypair that matches it.  One of those small transactions is mine from a bug in subvertx that apparently messed up the output address, wouldn't surprise me if at least some of the others came about the same way. Doing the math on the robohash it looks like it uses 22-24 bits depending on the settings to get an exact match, so roughly equivalent to matching 4 characters of the address.  It could add some extra security combined with something else but by itself yes it is fairly trivial to match. Code:mskwik@mskwik ~ $ ./vanitygen 1FakeDifficulty: 4476342Pattern: 1Fake                                                                 Address: 1FakerW3HiFf8Fz5bYPKApGeguoaY6F1xhPrivkey: 5JxThis1sAReaLPrivateKey111111111111111112zcbiLwEsU 1MB2HBuzi4LQ9XZwtQ3GzRGombGx72LUPZ1F9UeZCMcSfdYpVwSFfbaWQxK4p7FER79k Not really familiar with github but here is the script I was using:Code:#!/usr/bin/perluse Digest::SHA;$|=1;open(VG, "./vanitygen -q -k 1 |");while(<VG>){print $_;chomp($_);  $msg=$_;if(/Address: (.*)/ig){$addr=$1;    $hash=Digest::SHA::sha1_hex(Digest::SHA::sha1_hex($addr));    $id=substr($hash,0,2);    $id.=hex(substr($hash,2,1))%8;    $id.=hex(substr($hash,3,1))%4;    $id.=hex(substr($hash,4,1))%4;    $id.=hex(substr($hash,5,1))%2;    $id.=int(hex(substr($hash,6,1))/4);    $id.=int(hex(substr($hash,8,1))/4);    $id.=int(hex(substr($hash,10,1))/4);    $id.=int(hex(substr($hash,12,1))/4);    $id.=int(hex(substr($hash,14,1))/4);    $id.=int(hex(substr($hash,16,1))/4);    $id.=hex(substr($hash,18,1));    print "Identicon: $id              \n";    if($seen{$id} ne ''){      print "Match found\n".$seen{$id}."\n$1\n";exit;    }$seen{$id}=$1;  }}That's picking 32 bits out of the hash for the identicon string, to add more bits and get more accurate I would add more bits on the end of the colors that are using just 2 bits per channel there.  Notice that it just checks for a match against any icon it has found so far, to match a particular one you would find an identicon string for it from the same bits and just search for that, to search an address prefix as well you can change the vanitygen argument.  I also was running on a machine with 8GB RAM, run at your own risk with more bits or less RAM when saving every result like this. Replying to myself again , but just for fun if we disregard prefix we can fairly easily match 32 bits:1KbhFQVEUk8wMVtiuBURZAQ1PXnsDUqcag1EEwcrjaJkWLLZDuZA2Rhob3aVM8NwY5tRor 40 bits:1NcE7wksPMcydG7bfsGsGdjf2ckzXSfw1R1H26EaqCrbdHZk2SvqvZDfPHqYGbYqQsJjNot going to try for 48 bits on the CPU, but with OpenCL code on a GPU it shouldn't be bad either. So I did download the source and take a look at it.  Seems to me you would need to match about 32 bits to look fairly similar (like so someone may not notice if it had changed between site visits) up to about 48 bits to look fairly similar even comparing them side by side.  Mathematically this puts it roughly similar to checking 7 digits at the end of the address.As a short example here's 12 bits matched which only takes a couple minutes (plus I skimped a little on the prefix):1BoatSLRHtKNngkdXEeobR76b53LETtpyT1BoaDLmiNMdQJKe34nbbvJDCqAmpD1adMNI do like the idea, the human brain does seem to be wired to remember (and recognize if they change) colors and shapes better than random characters, just trying to quantify the results somewhat. It is however better than checking an equivalent number of characters just at the beginning since it includes the checksum part of the address.  It could be just as good as checking the identicon depending on how many bits you would need to get a similar-looking identicon.  Both the address checksum and the identicon are based on parts of a hash of the address, it's not clear without examining the identicon source further how many bits you would need to generate another that looks "close enough". And yet you have some centralized channel setup to announce your attack chain to miners?  Perhaps I'm misunderstanding it somewhere but doesn't the satoshi client not forward competing blocks until they become part of the longest chain?  I see how it mirrors game theory in that your individual reward might be highest helping the attacker, but the assumption there is that the players can't communicate with each other and I'm not sure that holds true in this case. This seems to assume that miners are either working for one side or the other, it seems to me that if the "bribe" is less than the block generation amount the optimal mining strategy is to keep both chains going out as long as the attacker can afford and have the attack fail in the end. And then of course you need to consider if there is some correlation between your current location and the chance of being struck by lightning... I do seem to recall having the same issue when working on mining code myself, now I keep logs of communications to replay for testing if needed.  Here are a couple of getwork requests and valid responses if that helps:Code:{"error": null, "jsonrpc": "2.0", "id": 1, "result": {"hash1": "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000", "target": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000", "submitold": true, "identifier": "91138", "data": "00000002fc517a2df2b283474b135215a00604af276318262f5eebc00000043100000000db9fcfcc3781c1342c2750214e46407286cbf29985e688d0392e6b8005c4c8245032580a1a07a85e00000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000", "midstate": "03ad4305c1cad2bf14a99b82f3557b5722a060d6ac207450e939cb9f8143a605"}}{"method": "getwork", "params": [ "00000002fc517a2df2b283474b135215a00604af276318262f5eebc00000043100000000db9fcfcc3781c1342c2750214e46407286cbf29985e688d0392e6b8005c4c8245032580a1a07a85e8e631c12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000" ], "id":1}{"error": null, "jsonrpc": "2.0", "id": 1, "result": {"hash1": "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000", "target": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000", "submitold": true, "identifier": "91138", "data": "00000002fc517a2df2b283474b135215a00604af276318262f5eebc00000043100000000db9fcfcc3781c1342c2750214e46407286cbf29985e688d0392e6b8005c4c824503257921a07a85e00000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000", "midstate": "03ad4305c1cad2bf14a99b82f3557b5722a060d6ac207450e939cb9f8143a605"}}{"method": "getwork", "params": [ "00000002fc517a2df2b283474b135215a00604af276318262f5eebc00000043100000000db9fcfcc3781c1342c2750214e46407286cbf29985e688d0392e6b8005c4c824503257921a07a85e75636781000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000" ], "id":1}{"error": null, "jsonrpc": "2.0", "id": 1, "result": {"hash1": "00000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000010000", "target": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000000", "submitold": true, "identifier": "91140", "data": "00000002fc517a2df2b283474b135215a00604af276318262f5eebc000000431000000004ef2e77a1afd0bc73e7b8e0becd271e43895372dabb062c78d5a97fb55f48cc05032581d1a07a85e00000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000", "midstate": "c2d1fff4a613196dd9ae9fd848673eefc1d7d501ae6ddc0ae2e5f820671971b0"}}{"method": "getwork", "params": [ "00000002fc517a2df2b283474b135215a00604af276318262f5eebc000000431000000004ef2e77a1afd0bc73e7b8e0becd271e43895372dabb062c78d5a97fb55f48cc05032581d1a07a85e376a8504000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000" ], "id":1} The maketx tool in the subvertx package will let you generate raw transactions given just the inputs and private keys to sign them. Also note that the sign was in fact wrong on one of those solutions that I posted the other day, I updated the post to have another correct example so they should be safe to check against. https://en.bitcoin.it/wiki/Protocol_specification#Signatures gives the public key format.https://www.bitaddress.org/ will give both uncompressed and compressed addresses on the wallet details tab (that's what I've been using to double-check my results) It's not base58, it's the compressed address format that the bitcoin client started using in v0.6.  Been working on improving vanitygen performance and added compressed support to vanitypool.thruhere.net for testing but promptly solved all the remaining work there.  Seems you can improve the hash rate by 80-90% pretty easily by checking the compressed addresses as well but it effectively cuts all the bounties here in half if half the solutions get rejected. https://bittit.info/ ? I see I've gotten a collection of rejections this morning, https://vanitypool.appspot.com/solveWork?key=1stDECx%3A04C13D9CF2B0E382A4AF29C5E2B97F85C6DD9445F7DCE82CD7207E6FC4716511981B0012C10B39EF152257A8407A2965F92F075379D311D5786D9421795B82D01C&privateKey=47F54EE114C935B1920EE833CFE90AD12A86D0C0A40A046C561C6517AA656893&bitcoinAddress=1PkdeXKsdPe5vEA3oTSv8HgCncfJxPqFab and https://vanitypool.appspot.com/solveWork?key=1QuanYin%3A04C13D9CF2B0E382A4AF29C5E2B97F85C6DD9445F7DCE82CD7207E6FC4716511981B0012C10B39EF152257A8407A2965F92F075379D311D5786D9421795B82D01C&privateKey=07B710E1E5485749B0AA2A4DFF88701BDC1C5EB1D8F4E3FD06611F8CE6C0144A&bitcoinAddress=1CLZJF7GcjPa2HkVWHTiLAefoSLb4eKPaF most recently.  The math checks out doing it manually so I'm guessing it doesn't like the compressed solutions. I suspect any of the FPGA boards could be adapted for IMEI cracking without any problems, that's a simple sha1 hash and would require even less communication bandwidth than Bitcoin mining.  Been thinking about adjusting an Icarus board to solve work for yambamoney.com at some point if it shows signs of becoming more profitable than mining, but the whole Windows-only client thing is such a pain that I was hoping for a similar site (preferably paying in BTC) with a better API to build off of. Sorry, must have missed that question, apparently the watchlist doesn't quite work like I would expect.  Anyway it does seem that transaction went through, may have just been a little slow at the time, I have been working on some updates.http://greenishblue.info/litedice/898ccc7e5450858dc3d5576be40d35750574efcf48a026041d3ff36c778f4f8a-0.htmlAnd on that subject I believe at this point it's been tested well enough to make public knowledge so without further ado I present the affiliate program.https://litedice.greenishblue.infoI have set it up so you can start out fairly simple but have all the data available in easily readable format if you want to do more with it.  It is LTC only right now, but you'll notice I do have a currency selector there and it should be fairly simple to add other similar cryptocurrencies if there is the demand for it.  As an example I have setup LfL1P8SkdFA7WSacf647rkWcj45kbqmb87 which has a 50% chance of winning and pays out 1.92x (the same 3% house edge as the rest of the games) but it is setup with the donation address of the litecointalk forums as the affiliate.  This pays 1% of the total bets placed (regardless of win/loss) to that address.  It has its own stats page at http://greenishblue.info/litedice/LfL1P8SkdFA7WSacf647rkWcj45kbqmb87.html and in JSON format at http://greenishblue.info/litedice/LfL1P8SkdFA7WSacf647rkWcj45kbqmb87.js.  I think the basics are relatively self-explanatory, but I don't exactly have a manual or FAQ or anything for it yet so go ahead and ask any questions and I'll try and come up with answers.
Any chance of cashing out what was on my account when the site went down?  (Or better yet anyone who had a balance)  Seems to me that shutting down shouldn't be a valid excuse to claim everyone's outstanding balance. Yeah, it just connects to a bitcoind (through the p2p connection, not RPC), does the handshake, and offers up that single tx hash and then the tx itself when it is requested.  Basically the same as 'mktx send' is supposed to do in the subvertx package, I just found it far easier to rewrite as a script rather than to try and get all the dependencies for that to compile on the systems I was working on. I've been using something like this to dump raw transactions into the network, feel free to adapt to your language of choice if you want something that runs locally.  I don't have anything like it running on a public web server but it shouldn't be too hard to do.Code:#!/usr/bin/perluse IO::Socket;use IO::Select;use Digest::SHA;$tx=shift(@ARGV);$btc=IO::Socket::INET->new(PeerAddr=>"localhost",PeerPort=>'8333',Proto=>'tcp') or die "Socket";$port="\x20\x8d";$magic="\xf9\xbe\xb4\xd9";$mmatch="f9.be.b4.d9";$sel=IO::Select->new();$sel->add($btc);$p="\x2c\x7e\x00\x00"; # Version$p.="\x01\x00\x00\x00\x00\x00\x00\x00"; # Services$h=sprintf('%x',time());while(length($h)<16){$h="0".$h;}$h=reverse($h);$p.=pack('h*',$h); # Unix Timestamp$p.="\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF"; # To IP$p.="\x7f\x00\x00\x01".$port; # 127.0.0.1:port$p.="\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xFF"; # From IP$p.="\x00\x00\x00\x00".$port; # 0.0.0.0:port@chars=('a'..'f', 0..9);$rr=join '',map {$chars[rand @chars]} 1..16;$p.=pack('H*',$rr); # Random Unique ID$p.="\x00"; # No User Agent$p.="\x00\x00\x00\x00"; # No Blockssendpacket('version',$p);while($gotver==0){  ($c,$p)=readpacket();  if($c eq 'version'){$gotver=1;}sleep(1);}sendpacket('verack','');$tt=pack('H*',$tx);$h=Digest::SHA::sha256(Digest::SHA::sha256($tt));$p="\x01\x01\x00\x00\x00".pack('H*',reverse(unpack('h*',$h)));sendpacket('inv',$p);$gotreq=0;while($gotreq==0){  ($c,$pp)=readpacket();  if($c eq 'getdata' && $p eq $pp){$gotreq=1;}sleep(1);}sendpacket('tx',$tt);print "Sent transaction ".unpack('H*',$h)."\n";close($btc);sub sendpacket{my $c=shift(@_);my $p=shift(@_);  my $o=$magic;while(length($c)<12){$c.="\x00";}$o.=$c; #Command  my $h=sprintf('%x',length($p));while(length($h)<8){$h="0".$h;}  $h=reverse($h);$o.=pack('h*',$h); # Payload length  $h=Digest::SHA::sha256(Digest::SHA::sha256($p));  $h=unpack('H*',$h);$o.=pack('H*',substr($h,0,8)); # Checksum  $o.=$p; # Payload  print $btc $o;print STDERR "Sent $c (".length($p)." byte payload)\n";}sub readpacket{  if(!$sel->can_read(1)){return 0;}  my @x;my $x;while(1){read($btc,$x,1);$x=unpack('H*',$x);    push(@x,$x);if($#x>3){shift(@x);}    if(join('.',@x) eq $mmatch){      my $cmd;my $len;      read($btc,$cmd,12);read($btc,$len,4);read($btc,$x,4);      $x=unpack('h*',$len);$x=reverse($x);$len=hex($x);      $x=chop($cmd);while($x eq "\x00"){$x=chop($cmd);}$cmd.=$x;      print STDERR "Read $cmd ($len byte payload)\n";      if($len>0){read($btc,$x,$len);return ($cmd,$x);}      else{return ($cmd,'');}    }  }} Yeah, looks like someone had a winning streak and it ran short on change txs with enough confirmations to resend.  Everything is paid out now but it is a little short on coins so max bets are low, will get it more as soon as I can move them through an exchange. The backend uses a couple methods to make double spend attacks more difficult.  It maintains connections to a number of peers and checks that incoming transactions have propagated to a majority of them (without forward them itself) before accepting them.  It also uses a separate connection (which does not accept incoming connections) from the receiving connections for sending new transactions out to make the listening connections harder to identify.For this application the return transaction is also the fastest feedback mechanism (as the web page listing is delayed by ~60 seconds due to the caching) and it will not propagate through the network faster than the original transaction (since any nodes that get it first will not pass it on without the other).  So basically any bets that are processed should be well distributed through the network before any attacker got the results to determine whether to try and invalidate the bet.  Obviously it's not perfect but should be enough to drive the risk up for any would-be attacker to beyond the expected rewards. The script does automatically update the max bets based on the available balance to make sure that it has enough to pay out winning bets.  You must have caught it right after they got pushed down because of the other win.  Perhaps I'll have to add a little extra leeway there for when that happens, the calculation is conservative enough that a couple minutes shouldn't matter but will let any bets through from people who started when the limits were higher. Yeah, I see around 40 bets queued up waiting for payout now but it'll catch back up shortly, the big win triggered a manual review on the payment backend, guess I should make it so that doesn't hold up the other payments in the queue.Yes it should return winnings with 0 confirmations when it manages to respond fast enough (these Litecoin blocks come pretty fast) which is relatively safe because it uses the original tx in the payout, so if it ends up voided somehow the payout will as well.And yes the tx fee can take a fairly large chunk percentage-wise at small amounts.  I don't necessarily want to make the min bet too large, but on very small bets it's way more than the house edge so can't afford to take it out of the house side either without a negative expected return (which isn't particularly sustainable). http://abe.liteco.in/tx/5e8888caffda681b90f02bf93544375bf2ed22c3765e2035038630924c2febd6And there it goes.  Guess I gotta go through and check my locking, looks like it was trying to double-spend one of those inputs with another tx created at the same time. Hmm, it looks like I have 3 payments now in the outgoing queue that are stuck at 0 confirmations but it has sent other payments in the meantime just fine, must be something about those it doesn't like.  I'm working on it, will (hopefully) get it sent shortly. Sorry if the return txs were a little slow there for a bit, seems my local litecoind decided to ban me for trying to relay too many transactions through it at once, at least that problem shouldn't happen again   I figured it was safest to start with the edge on the high side and adjust lower later if possible.  The actual house edge (as opposed to the average displayed) depends on the bet size due to the minimum amount returned for a loss (which has to be somewhat higher than the 1dice ones due to the current fee rules on the litecoin network) so basically I wanted to make sure the expected return stays positive even with a lot of small bets. I've been working on redesigning some of the backend bitcoin payment stuff that I have been using and in the process made it fairly simple to have it support alt-coins with the same basic design/networking.  My end goal was to make it much simpler to put basic (and not so basic) ***coin projects together without having to do security from the bottom up for each project.  Not really sure when/if those bits will ever be directly released but in the meantime I threw together a simple proof-of-concept to try things out.http://greenishblue.info/litediceThe display/explanations may be a little rough around the edges but it is fully functional.  As always don't gamble with any coins you can't afford to lose and if you run into any issues let me know the tx hash and I'll track it down. So in my spare time I've been playing around with various bits related to split-key vanity address generation (See https://bitcointalk.org/index.php?topic=84569.0 for more information but I didn't want to completely hijack ThePiachu's thread) and since now I've moved from the client to the server scripts I figured I'd open it up to the public if anyone else feels like testing.  The interface is fairly minimal, but it should do request handling and mining requests without a problem.http://vanitypool.thruhere.netThe mining interface is compatible with the split-key miners that have been posted through /getWork and /solveWork (or any URLs close enough to those).  I have been playing with other data formats accessible by adding a version number to the request, but don't have any fixed version other than the default at this point.  The server fee is currently set at 5% or 0.001 BTC, whichever is higher, and the bounty value shown in the /getwork list takes the fee into account so is the actual amount the miner will receive for submitting work for that line first.Still on the todo list:Check pattern requests for feasibility before accepting paymentFeel free to share any other feature requests/problems and I'll see what I can do. Ah, I see there is work now, data format just got switched around so it wasn't picking it up, will have to adjust that miner script. Don't really have the time right now to write it up properly myself either, just kind of wanted it noted before someone else following your documentation gets mixed up on the same thing.  For the record there are implementations of full address checking in a couple different languages in this thread:https://bitcointalk.org/index.php?topic=1026.0 I would note that your Bitcoin address verification is incomplete, to actually fully verify that an address is valid you would also need to base58-decode the address and check the checksum.  In general I wouldn't worry about checking the length/first character before decoding since you can easily check the exact length and network ID byte after decoding as well as easily verifying private keys or other types of addresses with very nearly the same code, but I suppose that's up to personal preference since the 00 mainnet byte does always give a 1 at the beginning of the encoded address. So if you need something to get started with here's what I patched vanitygen with:Code:*** pattern.c.orig Fri Jun 29 01:51:26 2012--- pattern.c Wed Jun 27 22:25:46 2012****************** 42,47 ****--- 42,52 ----  int  vg_exec_context_init(vg_context_t *vcp, vg_exec_context_t *vxcp)  {+  EC_GROUP *ecgrp;+  EC_POINT *tmpg;+  BIGNUM order;+  BIGNUM cofactor;+    memset(vxcp, 0, sizeof(*vxcp));     vxcp->vxc_vc = vcp;****************** 50,61 ****   BN_init(&vxcp->vxc_bnbase);   BN_init(&vxcp->vxc_bntmp);   BN_init(&vxcp->vxc_bntmp2);     BN_set_word(&vxcp->vxc_bnbase, 58);     vxcp->vxc_bnctx = BN_CTX_new();   assert(vxcp->vxc_bnctx);!  vxcp->vxc_key = EC_KEY_new_by_curve_name(NID_secp256k1);   assert(vxcp->vxc_key);   EC_KEY_precompute_mult(vxcp->vxc_key, vxcp->vxc_bnctx);   return 1;--- 55,76 ----   BN_init(&vxcp->vxc_bnbase);   BN_init(&vxcp->vxc_bntmp);   BN_init(&vxcp->vxc_bntmp2);+  BN_init(&order);+  BN_init(&cofactor);     BN_set_word(&vxcp->vxc_bnbase, 58);     vxcp->vxc_bnctx = BN_CTX_new();   assert(vxcp->vxc_bnctx);!  ecgrp=EC_GROUP_new_by_curve_name(NID_secp256k1);!  if(vcp->vc_opubkey){!    tmpg=EC_POINT_hex2point(ecgrp,vcp->vc_opubkey,NULL,NULL);!    EC_GROUP_get_order(ecgrp,&order,NULL);!    EC_GROUP_get_cofactor(ecgrp,&cofactor,NULL);!    EC_GROUP_set_generator(ecgrp,tmpg,&order,&cofactor);!  }!  vxcp->vxc_key = EC_KEY_new();!  EC_KEY_set_group(vxcp->vxc_key, ecgrp);   assert(vxcp->vxc_key);   EC_KEY_precompute_mult(vxcp->vxc_key, vxcp->vxc_bnctx);   return 1;*** pattern.h.orig Fri Jun 29 01:51:40 2012--- pattern.h Wed Jun 27 09:14:34 2012****************** 76,81 ****--- 76,82 ----   double   vc_chance;   const char  *vc_result_file;   const char  *vc_key_protect_pass;+  const char  *vc_opubkey;   int   vc_remove_on_match;   int   vc_verbose;   vg_free_func_t  vc_free;*** oclvanitygen.c.orig Wed Mar 21 19:54:31 2012--- oclvanitygen.c Fri Jun 29 02:04:31 2012****************** 2541,2546 ****--- 2541,2547 ----  "Options:\n"  "-v            Verbose output\n"  "-q            Quiet output\n"+ "-D            Print difficulty info only and exit\n"  "-r            Use regular expression match instead of prefix\n"  "              (Feasibility of expression is not checked)\n"  "-i            Case-insensitive prefix search\n"****************** 2550,2555 ****--- 2551,2557 ----  "-X <version>  Generate address with the given version\n"  "-e            Encrypt private keys, prompt for password\n"  "-E <password> Encrypt private keys with <password> (UNSAFE)\n"+ "-P <pubkeyhex> Add Public key to generated before checking\n"  "-p <platform> Select OpenCL platform\n"  "-d <device>   Select OpenCL device\n"  "-S            Safe mode, disable OpenCL loop unrolling optimizations\n"****************** 2580,2585 ****--- 2582,2588 ----   FILE *fp = NULL;   char **patterns, *pend;   int verbose = 1;+  int diffonly = 0;   int npatterns = 0;   int nthreads = 0;   int worksize = 0;****************** 2592,2600 ****   cl_device_id did;   const char *result_file = NULL;   const char *key_password = NULL;     while ((opt = getopt(argc, argv,!         "vqrikNTX:eE:p:d:w:t:g:b:VSh?f:o:s:")) != -1) {    switch (opt) {    case 'v':     verbose = 2;--- 2595,2604 ----   cl_device_id did;   const char *result_file = NULL;   const char *key_password = NULL;+  const char *opubkey = NULL;     while ((opt = getopt(argc, argv,!         "vqrDikNTX:eE:p:d:w:t:g:b:VSh?f:o:s:P:")) != -1) {    switch (opt) {    case 'v':     verbose = 2;****************** 2605,2610 ****--- 2609,2617 ----    case 'r':     regex = 1;     break;+   case 'D':+           diffonly = 1;+           break;    case 'i':     caseinsensitive = 1;     break;****************** 2717,2722 ****--- 2724,2732 ----     }     seedfile = optarg;     break;+    case 'P':+           opubkey = optarg;+           break;    default:     usage(argv[0]);     return 1;****************** 2785,2790 ****--- 2795,2801 ----   vcp->vc_verbose = verbose;   vcp->vc_result_file = result_file;   vcp->vc_remove_on_match = remove_on_match;+  vcp->vc_opubkey = opubkey;     if (!vg_context_add_patterns(vcp, patterns, npatterns))    return 1;****************** 2811,2816 ****--- 2822,2830 ----    fprintf(stderr,     "Regular expressions: %ld\n", vcp->vc_npatterns);  +  if(diffonly==1)+   return 0;+    did = get_opencl_device(platformidx, deviceidx);   if (!did) {    return 1;And here's the simple script to run it (the few configurable things are variables at the top) (Now edited to work with the new getwork data format)Code:#!/usr/bin/perl$newworkpolltime=180;$vanitygen="./oclvanitygen -d 0 -p 0";$myaddress="mhFwRrjRNt8hYeWtm9LwqCpCgXjF38RJqn";use IO::Handle;use IO::Select;$|=1;while(1){  if($servercheck<time()){$servercheck=time()+$newworkpolltime;    print "\nPolling server for new work\n";undef %prefix;undef %diff;    @data=readpipe("curl -L -m 20 -s https://vanitypooltest.appspot.com/getWork");    foreach $l(@data){chomp($l);      ($p,$pk,$n,$r,@x)=split(/:/,$l);      $n=int($n);$p=~s/[^0-9a-zA-Z]//g;$pk=~s/[^0-9a-fA-F]//g;      $_=readpipe($vanitygen." -X $n -D $p 2>&1");      if(/Difficulty: ([0-9]*)/ig){$d=$1;        $d=int($r/$d*(10**14));if($d>0){          $diff{"$pk:$n"}+=$d;$prefix{"$pk:$n"}.=$p." ";        }      }    }my @d;    for my $k(keys %diff){push(@d,$diff{$k}.":".$k);}    @work=sort{($b=~/([0-9\.]*):(.*)/)[0]<=>($a=~/([0-9\.]*):(.*)/)[0]}@d;  }  ($d,$pk,$n)=split(/:/,$work[0]);$p=$prefix{"$pk:$n"};  if($d==0){    if($running ne ''){close($vgen);kill(15,$pid);$running='';}    print "No work\n";sleep(30);  }  if($running ne "$pk:$n:$p" && $d>0){    if($running ne ''){close($vgen);kill(15,$pid);}    $running="$pk:$n:$p";    $pid=open($vgen, $vanitygen." -X $n -P $pk -v $p 2>&1 |");    $ss=IO::Select->new();$ss->add($vgen);    $vgen->blocking(0);$searchpk=$pk;  }  if($running ne ''){if($ss->can_read(5)){$line=$vgen->getline();    while($line){print $line;      $_=$line;if(/Pattern: ([0-9a-zA-Z]*)/ig){$foundp=$1;}      $_=$line;if(/Privkey \(hex\): ([0-9A-F]*)/ig){$foundk=$1;        print "\nSubmitting found work\n";        $url="https://vanitypooltest.appspot.com/solveWork?key=$foundp%3A$searchpk&privateKey=$foundk&bitcoinAddress=$myaddress";        $data=readpipe("curl -L -m 30 -s \"$url\"");chomp($data); print "\nServer returned $data\n"; shift(@work);      }$line=$vgen->getline();    }  }}sleep(1);}Not horribly user-friendly, but a reasonable starting spot. Well the code differences to have vanitygen do the generation are trivial, it only takes a handful of lines of code to get both the cpu and ocl versions to generate addresses (with the multiplication method) without any loss of speed.I did also throw together a simple perl script to talk with the server and get/submit work that it passed to vanitygen for the processing.  I'm sure it has a bunch of dependencies specific to my system but could probably be cleaned up to be a basic miner client without too much trouble.  Not heavily tested since there hasn't been too much work posted there and I didn't want to point too much processing power at it for just testnet coins but haven't had any problems so far, guess I'll see what I can do about making it more independent and let some other people test it out. Sorry about that, I do believe we've cleared up that particular issue.  I did fix the mailto link, that particular address gets posted enough anyway that using it on that page as well doesn't really matter as far as spam goes, might have issue if I ever start getting bitcoin spam on it but the spam filter does a pretty good job.Yeah the bitcoin daemon is not running on the same machine as the webserver so it does sometimes lag behind a little (or get turned off/rebooted) but it should catch up before too long (and it does wait for 5 confirmations before sending winnings), but if there are any issues with a specific bet you can always email me at admin@movoda.net and I'll verify that payment was made and send the tx id and/or a link to the payment in blockexplorer. I seem to just timeout when trying to connect there, but I got tester.bit and darts.bit to work fine.  So is it a problem with the site or is my configuration off somewhere?, don't see why that name would be different.
I seem to be getting "last_share":"45 minutes" through the API even though the worker page lists closer to 45 seconds Yeah, CPU usage was always pegged at 100% on one core when GPU mining with either pocblm or phoenix, didn't seem to matter to mining rate if I ran something else CPU-heavy that cut down on the amount it could use.  And now all of a sudden it uses less than 1%.  No idea if it's the same bug as people with multiple cards or not, just figured it might help someone else out. Yeah, it's definitely much better than it was and at that rate I wouldn't worry about mining long-term with it.  (Assuming the higher speed makes up for a few extra stale shares) Still seems to have a somewhat high rate of stale shares (as reported in the deepbit stats), but only about 1.5% compared with the 10% last time I tried it.  Does report the new long polling blocks properly now.As far as the whole untrusted code thing goes I have just been running it in a sandbox (the same as when testing other miners, open source doesn't necessarily matter if I don't have the time to look through it properly), no access to home directory, read access to standard system libs, write access to /dev/ati and /tmp and I can remap accesses to /usr/share/hashkill to something under the working directory.  Still have to trust code somewhat but it would stop any basic wallet-stealing (as well as reporting that it was tried). Well I was having this problem and just found that after upgrading from kernel 2.6.36-gentoo-r5 to kernel 2.6.37-gentoo-r4 it seems to have gone away.  No hardware changes, don't think anything else major got upgraded (although the fglrx kernel module was recompiled).  HD5770 w/ AMD 64 x2 CPU running Gentoo, not sure if that helps anyone else or what the changes between those kernels are, but figured I'd post for what it's worth. This was on a 5770.  Switched back to give the new version of Phoenix another try and it has submitted 700+ shares with none stale while using BFI_INT.  Can try it again if there's some way to get debug output or something to help, didn't get any extra errors or output (beyond the hashrate/stats) at all during the last run. Tried it out overnight on deepbit and while it was faster it also ended up with roughly 10% stale shares.  Not sure the long polling is working properly, is it supposed to give any indication when it gets a new block notification? Code looks very nice, unfortunately I get the same issues as with poclbm using it.  Hashrate is roughly as expected, but CPU usage is pegged at 100% on one core while it is running.  Guess I'll be sticking with Diablominer which also gives roughly the same rate without the CPU usage.This is a 5770 running on Gentoo, hashrate is in the ~165-170M range depending on exact settings. I've been running a bot for a while now that trades across exchanges to equalize prices (when it has enough of the right currency in the right place to do it and the prices are far enough apart to make up for the transfer fees).  Main issue is that most of it has to be done through screen-scraping and I'm somewhat reluctant to trust that longterm for large trades.So if you run an exchange you could potentially gain some trading volume by adding an automated trading API *hint* *hint* The black outline is actually a layer over the board part that is used to calculate the outcome, so the black pixels are calculated as the color underneath.  The official calculation is done from a database table that was made at the same time as the image by dumping the section information when they were still separate layers as well, so the edges where they run into each other may not match the image exactly.  I've always done stats calculations off the database and just considered the image as a visual, so far I've only had to adjust the database once when it called a pixel that was clearly well off the board as a double bullseye (must have had a stray pixel on that layer)I think I've shared the board stats before but not sure where so I will pull them again, just to give an "official" number to compare your stats to.  (Not that there's any sure way for you to verify this, but it's where my payout numbers come from)Code:mysql> select darts_section.comment,darts_section.amtback,count(darts_section.id) from darts_board left join darts_section on darts_board.section=darts_section.id group by darts_section.id order by amtback desc;+-----------------+---------+-------------------------+| comment         | amtback | count(darts_section.id) |+-----------------+---------+-------------------------+| Double Bullseye |    1000 |                     116 || Blue Triple     |     600 |                     781 || Bullseye        |     500 |                     566 || Blue Double     |     400 |                    1226 || Purple Triple   |     360 |                    1006 || Cyan Triple     |     300 |                    1026 || Purple Double   |     240 |                    1555 || Blue            |     200 |                    5221 || Cyan Double     |     200 |                    1600 || Red Triple      |     150 |                     972 || Purple          |     120 |                    7076 || Cyan            |     100 |                    7116 || Red Double      |     100 |                    1556 || Green Triple    |      60 |                    1259 || Red             |      50 |                    6632 || Green Double    |      40 |                    2194 || Green           |      20 |                    8365 || Off the Board   |       0 |                   17269 |+-----------------+---------+-------------------------+18 rows in set (0.30 sec)mysql> select darts_section.comment,darts_section.amtback*count(darts_section.id)/65536 as payoutpct from darts_board left join darts_section on darts_board.section=darts_section.id group by darts_section.id order by amtback desc;+-----------------+-----------+| comment         | payoutpct |+-----------------+-----------+| Double Bullseye |    1.7700 || Blue Triple     |    7.1503 || Bullseye        |    4.3182 || Blue Double     |    7.4829 || Purple Triple   |    5.5261 || Cyan Triple     |    4.6967 || Purple Double   |    5.6946 || Blue            |   15.9332 || Cyan Double     |    4.8828 || Red Triple      |    2.2247 || Purple          |   12.9565 || Cyan            |   10.8582 || Red Double      |    2.3743 || Green Triple    |    1.1526 || Red             |    5.0598 || Green Double    |    1.3391 || Green           |    2.5528 || Off the Board   |    0.0000 |+-----------------+-----------+18 rows in set (0.25 sec)Which should add up to the 96% that I normally give as the average payout %And just for good measure (without actual totals)Code:mysql> select sum(amountout)/sum(amountin) from darts_transaction where status>7;+------------------------------+| sum(amountout)/sum(amountin) |+------------------------------+|               0.943374072162 |+------------------------------+1 row in set (0.00 sec)Gotten enough plays now that it doesn't vary too much anymore, mostly tends to drift down slowly with upward jumps when someone wins big. This got me thinking so I had to go and check, and there that first 0.05 BTC transaction was, now with ~35000 confirmations.  Looks like I sent it back and forth to myself in 0.01 BTC increments several times over while testing the darts script and then it got given out to someone who won back when the max bet was 0.1.  Kind of interesting to trace its path since then, but not really all that informative as to what it has been used for (given the pseudoanonymous nature of bitcoin addresses). Customer Number 794407Any chance at getting an API sometime? It was a 1200 of the faster variety, not sure the package off the top of my head, will have to look at the project file later.  Don't have the dev board around anymore, it wasn't actually mine I was just borrowing it.  I can make a copy of the basic code files for you to experiment with, send me an email via PM and I'll pull together at least the basic test project VHDL files later today, just be warned I don't really comment anything when writing code for myself. Just to throw my own results on FPGA mining out there for comparison I did some experiments on a largish Spartan-3E (because that's the dev board I had around).  I did do a custom design just for bitcoin mining, my goal was to see if it could be done reasonably on FPGA hardware, I don't have the resources available to to take it any further so wasn't concerned about general purpose use, after all an FPGA is easy enough to change if needed.  So IO wasn't a problem, test nonces were generated internally, my inputs were the hash midstate and the 3 dwords of data for the second half and the output was any nonce(s) which resulted in 0 for the final H.  Basic serial communications with it buffering the data and continuing to run the main core on the previous data until it had a full new set of data.  With pipelining and parallel pipes I got it to check 16 hashes every 64 clock cycles, but given that it couldn't be clocked past 50MHz that still only gives 12.5 MHashes/sec.  Of course the power consumption is very low, but even if you price it based on the $45 FPGA chip and not the $200 dev board it still costs quite a bit extra upfront compared with a good GPU, I did run the math and figured that over the length of it's expected useful life including power usage the GPU still comes out cheaper per MHash.  Now compared with a CPU it could be competitive, especially if you found a minimal dev board or did a custom board to run it on, but still not very practical.Can't speak for any newer FPGAs from experience, I did try the ISE analysis on a smaller Spartan-6 (trying to match the FPGA price) and got it to (theoretically) clock up to 100MHz, but it only has room for 1/4 the number of pipelines so I only got half the speed total out of it and decided it wasn't worth trying to get the hardware to pursue it further. A relatively simple webservice, but it seemed like something where microtransactions might work out well and was easy enough to adapt so I figured I'd put it out there and see if anyone finds it useful.http://random.greenishblue.infoIt was coded as part of a larger project, this particular piece however was too heavy computation-wise for the hardware I was running it on so I outsourced it to the cloud and setup a spot for me to grab the backgrounds as needed.  What is does is generate unique images that are suitable for use as backgrounds.  You can see the thumbnails on the page for examples, the fullsize images that are unlocked after payment are 7680x4320 pixels, big enough to look good at any standard monitor resolution or to print up to a fairly large size.  If you buy one the rights to it are all yours, it will be completely deleted off the server once the download period is up and you can do whatever you want with it.  Price is set at 0.10 BTC each, but if you find something else useful to do with them in large quantities I'd be willing to discuss volume discounts  Not necessarily, I know that it's perfectly fair the way it is working right now.  What's under discussion here is more a way of offering proof of that...Was never really intended to be more than a "here try this out" type of thing, it kind of looses that aspect if you need to follow what it is actually doing to play.  I can certainly appreciate that some people will read everything and check the calculations themselves and so on, I would fit in that same category myself, but I also understand that some people will just want to throw a small amount at it and see what happens. Yeah, as I state there it doesn't necessarily prove anything about the output randomness, it just proves that the outcome is the same regardless of the bet amount.  The hashes are all sha256 (since that seemed to fit in nicely with what bitcoin is based on), suppose it probably should say that somewhere.I do see what you're saying, biggest issue with that sort of thing is that it adds to the complexity for everyone playing when most people aren't going to worry about checking the results every time.  I suppose it could be setup to be optional, have a set default and accept payment anytime after the address is given but also allow some user input that will verifiably change the result as long as it is received before the payment.  Even just a user specified coordinate offset with the way it works now would have the same effect. I was directed here by someone asking questions about the darts game and after looking it over I have adjusted the game to calculate the winning hash ahead of time (in the same random fashion as before) and along with the address to send the bet to it will show the hash of the winning hash for that transaction, so that after the transaction is complete and the winning hash is revealed you can (if you want to, no extra requirements to play) check that it matches.Still doesn't necessarily give any verification of the randomness of the hashes generated, but should be enough to show that the outcome isn't dependent on the size of the bet without revealing bet sizes in the history. And on a separate note I think another niche that could use filling would be an advertising clearinghouse.  I've seen a couple sites that say they will accept BTC payments for ad space but a central place to do it would be nice to have.  I've been using http://www.projectwonderful.com/ on other sites and like the way they work, something like that would seem that it could work well with bitcoins. That is very true, it is something that I could start development on by myself but the actual development won't really take all that long even just working on it in spare time.  The longer term job on the technical side will be keeping the central server running well and scaling up as needed.  On the other side in the beginning the marketing would be getting stuff to download (as you said) and yes an affiliate program of some sort could help there.  In the longer term there the issue is going to be providing help/support which is the big part I'm not really ready to take on.  I'm already on-call basically 24/7 for my main site, doing sysadmin stuff for another project (that would likely share the same infrastructure at least to start with) won't be a big deal but I'm well aware of how important good customer service is and don't want to jump into something that I'm not prepared to do a good job at.Main reasons for finding a partner upfront would be 1) that they have some input in the design process (if you want to market to a content distributor that they can theme this download page to match their site then I want to know about that as soon as possible) and 2) so that they are familiar with how it is supposed to work from the beginning and can give feedback if it's not as userfriendly as they want or such.  Neither of these is a necessity, I can code it and get a small site going regardless but I am a programmer by trade and know my limitations and something like this will need more than some fancy code to be more than just a small site.I've been considering some ideas already and am thinking I will put something together regardless, I guess this is more of an invitation for someone else who would be interested in running this sort of thing but may not have the technical skills to do it themselves to join me.
