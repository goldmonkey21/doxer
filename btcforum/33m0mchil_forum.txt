Testing on a clean WinXP 32bit in a VMAfter installing MinGW, I should set MINGWPATH in set_vars.bat to C:\MinGW\bin to be able to proceed. The default is 'C:/MinGW'. Am I missing something? @RuudsyJust put the server definition after all other options Mike, I obviously failed to explain it properly. Whatever headers and coinbases are presented to an SPV client, there is a rule  stating that at block 100 000 there should be strictly  5 000 000 BTC or less in circulation. So, a chain of headers which sums above that should be considered invalid. Excuse me for commenting so late on this topic. I just wanted to note that even if miners perform this, they can't inflate above the predetermined issuance schedule, i.e. at block N 'never greater than' money in circulation is easily calculated. Effectively, it's only possible to reassign already destroyed funds. rDNa6N2YsP9SGNoJdbNj1McViMDyxkdqsB Perhaps piuk will provide more details about the double-spends page. I'd guess that it lists transactions that spend inputs which are used in previously known (to blockchain.info) transactions. The majority of them should not enter a block. Every SDICE profit which is double-spent and confirmed, as with the ones you noted, is a dent in the edge. Yes, I still maintain the miner. It is now modular, i.e. you can implement your own hardware or work-source types. I just haven't released a py2exe recently (since BFL support actually) - POCLBM doesn't look so popular anymore and works fine for anyone able to setup python + pip and pull sources from github.Whatever you improve for MacOS is welcome. I explicitly asked for acknowledgement in a separate message and received one. It was not cryptographically signed though. I guess no respectable business will ever use such funny things as asymmetric cryptography these days. intel core i7 860 (4 physical, 8 logical cores)bitcoin-qt built with gitian-builder from sipa/turbo rev 3ccb06f5ae538260817b6ef474f93029be41a64dUbuntu 12.04 64 bit, SSD A-DATA SX910 256 GB64 bit, no -par (default), default cachefirst 193000 blocks from bootstrap.dat - 11m:40s CPU timereal    9m50.565suser    10m47.800ssys     0m56.548s64 bit, no -par (default), default cacheloading from blk000x.dat, up to arround block 211100-loadblock=blk0001.dat -loadblock=blk0002.dat -loadblock=blk0003.dat1 GB peak memory, ~80% average CPU usage, total CPU time 3h:16mreal    41m30.004suser    196m43.378ssys     2m47.834sdebug.log.ubuntu.12.04.x64.7zWindows 7 Professional x64, two Seagate 512 GB HDD in RAID 0-loadblock=blk0001.dat -loadblock=blk0002.dat -loadblock=blk0003.datdefault cache, with '-par 8', initially it seemed to run in single thread mode - first 193 000 blocks loaded significantly slower than on Ubuntu (same hardware), reason perhaps is slower storage.After block 193000 the average CPU utilization rose to ~75%. Looking at threads, there were 16 threads executing same code of which 8 were actually active.92 minutes real time, 6h:05m CPU time, 72% average CPU utilization, 235 MB peak memory working setI then tried with '-par=4' and setting CPU affinity to physical cores only. Now there were initially 12 threads at transaction crunching, with again only one actively processing pre-SatoshiDice blocks.debug.log.win32.7z How about making difficulty re-target optional parameter for mining.notify? Again, new version is up. Main difference is it will always prefer Stratum now - for example if there is http:// specified, but server returns stratum address, it will be used. As always, some small fixes were needed. Please update with the latest version. A new version is up with support for Stratum. See https://bitcointalk.org/index.php?topic=108533.0I am also planning multi-miner support (GPU) as well as FPGA support. Ok, 058-2 works for me. If cp866 is copied to 058-1 Electrum_SysFiles it works too.But is there any explanation why cp866 is needed at all? R047a lacks it and still works fine. @flatfly:Just quick update on the "not connected" problem. Tried to debug it on Windows 7 x64, elecwin 0.58 portable.When trying to connect:Code:Traceback (most recent call last):  File "C:\Users\mgeorgiev\Desktop\electrum\portable\Electrum_SysFiles\0.58\C_\ElectrumPY\lib\interface.py", line 226, in init_socket    self.s.connect(( self.host, self.port))  File "C:\Users\mgeorgiev\Desktop\electrum\portable\Electrum_SysFiles\0.58\C_\Python27\lib\socket.py", line 226, in meth    return getattr(self._sock,name)(*args)LookupError: unknown encoding: idnaFor some reason trying to manually import encodings.idna fails to load unicodedata.pyd.Also, for some reason running packed python.exe (2.7) as console:Code:Thu 06/14/2012 18:45:54.07> ..\Python27\python.exeActivePython 2.7.2.5 (ActiveState Software Inc.) based onPython 2.7.2 (default, Jun 24 2011, 12:21:10) [MSC v.1500 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.>>> import sysLookupError: unknown encoding: cp866Last working version for me is elec047a. Next I got is elec048b and it has the problem.I'll try to figure this out later, no more time for now. There are features already implemented which will make the recent heist a nightmare of the past. The problem is they can't be deployed before the majority of hashing power agrees.I am not vouching for a particular one - just trying to convince you that you should start mining at a pool supporting any of the solutions.Unfortunately Deepbit is currently supporting NONE of them.http://blockchain.info/p2sh New windows binary (2012_02_05) is out.Changes:-- support for proxy servers including socks5 (hint: tor)-- fixed bug in calculation of true target Please see https://bitcointalk.org/index.php?topic=1334.msg732081#msg732081 The problem is triggered by a feature in poclbm I suspect most of the users don't care at all - detecting if a real block is found if mining against a pool. The feature was introduced back in July 2011 and was fixed twice even before being released. Apparently, the fix was not good enough and with the last difficulty adjustment the problem showed up again.I sincerely hope it is really fixed now. Latest github should be OK. I plan a windows binary release for today. Hmm... I don't rebroadcast transactions in order to keep more of the fees for myself. But fees are denominated in... BTC. By not supporting the network and eventually breaking it, BTC will tend to have value of... right, zero. So, I don't really have an incentive to maintain cooperating node?Confused.
This is true even now - miners can fail to submit the precious one true solution due to many reasons. Even on purpose. And yes, I expect the miner to submit his blocks.Feel free to pull this in your code. My patch is tested against pushpoold and seems to work fine. Even if too late in this thread, I'd like to make some comments. Partly because I feel some guilt over the notorious 'getwork' RPC call.It was made with only one purpose - to experiment with mining outside of Satoshi's code. I never imagined it will feed heavy loaded servers in the way it is doing it now. Sadly, it made pooled mining possible and at the same time allowed de-democratization of the mining process. I believe this can be fixed.Right now, classic 'getwork' is re-processing all transactions whenever there are new ones and 60 seconds have passed or when there is new block(1). Worse, because each worker needs its own hash space, the Merkle tree is recalculated entirely with each request(2). When the size of transaction pool (unconfirmed transactions) gets really large, this becomes unfeasible. There were episodes with significant numbers of spam transactions which proved this.Some months ago I made https://github.com/m0mchil/bitcoin/tree/poolmodeAbout (1), transaction processing was moved out of the RPC thread (to main.cpp, ProcessTransactions) to make 'getwork' always return as fast as possible. For (2) UpdateMerkleTree was introduced to allow only specific branch to be rebuilt (specifically the first one). Bitcoind was creating new thread handle for each connection accepted (I guess it was needed for connection timeout guard) - this was removed (see rpc.cpp, around 'boost::thread api_caller') because with pools the server is always used locally, by trusted process(es). Even still single threaded, 'getwork' performance improved drastically.But it is time for a new scheme. I see Gavin's monitorX patch as a good candidate. We need something like 'monitorTransactionPool' to push whenever there is change in the set of transactions currently ready to be included in a block.Also, pools should be changed to allow miners to just prove they included pool's coin base in the block they solve. This is possible by sending the transaction with pool's address in it and the next Merkle branch. Then miners will have complete control over which transactions to include and which block chain to build on.I am intending to have this implemented soon. There is version in user-agent, server can determine miner and act accordingly. New version is upChanges:- support for server provided failback hosts- most of JSON-RPC fields made optional (to reduce pools bandwidth)- increased default primary server retry interval to 10 getworks- moved job processing to main thread- improvements by gominoa, enolan @ github - options separation, server names, quiet output Why would you need to retry submission? Because you either a) have connectivity problems or b) the pool is overloaded. Anyway, probability of result being valid is going down with time.As for GW/Efficiency - this will soon be irrelevant because of some new protocols being developed. Even now, it assumes difficulty of 1 and will show (@ 400 Mh/s) efficiency of 50% at non-'time rolling' pools and anything above 100% (even 700%) with 'time rolling' ones (Eligius). Feel free to explain to users what/why is this. Not that it is wrong, it just doesn't make my life exactly easier.Finally, what exactly is wrong with phatk? As far as I know, it's better on everything AMD 5xxx and up (majority of users). Nvidia users should have their own optimized miner anyway. New version is up. It incorporates improvements from many developers.Kudos go to:Phateus - phatk kernel 124RraPqYcEpX5qFcQ2ZBVD9MqUamfyQnvfpgaminer - Using poclbm With The phatk Kernel 1NT4RyJMqtRuDRr6zHdXdKSpmX3SR5he6zbitless, rethaw - 3% faster mining 15igh5HkCXwvvan4aiPYSYZwJZbHxGBYwB Kyle Gibson - Fallback mining pool(s) 1BdWJEUCkm6on231iX2ThXZHXZDfQny69Rlaanwj - sleep per frame But... PayPal seems to tolerate other currencies and exchanges. See Virwox for example. What are the differences compared to CoinPal? This means you have both Nvidia and AMD drivers. Just add --platform=0 or --platform=1 to choose one of them. @kindleYes, it is on by default if the hardware supports it.Both miners are now the same in terms of hash checking. Phoenix has far better documented and structured code. It also cares about 'efficiency', something I'm tired of explaining that actually doesn't matter. Also, Phoenix seems to have different way of load tuning (aggression) which on my particular setup results in more laggy behavior... and perhaps slightly better performance for dedicated mining rigs, not sure.I hope I won't attract anger with blatantly copying their BFI_INT support. I tried something like this a month ago but didn't understand there is "elf within elf". Grinder, it would be really nice if you mention what your setup consists of. Thanks New version is up. Changes:- BFI_INT (~10% performance improvement)- TCP keep-alive At least on linux you can try to export GPU_USE_SYNC_OBJECTS=1 environment variable. No. The kernel computes correctly only the 4 first bytes. It's confusing, because there is a code in BitcoinMiner.cl BelowOrEquals() which checks 8 bytes - this produces better assembler for some reason, at least in my setup. It can be replaced with 'if (H == 0)' (but it was slower). That's exactly why the targets are hard coded to difficulty of 1 (00000000 FFFF0000).Actually you are right, but in a different way - because of this I should use hard coded kernel target of 00000000 FFFFFFFF in order to not lose 1 thousandth of a percent of all valid difficulty=1 candidates. I'll do this with the next release.Why you check for 'lower' with a 'greater than' operator? Where did the '0x80000000' came from?Anyway, thank you for your comments, they are always welcome. You can try with lower -f, i.e. under 20. Or you can overclock your GPU (core, memory doesn't affect performance) a little. I don't think downgrading to 2.2 will bring much more. Yes. Thanks nelisky! I'll add this in next version. There is a change in the way '-f' works. Simply said, just use lower '-f' now to achieve same performance/desktop lag as before. 5% seems too much though, what's your setup? Is the first card faster? No. You need as fresh jobs as possible. Try to figure out why it fails to fetch new one in a reasonable time. If not in pool - there is an issue currently which can make getwork() extremely slow, see http://bitcointalk.org/index.php?topic=4853.0 Here is a temporary workaround for pool operators http://github.com/m0mchil/bitcoin/tree/poolmodeI renamed CreateNewBlock to ProcessTransactions and call it on every new block or incoming transaction. If less than 60 seconds elapsed since last execution it does nothing. Then CreateNewBlock simply provides most recent snapshot of processed transactions. The bottleneck is moved from RPC thread to network thread.Of course this will be obsolete when actual problem is fixed. As I understand it, now orphan transactions get verified (ECDSA) when their parents become available. New version is up. All changes are pool related. - long polling is slightly better in preventing stales to escape to server;- miner now supports 'time rolling' whenever there is 'X-Roll-NTime' header in HTTP response;- improved check for end of current task
It's actually 12 seconds or more, but I update at whatever_nonce_exhaust_time - TIMEOUT(=5 seconds).There is a separate independent update mechanism since LP was introduced. 'self.askrate' takes place only when LP is off.Guys, I really respect your hard work providing another pool. But please cut all this 'efficiency' pseudo-science. There is no correlation between searching whole 'nonce space' and the results you find. Yes, it affects server load, but there are other methods to solve this. This warning appears here with PyOpenCL built with NumPy 1.5.1.No warnings if using NumPy 1.4.1. I'll try to fix this in poclbm. What are your command line options? How do you set the timeout? Please give some more details about your OS, driver version, ATI Stream (APP) SDK version... Do you have crossfire? It shouldn't use any CPU (unless you use it on your CPU which you should not). Any other CPU usage is cleanly problem of driver + OpenCL SDK + OS. Miner updated with support for long polling, see http://bitcointalk.org/index.php?topic=3889.msg63957#msg63957 Perhaps really really low priority, but I want to remind you about redundant transmission of transactions with each block. May be it's better to solve this sooner rather than later.My proposal is to modify 'block' message to contain only transaction hashes. After that, 'getdata' can be used to further acquire missing transactions from block's sender.Unfortunately I don't see how this can be done without breaking current protocol. Computation is checked on CPU and you will see a 'verification failed' message. 'Invalid or stale' is received whenever the server rejected your result. It now is almost 100% 'stale' than 'invalid', but I didn't change the message because it would have caused more questions.This is problem with flash itself, if not hanging it at least 'reserves' roughly half of GPU for itself. 1.) Excuse me for this mildly obfuscated code. target[0] and [1] are actually A and B of original target - I'm using them just to pass a made up 32 bit target. If you look at kernel parameters you'll see that target[0] (0xFFFF0000) is passed as G.2.) G is used in belowOrEquals because I didn't managed to understand why this leads to better/faster assembler  I left it there wondering when someone will ask this question. Just fixed it to avoid this specific problem on Macs. My humble opinion - there is no free lunch. Every transaction must have a price. This price should be a constant, bound to current definitions of COIN and CENT.Anything else is just a dream. Client should also warn about low priority transactions and suggest a fee to increase chance for inclusion. Just to clarify - these would be winning hashes if difficulty is 1. Exactly equivalent to slush's pool shares. Great job Kiv, really glad to see this.I would definitely donate  I just uploaded latest version, could you please update and try again? New version is up. Changes:- handling httplib exceptions- proper handling of wrong user name and password when mining with bitcoind- support for more than one OpenCL platform- caching kernel binaries for faster startup- always flush stdout aistto, see http://blog.zorinaq.com/?e=11Initially, you can start the miner on first device, then connect your monitor to second device to make it available. If this seems too difficult, see above link for a way to keep second device always active. This is a windows only problem. nster, check if you have proper OpenCL support. Remove any previous VGA drivers. Most probably you switched from Nvidia to AMD and there are conflicting versions of OpenCL.dll on you machine. @aisttoSwitch crossfire off for now. Until I found why versions until and including 20101126 work with crossfire and later ones don't.No, no, no... use python 2.6poclbm is not compatible with python 3. Actually python 2 and python 3 are quite different and not compatible with each other. I really can't hide my disappointment   waited hours for Hal to provide the correct key - and to see that someone got it 3 blocks earlier. Should master my 'F5' key.There is a rather old patch (SVN 195) at https://github.com/m0mchil/bitcoin-impex-keys which supports RPC initiated exporting and importing of keys in PEM format. It also exports corresponding block numbers to speed up import.The reason I didn't announce it back then is that it doesn't solve the double spend problem. The patch could be easily modified to not remove exported key from wallet (it does so at the moment) allowing copying of keys.If anyone's interested I can easily add import method using just private key.
Last four bytes of address are check sum. Not sure what happens to first byte though.I guess there is some minor discrepancy between what Hal used to 'encode' his private key and what we use. 0x6763, what public key do you get?17KzV7RfQnmqcFC3cnS3RqWXQm1CREtNmj or something else? Hal, could you please provide HEX encoded private key ? @wolfangel91Disregard this error, it doesn't affect functionality at all. I just missed to handle and show server-side problem properly, will do so in next release this weekend. I have nothing against Compute4Cash.Please just make a separate thread to promote it.Thanks Or perhaps we should use something like protocol buffers, even for core bitcoin messages? This is the meaningful part of block hash. If mining by yourself you can search for it at blockexplorer.com and take a look at this exact block. It should be in your bitcoind debug.log too. When mining with pool it doesn't have much meaning - all you can see is some 'real' block found by your miner. Right now this will look something like '0002xxxx'. The 'Unexpected error:' doesn't affect mining at all. I just missed to handle HTTP exceptions. Will add it in next version.@[Tycho]: For example trying to figure out why 20101126 works but later ones don't. I just don't have 5970 to test on Windows right now. Keep-alive reuses same connection if the other party (pool) supports it. Using python standard libraries 'httplib' and 'json' makes poclbm to not depend on python-jsonrpc anymore. I was actually unaware that there is 'json' in python.If '--verbose' is specified there are no more '\r' (carriage returns) in output. You can redirect all output to file (poclbm [params] > filename). In this mode everything is on its own line, including hash rate. You may wish to use '-r 60' to have less hash rate entries in the log. Also, every single 'difficulty = 1' candidate is logged unless actual difficulty is 1.Version is now embedded in miner - allows user to check actual version. Pools can gather statistics about different miners and report eventual problems.Handler methods allow someone willing to create GUI for example to receive more information from the miner. New version, please update.Changes:- using httplib + json, keep-alive- optional verbose output suitable for redirection to log file- version in code- handler methods for hash rate, difficulty=1 candidate checks, failureYes, I'm aware of this problem. Unfortunately I'm still unable to resolve it. Any help from someone with 5970 on windows will be appreciated. The problem does not exist on Linux, but I can't figure out why it appeared on Windows only after the 20101126 release. I personally run it on Win 7 64bit, but with cat 10.12 and Stream SDK 2.2 and CPU utilization is pretty low, actually close to 0% Could you please try with Stream 2.2 and post results?There was a version which had a problem, generally not calculating correct hashes above first 32 bits. But with 20110204 I was able to find blocks on test net (which had significantly higher than 32 bits difficulty by the time).Do you at least get 'invalid or stale' message? This should show up from time to time even if miner is broken. Bitcoin will reject the solution. But I really can't imagine other reason for not seeing anything, not even 'invalid' message - the one and only reason to not see any message for a long time is difficulty. There are two ways to get something like this - first one is using ask rate of more than ~12 seconds with an overclocked 5870 (stock max -a is 10 seconds). Other one is network problems triggering resubmission of results - this mechanism is removed since last version. Since you said it happened with stock miner I vote for the latter.   (OT)@FamulusHi Mark, glad to see you here. I am one of your kickstarter supporters. Really nice to see you around!How is the 'Sidney experiment' replication going?  @LobsterMan, the default '-f' is 30 now, use '-f 60' (previous default) or more if it hogs your desktop tcatm, thank you for this miner.Just wanted to mention that since yesterday (Feb 4) poclbm and Diablo miners changed the way of getting kernel results back to host, reducing lost results to below 0.03% (or even less). Fixed issue with lost results due to single output per kernel run (thanks OneFixt, ArtForz). With which version? POCLBM uses separate IO thread since 18 December, around first appearance of the pool. It however sets maximum socket timeout to 5 seconds, everything above that would result in old jobs anyway. May I kindly ask to move this discussion to another/separate thread, please?I had private discussion with geebus already. Will try to explain one more time here.With bitcoin you have many much 'boxes' than 'tickets'. To be exact, the boxes and small prize tickets (pool shares) are 2^224. Grand prize tickets are currently ~ 2^209. Only one in 2^15 boxes contains a grand prize ticket. Deciding to begin another box is a probabilistic win - see the Monty Hall problem. OK, not a win, but every box is equal - checking 100 tickets from a new box completely compensates not checking 100 tickets from the previous box.@FairUser - poclbm makes some assumptions which are counter intuitive at first look. Because it pulls jobs, there is assumption that job should live at most N seconds because otherwise you risk solving already solved block. The probability for this is roughly N/600, but practically always worse because network is growing.Because there is no single GPU capable of exhausting the 2^32 nonces in 5 (and even in 10) seconds, poclbm does not check for nonce overflow.Again, I kindly ask to open another thread for discussions not related to poclbm. Miner is now fixed. It found blocks on testnet. Added verification of kernel result in host.I will highly appreciate any reports about hash speed with this version. Follow pyopencl instructions for manual installation.http://wiki.tiker.net/PyOpenCL/Installation/Linux/Ubuntupython-pyopencl depends on nvidia drivers
It should work fine on Ubuntu. Use latest fglrx (ATI's proprietary driver) and stream 2.1 Use stream 2.1 or 2.2. Not sure why, but 2.3 is slower. Ok, just confirmed... latest version is good only with 'difficulty = 1'. Working properly only on slush's pool.Please revert to previous version for mining solo. I'm working on a fix. At least anyone saying bitcoin is not anonymous enough can try to prove it. Updated to use ArtForz kernel. Lowered default 'frames' to 30.I am seeing biggest improvement on linux, Stream 2.1, 2x5970 - ~5%Thanks ArtForz, tcatm I made some pool related changes - socket timeout is now 5 seconds to avoid solving some jobs more than once. Exception handling should be somewhat better too. Searching for more than one solution doesn't break compatibility - bitcoind would just reject second solution. Nothing is lost, you will have new search space in a short period.But even if other miners do this, I am not quite sure if it improves apparent performance (to pool). Every nonce has equal probability. Hash accepted means only that the block was accepted by your client as a valid solution. Next, it's broadcast to your peers, they broadcast it to theirs and so on. For some reason this broadcast didn't reach my node. This means it didn't reach other parts of the network too. Does someone see this particular hash in debug.log?I definitely recommend opening your port 8333 to ensure better connectivity. This would also make someone cornering you out of the network harder. (I am not saying someone cornered you actually, it's difficult even with the port closed).As for the pool - don't mix up problems. There was a major change recently and you should update poclbm to latest version. Fixed issue with intermittent solving for duplicate pool job. Anyone using the miner against a pool should upgrade to latest version to avoid losing shares.Also, kernel now compiles with vectors on Stream 2.1 Would someone please explain why sending solved block with raw TXs is needed? Isn't it possible to broadcast lighter version of solved block with only TX hashes (32 bytes each), bringing above number to ~32 megabytes (instead of a GB)? Just posted my best settings for Windows 7, Stream 2.2, AMD 5770, 5870 (first post). Teknohog, could you please try with Stream 2.1. I can't see why 'vectors' would give invalid results. FairUser, please describe your setup with as many details as possible. When did it start showing this?Does anyone else see something similar? Updated to support latest change of slush's pool which now returns JSON RPC error when its back-end server is down. Original bitcoind never returns such error as a response to getwork(data).Summarized, this should help miner continue after pool downtime. http://nullvoid.org/bitcoin/difficultiez.php Elanthius, in previous version I forgot to remove OpenCL.dll from the py2exe distribution. It is not there in current version and you should check that you have Stream SDK 2.2 installed and proper version of OpenCL.dll loadable by miner. Be sure there aren't multiple versions - for example if an nvidia one from previous drivers load first it could give you this error. Just wanted to announce here that my miner now has some fixes related to pool usage. It should cycle over network problems. Also, mining is done in a separate thread to avoid performance drops due to IO. Moved actual search to separate thread to avoid IO overhead. It wasn't a problem when used with local bitcoin client, but become a problem with slush's mining pool.Davout, check if crossfire is switched off. Or try with lower clock. Xelister reported on #bitcoin-dev similar issues with 5970 and Diablo's miner. Exactly what you will get with 'normal' mining - pool server received new, network block just before your last solution. Because pool target is quite low you will see this more often. With ask rate of 5 seconds and network speed of 6 blocks/hour there is probability of 1/120 'shares' to see this. Added update of block time every second and support for targets < 32 bits. Output now shows block hash and acceptance status. From bitcoin docs
Apparently you copy-pasted the file, loosing some important details. Use raw view instead (https://github.com/m0mchil/poclbm/raw/master/poclbm.py). Perhaps for other files too. Please provide full information about your platform - driver, SDK, OS. Did you tried with different values for worksize, '-f'? With catalyst 10.11, SDK 2.2 on windows I actually see slight improvement with vectors against previous version. There are many questions still unclear about bitcoin. We have yet to see a lightweight client, freed of the block chain's burden. We still have to see how the TX fee market will develop. There is uncertainty about what the average number of transactions per minute would be in, say, two years.Distributed DNS using bitcoin concepts is really cool. But isn't this a separate currency/commodity? Why not create a separate chain for it? Why force bitcoin users to support services they aren't aware of?What if I want only BitDNS? And I don't need the payments stuff? I will change my miner to check lower targets. Keep in mind that GPUs are perhaps 30x+ faster than CPUs. Are you going to adjust the target to control the number of results you receive from specific client? Because with target suitable for getting 1 result per minute from CPU, you may receive 1 result per SECOND from a GPU. Great danger? But wait, isn't bitcoin invincible?! (Well, perhaps if it adopts random ports, protocol obfuscation, DHT bootstrapping...) Thanks Mike!Could you  please try to run it on a single device? Or use '-d 0' and '-d 1' in two separate processes. poclbm is not optimized to run on more than one device (needs to maintain different queues to avoid choking one or the other). Perhaps there's better way to do this, don't know.Anyway, even if you manage to get more of them it won't be 27x. Search for 'GPU caps viewer' or other tool to check if your setup is OpenCL enabled. With AMD you need Stream SDK installed except you are using catalyst 10.10+, 'Accelerated Parallel Processing (APP)' flavor.LobsterMan, please mention in your article 'GPU caps viewer' or something similar as a way to confirm OpenCL is working. Thanks David. I forgot to remove that one and now I am unable to remove your quote of it  btchris, please send me a personal message. Since your are using the 'compiled' version (and nobody reported such problem recently with it) I want to know what is your GPU and how do you start poclbm (what parameters you use). Fixed. Updated the miner to work with official bitcoin SVN 189. Thank you satoshi, it is a small fix, I hope it will be ready tomorrow. No need to do this, I'll change the miner to comply. I am just a little busy right now. Initially it downloads 'blocks' from other peers. It does this in bundles of 500, but this still involves some disk activity. This will stop when you have all blocks.At the moment the block chain will take about 100 MB of disk space. This is the public shared history of all transactions ever happened. It will grow with time. There are plans for some optimizations like removing spent transactions from disk.About the CPU - bitcoin is trying to solve current block, containing all recent transactions. This could take a significant amount of time. Please search and read more past forum threads - all this is explained many times. updated to SVN 186 caveden, please reconsider. Regardless of what the generator is requiring for confirming the (spam) transaction, all other participants will pay with their disk space. This is a collective cost that any single participant can easily (and free) induce at the moment. There is only one condition at the moment for a spammer to be able to flood the network - available balance. He could easily generate new addresses and make as many transactions to himself as he wish, not loosing balance in the process.For me there is only one obvious solution to this... to introduce 0.01 (or other amount, could be discussed) mandatory transaction fee. This will effectively reduce spammer's balance with time, making him unable to spam further.This is exactly the same phenomenon that allows other kinds of spam - lack of 'price' for some action. Even a small such price solves the problem.Someone would grieve about 'free' bitcoin transactions. I would argue that small mandatory transaction fee would be far cheaper than the millions of spam transactions we are facing to deal with in the future. I am really worried about this. It's highly possible that the problem is in my getwork patch, now used by many.I would really appreciate someone taking a look at the patch, specifically the CheckWork() and PrepareWork() functions in main.cppYes, it is reusing a key from the pool, but if block is found the key is never used again. Both functions should be thread safe.Theymos, are there other such generations? Just updated to SVN 181 and fixed getwork patch to wait 60 seconds between rebuilding the block with new transactions. This is actually the behavior of the original client, was forgotten in the patch by mistake.  Fixes heavy CPU usage on every getwork request (this became obvious with recent heavy transaction spam). Please upgrade. See first post for updated (SVN 179, 0.3.15) win32 getwork patched client Difficulty adjustment will take place in less than 300 blocks.
I definitely agree. Push-based work distribution is the way to go. I just wanted to make as few changes as possible using existing RPC server. My hope was that BTC developers will evaluate the idea and make something better to get in the mainline. Perhaps we should just implement this 8334 push patch and propose it for inclusion?Also, it's OK to have CPU generation in mainline. Just let the user decide how much resources he is willing to give. Something like how many lottery tickets he is willing to buy. Its not for the masses obviously.  Edit btc_miner.clInsert at the top#pragma OPENCL EXTENSION cl_amd_media_ops : enablechange#define rot(x, y) rotate(x, (uint)y)to#define rot(x, y) amd_bitalign(x, x, (uint)(32-y))See Stream SDK OpenCL Programming Guide for details.I'll try to add some macro to resolve this by default. If some commodity (bitcoin for example) has changed it's price significantly against some well established currency ($) shouldn't its trading volume decline? Because volume of 50 000 BTC at 0.06$ and 0.2$ represents proportionally different volume in $. It will stay the same only if the actual volume of the economy is larger.Perhaps BTC exchangers should provide volume data in their other currencies? This will provide more realistic view in my opinion. Just fixed problem with getwork (different miners were showing same results). Updated to SVN 173. See for windows build in first post. Sorry guys, I screwed it with the update to SVN 170. There is a bug in getwork patch that makes poclbm useless with more than a single instance. Until this is fixed anyone using more than one instance should use previous version of the patch (against SVN 166). Win32 binary bitcoin-getwork-svn166-win32.7z Well, this is not good. I will take a look to figure it out. The block won't show up. This happens when the network discovered block just after last request for work by the miner. This is the drawback of the pull manner in which getwork... works. The probability for this to happen is 1/60 with ask rate of 10 seconds and 1/120 with ask rate of 5 seconds. It will be better if work is provided in 'push' manner, but I didn't want to complicate the client with separate server thread. From now on I'll post latest versions only in the initial post of this thread. The miner should display 'bitcoin is downloading blocks...' until all blocks are downloaded. Please test. This was added in the SVN 163 patched client.David, I removed usage of vectors. So the '-w 128' is not relevant anymore. Of course you can grab the vectors version from git and use it like before. It is really difficult to optimize for all possible devices. Current version is kind of best for all. bitcoin-getwork-svn170-win32.7zpoclbm_win32_exe.7z Wrong kernel was packed in the py2exe version, now fixed. Removed AMD OpenCL.dll to prevent conflicts.I also reverted back to scalars. With vectors it was faster, but required hardware specific tweaks and was making it slower for others. Unfortunately OpenCL is not mature enough to provide means of automatic performance optimization. Thanks Jef! There is new version that should work on Nvidia now. I also changed default getwork request rate to 5 seconds to reduce the risk of solving stale block. The patch itself has now one more check to not show 'proof of work found' in this case.Can someone with Nvidia please test this, it should resolve the 'code selection failed to select' issue. Jef, at least it's now clear the problem is in the bytereverse(x) macro. Please try to replace it with:uint bytereverse(const uint x){   uint result;   uchar* b = (uchar *)&x;   uchar* l = (uchar *)&result;   l[0] = b[3];   l[1] = b[2];   l[2] = b[1];   l[3] = b[0];   return result;} jef.blanc, try to replace the rotate() function with some native rotate left. rotate() is compiled to bit_align AMD specific instruction on AMD. Also there are problems with casts... I switched to uint2 vectors and all operations with mixed types (vector, scalar) work fine on AMD, but Nvidia compilator has problems. The IDs stay the same as long as there are no changes in hardware (new cards for example).The -w parameter sets the number of 'work group size' (local threads). Unfortunately it's very difficult to determine the optimal value for this because it's different on different hardware platforms. The default is to use maximum reported by OpenCL for the specific hardware. This also was the behavior of previous versions. Last days I tried an optimization which tests two hashes in kernel run and it is 1-2% slower with default local threads (5770 - 256), but 5-6% faster with half of them (128) and global threads little bit more (-f 35). Generally, with default parameters one should achieve about the same or slightly worse performance than before. bethel, what are 5870s showing at stock frequency (850 MHz)? Perhaps one of the cards throttles down?Latest version has new parameter, -w, to set work group size. I have best results on 5770 with -w 128 -f 35. Jimbo, please try this and see if the tool shows OpenCL is supported. It would be helpful if you post a screenshot. Try to update your GPU driver. See http://forums.nvidia.com/index.php?showtopic=150585It seems OpenCL is still problematic on Nvidia GPUs. Unfortunately I don't have one to try to make a PyCuda miner. It only tries to keep single kernel run under specific time by changing the number of 'global' threads. If you start a game, kernel execution will get slower. The number of threads will then be gradually adjusted to achieve the desired execution time.By default this time is 1/60 of a second. If shorter i.e. 1/120 sec it will leave more time for other GPU tasks.This is adjusted with the '-f' switch. Right after these lines is there something like:ProcessBlock: ACCEPTEDsending: inv (37 bytes)If so (and you are sure this is the block in question) it was announced to the network, but another block got included in the chain instead. Do you have other blocks after that?BTW, if you want poclbm to crunch slower, start it with something like -f 400. Experiment with the number. The miner asks for work at an interval of 10 seconds. If there is a new block from the network in the last such interval your client won't even try to announce your own next block. I am not sure, but I think this is the behavior of the original client too. Please take a look at your debug.log and if possible send me an excerpt from around where this happened. Look for terms like "SetBestChain" and "height=" if you know the block number.Sometimes the client just doesn't show the new transaction right away.
Use '-server'. Sorry, forgot about that. You should install json-rpc. See at http://json-rpc.org/wiki/python-json-rpcL29Ah, unfortunately there isn't Nvidia card here to test with it. I suppose you should try different drivers. It seems the problem is in nvidia OpenCL compiler. This patch is maintained now at http://github.com/m0mchil/bitcoin-getwork Win32 bitcoin with getwork, against SVN 161. Slightly improved kernel (~10%). Fixed a problem with rotate() and Nvidia OpenCL. I won't upload anymore to the forum, please use the repo. Added auto adjustment to keep desktop responsive. Also, doing hash rate calculation at user defined interval. Sorry, just realized i broke it with latest changes, please update. (It won't submit to RPC properly) There is information on wikipedia about the performance of various AMD/ATI and Nvidia chips.4350 is cited at 92 GFLOPS. 5870 has 2720 GFLOPS. tcatm has 3x5870s. Due to it's superior architecture 5870 is capable of more than just the difference in GFLOPS. For example I get 6 Mhash/s on 4350 and 137 Mhash/s on 5770 (ratio of 1/22) even if the ratio of GFLOPS for the relevant cards is 92 to 1360 (1/14). Due to popular demand  bitcoin PyOpenCL miner is available now at http://github.com/m0mchil/poclbmThere are some minor fixes. Be sure to experiment with globalThreads to achieve better performance/dekstop lag ratio. ATI HD3850 has no OpenCL support.4xxx and 5xxx have. davidonpda: you need1. Some OpenCL capable hardware and driver.2. python 2.6.63. PyOpenCL. This could be tricky, follow the official installation instructions.oclbm.py -h or --help for some options, by default looks for bitcoin RPC at 127.0.0.1:8332Hope this helps nelisky: Integrating CUDA/OpenCL seems to have portability issues. Also, my goal is actually to convince satoshi to patch the mainline. The patch must be crystal clear for this to happen.jgarzik: I tested this against vanilla client to be sure blocks are actually accepted. On ATI 4350 it makes ~5800 khash/s.Forgot to mention that original client generation could be used in parallel. Latest minerpoclbm_py2exe_20120920mirrorSources for poclbm are at http://github.com/m0mchil/poclbmGUICreated by Kiv, see http://bitcointalk.org/index.php?topic=3878.0GuidesWindows - http://www.newslobster.com/random/how-to-get-started-using-your-gpu-to-mine-for-bitcoins-on-windowsUbuntu - http://bitcointalk.org/index.php?topic=2636Mac - http://forum.bitcoin.org/index.php?topic=12360Known best settings(please PM better/best settings for your platform)AMD 5xxx and upuse '-v -w 128'Frequently asked questionsQ: Does my video card / driver supports OpenCL?AMD - 4xxx and up. Nvidia - 8xxx and up. On Windows you can use 'GPU Caps Viewer' or similar.Q: I am seeing 'pyopencl.LogicError: clGetPlatformIDs failed', what is this?Q: It says 'ImportError: DLL load failed: The specified module could not be found'?Q: Or 'ImportError: DLL load failed: The specified procedure could not be found'?You don't have proper OpenCL support. The reasons may vary. Be sure to remove any old drivers and SDK from different vendors you may have used. Use web search to see how to make it work for your combination of GPU and OS.Q: When I try to run it with the following parameters: '--host=http://mining.bitcoin.cz:8332' miner errors out with  'nonnumeric port'Remove 'http://', it's intended for browsers (becames '--host=mining.bitcoin.cz'). Use '--port' to specify port (default is 8332 so you don't need to specify it if the pool you use is at same port).Q: Why it uses 100% CPU?You probably selected the CPU as OpenCL device. Or you are using it on Linux with AMD Stream SDK 2.2. Use 2.1 instead.Q: What does 'invalid or stale' means?The block last submitted was either invalid or stale.Q: How a block becomes stale?You submited solution for a block which was just solved by someone else.Q: Why a block is invalid?Don't overclock too much. And switch crossfire off. Or may be I screwed the search again?  It's good if you see more 'accepted's than 'invalid's.When I try to run the miner a new CMD window flashes on my screen too rapidly to read anything, or even see if it says anything.It's console application. You use that ugly black thing called 'Command Prompt' to run it. This is a patch against SVN 159 that allows external RPC clients to ask for unsolved block data and eventually submit back a solution.It opens the way for external bitcoin miners. If non-local RPC is used it also enables multiple-miners-to-client arrangement.EDIT:theymos is expressing some concerns regarding extraNonce hereThere are actually many components of a block that change its hash. Let's assume the block contains only the initial (award) transaction. The hash will change if either:     - transactions merkle hash - if you change txOUT publicKey, txIN difficulty or extraNonce     - block time - 4 bytes that are updated every n seconds in the original client     - block's nonceBitcoin is giving by default each mining thread it's unique extraNonce (to ensure different hash space). However if there are new transactions after at least 60 seconds merkle hash will change. This patch rebuilds merkle hash at each request for work because of the new extraNonce it assigns. If there are new transactions it should rebuild merkle hash anyway so I don't think this is much of a problem. Also, the external miner may change it's block time if needed - it will get back and processed/verified accordingly.I made some tests with difficulty of 1 and generation rate was equal to the expected values. You have downloaded all existing blocks already. At this moment there will be new block roughly every 10 minutes. It will validate all transactions made since last block.With your hash rate of ~750 khash/s it would take on average 40 days YOU to find the next block. However, this is not guaranteed - it's more like a lottery.Take a look at the FAQ. That was what I first thought of too... a likely resolver for the wikipedia issue. He meant 8 thousands of a dollar per BTC (0.008). That was slightly better than average BS (before /.) exchange rate. Is this offer still open? Why not listed in the WIKI or the official trade section (bitcoin.org)? Fastest possible stock build removes any advantage other 'special' builds would have. Which is good because generation will be more uniformly distributed. It's important for the official build to be always the fastest available. It should use any known optimization (including CUDA, OpenCL, ability to work on the Cell proc etc).The one and only effect for now - another difficulty adjustment, still same chance to generate until more users/cores came in. hmmmmm, that's strange... because I am experiencing the problem already fixed in http://bitcoin.svn.sourceforge.net/viewvc/bitcoin?view=revision&revision=102
