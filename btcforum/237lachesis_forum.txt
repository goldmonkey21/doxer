Agreed in principle, although I'm not sure 3 seconds is the right limit. I'd be alright with 5 or 10, easily. I got 1LACheSisXMvs9w2ydkNJxRrygBfvW6nd7! I haven't gotten around to importing it yet - I'm gonna have my computer spend a week on trying to get 1Lachesis[A-Z1-9] first. However, thanks! Sorry to bring this one back from the dead, but I've added secure remote generation to Scallion.I'm now generating vanity .onion addresses for a small fee. See the Scallion as a Service documentation for more details. In particular, 7 and 8 character .onion addresses are free if you send me a dirty limerick featuring Tor in some way.  Contact me through the email in the documentation above or with a PM here. 'I want to link my Bitcointalk name with BTCJam's. Verification code: 1840ccae-68e2-4c8f-92f8-6595ce351ec9' I'd like to announce Scallion, an OpenCL vanity .onion address generator. It gets around 600MH/s on a 6870 (similar on a 5770), allowing it to generate an 8-character prefix in just 15 minutes on average. It's written in C# and runs in both Linux (on Mono) and Windows.Update (23 Nov 2013): I'm now generating vanity .onion addresses for a small fee. See the Scallion as a Service documentation for more details. In particular, 7 and 8 character .onion addresses are free if you send me a dirty limerick featuring Tor in some way.  Contact me through the email given above or with a PM here.I mentioned this in a thread over in off-topic, but that's not really the right spot for a project announcement.Features:1) Blindingly fast - 600MH/s vs. 2MH/s for shallot2) Performs PKCS #1 v2.1 sanity checks via openssl's RSA_check_key function3) FOSS - MIT licence4) Support for 1024, 2048, or 4096 bit keys5) Estimates time required to generate a key (on average)Check out the Github page: http://www.github.com/lachesis/scallionor skip straight to the binaries: https://github.com/downloads/lachesis/scallion/scallion-v0.9.zipIf you have any problems, reply to this thread or open an issue on github.Donations: 1onion1PNeM2x9LhdqWn6uVFyU2iSpy7M I'm not sure if there are any good top to bottom tutorials. We learned it through projects and documentation. In general, we simplify the GPU code as much as possible, both to make it fast and to avoid branches, loops, etc. Pick your favorite language, find OpenCL bindings, and run some Hello World tutorial. Then pick a project that's embarrassingly parallel (hash searches, noise generation, etc) - each result has no dependence on its neighbor. Read the documentation and pay attention to the memory model. There are a lot of hidden gotchas that can dramatically reduce your performance if you miss them. I've just edited the post; here's a donation address: 1E82DM9mxvvfMfVAwpDANbkwXc2uWvQD1. I hope the original authors of this thread show up at some point as well. I've just tested on a 5770 - about 600MH/s. I've posted a reply to the original thread - I wrote a program like this. I'd like to announce Scallion, my OpenCL vanity .onion address generator. It gets around 600MH/s on a 6870, allowing it to generate an 8-character prefix in just 15 minutes on average. It's written in C# and runs in both Linux (on Mono) and Windows.Features:1) Blindingly fast - 600MH/s vs. 2MH/s for shallot2) Performs PKCS #1 v2.1 sanity checks via openssl's RSA_check_key function3) FOSS - MIT licence4) Support for 1024, 2048, or 4096 bit keys5) Estimates time required to generate a key (on average)Check out the Github page: http://www.github.com/lachesis/scallionor skip straight to the binaries: https://github.com/downloads/lachesis/scallion/scallion-v0.9.zipIf you have any problems, reply to this thread or open an issue on github.Donations: 1E82DM9mxvvfMfVAwpDANbkwXc2uWvQD1 My client tried to connect twice. The proxy tried to connect a number of times and received several responses, but forwarded none on to my miner.I wonder if there is an issue here: this server has two IPs on the same subnet. Is there a way to prioritize your proxy to choose one of them exclusively? I'm afraid it's expecting an answer on eth0 but receiving one on eth1 and not properly handling it. I'm getting the response Code:{"error":"No enabled pools responded to the work request.","result":null,"id":1}with Multipool. I just verified -- Multipool is up. In fact, when I make the exact same work request which I made to the proxy (with updated credentials) to multipool.hpc.tw, I get a response in under a second.How can I troubleshoot this? An Arduino isn't needed for this; just boot to a live CD to generate your keys, put the wallet.dat on a brand new, freshly opened (and maybe encrypted) flash drive or SD-card, and generate an address. Reboot into your primary OS and send some coins to that address. Maybe reboot again to test that they were received.Are there any ECDSA smart cards out there? It'd be pretty cool to use a smart card for Bitcoin crypto. Hey Tim,I just read your article. Great piece! It seems that Ars is getting the technical aspects of Bitcoin right, unlike the mainstream media.It's still a little surreal to read about Bitcoin anywhere besides IRC and slashdot. Anyway, keep up the good work!-Lachesis I'd like to suggest some really basic SEO: 1) Modify robots.txt to hide all URLs with "?action=printpage;" in them. These "Print Page" results often come up first in the Google search results, which kinda sucks because their formatting is far worse for screen reading.2) Configure Apache to rewrite all requests to the forum's IP (174.143.149.98) to the official forum URL. These show up in Google results and often trigger SSL errors.Just try searching for "bitcoin dnsseed" on Google to see what I'm talking about. What if we have multiple IP addresses? I have two miners here, one at my friend's house, and one at my parents' house. Will I be able to enter all 3 IP addresses? Nobody's forcing him to do anything. I didn't ask him for coins - he offered. I've found what appears to be a nasty bug, and has made me potentially lose 65 BTC so far:I called "bitcoind getaccountaddress Testing" or something similar. It returned the address "1HT7xU2Ngenf7D4yocz2SAcnNLW7rK8d4E". I then sent 10BTC to this address (showing my friend how the unlock RPC command works).A few minutes later, I called "bitcoind getaccountaddress FromMtGox" to withdraw some BTC from MtGox. It also returned "1HT7xU2Ngenf7D4yocz2SAcnNLW7rK8d4E" although I didn't notice it at the time.In fact, no matter what account I ask for, I get that address. Even worse, I don't seem to have the private key for it. I don't see the recv part of any of the transactions that I just described in my listtransactions output.Code:bitcoind validateaddress 1HT7xU2Ngenf7D4yocz2SAcnNLW7rK8d4E{    "isvalid" : true,    "address" : "1HT7xU2Ngenf7D4yocz2SAcnNLW7rK8d4E",    "ismine" : false}If you check blockexplorer, you'll see that address has clearly received the coins. The 0.01 is from me as well. However, the 3.79 transaction is not from me. What's going on here!? Furthermore, who owns that address and how the hell did my client get it and decide to use it for all my accounts?--Lachesis Hello,I'd like to buy a Feitian FTCOSPK01C (http://www.gooze.eu/feitian-pki-smartcard-ftcos-pk-01c) from Gooze. Unfortunately, under French law, they're not permitted to export these cards from the EU. Since I live in the USA, this means I can't buy it. So, I'll offer enough BTC to cover the cost of purchase, VAT, shipping to your residence, shipping to my residence in the US, and another few Euros worth for your time and hassle.From what I understand, it's perfectly legal for citizens of some other EU countries (Germany) to export this crypto hardware, but IANAL. You accept all legal risk associated with this. Additionally, please ship with insurance. If I do not receive the product, I will not pay you the BTC.It should cost around 13,80 to get the product shipped from Gooze to anywhere in the EU. I don't know how much it costs to get shipped from your country to the US. Please provide me with a quote in your reply.I have a good rating on Gribble (lachesis on IRC as well as here). As such, and owing to the time-delayed nature of this transaction, I'd like to keep my BTC until I actually receive the smart card. We could also use clearcoin or similar if you'd like. You pay any escrow fees. I'm flexible with regards to quote time. That is, I can guarantee the number of Bitcoins that you'll receive when I get the smart-card beforehand if you'd like, or we can wait until I actually get it to determine this amount. Obviously if you expect Bitcoin to go up in value, you want a quote now, but if you expect it to drop, you want one at the end.Thanks,Lachesis-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.11 (GNU/Linux)iF4EAREIAAYFAk3sRPEACgkQM9Zg6f/HQg27GQD+MveYiyCZBsWn1qZHd8PO5YYhEOEQXOhrqh7xWtq7o1IBANADH8+lvCyMBdmYU+Rn5QwHmbguXDqlzhmZ7jNgwiwS=Vb5E-----END PGP SIGNATURE----- Permissions problems, most likely. Yeah, waaay better. I joined when the difficulty was around 20 and I made 2 blocks a day on my CPU.
I agree with caveden: I think fees should be entirely up to the miners.I like the idea of offering a small (฿0.0001) fee for every transaction, but wouldn't that just lead to more dust and wallet fragmentation?Alternatively, we could greatly raise the limits for free transactions, or raise their score if they're old so they can get outside the free transaction space. What are the problems with that approach? Sorry, I don't really have time for that. My hint would be to use a better AMI than the default, like the starcluster gpu one (ami-12b6477b), found here:http://mailman.mit.edu/pipermail/starcluster/2010-December/000572.html.However, I don't think it's worth it. First of all, there are only 2 GPUs as far as I can tell. Didn't see an option for a 4x GPU cluster. Furthermore, you'd need something like 1600 MHPS to justify the $2.10 cost / hour. Just tested this out today. I got about 77MHPS / Tesla core using an OpenCL miner, which is far too low to justify running the box. I didn't test with Puddingpop's CUDA miner, though. My time is correct, and my debug.log shows nothing out of the ordinary. I'm stumped here, guys! Yeah, I'm having similar results. I've been running a self-compiled Linux build on a machine with roughly the same khash and haven't generated a block since mid July. Of course, it was a _broken_ Linux build for a few weeks of that, but I'm running the latest SVN version now and still no luck. I challenge that assumption. I started documenting things like the version message before he released that. His documentation is broader than mine, but mine is more in depth. If you believe that the earliest description of the protocol in plain English somehow magically controls it, then we're safe since I came before him, and Satoshi probably has docs from 0.1.0 or before.Honestly, I don't think Jgarzik's going to go to a court of law over a single page of docs, and even if he did, what would he accomplish? He couldn't stop Bitcoin nor could he co-opt the documentation. There are enough anarchist-type people in the Bitcoin community to be frightened of someone controlling the protocol or documentation or whatever by releasing an HTML table with a rough summary of messages as a copyright landmine of sorts. Let's not press this issue and drive away one of the few community members who is actually contributing code instead of just talking about it. What platform are you on? I have builds for Linux on my site (out of date atm, but I can get a new release up soon).If you're on Windows, then I guess you're out of luck with me. Use Gavin's -port and -rpcport patch.http://bitcointalk.org/index.php?topic=589.0It works great. Some people have apologized:Some people in the community (NewLibertyStandard, I'm looking at you) are continuing to insist that you have no right to copyright your works, which is clearly false. That said, I don't think mizery meant any harm in posting your information on the wiki. You didn't originally specify anything suggesting that you didn't want the document copied. When you did specify that you didn't want your document posted, it was taken down. It is common practice in this forum to copy important or interesting information to our wiki. Thus far, nobody has cared.Let's not overreact: this is a single page of documentation we're talking about. I could reproduce it in a few hours, but I really don't want to if it is eventually going to get released under a permissive license. Let's not alienate one of our best community programmers over a single page of documentation.Please guys, let's not make this a huge deal. Jgarzik, you could defuse this whole situation by releasing your document under a license that's friendly to copying and cooperation. NLS, please don't be a dick about all of this. Again guys, we're trying to build a community, not a conformity. If Jgarzik doesn't want to allow copying of his document, that's 100% his right. At least he has agreed to release all of his code, patches, etc etc with a MIT license, which is the really important part.Jgarzik, NLS, etc: I have great respect for all of you and your contributions to Bitcoin. Please, let's not make this a us vs him thing. That's great news! How did you figure that out, though? I was considering writing a client specially tailored to put itself out there and try to get as many people to connect as possible, then survey their versions and write out a log (in addition to all the normal bitcoin stuff). Thanks for the code.I think documentation should be released under some permissive open-source style license. That way others can correct potential mistakes, add info that you left off, etc etc and publish it back under the same license. Essentially, we should apply the FOSS philosophy to documentation.That said, I agree that you have the right to prevent people from copying your works exactly if you so choose. You really can't stop them from using it to produce a derivative work, though - after all, how would you know they didn't just read the code themselves? That is strange. What does the TxIn look like?It's 2^63/10^8, so it looks like it's INT64_MAX, not UINT64_MAX That's a great changelog. I sent you ฿2 for your trouble.  Jgarzik's been doing a lot of good with his patches. I for one have incorporated his GetBlock and ListTransactions patches into my unofficial builds.That said, I guess we do need to clarify the legal status of everything he's made now. Jgarzik, could you please publish a license or at least go on record with your feelings about copying and/or modifying your works? Do you require attribution?If you don't, a lot of people (myself include) will naively (and possibly incorrectly) assume that you intend all of your code and documentation to be released under a permissive (MIT or BSD-style) license. As to the solution, I've not seen a convincing reason that adjustments are done every 2016 blocks or whatever. Why not every 50 or 10? Yeah, difficulty would vary a lot more often, but how is that bad? Thank you  Size of vectors and strings is stored using a compact size format:Code://// Compact size//  size <  253        -- 1 byte//  size <= USHRT_MAX  -- 3 bytes  (253 + 2 bytes)//  size <= UINT_MAX   -- 5 bytes  (254 + 4 bytes)//  size >  UINT_MAX   -- 9 bytes  (255 + 8 bytes)//The size field proceeds the vector or string of which it is specifying the length.Check out http://code.google.com/p/pybitcoin/wiki/BitcoinProtocol. We haven't gotten as far as you have, but we are making some progress on decoding the protocol. The problem with your analysis is that you assume that all for-profit minters will have the same profit margin. They won't. Among other things, larger minters will have economies of scale in their favour, making them more profitable.In addition, as Bitcoin grows, people will develop dedicated hardware that maximizes the khash/dollar spent. In addition, people will tune the software in more and more precise ways to squeeze slightly more khash/second out of the same hardware. The people who invest a large fixed cost to do that will receive a correspondingly lower variable cost per Bitcoin minted in return, so they'll be able to mint at price levels that would drive others out.Finally, at the point that this becomes an issue, everyone will be including transaction fees with their transactions to incentivize minting. What's new? Do we have an official changelog yet? Can you add the date and time associated with each transaction?
Unfortunately, as simple to implement as it is, in order to be effective it would have to be a breaking change.Older clients won't send the proof of work because they don't know to. So an attacker could just claim that their client version was, say, 308 - too old for the protection. So your node would have to choose between dropping support for older clients and being secure against this sort of attack or continuing to support older clients and being insecure against this.I'm not saying we shouldn't do it, but I think we ought to get a list of important breaking changes together before we make one. Users really don't like being told that they have to upgrade every other day.Also, I don't know how the message relay protocol works. I guess each node could just relay that Tx with the same nonce and hash that the first one gave it. There's no danger of "reusing" a hash since a duplicate transaction is by nature invalid (although it could still harass the nodes).Some detection and blacklisting code would be useful too. If an IP sends you a certain number of invalid transactions within a certain time, disconnect and refuse to accept connections from them for a certain period of time. If they do it again upon reconnecting, block them for longer... etc. Yeah, that would be useful behaviour. I think better key management - the ability to import, export, create, and delete addresses at will - is also in order. The current system only let you create them - you cannot delete them or export them to a file. I've tried to do it before too, but I never considered it a large enough bug to report. It would be nice to see a fix, though. You were right before. The reason all of his coins were lost is that he first transfered all ฿9000 to himself, merging them into a single TxIn. If he had skipped that step and gone straight to sending himself ฿1, he would have only lost the smallest payment that he had previously received that was over ฿1.I think the client needs to communicate TxIns and TxOuts better to the user. I don't know how to do that without being confusing, but there are real privacy, safety, and security implications in which coins the client chooses to transfer. Do you have an updated version of this patch for SVN revision 125? Also, does Bitcoin open the BerkeleyDB as exclusive, precluding the need for a file lock?It does not -- did my own tests. Why are we using uint64 in Version but 32-bit integers in everything else? Yet another argument for cmake or similar. Timestamps are already stored as uint64s. At least, that's how they're transmitted on the network. Nice work mate! Time to PM Satoshi.Sent you ฿5.01 for your troubles. That appears to fix it for me too. EDIT:I've uploaded corrected Linux builds to http://www.alloscomp.com/bitcoin/binaries/release-r123-2010-08-08/. Enjoy! I'm having a similar problem with my own compile of the SVN trunk. I just reverted to the stock builds to test and see what happens. I should try setting up my own network of two nodes with my builds. Why isn't it practical? I agree that a good micropayment system would avoid generating thousands of transactions (e.g. one per packet), but that doesn't mean that bytemaster's change idea is wrong:That seems like a great use case. Furthermore, as llama said, the fixed component of a transaction fee should always represent the real cost of including that transaction in a block. So, are there any more intelligent and less painful ways of implementing anti-dust spam systems? It lists transactions while the getreceivedby* functions return the sum of all transactions to that label or address. There's no reliable way to see individual transactions using the getreceivedby* functions. You should be using Python or Perl or something when writing a high level interface. The CLI code is really just there to let you play with the server. You should try the python-jsonrpc library. What sort of attack is this intended to protect against? If it sees a longer chain but can't process it, it should also fail to validate any of the transactions in that block, right? On a slightly more meta note, here's the protocol for making a transaction:Transaction is built and the hash is taken.My client sends "inv" message to every other host to which it is connected.If the other client doesn't already know about the tx, it responds with a "getdata" message with the same data (and therefore checksum).My client then responds with a "tx" message. I've been decoding the tx message, but I haven't gotten it down yet.These messages are or will be decoded on the wiki here http://code.google.com/p/pybitcoin/wiki/BitcoinProtocol. Support is planned but not yet implemented. I don't think it would be that hard. It includes the version number as the first four bytes (host byte order) of the message. That number is converted to the 0.3.6 notation that you see in the client:Code:init.cpp:191:    printf("Bitcoin version %d.%d.%d%s beta\n", VERSION/10000, (VERSION/100)%100, VERSION%100, pszSubVer);Here's an (ugly) colorized version of the version packet from my machine:http://www.alloscomp.com/bitcoin/messages/version.html I hate to sound rude, but that sounds like the danger with the SCRIPT field in transactions. You're comfortable writing a whole evaluation language letting the blocks suggest operations to the client, but you're not comfortable using a library like protocol buffers?Why not use XML for that case? The size of the wallet file on disk isn't exactly a big concern when it comes to export, and XML compresses pretty well. Plus, it's completely human readable - it would help people to understand what is actually stored. Nice work! I made some small changes.nBestHeight is the number of blocks minus one, which means it's probably the index of the last block the host knows about. That's so the nodes can choose who should ask for blocks after the initial version message exchange. I don't know what the rest of those are, except that nLocalHostNonce is used (at least partially) to make sure the client isn't connecting to itself and nLocalServices appears to always be 1.[/quote]Don't forget "tx", used to insert a transaction.
I'm getting this error:Code:Your credit card payment failed with the error code "The configuration with processor is invalid. Call Merchant Service Provider."I tried two different credit cards. The "0x00" groups each represent one byte. The length of the standard version packet is 87 bytes plus 20 for the header. The header could be massively optimized as well:Code:message start "magic bytes" - 0xF9 0xBE 0xB4 0xD9command - name of command, 0 padded to 12 bytes "version\0\0\0\0\0"size - 4 byte intchecksum (absent for messages without data and version messages) - 4 bytesObviously using proto buffers here, while absolutely a breaking change, would save a fair bit of space, especially because the "I've created a transaction" packet has the name "tx" meaning that there's at least 10 bytes of overhead in every one of those packets. Why is it unreliable? It provides the same information that the GUI provides, and that works fine for watching for payments...We really shouldn't adopt a policy of protecting users from themselves. If we do, there should at least be a "devmode" switch or config line to turn it off. Well, from the software's point of view, each 1.00BTC is actually 100,000,000 units. If you think the block list is big now, imagine how bad it would be if it were tracking 355,300,000,000,000 individual units!It's redundant data. It would help clients to verify transactions without having to (worst-case) verify the entire block chain, but it would also take up space in the block list. I agree that it could be smaller; not necessarily because of clever encoding, but because it would allow us to drop reserved bytes and the like.That would be the hard part, of course. If you want to test with the version packet (not really ideal, since it's only sent once per connection), I've decoded that fully:http://bitcointalk.org/index.php?topic=231.msg6250#msg6250 It would be useful if somebody else had commit access to the SVN and there was an explicit plan in place to continue in Satoshi's absence. Perhaps. In that case, you should switch the order of includegenerated and count. Perhaps even make includegenerated true? Generations are included by default in the UI, after all. Could you make count=0 return all transactions? Very nice! Send Satoshi an email and ask him to add it to trunk.By the way, anyone having trouble applying this on unix can use:Code:curl http://pastebin.ca/raw/1911295 | awk 'sub("$", "\r")' | patchThat'll make the line endings on the removed parts match the Windows line endings in the code files. Sure. I sent you a PM. Anyone who wants to be part of the project just drop me a PM with your Google Account / Gmail email address.  Do you have a project page?  CDecker and I are working on reimplementing Bitcoin in Python. I'm not sure 100% what will come of this, but I plan to at least fully document the network protocol on our Google Code page:http://code.google.com/p/pybitcoin/ Just another reason to get working on over-the-wire encryption. I'll answer the ones I canThis is 2 weeks * 10 minutes / block.I think daily adjustments would be / have been better. Two weeks seems a bit arbitrary to me, and I see no disadvantages to making it happen more often. There isn't a low latency attack, since difficulty adjustments are tied to blocks and you can't successfully generate coins without the newest block.I understand the trade off here; we're balancing speed of transaction confirmation with bandwidth usage and the risk of low latency advantage. If blocks were generated every 10 seconds, then people with a faster internet connection would have an advantage, which is against Satoshi's goal. However, if they were generated every hour, it would take at least an hour to confirm a transaction.Addr = RIPEMD160( SHA256( public_key ) )This makes addresses 160 bits long (shorter = better for usability) but also ensures that the input to the RIPEMD160 is an unpatterned 256-bit number (assuming there are no flaws in SHA256).I dunno - that's a good idea. I think there's a real advantage to being able to trade the keys independently of the Bitcoin network. On Debian testing 32-bit, I get a few build errors, all resembling:Code:script.cpp:114: error: OP_NOP1 was not declared in this scopeI got these when attempting to "make bitcoind" without "make clean" or "make" first. It looks like the bitcoind build instructions don't compile the headers first, but they also don't delete the headers.h.gch, so the old headers are used if present.If anyone else gets this error, the simplest solution is to "make clean" and retry the build. That already exists. bitcoin -datadir=/path/to/files Alright. I'll mail Satoshi my patch - maybe he'll accept it into the mainline. I already wrote a patch like that. There's a link at:http://www.alloscomp.com/bitcoin/ I too am a bit skeptical of the power of the spec in the merchant market, but I think it would be great for exchanges, which need to get scraped often.The white/blacklisting stuff could be better handled by FOAF and the like. So andyc, any comment on this? As the bcspec.org maintainer, it would be nice to hear your ideas.
--EDIT--Here's my (sloppy) Python script to read and parse the initial version message. Run it with no arguments to connect to localhost or one argument to connect to the computer at that IP / hostname.http://www.alloscomp.com/bitcoin/version.pysI also decided to host the code on GitHub and create a Google Code page. I'll be happy to give commit access / read-write privs to the Google Code page to anyone who's interested.http://code.google.com/p/pybitcoin/andhttp://github.com/lachesis/pybitcoinSample output:Code:"version" 87b (checksum: 0)Version: 304nLocalServices: 1nTime: 1280347633addrYou: 127.0.0.1:57461 (nServices: 1)addrMe: 65.27.194.186:8333 (nServices: 1)nLocalHostNonce: 2584997320055052487vSubStr: ".0"nBestHeight: 708520x30 0x01 0x00 0x00 0x01 0x00 0x00 0x000x00 0x00 0x00 0x00 0xF1 0x8D 0x50 0x4C0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0xFF 0xFF0x7F 0x00 0x00 0x01 0xE0 0x75 0x01 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000xFF 0xFF 0x41 0x1B 0xC2 0xBA 0x20 0x8D0xC7 0xD8 0x37 0xDF 0x5D 0xC1 0xDF 0x230x02 0x2E 0x30 0xC4 0x14 0x01 0x00--/EDIT--Pretty close.Absent for version messages. I think it will be included for every message _after_ version though.This is in host byte order afaict: Code:0x7E 0x81 0x50 0x4C  0x00 0x00 0x00 0x00I'm getting some weird stuff here: my string is 3 bytes long and starts with 0x02:"0x02 0x2E 0x30" ("\02.0"). It's also not 0x00 terminated. On an older client with no subversion string, it's just one 0x00.Oh nevermind: it's one byte of length followed by the string.So 0x02: ".0". On the older client, the string's length is 0. That's much better than I anticipated. Everything else in your summary looks good!Finally, it looks like checksum is only calculated when message size > 0. That's wise. Checksum also doesn't appear to be sent for "version" messages even when one client knows the other is new enough to accept the checksum.Upon connecting to one another, both clients send a "version" message. With that complete, they both send "verack" upon receiving the other's version message. Then one sends an "inv" message that appears to contain a list of transactions IDs that node knows about. The other node then queues the transactions it doesn't know about to "mapAskFor" and executes a getdata request (or several - it cuts them when their size > 1000) for those transactions. By the same logic, C is faster than Python. However, I've run across a few Python programs that were orders of magnitude faster than similar C programs. How? The C programs were sloppy and Python's standard library functions are increasingly well-optimized.As an example, the CAddress serialization in Bitcoin, passed around in at least the addr message and version message, is 26 bytes. That's 8 bytes for the nServices field (uint64, and always 1 on my system), 12 bytes marked "reserved", and the standard 6 bytes: 4 bytes for IP, 2 bytes for port number. While I agree that including the ability to support IPv6 and other services (or whatever nServices is for) in the future is a great idea, I also think it's a bit wasteful to use 26 bytes for what can currently be encoded as 6 bytes. With protocol buffers, this would be smaller now but retain the ability to extend in the future.I agree that encryption and compression are a bit harder to take into account, but at the very least they could be layered on top of the protocol buffers. Build the byte string with something extensible, then encrypt/compress it and wrap it in a tiny header that says that you did that. You lose 2 or 4 bytes for the trouble, but you gain the ability to change the format down the road. Either that, or encrypt only certain protocol buffer fields and put the serialization on top of the encryption. From my research, the header is _not_ considered in the size. It cannot be considered in the checksum, since the checksum would have to be known to calculate the checksum.Here's the relevant code. Some comments added. I don't know what exactly the Hash() function does yet.Code:        // Set the size        unsigned int nSize = vSend.size() - nMessageStart; // vSend is the message buffer, of type CDataStream (look in serialize.h)        // essentially, this says "size of whole message" - "starting position of data chunk"        // therefore, nMessageStart = size_of(header).        memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nMessageSize), &nSize, sizeof(nSize)); // writes nSize into the right spot in the message.        // Set the checksum        if (vSend.GetVersion() >= 209)        {            uint256 hash = Hash(vSend.begin() + nMessageStart, vSend.end()); // Take a hash of the message data            unsigned int nChecksum = 0;            memcpy(&nChecksum, &hash, sizeof(nChecksum));            assert(nMessageStart - nHeaderStart >= offsetof(CMessageHeader, nChecksum) + sizeof(nChecksum));            memcpy((char*)&vSend[nHeaderStart] + offsetof(CMessageHeader, nChecksum), &nChecksum, sizeof(nChecksum)); // Put that hash in the right spot.        }It's from net.h:703-716.The problem I'm having is parsing the version command's data. Version _should_ be made of these things serialized, as per net.h:580:Code:PushMessage("version", VERSION, nLocalServices, nTime, addrYou, addrMe,                    nLocalHostNonce, string(pszSubVer), nBestHeight);However, VERSION = 304 according to my client, and here's the hex dump of the data I'm getting:Code:eswanson@eswanson-laptop:~$ python read.py "version" 87b (checksum: 304)0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x000x9F 0x92 0x4F 0x4C 0x00 0x00 0x00 0x000x01 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0xFF 0xFF 0x7F 0x00 0x00 0x010xB5 0x2C 0x01 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0x00 0x00 0x00 0x000x00 0x00 0x00 0x00 0xFF 0xFF 0x41 0x1B0xC2 0xBA 0x20 0x8D 0xDF 0x51 0xFA 0x2A0x26 0x52 0x6C 0x67 0x02 0x2E 0x30 0x440x14 0x01 0x00You know, I just realized: the checksum is 304... So my header parsing code must be doing something wrong. The header _is_ supposed to be 24 bytes, right?--EDIT--Alright, I've been playing with the "version" message the client sends automatically when you connect to it. First of all, as much as I respect Satoshi, I really don't like this format. Something like protocol buffers would have been much neater and more efficient.Secondly, I suspect that this message doesn't have a checksum because it can't be sure if the client it is talking to has a version > 209 until it gets a verack or version message. I'll play with that next, but I think the checksum is omitted initially to deal with older clients.Here's my analysis of the components of the data section of this message:Code:VERSION - int (4b)nLocalServices - uint64 (8b)nTime - uint64 (8b)addrYou - struct (26b) - more belowaddrMe - struct (26b) - more belownLocalHostNonce - uint64 (8b)pszSubVer - variable length stringnBestHeight - int (4b)Now for the address struct, here's the IMPLEMENT_SERIALIZE block:Code:IMPLEMENT_SERIALIZE    (        if (nType & SER_DISK)        {            READWRITE(nVersion);            READWRITE(nTime);        }        READWRITE(nServices);        READWRITE(FLATDATA(pchReserved)); // for IPv6        READWRITE(ip);        READWRITE(port);    )from net.h:222-233.From what I can tell, this indicates that the over the wire format is:Code:nServices - uint64 (8b)pchReserved - (12b)ip - uint (4b)port - unsigned short (2b)Interestingly, the IP and Port are in Big-Endian / Network Byte Order, while everything in the main struct is in Little-Endian / Host Byte Order According to main.cpp:1761 (svn r113):Code:    // Message format    //  (4) message start    //  (12) command    //  (4) size    //  (4) checksum    //  (x) data How else would you encode a list inside a dictionary?-- EDIT --I suppose I could remove the { pair: {"buy": "BTC", "sell": "USD"}... } nesting and just make tags in each pair's dictionary:Code:{"version": 7,..."pairs": [ { "buy": "BTC", "sell": "USD", "ask": 0.005, "bid": 0.004, "last": 0.0045, ... }, ... ]}That might actually be better than how I had it. Anybody have an opinion? I would combine pairs and quotes into one reference. My ideal syntax would be something likeCode:{  "updateTime":1280200412,   "specVersion": 6,   "marketOpen": true,  "pairs": [     { "pair": {"buy":"BTC", "sell":"USD"}, "lastTradeTime":1280200411, "bid": 0.050, "ask": 0.055, "last": 0.052, "vol": 1000 },    { "pair": {"buy":"BTC", "sell":"EUR"}, "lastTradeTime":1280200200, "bid": 0.025, "ask": 0.027, "last": 0.026, "vol": 0 }  ]}This format is evolving. I'd be glad to take suggestions on what the field names ought to be. I could see replacing "sell" with "with" or something. That makes sense in English: buy BTC with EUR. Also, it might be better to replace Unix timestamps with one of the RFC 3339 timestamps:Code:1985-04-12T23:20:50.52ZTo make things simple, they should probably always be given as UTC timestamps; this is more restrictive than RFC 3339, which allowsCode:1996-12-19T16:39:57-08:00to indicate a timezone of UTC-8 (Pacific Standard Time).strptime(), a function of at least PHP, Python, and C (and probably everything else), can easily parse this date back into a unixtime, and it's much more readable than "1280200412".We should also define volume: I've always interpreted it as the sum of the values of the trades that completed within the last hourlast 24 hours. Thanks klba. Those would almost certainly be Satoshi's, and chances are they're all been "tainted". Awesome! That's really great news. I thought wxbase was to integrated with the software for this, but I'm glad I was wrong. Can you release the source for these builds, please? I would very much like to look over the changes that you made. This belongs outside the main client. There's no reason you can't write a trivial system in Python or something, but there's also no reason to clutter up my Bitcoin client with that.I wonder if there's any viable way to make a simple extension system for Bitcoin? It seems like it would be a lot of work... I don't see any mathematical justification for that. I'd love to see the outcome of a program that does rolls like you're discussing.What's the difference between one person rolling 10 dice (simultaneously, not sequentially) and ten people rolling one die? That's essentially what you're discussing. Ah alright. In that case, your username was actually "anything; does not have to be a 'real' user". That's why using the Bitcoin command line client worked - it used the full field for a username. I updated the wiki to remove the "; does not have to be a 'real' user" comment. Wow, that's awesome. That seems a lot like what the SCRIPT part of transactions was designed to address, but this seems like a better way... First of all, does "bitcoind getinfo" work?Second, try to grab the attempt that jsonrpcclient.php makes with netcat (might have to install it first):1) Stop bitcoind2) netcat -l 83323) Run your client code with a modified (insecure) username and password4) Ctrl-C netcat and post the output That was me; I'm using the library at http://jsonrpcphp.org/ (download at http://jsonrpcphp.org/download.php?file=tgz&package=light), and I can confirm that this works:Code:<?phprequire_once 'jsonRPCClient.php';$bitcoin = new jsonRPCClient('http://username:password@localhost:8332/');echo $bitcoin->getblockcount();?>Thanks to gavinandresen and satoshi for fixing that bug so fast. Marketmaker, I didn't mean to come across as hostile or unhappy. I wouldn't be surprised if there is some flaw - like I said, stats isn't my thing. I agree that some people don't realize that you're never "making progress" towards success - each roll of the dice has the same probability as the one before it.NewLibertyStandard, khps should be fully accounted for by my math. The per-hash probability is very simple (p=target/2^256). Across a small enough timespan (1 second), the probability is linear (the principle of local linearity):p = (hashes / second) * (p of winning with one hash)p = (khps*1000) * (target/2^256)Across a longer timespan, the Poisson distribution comes into play, giving us that exponential term. The "Average" time on the calculator treats the problem like it's a linear distribution, so it will never be as accurate as the 50% and 95% numbers.Basically, if you _don't_ generate at least one block in the 95% timespan, then you're very, very unlucky. The chances of generating a block in the 50% timespan are the same as flipping a coin and getting heads - even odds. Digest auth is a fair bit harder to implement on both the client and the server side. It _should_ be using SSL and client certificates, but that's just a major PITA. Either that, or unix sockets. Thank you sir.  The PHP library I'm using definitely supports HTTP Basic authentication. You just have to craft the URL right:http://username:password@localhost:8332/ I found what appears to be a bug: with a long enough username and password combination, the base64 encoder in bitcoind produces authorization headers that look like this:Code:POST / HTTP/1.1User-Agent: json-rpc/1.0Host: 127.0.0.1Content-Type: application/jsonContent-Length: 40Accept: application/jsonAuthorization: Basic YWJiYWJiYWFiYmE6aGVsbG93b3JsZGhlbGxvd29ybGRoZWxsb3dvcmxkaGVsbG93b3JsZGhlbGxvd29ybGRoZWxsb3dvcmxkIt inserts a newline every 64 characters, which obviously breaks the Authorization header, so commands like "bitcoin getinfo" fail. The server still works fine with properly behaving clients.This can be solved by removing the newlines (and maybe '\r's) from result at the end of the Base64Encode function:Code:result.erase(std::remove(result.begin(), result.end(), '\n'), result.end());result.erase(std::remove(result.begin(), result.end(), '\r'), result.end());There's probably a more elegant solution, but that works for me. Here's a patch:http://www.alloscomp.com/bitcoin/patches/bitcoin-svn-109-rpcbug-2010-07-25.patch
I wrote that calculator.My understanding was always that (based on those numbers) in any 27 day period, you have a 95% chance of generating one or more blocks. In any 6 day period, you have a 50% chance of generating one or more blocks. I might have screwed up the math somewhere - I don't know stats that well. The formulae came from a friend of mine who read the design paper. Apparently it has some code for calculating block generation.P(p,t)=1-e^(-pt)Where p is the probability that you will win in one second: p=khps*1000*target/2^256, and t is the number of seconds.So I solved for t:t = -ln(1-P)/pIf anyone has a better understanding of the math and sees a mistake, let me know! Great analysis. You should do these weekly!  Congrats! I ran with libeatmydata for the initial download I had to do after I accidentally wiped my blk*.dat and it helped a bit, but this sounds even better! Gavin, no. I know my way around urllib2 so that's not a problem. I would like to see the option to disable password authentication in the bitcoin.conf. We really shouldn't be protecting (advanced) users from themselves.I was just annoyed that to even start -server (albeit on my test client), I had to edit the config file and insert a password. I can always hack my version of Bitcoin to not require a password by default if that's what I want, but I don't like the fact that bitcoin completely fails to start when I put in "rpcpassword=" with -server. I think the right way to do it would be to warn users (perhaps with a popup box if the GUI is starting) but still start the other stuff, even if the RPC server won't start.Running with a password only marginally improves the security for a lot of applications anyway, since that password will have to sit in an httpd-readable file for my web server to execute JSON-RPC commands. The only user that's ever been hacked on my server? httpd. It is an important step for machines with multiple users, though, as is allowing the port number to be changed. Yeah the 1.0 spec is a bit strange. JSON-RPC 2.0 pins it down quite nicely: a list of requests begets a list of responses. Afaik, none of the JSON-RPC client libraries handle the error code. They all just look at the "error" field of the JSON-RPC response. At the very least, I would return 200 if ANY of the requests succeed. The password definitely shouldn't be required. Also, the new code chokes on "rpcpassword=". If there's no config file, the config file doesn't contain an rpcpassword line, or it contains "rpcpassword=", the password should be disabled. Generation never "stops" - the number of coins generated gets halved every 210,240 blocks (4 years). It will take somewhere around 17.5 years from block 0 to generate 20 million coins. The next 1.024 million will never be completely generated. Generation won't "stop" until the number of coins generated per block is less than 10^-8 (minimum precision of Bitcoin). That will happen somewhere around block 6.76*10^6, or roughly 130years in the future.Bitcoin has a Merkle Tree implementation that allows old block transactions to be purged or something like that. Read the design paper, it's all a little above my head.Besides, in 10 years our phones will all have a terabyte of storage and our desktops will have god knows how much. -1 for now.I think keeping the vanilla client as plain as possible is a good thing. These things can easily be implemented in other clients, but the one on this site should serve as a sort of "reference". We should also focus on the JSON-RPC API so that other clients can interface with this one instead of having to modify it. Here's my response to his blog post:This is an attack in that you can play with the block generation rate, but the most you can influence it is 4x per 2016 blocks. If you bring 3x the network power in, you can make the difficulty go up 4x in roughly 4 days. You could then leave, forcing the block generation rate back down from a block every 2.5 minutes (at the height of your noding) to a block every 40 minutes. You would also get ~ 75,600 BTC in the process. If, however, you wanted to raise the difficulty *another* 4x, you would need to bring in another 3x the *current* network power, so you would account for 15/16 of the network. This would obviously cost more, and would net you the same reward in both increased difficulty (so called denial of service) and in bitcoins. The "solution" to this, in my opinion, is to shorten the difficulty adjust time from ~2000 blocks to ~100 blocks, but even if this attack isn't solved, there's nothing wrong with you controlling a large part of the network as long as your nodes are honest.What do you mean by this? All you can do is sell your bitcoins for a very low price, giving whoever was around to buy them a decent chunk of coins and netting you less than ideal profit. This wouldn't cause bitcoin to "fail" - it would just lower the market price. The price would recover eventually. You'd be better off selling the coins at some value that made you profit considering all the computer time you spent to get them.Nenolod, don't spend your time worrying about those attacks. Anyone who has more than 1/2 of the network's computer power can execute the much more dangerous "double spending" attack, which has the potential to damage Bitcoin's reputation as well as get a lot of coins stolen.I cross-posted this there too.In addition, if Nenolod had stopped generating when the difficulty spiked so much, wouldn't we expect to see the rate of generation drop below one block every ten minutes? On the contrary: we're currently doing better around 9/10 blocks per hour, or a block roughly every six minutes. (http://nullvoid.org/bitcoin/statistix.php) The difficulty is based on the *minimum* target, and this target is generated rather inexactly as 00000000ffff000000000000000... (eight 0s, four Fs, 0 to taste ) The really interesting idea of a PayPal for Bitcoin (call it Bitpal) would be if a company were to come in and provide fraud insurance like PayPal currently does (hopefully less skewed towards the buyer). That way buyers could transact without trusting the seller. Bitpal would know both parties (somehow verify ID) and then offer to punish the seller and refund the buyer's money if the seller didn't deliver.Bitcoin's strength is that it enables anonymous, irreversible transactions upon which it is possible to build other transaction types, including the more buyer-friendly reversible ones.Bitpal could force the seller to keep coins on deposit for a certain amount of time, relaxing this requirement as they reached a higher and higher reputation. They would cover any losses above the amount they could recover from the seller. Sellers would gain rep for successful transactions and lose it for unsuccessful ones.They would need a good system to ensure that neither the buyer nor the seller was lying about the transaction. Tracking numbers only help so much - the goods could have arrived damaged, and not all shipping services provide them. I've also envisioned a system where the seller ships items to a trusted party who checks them, sends pictures and description to both the buyer and the seller, and asks both parties if they wish to proceed. If so, they ship them to the buyer with a tracking number and optional insurance. If they arrive damaged and the buyer chose not to get insurance, they don't get their money back. If they chose to get insurance, then that claim is filed. It would double the cost and time of shipping, but would allow everyone involved to verify that the item shipped was correct and not a small pile of stones.  -1Sorry, but splash screens are fairly annoying. My software starts fast and I don't want to see a flicker of a splash screen, or worse, wait for it to show itself and delay my programs' startup. Alright, I know it hasn't been more than an hour since I last posted about this, but I decided to solve this problem myself.If there's a better solution out there, I'd be glad to hear it, but here's my version 0.1 attempt to make this work:http://www.alloscomp.com/bitcoin/btcjsonrpc.pysLet me know if you like it, hate it, or see any obvious flaws with it. There's some getting started docs in the source, but here's the code of the test suite:Code:    from btcjsonrpc import Service    s = Service()    print 'preparing getbalance; id:',s.getbalance() # Each call returns its ID so you can find it later in the results    print 'preparing getdifficulty; id:',s.getdifficulty()     print 'preparing listreceivedbyaddress; id:',s.listreceivedbyaddress(10000) # Call with a parameter    print 'preparing getbalance; id:',s.getbalance(id='getbalance 2') # You can also specify your own ID    print '\nexecuting call\n\nresults:'    results = s() # Get the results by calling the Service object    for id,value in results.iteritems():        print id,value    # If you'd prefer to work directly with the JSON responses instead of a dict of IDs, then access the list Service.responses.    print '\njson responses'    print s.responsesAnd here's the output, including the docstr:Code:$ ./btcjsonrpc.py  Socket-based, Bitcoin-compatible JSON-RPC v1.0 client. By: Eric Swanson (http://www.alloscomp.com/bitcoin) Version 0.1, July 21, 2010Don't use this for one-off request->response pairs. Use something like the reference python-jsonrpc library, or urllib2 + json. This client is hackish, but it works for me (and has sped up my JSON-RPC accesses tremendously).For details of WHY exactly I felt the need to redo python-jsonrpc using a raw socket, check out the follow forum post: http://bitcointalk.org/index.php?topic=528.0Usage is fairly straightforward, and a code sample can be found below the library code (in the if __name__=='__main__' clause). preparing getbalance; id: jss-1preparing getdifficulty; id: jss-2preparing listreceivedbyaddress; id: jss-3preparing getbalance; id: getbalance 2executing callresults:jss-2 181.543289364jss-3 []getbalance 2 2345.94jss-1 2345.94json responses[{u'id': u'jss-2', u'result': 181.54328936405051, u'error': None}, {u'id': u'jss-3', u'result': [], u'error': None}, {u'id': u'getbalance 2', u'result': 2345.9400000000001, u'error': None}, {u'id': u'jss-1', u'result': 2345.9400000000001, u'error': None}] I noticed from a hint that Satoshi dropped in the JSON-RPC password thread about so-called "Multiple Invocation" support in Bitcoin's JSON-RPC.As I run a site that polls bitcoind for payments to a large number of addresses twice a minute, I was intrigued. First of all, this isn't JSON-RPC 2.0's "Batch" support, where requests are submitted in an array and responses are received the same way:Code:request = [        {"jsonrpc": "2.0", "method": "sum", "params": [1,2,4], "id": "1"},        {"jsonrpc": "2.0", "method": "subtract", "params": [42,23], "id": "2"},        {"jsonrpc": "2.0", "method": "get_data", "id": "9"}     ]response = [        {"jsonrpc": "2.0", "result": 7, "id": "1"},        {"jsonrpc": "2.0", "result": 19, "id": "2"},        {"jsonrpc": "2.0", "result": ["hello", 5], "id": "9"}    ]Instead, it's something different, and I can't figure out how to parse the responses in Python. Here's a screen capture of a telnet session to the Bitcoin RPC server:Code:$ telnet localhost 8332Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.POST / HTTP/1.1Content-Type: text/plainContent-Length: 97{"params":[],"id":1,"method":"getconnectioncount"}{"params":[],"id":2,"method":"getdifficulty"}HTTP/1.1 200 OKConnection: closeContent-Length: 33Content-Type: application/jsonDate: Sat, 08 Jul 2006 12:04:08 GMTServer: json-rpc/1.0{"result":8,"error":null,"id":1}HTTP/1.1 200 OKConnection: closeContent-Length: 49Content-Type: application/jsonDate: Sat, 08 Jul 2006 12:04:08 GMTServer: json-rpc/1.0{"result":181.5432893640505,"error":null,"id":2}Connection closed by foreign host.As you can see, the server replies with two complete HTTP 200 responses instead of (as I would have expected) one response with the two lines concatenated as I did in the request.I can't figure out how to parse that with anything at all semi-automated in Python. urllib2 and httplib both return after the first response and drop the second one on the floor. Has anyone encountered this problem before? Does anyone know of a Python library that can handle this strange multi-request behaviour? The original reason was fear of DNS spoofing, combined with the belief that thransactions to IP addresses are fundamentally insecure. There's no secure handshaking (and can't be, short of something like SSL, which is pretty heavyweight), so you don't know who your coins are going to. Essentially, the IP system was just created for local testing and sending coins around your local network, not for any larger use. Excellent Gavin. We should start a list of proposed config file options in this thread.I, for one, suggest a noirc (off by default) option and a minimizetotray option, both of which would do the same thing as the command-line switches by the same name. That'll stop the hackery of launching my Bitcoin with -minimizetotray each time. Also, maybe -server and -daemon should get similar options? I think the fixed port solution was just a stopgap. Satoshi will eventually implement switches (or a config file - overdue) to allow you to specify the port. At that point, a cross-platform locking method for the DB would have to be found. If we can't have ฿, then that's my vote. I see no reason why we can't just steal the Baht's symbol - lots of people use the $, and usually without much trouble. We could also consider a more "open" symbol, like £ and . As davidonpda said, we've done business and all turned out well. I'd happily buy from him again! I also bought some (novelty) money from bencoder a while back and everything went well.Finally, I can personally vouch for Llama - I know him in real life; he's a great guy and we've done a variety of business ventures together. He's never tried to cheat me out of anything. It's really too early to tell about Bitcoin Market people, since the deadline for chargebacks is either 30 or 60 days, but here's the (md5 [sha256]) list of people I've sold to who haven't (yet) screwed me over:c3e0a4636987bcc7152e6b8b9127c4fe [ca7dfe020e6ef837858f404b13570e0aa6925b8a4a25bbe5c87aad336aa149a7]55369789466d7e1efaf7ad80e6cfeebe [c65d2ce4ee267a0e8923ec379499518907576c4a55762f978694a427e4e8f0fb]910c5c0b9c5e5ff5bed4aadcdbbcc2e4 [042193a832e31376d3ca93d4a68971183bbf0309e4487aa7f431db679fcb382f]c975ee5caca381c16bddaaf34ff434b5 [811596b0605b339684be3537ffec226d9f7bab36df8e817f1024f762ed7a19ed]Great idea to create this list! We should formalize it in some way and build a web of trust. Or, at the very least, a sticky!  Yeah, that would be really nice. There's also already a proposal for this. Try adding your support there.http://bitcointalk.org/index.php?topic=214.0
Yeah, generation would be challenging / impossible, unless we decreased the generated block rate to something like once an hour, but that brings more problems. The time per block is targeted at 10 minutes to balance transaction speed with latency concerns. I think The MadHatter is right, Mars would have its own Bitcoin network for Mars-Mars transactions.However, Mars-Earth transactions could happen on either network. The Mars client would send his transaction to Earth. Ten minutes later, an Earth node sees that transaction, checks for double spending, decides it's ok, and puts it into a block. Ten minutes after that, the Mars client sees that his transaction was confirmed by at least one block. Earth-Mars transactions would be even simpler. An Earth client broadcasts his transaction to Earth nodes, who check it and include it in their blocks. Eventually one of them wins the race and the transaction gets confirmed. Ten minutes later, the Mars client gets the new block and sees that he has received the money.Transactions on either planet could happen in either Terracoin or Marscoin. It would be silly for people on Mars to conduct local transactions in Earth's Bitcoin (and vice versa), but it would be technically possible.I see no need for dedicated edge nodes or anything similar. Today's Bitcoin could handle this situation (unless I'm missing something big). The simplest Linux config files typically have formats that look something like this:Code:# how often (in minutes) data is saved when all interface are offlineOfflineSaveInterval 30# force data save when interface status changes (1 = enabled, 0 = disabled)SaveOnStatusChange 1# file used for logging if UseLogging is set to 1LogFile "/var/log/vnstat.log"# file used as daemon pid / lock filePidFile "/var/run/vnstat.pid"The standard extension, if there is one, is .conf. Hash (#) is the most common comment character by far. Semicolon ( and C-style comments crop up too.I think a good, human-manipulatable config file that ISN'T part of the wallet would be a big step forward. There are a lot of options that are currently specified on the command line (noirc, for example, or -minimizetotray) which might be better specified in a config file. Nah, it's insanely easy nowadays. Have you seen evilize?http://www.mscs.dal.ca/~selinger/md5collision/ That number is based on the average payment. Specifically, anything over 500 times the size of the average payment will incur a roughly 0.02% fee. Satoshi, why does difficulty adjust so rarely? It would seem to me that it would be better to adjust once every 50 blocks or so. Passing the password in the GET string is wrong, but passing the password without hashing it is perfectly acceptable.As the DB operator, he could easily steal any bitcoins or cash you gave him. There's really nothing to do about that. Cool! How exactly are you analyzing the topography of the chain? There _is_ a getreceivedbyaddress call! I use it .Also, (get/list)receivedbylabel is nice for when you want to get the amount received by every address in each label. Let's say I create one-time use addresses for a store all with the same label. If I want to know how much my entire store has received, I don't have to call getreceivedbyaddress a million times; I just call getreceivedbylabel for the label.I use this for my donations system in my signature. Alright, thanks. That's all I need. Satoshi, you didn't fix the bug; you just ripped out the minimize to tray code. Could you possibly make this optional? I wasn't experiencing the original bug, and I very much like the minimize to tray feature. I think that would be cool, but as always, the decision rests with Satoshi, the project lead. That's not a terrible idea, though. A better low level interface to the generation and transaction spec would be nice. So wait, I have to pay you AND put one of your banners on my site? No thanks.Why not just do a banner exchange in that case? What service do you provide for me that necessitates me paying you? The JSON-API definitely needs some sort of security features. On Linux, you can use iptables to restrict the users who can access it, but that's hardly secure. If I want to access it from my website backend, then whatever user runs my httpd needs to be able to access it, and that's the user most likely to be compromised on my server!Of course, a password wouldn't help that scenario too much, since the password would just be another variable in django's settings.py for an attacker to read, but still, it beats a blank! Very nice Satoshi. What about the slow block download bug? By the time everyone has Bitcoins, the fee will have been removed or adjusted. It's good the spec already addresses this problem. I'd like to see some more in depth access to things like the coin list (so we can choose to spend coins based upon who sent them to us, etc) and the client list. For example, all of my computers at home -connect to my router, which runs (but does not generate) with port 8333 open.I wish there were some way to prioritize network traffic to my own local nodes over remote nodes. Hello all,I've made a patch against svn-r102 that adds three RPC methods:ListGenerated [pendingOnly=false]Returns a list of generated transactiosn. If pendingOnly is true, includes only accepted but not yet matured transactions.Here's an example output:[    {        "value" : 50.00000000000000,        "maturesIn" : 0,        "accepted" : true,        "confirmations" : 8184,        "genTime" : 1275586091    },    {        "value" : 50.00000000000000,        "maturesIn" : 0,        "accepted" : true,        "confirmations" : 7545,        "genTime" : 1275963218    }]I released a similar patch is the past, but this one is finally production-quality.I also added two more functions:gethps and getkhpsThose just return the hash rate and the hash rate / 1000. getkhps was also added as a key in getinfo.Anyway, this patch can be downloaded at:http://www.alloscomp.com/bitcoin/patches/bitcoin-svn-102-rpccalls-2010-07-14.patchIf you're using Linux x86_64, you can try out my binaries at:http://www.alloscomp.com/bitcoin/binaries Could you make it possible to reenable that feature with a startup switch or even compile flag? I like it a lot, and I don't have this issue. For the block download problem, this patch might solve it. I haven't had time to test it yet, but it looks good.http://bitcointalk.org/index.php?topic=354.0
Very nice! So far the policy has been to email Satoshi and post here with patches, but that will have to change in the upcoming months. No problem, Satoshi. Alloscomp.com is my domain.It's nice to see you around! Oh yeah, more registers. That's true, it might matter.I don't know why we don't have an x64 build. Please read the FAQ and the design paper again and come back when you have. 513 is my area code.  The old users have definitely gained by being here earlier to generate coins, but again, Bitcoin is about trading. If you're not going to trade with coins, why do you want them? If you _are_ going to trade, convert some of your USD or EUR into coins, or sell your time or possessions or skills for coins, and get trading! Mazel tov!Don't be hatin' on Ubuntu though. It's a good OS, and it's helping to drive Linux adoption in the home.Try building yourself when you get some free time on the honeymoon! Alternatively, try this build: (x86_64 only, sorry)http://www.alloscomp.com/bitcoin/bitcoin-r102 Here's my version of that same page.http://www.alloscomp.com/bitcoin/blockCount I like both of those ideas a lot! Welcome to the community, andyc. Here's the code. It requires JSONRPC from here: http://json-rpc.org/wiki/python-json-rpcCode:#!/usr/bin/pythonimport jsonrpcBCAddress = "Put Your Master Computer's Bitcoin Address Here"bitcoin = jsonrpc.ServiceProxy('http://localhost:8332')bal = float(bitcoin.getbalance())if bal > 0.01:    print "We have a balance of {0:.2f}BC. Sending...".format(bal)    bitcoin.sendtoaddress(BCAddress,bal)else:    print "No coins here." Me too.  This was a suggestion in my Feature Request thread:http://bitcointalk.org/index.php?topic=282.0;topicseenI agree wholeheartedly. Here's yet another reason it should be done! And there's no real advantage to running the 64-bit version on Linux. It doesn't run any faster really. Asdfman, what program is generating that output? I like it  Yeah, you're right. BerkleyDB doesn't support more than one process accessing a file at once. Yeah, I'll do it too.50 BTC sounds like a fair rate. I'm available any time between about 12pm and 3am EST (UTC-5 (or -4 right now for daylight savings)). I think this would be a great idea, especially if we can get Satoshi onboard. We plan to create a Bitcoin-specific site, but for now that page is hosted (and generated) by eBay. We'll have to wait for Llama to respond, but I don't think we can add Bitcoin payment instructions at the moment. I'll post back when we have the Bitcoin-specific site up.Edit: I bite my tongue. See below. Great idea, Gavin. Thanks for the code; I'll copy that exactly (except for the gavin part ) I think a 0.01 BTC minimum send is fine for now. At the current exchange rate, that's 8/1000 of a penny USD, or 80 millionths of a dollar. Any micropayment smaller than that would not be made one at a time. If, for example, you wanted to charge 0.001BTC for something, you could just charge 0.01 and keep a balance.If bitcoins become much more valuable, we can change this and push out a new version.
This kind of error has only happened to me once, but I'm on a low latency connection at my Uni. Typically it occurs, like Laszlo said, when another node solves the next block and you don't receive it before you transmit your own connection.It could be due to a whole number of things, but a bad internet connection is probably the first thing to look at. Allowing -datadir to be relative is a good idea, though. It should be a relatively simple addition to the code. However, just because you can't generate doesn't mean Bitcoin is useless! Bitcoin is primarily about exchanging coins, not generating them. You can still send Bitcoins when your network is up, and your client will still get coins sent to you even if it happens to be offline when they are sent. When you download the newest blocks from other nodes upon coming back online, your client will get those transactions. That's actually fairly hard to implement. Gavin would have to create a donation address for each client so that he knew _who_ donated them back, since coins don't come with any sort of information about who last had them.Gavin, you COULD look at the previous owner of the coins and remove that address from your blacklist. However, I dunno about the IP data. Damn, yeah I noticed that reading back through this topic. I get burned by that so often! Thanks, I'll edit my post.You can easily automate that task. I made a Python script to do just that. I'll upload the updated version to my site and post back here later tonight. I wondered about that, but I've never noticed any issues on a dual-core 64bit system. I never noticed responsiveness issues. Perhaps I should nice Bitcoin until the fix. I agree that the wallet should be kept encrypted on disk and only copied into RAM unencrypted. +1 Bitcoin has obviously outgrown the initial experiment stage. It's getting robust and has gained at least 400 clients today (according to the counts in #bitcoin on LFnet). As a result, it needs to grow some new features.1) Bundle the first 80% of the blocks with the client download!   It really hammered the network to slowly distribute the blocks, and a lot of people talked about how annoying a problem this was for new users.2) Disconnect from the IRC when the outside port (8333) isn't connectible.   We gain NOTHING by having Bitcoin idle on the IRC channel when nobody can connect to it, and we hit the server harder and annoy privacy-minded people.3) Allow different ports than 8333 and 8332.   Right now, it is trivially easy to block Bitcoin at a network level, and nothing has used fixed ports since BIND. We can do better.4) Allow exporting the wallet for backups.   People might actually backup then!I'm sure there are others, but those are my top four. This is based upon participating in the chat in #bitcoin-dev. The other request was to drop wxWidgets from the daemon, but having read the code, that seems like too much trouble to do now.I'm sorry if this post sounded harsh, but these are some nice (and fairly simple) things to do to make Bitcoin more new user friendly. You do not have to open the port. It really just helps you get better connected to the network. If things are working, you're all good. Check out:http://www.alloscomp.com/bitcoin/calculator.phpSomebody else can chime in on the validity of the formula:( 1/(currentTarget / 2^256) ) / (hashesPerSecond)I got that out of a thread here some time ago.My source code can be found at:http://www.alloscomp.com/bitcoin/calculator.phps Oh I like that idea a lot Laszlo. There's no reason for a non-forwarded client to idle in the IRC. I wrote just such a command. The patch is pretty simple. It adds gethps and getkhps which return the value of the internal hashmeter. It also adds getkhps as a line in getinfo. The patch also adds ListReceived, but that is pretty crappy. It just lists the description line from the UI. I'll eventually get around to making it more JSON-ish if Satoshi doesn't add something similar to mainline.You can get the patch (for r102) at http://www.alloscomp.com/bitcoin. It is unnecessary to protect against an attack in which an attacker buys all Bitcoins and deletes their wallet.Assuming we were all willing to sell, the attacker would just give us large amounts of cash for our Bitcoins. We could then start another Bitcoin block chain and start over from square one (only with a much larger confidence in the market, since it worked once!) and reinvest that money if we wanted.Essentially, no matter what happens there is always the nuclear option of "starting over."There are much more dangerous and likely attacks to be worried about. I'm not sure of the implications or even validity of this, but here's what high school economics tells me:Look at Bitcoins as a good instead of a medium of exchange for a moment. The characteristics are similar enough that I think it will work.The current Bitcoin generation market is perfectly competitive, meaning that it is easy for people to come and go as they choose. If I can't make a profit generating Bitcoins, then I just turn generation off for a while until my calculations indicate that I can make a profit. If people _are_ making a profit, then others will see the market and be attracted. They will download Bitcoin and start generating.Because of this, in a perfectly competitive market no one makes a profit. It's important to realize this means zero ECONOMIC profit, not zero accounting profit. Economic profit includes opportunity cost - i.e. what else could you do with your time?Sooo, the upshot is that the TOTAL value of generated Bitcoins should be equal to the TOTAL amount spent upon generating them. If the Bitcoins are valued less than it costs to generate them, some generators will shut down, decreasing the total amount of money spent on generation. If they're valued more, more generators will come in.That's as far as I know how to go with that starting point. Anybody else want to help out? My trade went great. I paid Davidonpda 1/2 the agreed upon amount and received the flash drive two days later! My experience was completely positive. Thanks! Wobber, sorry, too late  I just completed the trade with davidonpda.Thanks for the offer, though. Hey wobber, I sent you a PM. Still interested?  Alright. Thanks.Would still be a nice feature. I don't mind people connecting to me to bootstrap or something, and I'd probably leave it at 40 rather than 15.
I think you mean fragment, not defragment. Satoshi is strongly against other clients because if two clients on the network don't agree on something, there's no central judge to sort it out. It could create problems for both groups of users.Also, Bitcoin is OSS. Why would we need another implementation?I agree with dwdollar. MadHatter, will you do the opposite and send cash in the mail in exchange for Bitcoins? I'd like to see an option (with an RPC interface as well) to limit the number of connections that a Bitcoin client accepts. My home client is connected to 70 different nodes and my poor wimpy router just can't keep up. It's starting to slow my network down, to the point where I'll need to force Bitcoin to ignore connection requests (with -connect=<a node>) if this keeps up.A connection limiting option would be a great alternative. Or you could use my "completely unsupported, don't blame anyone if it doesn't work" patch to rpc.cpp that adds listgenerated as a method. Pass it false (./bitcoind listgenerated false) to get only the unmatured coins. No argument or true gives a list of all coins. The interface is going to change, since a list of strings isn't really the way RPC is supposed to work!Of course, for that, you need to build from the SVN.The latest version of the patch can always be found at http://www.alloscomp.com/bitcoin. True, and it is your project. 1.3 it is! +1 NLS. Version 1.0 sounds better than 1.3. However, having a signed certificate has no impact on whether or not somebody's server gets hacked. Also, I think you mean non-Western character sets, since almost everything is a Unicode character. I think a good community reputation system is essential to trust Bitcoin. Crypto isn't terribly necessary in building such a system, especially if it's forum-based. Of course, then the forums become a single point of a failure and a huge vulnerability. Jago, do you have all the proper dependencies installed? The problem with Bitcoin Certify is that it seems a lot like what Verisign does, which is to issue certificates for a fee to anyone who submits correct contact information. The only way something like that might work is if there were already a reputation stat on the forums and you were pledging to contact all involved parties and verify the transactions. And people would have to know and trust your practices as well.Basically, it would be a whole lot of work for a fairly measly fee.But I don't want to pay 100BTC for a PGP-signed PNG with my username on it.  What if he's out of the States, though? I thought Paysafe was a UK thing. Wobber, how much would you like for your drive? Hello all,I'm looking to buy a relatively new 4GiB flash drive to use as a root device for a Debian machine that I'm building. Anyone interested? Yeah, 0.3.0 seems to have a performance increase over svn r84 with Laszlo's performance patch. Very nice! There have definitely been some major improvements, including the hashmeter, RPC support, and a command-line daemon. It would be nice if the listtransactions RPC method were finished before the next release, though. Also, some code should be added to the JSON-RPC methods to list out dHashesPerSec.Great work Satoshi! Yeah, r89 works as expected for me. It doesn't seem to have any problems creating or removing icons, but I'm using XFCE, so that might be the difference.In addition, there's a difference between standard behaviour for tray icons in Windows and Linux. In most Linux apps, clicking the tray button while the app's window is open will cause it to close again. I personally like that better than the Windows default, where a single click does nothing once the main window is displayed. Is there any chance that feature might get added to the Linux version? Satoshi, that definitely made it look better for me, but now Bitcoin won't minimize to tray in Ubuntu 10.04. The proper check box is checked, but it just minimizes to my taskbar like always. The US doesn't have the world's largest army. That distinction goes to China, I believe. They also have the largest air force and I think the largest navy.El Estados Unidos de América has the most effective army, though. And we have a lot of very big bombs. You should try one of Laszlo's builds of Bitcoin. They show the number of hashes / second that you're computing. Post that number, and you/we can calculate how often you will find a block (on average, statistical caveats apply as Laszlo suggested). That's not exactly true. At the moment, Bitcoin only binds RPC to the loopback interface, 127.0.0.1. I would assume that this web interface would be the same. However, there SHOULD be a password to prevent trojans from trivially sending your wallet away. Wallet encryption needs to happen, too. I think that hiding the complexity of Bitcoin addresses from the casual user is a good thing. Barring that, it should be possible to embed an observable but unalterable message with address transactions. Is there some reason this is technically infeasible?I think you're misunderstanding the issue. My browser will always be able to go to 127.0.0.1 (barring some strange IE settings or a virus). If I type the address into the URL bar or click a link, it will work fine. However, it isn't possible to use Javascript to complete POST requests between domains (or ports on the same domain).Try clicking this link:http://127.0.0.1/You probably don't see anything (unless you're running a web server on your system), but the browser happily tries to take you there.XMLHTTPRequest is what we were discussing in that other thread.
So it's possible to switch "on the fly" to a new hash function? Wouldn't all the old transactions then be compromised (because they could be trivially recomputed)?SHA-256 has already been weakened by a factor of 16 (according to my friend. I can't find documentation on that, but I trust him). That's 16 out of 2^256, so not a huge deal, but still. Thanks Gavin. Glad to help. A mathematician friend of mine pointed out that there are very few if any hash protocols that have survived for 10 years or more. What would Bitcoin's solution be if SHA256 were to be cracked tomorrow? Gavin, you should set DEBUG = False in your Django settings next time. I hit some kind of exception page and it gave me your secret and the URI of your JSON gateway.I'll send your bitcoins back to you if you'd like.  I'm emailing you. 77 81 96 Are you verifying their information before you issue the certificate? Or are you just signing anything that somebody gives you 100BC for? It would be interesting if we could find some way to make this distributed like the Bitcoin client. I dunno if that's even close to possible, but it would be cool if it were. So basically, you're running Bitcoin on a VPS and using an HTTPS connection from App Engine to signal it what to do? Why not just host the site on your server?  Sure, but Apple would likely not accept it. I think a nice feature would be the ability to keep multiple Bitcoin "accounts" in your wallet.db. Perhaps one account for spending money, one to save for your monthly payments, etc etc. You would then be able to choose what account each receiving address fed into.It would be nice for people like gavinandresen who is running [link=http://freebitcoins.appspot.com/]The Bitcoin Faucet[/link] or casino operators. That way, the casino's "bank" or faucet's "tank" or whatever could be kept separate from other coins in the same wallet. I got 5 then felt bad so sent you 50 back My mistake. I don't see that being a big problem. Perhaps have it reset every week? I doubt you'll be hard-pressed for coins, at least for now.That actually wouldn't help much. It's completely trivial to generate a new address per transaction (with JSON-RPC). If I were coding a botnet, that's how I'd do it. Adding a CAPTCHA might be wise if you notice problems, but for now I doubt you have much to lose by skipping it.Just out of curiosity, how did you build that on the App Engine? Could I possibly see your source? I might set something similar up on my local server. As I understood it, you can't make any sort of outbound request from app engine, though. So how do you send the coins? Code:FATAL: Module xt_owner not found.It's not a big problem at the moment. I'd still like to see authentication and wallet encryption in bitcoin in the future. Also, if I were root, couldn't I justsudo su - <USERNAME>and evade the owner check in iptables? Yeah, using only the IP is somewhat unsecure, but it's better than nothing.I wonder if it's possible to generate coins on app engine... It only gives 5 coins / IP / day. I dunno if it also checks addresses.But it's true, a good captcha wouldn't be a bad idea.  That's true. It is getting to be time for a new release. Maybe Laszlo's performance patch will make it into the svn too? Oh sweet. I didn't know you could do that. Setting the UID to my username will block the packet for everyone but me (and root, obviously), right?Not working for me. It gives the error:Code:iptables: No chain/target/match by that name. I really like that. Do you think it would be good to post when the number of bitcoins left is below 200-300? That way people like me could donate to it to help keep this going. Is there some way this might be recast as a file socket (I suppose Windows would be an issue) or with some sort of security?At the moment, the lowliest user on any of my machines can happily make a completely unauthenticated SendToAddress call and empty my wallet. That's a very pragmatic answer. I like it.However, how would that work with the combined IP / Bitcoin Address URI (URN? URL?) scheme described here?[link]http://bitcointalk.org/index.php?topic=158.msg1322#msg1322[/link]I know it's been nearly a month, sorry. I don't see why these two ideas are mutually exclusive, although I'd assume implementing SSL/TLS is not trivial. We do already link to the OpenSSL library, so I don't know.I personally would prefer a urn scheme to handle a bitcoin address.That would be perfect, although I would prefer to use the hostname on the right side.Of course, I'm the kind of guy who might shop at thenerdsshop.com For grandma, the entire bitcoin concept is pretty confusing at the moment. Even neglecting all the technical details, the UI still shows a huge string of numbers and letters (your receiving address) and best practices currently require you to deal with that every time you give someone your address.Another option is to use something like what OpenID uses: hidden tags on the store's (hopefully SSL) site. Then you could just enter a site's URL as the receiving address. It would hit that site, search for something likeCode:<link rel="bitcoin.address" href="19vcWM6EEbQHVdN2W8NXv9ySgsPjbZ6gU3"><link rel="bitcoin.server" href="12.34.56.78">Or some other form and try to send securely to that.
My VPS, validity.alloscomp.com (resolves to 208.98.52.221), should also be up nearly 24/7. I'm down. How do we make this happen? I like the idea, and I think keeping it simple is an incredibly good idea. I wish you much support in creating such an auction site! Hello Nixoid. I'll answer what I can. Everyone else, feel free to jump in and help, or to correct me if I have something wrong!0) Yes and no. When people speak of a node here, they usually mean a generating node. You can have a wallet without generating coins, but you must have the software installed and running to make and receive transactions. You can, however, move your wallet between computers / accounts as long as you only keep one version of it. Otherwise, Bitcoin might try to spend the same coins twice. Your use case (on a flash drive) would be fine.1) You do need the whole transaction log to validate transactions. At the moment it comes to something like 25MB.2) I'm not sure about this one.3) This one either, sorry.4) At the moment, there is no transaction fee (I think). There is just support for one in the source code. At some point in the future, the transaction fee will be used to replace "mining" bitcoins as an incentive to run a node. Also, a transaction fee might be used to insure that other nodes accept your blocks.5) I'm not sure what sirius's plans are, but I would like to decentralize this very much. I think IRC is one of Bitcoin's Achilles heels at the moment.6) The rate of generation asymptotically approaches zero. About every 4 years, the number of coins created by each new block is halved. In roughly 10-11 years, each new block will generate 6.25 coins for the miner (instead of 50 today). At some point, transaction fees will be implemented to replace generation as the incentive to supply your bandwidth acting as a node. The idea is that the fee will be < 0.5%. I like it, Max. I wonder how much overlap there is between university pot smokers and university bitcoin users, though.   You could use the JSON-RPC API to Bitcoin to create a new sending address for each account and then monitor the transaction list. When you get coins to that address, you increment their balance on your site. What language is your casino written in?Edit: I take it back. Bitcoin's RPC doesn't currently seem to support any way of listing transactions independently (just totals). I'll try to hack something together. Here's a little python program I wrote that checks to see if you have a bitcoin balance and, if so, sends it to a stored address. I use it with a cron job on my headless Bitcoin generating box to keep my main wallet fed with coins.Code:#!/usr/bin/pythonimport subprocess,sysMyBCAddress = 'PUT YOUR BITCOIN ADDRESS HERE'p = subprocess.Popen(['bitcoin','getbalance'],stdout=subprocess.PIPE)out,err = p.communicate()out = out.strip()try:    bal = float(out)except ValueError:    sys.exit(1)if bal > 0.01:    print "We have a balance of {0:.2f}BC. Sending...".format(bal)    p = subprocess.Popen(['bitcoin','sendtoaddress',MyBCAddress,str(bal)],stdout=subprocess.PIPE)    out,err = p.communicate()    print outelse:    print "No coins here." Sirius, I don't think he can redirect them. His ISP blocks port 80, so he never even sees our attempted connections. Another option is an mobile-optimized, https-secured web interface on your local computer. That's already possible with something like LigHTTPd and PHP or Python and JSON-RPC. Not quite as good as running Bitcoin on your phone, but better than vekja.net for trustworthiness. That's it.  I'm particularly interested in the backup part. What would need to be done to allow backups safely from within Bitcoin without shutting it down? Is there some way to flush the wallet and then lock it until the backup is complete? Chances to generate bitcoins shouldn't depend on network connectivity above a certain base level. If you can receive blocks in a timely manner (somewhat low latency and a decently low packet loss), generating should only depend upon CPU speed (and maybe some other internal specs like memory speed).Forwarding ports helps the network since more people can connect to you, but I'm running on a university network so I can't forward any ports and it works fine for me.-connect is a command line option. Right click on your shortcut for Bitcoin, go to properties, and add "-connect=192.168.0.100" (no quotes, and replace the IP with the right one for you) to the end of the path.July 12th: Edited to fix my command line. I like the idea of distributed host caches like Gnutella uses. At the moment, for the majority of people, IRC is a single point of failure. Let's assume that for some reason our Freenode channel was gone. Maybe Freenode got fed up and shut us down. Maybe MenInBlack saw our system, laughed maniacally, and then pressured Freenode to shut us down.When you start your client, it will do nothing. You could drop to a command line and type "-addnode" (or is it -peer? whatever) to connect to a known node, but at that point you'd somehow need to know a node. It probably wouldn't be that hard for one of us, but what about a new user? We could keep a list of peers on the website for them to use, but at that point, they've gone from "just double click the shiny gold coin and get trading" to "check our website for updated peer lists, open command prompt, navigated to the bitcoin directory, and type the proper peer....." And if MIB were after us, the website would probably be long since gone.Of course, we could implement addpeer in a more user-friendly manner. Perhaps a popup that says "I can't connect to the network. Enter a peer: " with instructions on some ways to find one, but at that point we're creating a social solution to a technical problem.Also, if we get bigger we will need to move away from IRC anyway (as implied by the OP's conversation with a Freenode staffer). And what about Tor users? Why should people who want to use Tor to be anonymous have to manually add a peer? Finally, anyone on Freenode can easily get a list of all running Bitcoin clients, when they came online, when they went offline, etc. That goes against the project's stated goal of anonymity. Of course, with a host cache system, anybody who connected to that cache could be logged by the server operator, but no one operator would have a full picture of the network.I think the IRC solution is a wonderful beginning, and I applaud how stable it has proven to be. It was a great decision to get the network up easily and concentrate on the more interesting and important considerations in the program. I just think that Bitcoin will outgrow it someday, if it hasn't already. After an IRC session, I modified laszlo's bitcoin performance patch to be slightly faster and cleaner. I also added two rpc calls: listgenerated which just lists the strings from the UI of any generated blocks (nice for headless bitcoin mining servers) and gethps which returns the performance count in RPC. I also added gethps to the end of getinfo. Finally, I fixed GCC's issue with optimizations and htons in net.h.I've mentioned all of these patches elsewhere, but laszlo suggested that I compile them into one patch and post it. Here's that patch:http://www.alloscomp.com/bitcoin/bitcoin-svn-80-combined-2010-06-07.patchhttp://www.alloscomp.com/bitcoin/bitcoin-svn-81-combined-2010-06-11.patch^ Updated for r81. Check out http://www.alloscomp.com/bitcoin. The latest version is there.Enjoy! It's possible that you just got unlucky. Keep trying for a few days. Laszlo and I talked about this on IRC. I made a slightly cleaned up version against r80 of the SVN (no differences, but it might be a hair faster). You can get it here:http://www.alloscomp.com/bitcoin/bitcoin-svn-80-perfcounter-cleaned-2010-06-07.patchOr you can just get the combined patch that also includes the net.h workaround and some RPC extensions:http://www.alloscomp.com/bitcoin/bitcoin-svn-80-combined-2010-06-07.patch Sure. My computers ran all last night without generating again.http://validity.alloscomp.com/bitcoin/vps.debug.log.bz2 (2.1MiB compressed)http://validity.alloscomp.com/bitcoin/laptop.debug.log.gz (489KiB compressed)Thanks. I'm on campus internet. It's pretty reliable. It occasionally asks me to reauthenticate with the master server, but that's fairly rare. The VPS is el-cheepo, but it never drops for more than a second or two. Would it help for me to post or link my debug.log?  No, I'm not seeing that on either. On my workstation, the debug.log file has for some reason been clipped at the beginning. It's around 4.8 MiB. On my VPS, it's 20MiB and going strong. I haven't generated a block since 6/3/2010 while running my VPS (up to 2280 khps) 24/7 and my laptop (1200 khps) every night. I'm rather disappointed.
