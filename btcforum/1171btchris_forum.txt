It's clear that several people have been conned by this particular wallet (not that the wallet-selling-scam is anything new). It also seems that at least a couple of people have been reselling this wallet, possibly without the knowledge that it's empty or broken, or possibly with that knowledge.FWIW, there's no hard evidence that I've found which implicates anyone in this thread (or the others referenced) of being the creator of this wallet / original scammer, so I personally see no reason to assume malice on anyone's part. On the other hand, reselling this wallet (or any for that matter) is at the very best terribly irresponsible.I wouldn't think this needs saying, but buying a wallet of dubious origin is never a good idea. It's trivial to create a wealthy-looking wallet which appears undoctored but is actually devoid of any spendable funds. This particular wallet is not an example of this (it's obviously messed up in several ways), but the bottom line is: caveat emptor!Anybody with a full node and the wallet.dat in question can verify that it contains no spendable funds. (This is not true in general, but is true for this particular wallet.) The email where I was quoted above (highlighted in way-too-much-red) shows how to do this.I don't mean to pick on you, but claiming that your are "in crypto full time" and at the same time were unable to see any problems with this wallet (some of which were very much related to cryptographic mistakes) does little to advance your credibility IMO. 1. Decode the base-64 into binary.2. Remove the first 16 bytes, they are the IV. The rest is the cyphertext.3. Derive the encryption key as sha256(sha256(convert_to_utf8(password))).4. Decrypt they cyphertext with AES-256 in CBC mode using the key, IV, and cyphertext from above.5. Remove the trailing PKCS7 padding.This script will do so for you from a wallet file: https://github.com/gurnec/decrypt_electrum_seed By default, btcrecover only uses multiple GPUs at the same time if they're identical, but you can force it to use different GPUs if you'd like.First, ask it for a list of your current OpenCL devices like so:Code:> C:\python27\python btcrecover.py --list-gpus#1 GeForce GTX 1080 Ti#2 GeForce GTX 1080#3 Intel(R) Core(TM) i5-2500K CPU @ 3.30GHzIt's easiest to specify the GPUs you want to use by the #ID numbers, so for example to use the two 1080s, even though they're different models:Code:> C:\python27\python btcrecover.py --enable-gpu --gpu-names #1,#2 ...Note that you may get better performance if you use a different global-ws for each GPU (with a bigger global-ws for the Ti), something like this:Code:> C:\python27\python btcrecover.py --enable-gpu --gpu-names #1,#2 --global-ws 262144,196608 --local-ws 1024 ...Note that the order matters: in this example, GPU #1 (the faster one) is listed first after --gpu-names, so the larger --global-ws is also listed first. Only way to know if using different global-ws values improves performance is trial and error unfortunately.Good luck! Do you mean a seed could be used as an alternative for a UUID? I suppose, they both "encode" 128 bits of data minus a checksum (for seeds) or a small header (for UUIDs), except that UUIDs are designed more to be convenient for machines, whereas seeds are for humans.Actually, the "Random UUID probability of duplicates" on Wikipedia is quite relevant for seeds too. If Dave doesn't respond, you can try recovering the password yourself with btcrecover, however it will be more difficult and involves a bunch of reading to get it set up and running... I realize I may be a bit late here to be helpful, but if your wallet was created by Bitcoin Wallet v4.0 or later (released Oct 2014), it may be easier to extract the seed with this tool and restore it into a compatible wallet such as MultiBit HD.  Ah, gotcha.Yup, pretty much that.It accepts as input a seed "guess", plus something it can use to test potential seeds against: either a Master Public Key, a wallet file (which contains the MPK), or an address that can be generated from the seed.It then introduces various changes to the seed (cartesian-product-wise) and tests each result against the MPK/address, such as swapping consecutive words and/or replacing words with similarly spelled ones (from the same language list as the other seed words).Although most of the variations it tests are "small" variations such as those listed above which don't lead to a large growth of tested seeds, it also tries up to one "large" variation which means inserting a word or replacing an existing word with one that isn't even spelled similarly.Of course it skips seeds which can't possibly be correct (BIP39 seeds not of lengthâ‰¡0 (mod 3), Electrum 2 seeds of length > 13 (or > 12 for Electrum 2.7+), seeds with invalid checksums, etc.).Being part of btcrecover, it picks up a few additional features from it (multithreading, Unicode support, progress bar/ETA, etc.). I could go on, but I'm sure you've already had enough  I appreciate that you don't explicitly promote brain wallets, but you must admit that you did post a response in a thread that was started by OP to promote a "good" way of creating brain wallets (it wasn't) showing that your brain wallet was still safe as pro-brain-wallet evidence. Depending on how some will read that response, it could be misinterpreted as a general promotion of brain wallets (how many people will follow your link and read that entire thread? or even read the context in this thread?).... that was my complaint. That last sentence is rather important, and usually gets lost in the noise.It's not a question of whether or not it's theoretically possible to create a safe brain wallet, it's one of whether or not it's a wise idea to promote them.I've no problem if CIYAM wants to create a brain wallet because he's demonstrated that he generally knows what he's talking about, and is willing to accept the risks.I've a big problem with OP (or anyone else for that matter) promoting brain wallets in general because of the damage it can cause. This is further compounded by the fact that most people (I'm no exception) tend to overestimate their knowledge of a subject they haven't thoroughly studied ("maybe someone else will choose a bad brain wallet, or forget their brain wallet due to a wetware malfunction, but surely I'm smart enough to avoid these problems").In short: please don't use brain wallets. Please don't promote them (that includes you, CIYAM). If you still have your wallet file (or if you have your master pubic key or an address that's part of your wallet), and you know most of your seed as you said, you can use seedrecover to recover the missing parts of your seed: https://github.com/gurnec/btcrecover/blob/master/docs/Seedrecover_Quick_Start_Guide.md (which is part of btcrecover).If you have any questions about it, feel free to ask.They are interconnected to the master public key (stored unencrypted in the wallet file) and to the addresses they generate, but of course it's only possible to "brute-force" the seed if most of the seed is also known. Maybe I'm not understanding you correctly.Surely a human-created pass phrase is very likely to be weaker than a randomly-generated private key, but a sufficiently long randomly-generated pass phrase (such as a seed created by Electrum, assuming a non-broken OS) is not any weaker than any private key.In other words, for a 256-bit EC curve, a seed with 128 bits of entropy which generates a private key with just as much entropy is as strong as a private key with more than 128 bits of entropy since the weakest link is the curve itself (reversing an exponentiation takes on the order of "just" 2^128 EC operations even when the private key has more than 128 bits of entropy). adaseb,Your math is more or less within the right order of magnitude, but is missing a few things.First, you need SHA512, not SHA256.Next, for each seed you try, you need to check its "checksum" with HMAC-SHA512, so that's 2x SHA512's, not one.1 in 256 of the seeds you try will pass the checksum step above, and with these you'll need to run PBKDF2-HMAC-SHA512 with 2048 iterations (and each iteration requires 2x SHA512's) to get the xprv. This means on average, you'll need another 16x SHA512's per seed tried (so your initial estimate was 18x too small).Once you have a potential xprv, you still need to check if it's in use. This means deriving a bunch of private keys from the xprv (let's say we derive 30ish keys on both the internal and external chains, using both BIP32 and BIP44 style paths). Now we're looking at 120+ EC operations per seed which passes the checksum step (on average 1 EC operation for every 2 seeds you initially try). There is also another HMAC-SHA512, SHA256, and RIPEMD operation per address that's generated.Finally, we need a whole bunch of CAMs to look up (in parallel) these addresses in the UTXO set (which has about 43M entries today). I'm not sure how big CAMs get these days, but I can say that a 43M-entry cam is at least 10x or 20x bigger than anything commonly used in networking gear.We can shift some things around a bit (generate fewer private keys/addresses, but search in the every-address-every-used set which is 10x bigger), but it remains a daunting task.Of course, if we have this theoretical hardware mentioned above that can do silly-fast EC operations, it makes a lot more sense to just choose a public key visible on the blockchain which has a large UTXO value and attack it directly (which would take only on the order of 2^128 EC operations). In any case, it seems pretty likely it would take longer than current the age of the universe to succeed--personally I'm not that patient.So yes, "12 worded seeds [are] really secure from Brute force".  Given enough private-key entropy, the weakest link in securing Bitcoin funds is the secp256k1 curve used to sign transactions and generate public keys from private ones, which takes on the order of 2^128 operations to break. Using more than 128 bits of entropy does not help at all. While it's true that Electrum uses slightly less entropy as Abdussamad mentions above (124 bits), practically speaking this is still in the same ball park.Claiming that is flat-out wrong. Each wallet is stored in its own file on your PC. You can locate your wallet files here: http://docs.electrum.org/en/latest/faq.html#where-is-my-wallet-file-located. Actually, the FAQ is confusing when it comes to Windows; to find you wallet there, open File Explorer, and copy and paste this into the address bar: %appdata%\Electrum\walletsWith Electrum closed (very important), rename the current "default_wallet" file to something else, and then rename your imported old wallet to "default_wallet". Thanks!I'm glad it's solved!Not to be argumentative, but when you initially created your wallet, you did use a '/', specifically you named it "Escrow/MISC wallet". That slash was definitely the culprit. You probably forgot about the slash because (related to this bug) the "Escrow/" part wasn't being displayed when you re-opened (recreated really) the wallet via the "Recently open" menu item. It was hidden from view in the menu/wallet name, but it was still in there and was the cause of this issue.Having spaces in the wallet name works fine (feel free to give it a try). Great, there it is! You can't use a '/' in the name of an Electrum wallet. Electrum obviously didn't handle this in a user-friendly way.... Oh well, was worth a try.If you're up to it, could you try this next?Recreate your wallet as normal, and once it's ready, close (via the X in the upper right, there is no cancel button) the "Electrum is generating your addresses" window. Next, on the Console tab, run these four commands (each command is the text to the right of the ">>"). If it's successful, it should look like this:Code:>> wallet.gap_limit20>> wallet.gap_limit_for_change6>> wallet.synchronize()>> wallet.storage.write()>> I'm hoping it's not successful, and that one of the last two commands (they are what get run in that dialog box you closed above) either generates an error or hangs... it might offer a clue as to what's going on. Ah, makes sense.The instructions for using it are right in that link. You need to download it (it's a .zip file), extract it, install Python, and run a PowerShell script to install two other dependencies. Then just double-click it to run it. The instructions in that link should walk you through it.This isn't Keepkey's tool, I doubt they know anything about it. The seed is stored in the wallet file, it just needs to be decrypted (which is all the tool at that link does, it doesn't do any sweeping). So, did you try it on a different Internet connection? Can you simply wait until Friday?Do you still have your wallet file (mbhd.wallet.aes) and your password? If so, you could use this tool to extract the seed (wallet words) and then try restoring them into a new MultiBit HD wallet (perhaps even on a different machine) or into a compatible wallet (I think that breadwallet is the only wallet that's compatible with MultiBit HD and still supported). Silly question perhaps, but might this be a simple file permissions issue (for ranochigo's issue; mocacinno's issue seems different because it's intermittent)?ranochigo, can you try creating a file (say a text file) in the wallets folder next to your default_wallet?
Airbitz might interest you. If you'd like to try to recover it yourself, here's the Quick Start for the open source (free) tool btcrecover: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#quick-start. It does take a bit of work to get it set up and running, though. (Full disclosure: I'm the author of that tool.)If you have any questions about it, just let me know.Although I've never dealt with Dave @ walletrecoveryservices personally, he's gotten nothing but good reviews from what I can tell, so that seems like a good option too.In either case you'll need to have a good idea of what's in your password. Plus a "checksum". Only half the 8-bit checksum (plus the entropy) would fit into 12 words, hence the need for a 13th which encodes just 4 bits. (Note that BIP-39 has a smaller 4-bit overhead for its checksum which does fit into 12 words.)Yes, but only more efficient in the sense that there are no words which encode fewer than 11 bits; so better encoding efficiency. Since half of the 8-bit "checksum" wouldn't fit into 12 words, the choice was apparently made to reduce security by 4 bits post-2.7 so that now everything fits into 12.Potentially, but it depends on how you call make_seed().With post-2.7, calling make_seed() with 133 <= num_bits <= 143 gives you a wallet with 13 words and always 135 bits of security due to the rounding-up-to-improve-encoding-efficiency I mentioned. With pre-2.7, you'd get the exact same security level and word count by calling make_seed() with num_bits == 135.The difference is that pre-2.7, num_bits was the desired security level you wanted, and could result in a mnemonic with an added word which encodes fewer than 11 bits. Post-2.7 num_bits is now a lower bound for the total number of bits you want to encode in the mnemonic including the "checksum". It's a bit confusing post-2.7 IMO.Regardless, by default, make_seed() is called with num_bits == 128, which generates a 12-word 124-bit-security mnemonic with post-2.7, and a 13-word 128-bit-security mnemonic with pre-2.7.To improve security if ECDSA is ever broken (given 160-bit RIPEMD)? I suppose, but practically speaking there are many other far more likely attack vectors, such as side channel attacks against Electrum/Python, the quality of the underlying OS's CSPRNG, the ability to see pubkeys in the mempool prior to being added to a block (bad if ECDSA is broken), etc. Thanks!There's really no single "best", or rather "best" is very much a matter of opinion.There are at least three factors to consider when security is your most important goal: risk (of loss), convenience, and cost. There's no single solution which maximizes all three. (And of course there are plenty of other non-security-related factors, e.g. privacy, tx validation type, software license, protocol stance (block size/RBF/SegWit), etc.)I'm not an Electrum expert, but I believe you'd have these five options: "standard" online; standard cold/watching-only; 2FA; multisig; and hardware. The breakdown in order of best to worst looks something like this (and even this is somewhat a matter of opinion):RiskCold/watching-only & hardware > multisig > 2FA > onlineConvenienceOnline > 2FA > hardware > multisig > cold/watching-onlyPer-tx Cost (least expensive to most)Hardware, cold/watching-only & online > multisig > 2FA(Of course, hardware wallets have a startup cost, and so might cold/watching-only, multisig, or 2FA if you don't already have spare hardware/phones available.)So the best option for you is impossible for me to say, but if you have any specific questions about the above, ask away! First off, it's great IMO to seeing people doing code reviews of Electrum, the more eyes the better!In short, pre-2.7 seeds have slightly more entropy, but it probably doesn't matter.Â  Â  Â Prior to Electrum 2.7, Electrum encoded 136* bits of data into 13 or fewer mnemonic words using a wordlist of length 2048**. log22048=11, so each word is capable of encoding exactly 11 bits of data. This made Electrum perhaps not as efficient as it could have been, since 13 words (as you already pointed out) can store 143 bits of data, but it only needed 136 bits of storage.*From the source:Code:n_added = max(16, len('01')*4 + 128 - ceil(log2(1)))n_added = max(16, 2*4 + 128 - 0)n_added = 136**Except for the Portuguese word list which has 1626 words in it, log21626â‰ˆ10.67 bits per word.Â  Â  Â Prior to encoding, Electrum truncates any leading 0 bits, so if the 136 bits of data has 4 or more leading 0 bits (1 in 16 chance for random data), the resulting mnemonic would be 12 or fewer words. There's no loss of bit storage/security here, it's simply the equivalent of using a simple compression algorithm before encoding into words.Â  Â  Â These 136 bits are generated randomly by the OS (assuming no OS bugs), but are then incremented until an HMAC of these bits starts with the byte 0x01 to act as a sort of checksum. This effectively discards 255 out of 256 all possible seeds, which decreases the entropy by 8 bits (28=256), resulting in a seed with about 128 bits of entropy.Â  Â  Â AFAIK, all versions of Electrum 2.x prior to 2.7 used this algorithm (assuming custom entropy wasn't added), but I could be mistaken.Â  Â  Â The commit you referenced makes two changes. First, instead of aiming to gather 136 bits from the OS, it aims for just 128 bits. Second, it rounds 128 up to remove the inefficiency I mentioned above so that the mnemonic's max possible length is fully utilized. 128 bits gets rounded up to 132 bits ( âŒˆ128/log22048âŒ‰*log22048 ). The result, after removing the bits to account for the checksum, is 124 bits of entropy (â‰ˆ120 bits for Portuguese).Â  Â  Â The second change makes sense to me, but I don't understand the reasoning behind the first. The commit message says in part "count prefix length as entropy" which I disagree is a valid thing to do.Â  Â  Â Does this commit matter practically? Not really IMO, 124 bits of seed entropy is still far beyond any practical ability to crack any resulting ECDSA keys. OK (and wow! ), so I think you should be able to create an Electrum 2.7.x wallet with both master private keys that can finally spend your funds.Download the latest Electrum (it must be at least Electrum 2.7, or maybe even later, I'm unsure, just grab the latest to be sure).Create a new wallet, choose multi-sig, and choose 2 of 2 (which is the default).Select "I already have a seed", and enter your Electrum seed. It will display an xpub which you can ignore.For the cosigner, choose that you "Enter cosigner seed" (not "key").Before entering a seed, click Options, and enable "BIP39 seed". Then enter your newly discovered Copay seed.It will ask for an account number, accept the default of 0.Hopefully that should be it, but I'm not 100% sure, so let us know. Incidentally it doesn't make much sense to use this wallet going forward; it will be a 2 of 2 wallet which creates larger txs (more fees) with none of the advantages of a 2 of 2 wallet (separate signing devices). OK, so this is a 2 of 2 multisig wallet, and it has stored inside it only one of the two master private keys required to send transactions out of this wallet.Back when you created this wallet, Electrum must have asked you for the cosigner master public key (which starts with xpub), there's no other way you could have created such a wallet (unless you happen to have a hardware wallet?).Is it possible you entered the xpub from your Mycellium wallet when you created the Electrum 2 of 2 wallet? You can check to see if the xpub displayed in Electrum under Wallet menu -> Master Public Keys, the second/cosigner one, matches the xpub in Mycellium.If not, do you know where else you may have gotten that xpub?(I'm assuming that the 12-word seed you do have is the same one that's displayed when you go to Wallet menu -> Seed, correct?) Glad to here it. Sorry if I implied earlier that you were trolling, but you're definitely mistaken.To simplify a bit, creating a child key from a parent key involves two steps as per BIP32:(for non-hardened keys) The second step looks more or less the same for both public keys and private keys:Code:For private keys: privkey_parent + privkey_temp = privkey_childÂ  (privkeys are 32-byte long integers)For public keys:Â  pubkey_parentÂ  + pubkey_tempÂ  = pubkey_childÂ  Â (pubkeys are points on the EC)...and the first step is to create the "temp" keys, which involves taking an HMACSHA512:Code:Â  Â  For private keys:privkey_temp = HMAC_SHA512(key=chaincode_parent, data= PrivkeyToPubkey(privkey_parent) | index)Â  ("|" means concatenate)Â  Â  For public keys:privkey_temp = HMAC_SHA512(key=chaincode_parent, data= pubkey_parentÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â | index)Â  (both privkey_temps are equal)pubkey_tempÂ  = PrivkeyToPubkey(privkey_temp)Â  (note we need pubkey_temp for that second public key step above, privkey_temp is of no use) where "index" is the child key number which increments for each new key.The important part here is that we use HMACSHA512 to create the temp keys. This means that the temp keys look completely random and unrelated to one another, as do the resulting child keys. The only way to relate child keys with one another is to reverse the HMACSHA512, which is infeasible as long as SHA512 remains unbroken.Of course if you have the parent key and chaincode, you can derive the children, but the parent key and chaincode never appear in the blockchain. They're stored in the MultiBit HD's encrypted wallet file. No offense intended, but that's a matter of opinion.Electrum has never used key stretching, which makes wallet files with shorter/weaker passwords in the realm of being brute-forcible. For example, an Electrum wallet with a password containing 8 lowercase letters or digits would cost somewhere around $100-$200 to brute-force (some back-of-the-napkin calculations can be found here).Personally I'd avoid uploading my wallet to the cloud unless I was certain it had a strong password, or used an additional layer of encryption with strong key stretching such as Veracrypt as shorena mentioned. That's a wallet dump from Bitcoin CoreÂ—there is no associated master public key.Core uses an entirely hardened BIP-32 path, which makes it impossible to create a master public key or an HD watch-only wallet. (edit: at least at the moment, there does seem to be a desire to do so eventually) Neither person has such an address in the sense that they have the private keys used to spend any funds sent to the address.It's trivial to create any address (except for the last few characters and the first). It's trivial to send funds to such an address (poorly programmed wallets sometimes do so). It's not trivial to create a private key with an arbitrary address (hence vanitygen, which can "choose" a few characters in an address along with a private key, but not these addresses). This is somewhat anecdotal, but it may be helpful anyways.I had similar problems a few years back, and it turned out to be bad RAM.I wasn't having any other PC-related problems; no crashing, no problems when gaming, just problems w/core. I eventually ran memtest86+, and discovered a single bit error (in all 16GB) which matched up perfectly with the single-bit error (in terms of its position in a 64-bit word) I had also tracked down in my block files.Although I was surprised, perhaps I shouldn't have been. Unlike most software, Bitcoin does a whole lot of checking/hashing of its block data, so it's much more likely to uncover hardware problems on a PC than most any other non-diagnostic software.Win 10 has a memory diagnostic tool built-in. Just click the Start, and type "diagnostic", and should show up (it will require a reboot). Memtest86+ is probably more thorough; it's a little harder to set up, but worth the effort IMO. No practical limit, but (please correct me if I'm wrong) technically there's about a 2.1 billion address limit. Might be a problem for Amazon, but not for most anyone else.With Bitcoin Core's current implementation, I believe it will wrap around once it hits that limit and begin producing non-hardened keys, and once those are exhausted it will loop infinitely. Not that I'm particularly concerned about that at the moment.... It sounds like you pretty much already know the answer, or maybe I don't understand the question?On the secp256k1 elliptic curve used by Bitcoin, there is a point that's called the "base point generator", often denoted G. It was arbitrarily chosen (by Certicom I believe, or whoever defined the secp256k1 curve parameters).A private key is simply a 32-byte (approx.) long integer. A public key is a point on the curve-- it is found by taking the point G multiplied by the private key (via the double & add method, or some other). You misunderstood OP's issue.You can create a wallet containing loose (non-HD) keys: create a "standard" wallet, select "Use public or private keys", and paste in one or more keys. Set a password when asked.After creating the wallet, go to Wallet --> Private keys --> Import to import additional keys. Electrum will ask you for your password. In versions 2.7.9 and earlier, you could hit Cancel on the password prompt, but Electrum would still allow you to enter new private keys for import, and you'd end up with a wallet with the original keys encrypted, but the new keys in plaintext.As I said above, this was fixed in 2.7.10. It doesn't look like this was a known bug, but it was fixed here (as a result of fixing a related issue) in version 2.7.10 (current version is 2.7.11).After upgrading, you'll still need to fix your wallet. Delete any affected addresses on the addresses tab, and import them again. It sounds like you created a multisig wallet for some reason.In Electrum, go to the Wallet menu and select Master Public Keys. How many are listed? If more than one is listed, how are the labeled (e.g. "x1/ (self)" and "x/2 (something)")?Also, how many words are present in your seed (Wallet menu -> Seed)? My apologies, that was a very poor choice of words on my part (I should know better). I should have written "different (and in some ways better) than BIP-39" or similar.... That's only for wallets which are restored from a BIP39-compliant mnemonic sentence created by some other not-Electrum software (Electrum currently supports this, but it may not always).Wallets created by Electrum use Electrum's proprietary mnemonic-to-xprv algorithm, and use a path of m/c/i. Electrum uses m/c/i, where c is 0 for external, 1 for internal (change), and i is the incrementing index.For a summary of various wallets, see this spreadsheet.
Out of curiosity, which altcoins?What about the added requirement of a good CSPRNG source for every tx (not required by ECDSA), something which is more difficult to obtain in an isolated IoT environment w/o added (and unauditable) hardware support?There's also extra non-volatile state which much be maintained to commit the tx, another weak suit of IoT devices in general, correct?ECDSA isn't that hard, otherwise hardware wallets wouldn't exist.... Are you sure you're loading the correct wallet file (maybe you created more than one wallet)?Are you sure you're using the correct 2FA entry in Google Authenticator?Have you checked that both the current time and time zone in your phone are correctly set?If all else fails, you can restore a wallet with your seed (which you do have, right?) to recover your funds. Note that the restored wallet will not be 2FA-enabled, so you'll probably want to create a new 2FA wallet and transfer your funds over to it. Someone correct me if I'm wrong, but the Android security model doesn't (I believe) extend to files saved on a USB OTG stick. That means that any app could access the wallet-protobuf file.Although Bitcoin Wallet for Android uses good key stretching for the PIN, it's still short enough to be fairly easy to brute-force by your average PC once stolen by a malicious app. So, not a good idea.... It looks like this was fixed 15 days ago in master here.As a workaround, check that your default locale ends in ".utf8" by running "localectl status". If it already does, then I'm not sure what workaround might work (unless you modified the locale just for your user).If it doesn't end in ".utf8", see here to change it. Serious question: are you a troll, or innocently misinformed/ignorant?In any case, what "Cereberus" has said in regards to privacy here is false. Please ignore him/her. It's mostly compatible with Bither, breadwallet, Coinomi, Hive (defunct), Mycelium (Android and iOS), myTREZOR, and Wallet32 for Android, but there are various "gotchas".It is incompatible with Armory, Bitcoin Core, Bitcoin Wallet (for Android), and Electrum.If you have a specific wallet in mind, I can describe the minor incompatibilities, or you can look at this spreadsheet here for the gory details. https://www.reddit.com/r/btc/comments/4kzrp0/multibit_is_being_sold_to_keepkey_llc/Also, I should probably revise what I said earlier... the original MultiBit devs (who released version 0.3.0) certainly have my trust, but I don't know anything (good or bad) about the KeepKey folk. It certainly seems like they have a vested interest in keeping up with MultiBit's good reputation, though. Mandatory developers' fees were removed in version 0.3.0 (and even before then, the devs did their best to maintain user privacy with their BRIT donation scheme).No. Privacy is perhaps a bit better than many other desktop wallets because you need a password to simply view your current balance (many other wallets only require a password to initiate a transaction; addresses and balances for those are available w/o a password).MultiBit HD also uses a significantly better (if perhaps imperfect) wallet encryption scheme; in particular its key stretching makes brute-forcing much more time consuming than MultiBit Classic's.As you already noted, they certainly can via new releases (but not remotely). The old fee code was removed from MultiBit HD, and they have committed to not reintroducing it in the future. That doesn't mean they're technically incapable of doing so.Given how long they've been involved in the Bitcoin community, I think it's safe to say they are among the most trustworthy of wallet developers IMHO, and I wouldn't worry about this possibility. My bad, the tool I linked to appends the last element on its own, so you should enter a path of just m/0'/0.Also, is there any chance you created the wallet with a beta version prior to the 0.1 public release? Versions earlier than 0.0.8-beta had a bug that would affect you.... Do you have the seed?If so, you can use https://dcpos.github.io/bip39/ to generate your extended master private key (your "xprv") from your seed. (Follow the directions to use that tool offline before actually using it, though).To verify, that tool can also generate your addresses. Select the BIP32 tab, and use a derivation path of m/0'/0/0 for your first address, m/0'/0/1 for your second, etc.If you don't have your seed, you can extract it from your wallet file (assuming you have the password of course) with this: https://github.com/gurnec/decrypt_bitcoinj_seed. That's not entirely true, notably for Electrum (and MultiBit Classic, and maybe one or two others with equally low key stretching).I ran some quick-and-dirty numbers based on btcrecover's speed (which isn't really a brute-forcer, I'm certain a real brute-forcer would be a few times faster).Assuming only lowercase letters, passwords of length nine are quite feasible for an individual to brute-force.Add in digits, and then it drops to about eight characters long.Add in uppercase letters, then it's seven characters. Still not too bad.Take a character off, and it goes from feasible to downright cheap ($10 and around 24 hours or less on a single monster AWS EC2 instance).In short, brute-forcing weaker (yet not trivial) passwords is possible, and none of this takes into account how a real brute-forcer would work, e.g. going off of good dictionaries w/good mutation rules.Regardless, to OP: unless you're willing to try to find the password yourself (e.g. with btcrecover mentioned above), Dave has a good reputation and may be able to help (for a fee that is). Take a look at the pseudocode in the second half of this response on StackExchange, it may answer your question. I'm afraid I don't know enough about OpenCL to say which architecture is better... I'll give you what little I do have though.These are P/s rates from a Bitcoin Classic/XT/Core wallet with an iteration count of 67908.1x 560 Ti: 1070 P/s2x 560 Ti: 2110 P/s1x R9 390: 4470 P/s(the test numbers for other wallet types are here)It's an apples-to-oranges comparison, but I'd guess that it points to AMD architecture at being better for this... but it's just a wild guess.For Classic/XT/Core, VRAM makes practically no difference (you just need 64 x --global-ws bytes). For Armory, it makes a big difference.Edit: I just noticed an old thread by you.... if you have any specific questions, feel free to ask, but in the mean time:By adding the "--delimiter *" option, "*" is now used as the delimiter between tokens, instead of spaces. This means you can use:%[ _] - a single space or underscore (note the space before the _, it may be hard to see)%0,1[ _] - 0 - 1 single spaces or underscores, e.g. a single space or underscore or nothing at allHope it helps. Thanks for the update! Hi, Jim.I hate to be a pain, but do you (or someone at Bitcoin Solutions) plan to re-sign the Windows 0.5.18 binaries sometime in the future to fix this certificate expiration issue? Like ladyada, who also just happens to be an apparent bitcoin supporter?(not saying your wrong in this particular case, just that you never know....) I stand corrected, thanks. Well, if you think you may have made a mistake in recording your seed, you can give seedrecover a try (it's part of btcrecover): https://github.com/gurnec/btcrecover/blob/master/docs/Seedrecover_Quick_Start_Guide.md#seedrecoverpyIt's an open source seed recovery tool; it requires that you have a good estimate of what your seed is, and also that you know either your master public key, or an address generated from your wallet (preferably one that was generated shortly after your wallet's creation). Sakarias-Corporation: Note that of these three, only Mycelium (edit: and also Electrum, my mistake) support multiple accounts (which you apparently make use of). GreenAddress.it also has TREZOR support, but I don't know if it supports multiple accounts with a TREZOR (and also it's an online multisig wallet, which may or may not be what you want). Coinbase began supporting 2-of-3 multisig wallets about 8 months ago where you control 2 of the 3 keys. Unlike blockchain.info, there have been no known security failures (yet) with Coinbase wallets.
It appears to be a bug. I opened an issue here: https://github.com/spesmilo/electrum/issues/1312Edit: it's just been fixed, and should make it into the next release (after 2.3.2). We're getting off-topic , but I must respectfully disagree.Any online service is vulnerable to attack, and by using one you are obligated to understand and accept this risk. I agree that a local password manager which doesn't require a centralized service is probably safer, but in exchange for that safety you must give up some convenience. More importantly, I think that LastPass is the best among the various online services, and I have no trouble trusting them with all but my most sensitive passwords.In particular, they adhere to good security best-practices (salted well-key-stretched hashed passwords), and they have been, at least in the past (and including their most recent issue), very transparent when something bad happens or when they screw up. I also find their mitigation recommendations to be reasonable (when problems do occur), and not overly sugar-coated.Anyways, just my 2Â¢.An aside: was there another hack? I was only aware of one recent one.... Just FYI, it's 13 words or less for seeds as currently generated by version 2.x (reference: http://bitcoin.stackexchange.com/questions/38011/ramifications-of-creating-electrum-2-x-seeds-which-are-not-bip39/38027#38027), however that's likely to change in a future version to 12 or less. It's an ease-of-use trade-off. Because it's unencrypted, you don't need to type in your password if all you want to do is check your balance or generate a new receive address. (Of course, all of your private keys are encrypted when you set a password.) "Risk" is exactly the right word. As I said, once someone has a single private key, they only need to get your master public key to compromise the rest of your wallet. Your master public key is stored in you wallet file unencrypted, so it's not that hard to get.If you're comfortable there's no way an adversary could gain access to your master public key, then you're probably safe, but it remains risky....(Note that if you decide to take this risk and give out a single private key, there's no additional risk to giving out more private keys to the same adversary.) Please see the post I wrote a few minutes ago just above yours.... Maybe.Anyone who has a single private key and your master public key (from the same wallet) can compute the wallet's master private key (and therefore all of the other private keys). Keep in mind that your master public key is not encrypted in your wallet file, so gaining access to it is easier than gaining access to the encrypted master private key stored in your wallet file.If all one has is a set of private keys from the same Electrum wallet, they cannot determine any other private keys.Personally, I'd never give anyone any of my private keys unless they were from an isolated wallet I didn't use for any other purpose (which I'd then consider compromised for all intents and purposes). Me too.I also hope you've added an email address, enabled both send & receive notifications, and written down your mnemonic so that you won't have to worry about losing your funds.... +1 IMO....I believe that the upcoming "Android M" will be fairly aggressive (for better or worse) in what it automatically backs up to the Google cloud, but as of today app data is not backed up by default. Paper codes only work for specific services, they will not work with Electrum / TrustedCoin 2fa.If you've lost both your 2fa app (and have no backup of it) and your seed, you very likely out of luck, sorry...Â   If you think there's a possible mistake in the seed, you could give seedrecover a try: https://github.com/gurnec/btcrecover/blob/master/docs/Seedrecover_Quick_Start_Guide.md. If you're a techie (and I know you are), it's quite easy to get up and running. I don't think BCCAPI is being supported any longer. I don't see any updates to it since late 2012.BCCAPI was the library behind the BitcoinSpinner open source wallet, and BitcoinSpinner was discontinued in late 2013 in preference to its successor, Mycelium (which is not open source FYI).If your interested in a Java wallet library for a new project, I'd suggest bitcoinj.If you need help with BCCAPI, I'm not sure where the best place to ask would be (certainly not here though).Maybe you could ask this exact same question in the Mycelium thread? https://bitcointalk.org/index.php?topic=293472.0 I'm glad you finally worked everything out!It's possible that some of your deposits have not yet expired, even if most of your larger ones have. If there are still funds left in your old wallet, you may want to try this process again in another week or two to recover the remaining funds (if any).It should be pretty straight-forward. On one of your devices, launch the app and choose "Create new Wallet" in the upper right corner. On your other devices (if any), click the slider at the bottom labeled "Show other logins", and use your full mnemonic (from step one) to log in.Since the app only keeps track of the most recently used wallet, there's no need to do any wallet deleting.FYI when you set up 2FA, I think you might need to use a separate email address, not sure though.... (And of course this goes without saying: give them an email address and enable notifications just like you did last time in case you need to do an account recovery again ) Whoever did move it didn't leave behind the typical "Moved" post, so we can't see who it was.But yes, Theymos is very much against a hard fork. For example, he has stated that he will not allow Bitcoin XT to be listed on his bitcoin.org site unless/until the "extremely unlikely event that the vast majority of the Bitcoin economy switches to XT and there is a strong perception that XT is the true Bitcoin". FYI BIP-39 (and Electrum 2.x) starts with a specific amount of entropy, and then derives the words from that entropy, not the other way around as you implied. Typically, this is 128, 192, or 256 bits for 12, 18, or 24-word long mnemonics.(and of course the hashing which follows does nothing to increase that initial entropy) The bitcoin address which appears at that link was inserted there around the same time fabiola! joined the forum. All this implies is that someone who has access to the DreamTribesband YouTube/Google account created the fabiola! account here.This might be the person you think it is. It might be some random person who illicitly gained access to the DreamTribesband account. It might be some other individual associated with Dream Tribes.For a specific example: it would be reasonable to assume that David Sanger-Kildare, Dream Tribes' producer, would have access to the DreamTribesband account. It turns out that he is a bitcoin enthusiast with a post to his name here on BitcoinTalk. In the video he links, we can see four of the exact same miners fabiola! happens to own (although fabiola! has pointed some of this out already).So maybe you're talking to an attractive young woman, or maybe to an old English guy, or maybe to a script kiddie who lives in his parents' basement; I certainly don't know.Cute.... How would it know you've never used an address?In other words, an address should be considered "used" as soon as you give it to someone else. There's no way to know if that someone else will spend to that address right away, or at some point in the future.Some wallets wait for a transaction to show up in the blockchain before an address is considered used, or else require that you mark it as used manually. That's OK, but it's not as safe IMO because it requires you to track your address usage manually. What leads you to believe that Windows isn't using all 6 cores?Not all programs are good at using multiple cores to improve their performance, so it's not surprising that some programs are benefited more by overclocking.To check if Windows sees and is using all of your cores:Â 1. Start -> type Task Manager, press Enter.Â 2. If you see a More details button in the lower-left, click it.Â 3. Click the Performance tab.Â 4. Click CPU.Â 5. Verify that "Cores" says 6, and that "Logical processors" says 12. OK, but that's a moving target. Over time, ASICs get bigger.In our context, I assume you mean that the revenue benefits from mining would be insufficient to compensate for their production costs, but this is also a moving target (for healthy coins on the rise, that is).Eventually either the two meet and create a profitable market for ASIC production, or the coin dies off.As a coin designer selecting a PoW, the only questions you have control over is how long before this happens, and how expensive are ASICs (relative to other PoW choices) when they arrive.If only the super-rich can afford ASICs, then you'd end up with increased centralization (relative to having used a simpler PoW) when ASICs first appear, no? Appears to be a minor bug.Easiest solution would be to install v2.2 from here: https://download.electrum.org/electrum-2.2.dmgAs an alternative, you can open ~/.electrum/config in TextEdit, and then on the second line, insert this new line:Code:"requests_dir": "",(just do one or the other, not both)Fixes on the way shortly (or already here), see below....
Welcome, and sorry I didn't think of it sooner.... It means "invalid one-time-password" / invalid Google Auth code.Either your Google Auth secret has become corrupted, or whatever device that you have Google Auth installed on has a miscalibrated clock. Check that your device's clock matches up with the correct time to the nearest second or so (US: http://www.time.gov/, worldwide: http://www.timeanddate.com/worldclock/), and also make sure the time zone setting in your phone is correct. When you copy & paste, you can't include the new-line character at the end of the statement. In other words, after you paste, the cursor should be at the end of the line, and then you press Enter. If the cursor is at the beginning of the next line, the entire thing will be ignored for some reason, and that's what happened with the "tx =" line above, and a few others.Am I making sense? Can you try again? Thanks. First, upgrade to Electrum 2.2 if you haven't already. Try this longer one next (if you still have patience to ):Code:>> import sys>> plugin = filter(lambda p: p.fullname()=='Two Factor Authentication', sys.modules['electrum.plugins'].plugins)[0]>> tx = wallet.make_unsigned_transaction([('address', '1destinationBitcoinAddress', 10000000)])>> p = gui.password_dialog(); plugin.send_tx(tx); wallet.sign_transaction(tx, p); del p>> tx.error>> tx.signature_count()That lasts one should print two numbers, like "(3, 6)". If the numbers are the same, then everything's working right, and I'm not sure what to do next. If the numbers are different, continue:Code:>> wallet.storage.get('wallet_type')>> pluginm = sys.modules['electrum_plugins.trustedcoin']>> plugin.send_tx(tx); r = pluginm.server.sign(plugin.get_user_id()[1], tx.as_dict()['hex'], plugin.auth_code)>> r.keys()>> tx.update(r['transaction'])>> tx.signature_count()I hope to see an error in one of these.... I don't actually have an Electrum wallet, so I'm doing some guessing and getting it wrong....Please try this:Code:>> tx = wallet.mktx([('address', '1destinationBitcoinAddress', 10000000)], gui.password_dialog())>> tx.error Sorry, my mistake. The amount to spend should be in satoshis, not in BTC. Please change the 0.1 argument to 10000000, and give those two commands another try. (FYI, it won't actually send the transaction, it just tries to prepare it.) The only way to remove 2fa from a TrustedCoin wallet is to restore the wallet from the recovery seed (and when you do, 2fa is forever removed unless you create a new wallet).That's unfortunate.... the seed is not stored anywhere in the wallet for TrustedCoin wallets (medUSA is mistaken for this type of wallet), and so if you've lost it, there's no way to get it back.Try to run this in the Console tab, placing your destination address below where it says 1destinationBitcoinAddress, and post back the results:Code:>> tx = wallet.mktx((('address', '1destinationBitcoinAddress', 0.1),), gui.password_dialog())>> tx.error(Note that if you solve this issue, you should really consider making a new wallet (a new TrustedCoin one if you like) and transferring your btc to it, and making sure you keep the seed in a safe place. Without the seed, your btc will be stranded if TrustedCoin ever decides to close their 2fa service.) You can install Python 2.7 alongside 3.4 (if you need Python 3 for some other reason). Just change the install directory to a different location, e.g. C:\Python2, during installation. btcrecover depends on a number of features that were removed from Python 3 (although it would benefit from certain other features added to Python 3, it was a trade-off...). Did you install Python 3 or Python 2? btcrecover requires Python 2, preferably the latest version (2.7.10 as of today). Electrum 2.x by default starts with 136 bits of entropy, and then adds and increments a nonce until the resulting HMAC starts with 000000012, so the result has (slightly less than) 128 bits of entropy (since 28-1 out of every 28 potential mnemonics are discarded).Slightly less, because Electrum also discards mnemonics which are valid for Electrum 1.x wallets to avoid any confusion from restoring such a mnemonic, which removes an additional small amount of entropy. To determine if a mnemonic is valid without using a word list, Electrum 2.x takes an HMAC of it (using a hardcoded key) and looks at the first byte. In pseudocode:Code:if hmac_sha512(key="Seed version", utf8_encoded_mnemonic_sentence)[0] â‰  0x01:Â Â  Â fail("invalid checksum")The only way Electrum can create a mnemonic whose first byte of HMAC is the byte 0x01 is by generating different mnemonics and trying each's HMAC until it finds a valid one, similar to the way vanity address generators work. This takes on average 256 tries, whereas with BIP-39 only a single mnemonic is created, and then its checksum is simply appended.In order to go from mnemonic to binary seed, 2048 HMAC-SHA512's are needed for both Electrum and BIP-39, so the effort difference is roughly 2304 for Electrum vs. 2048 for BIP-39, about 12.5% greater, not a big deal....  Welcome.Is it not being calculated correctly for you (it's a formula cell)? Are you looking in the wrong place maybe? Here's what it looks like for me:Perhaps you already know this, but it was an intentional trade-off made by the Electrum dev: https://bitcointalk.org/index.php?topic=1082586.0, https://bitcointalk.org/index.php?topic=939337.msg10366268#msg10366268On the positive side, Electrum 2.x does have some xpub (watching-only) compatibility with other wallets, and it's the only wallet to have xprv compatibility with any other. I would guess that multisig web wallets are looking for ways to monetize their user base (integration or tie-ins with exchanges? non-free instant confirmations? advertising? time will tell...). It seems unlikely they'll remain "free" (as in no monetization) forever. If that guess is correct, a multisig web wallet would have no self-interest in permitting users to download the provider's private keysÂ—that would allow users to move their wallets to a competitor. It also probably isn't a good idea from a security point of view, either.For another take, consider GreenAddress 2-of-2 wallets. Their security model for instant confirmations outright prohibits them from sharing their private key, lest a user be able to double-spend a UTXO which GreenAddress has placed its instant-confirmed faith behind.They already all (I certain hope?!) provide a recovery mechanism, so sharing keys between wallets isn't necessary for recovery purposes either.In short: I don't think web-based multisig providers will ever share their keys (nor should the need to), and so I doubt they have much place on this spreadsheet. Could be wrong, though....There are however non-web-based multisig wallets, like Armory, Electrum 2.x, mSIGNA, and Copay. These certainly do have a place here, but I don't think any are yet compatible with one another (I'm not sure about Copay though, I haven't checked them out yet). Since adding them would complicate the spreadsheet and not add much new value, I'm hesitant to expend the effort at the moment.... however I think it should be done one day. (BTW I'd be happy to be wrong about their current compatibility if someone could correct me.)Agreed, BIP-67 is a good thing. Thanks for spelling out all the details! I've updated the spreadsheet.If you remember to let me know once new features are released, I'll update the spreadsheet to include them.-Chris That's great, thanks.I corrected both the spreadsheet and the btcrecover repo. Welcome!The backup password speeds are identical to MultiBit Classic, so I didn't bother listing them both.Are the file formats the same for BlackBerry? If you mostly recall your password, and if you're somewhat computer-savvy and can follow technical directions, you may want to try btcrecover which is open source and free.Otherwise, shorena's suggestion to contact a wallet recovery service seems like the best idea (you still need to mostly recall your password, though).If you need any assistance with btcrecover, please feel free to ask me, and I'll help if I can. Not quite.... They both use PBKDF2-HMAC-SHA512 to convert a mnemonic sentence to a binary seed (which becomes the extended master private key). BIP-39 uses the positions to calculate/verify the checksum, whereas Electrum uses an HMAC.I think you just answered your own question Electrum 2.x is not tied to any particular wordlist (good), however its mnemonics are not compatible with any other wallet (bad(?)). It's a judgement call....True, on both points. Seedrecover.py for example assumes that for Electrum seeds, the word lists which currently ship with Electrum were used. If this assumption is wrong, or if Electrum is updated and I don't notice it and don't update seedrecover, it will silently fail.One other potential minor negative to Electrum 2.x's method: although both can be used to create weak/ill-advised brain-wallet style mnemonics, Electrum's method makes it a bit easier. For example, these are all perfectly valid (if criminally stupid) Electrum 2.x seeds; feel free to try restoring them into Electrum if you doubt it:Code:pass666pass789p@ss4wordpassw0rd6pa$sword321p4ssword44444password456789999edited to add: One other very small disadvantage with Electrum 2.x's method: it takes more effort (CPU time) to create a mnemonic, although this extra effort is small compared to the effort required to run PBKDF2 to generate the binary seed which both methods still require. FWIW, btcrecover supports Bitcoin Wallet for Android. It supports searching for openssl passwords or scrypt PINs in these formats:Bitcoin Wallet for Android v3.47+ (protobuf with or w/o a PIN, with or w/o openssl)Bitcoin Wallet for Android v2.3 - v3.46 key backup files (openssl starting with "# KEEP YOUR PRIV")Bitcoin Wallet for Android v2.24 and older key backup files (openssl starting with a WIF, same as MutliBit .key files)Slightly related if you've any interest, performance numbers comparing btcrecover (and JohnTheRipper) for various wallet formats (including the above), running on a 2nd gen. quad-core i5, are available here: http://1drv.ms/1pnpk0m Did I? From the manual here, it says "must begin with exactly #--". Maybe there's somewhere else I missed? I guess it doesn't really matter now that it works either way, though...I should have noticed that from your first response, sorry If you want to use the btcrecover-tokens-auto.txt feature, do not use a separate tokens.txt file. Remove "--tokenlist tokens.txt" from the first line, and then take the contents of the tokens.txt file and place them inside the btcrecover-tokens-auto.txt file after the first line so that it looks something like this, all in one file:Code:#--wallet wallet1.dat--autosave savefilepass Password Word(which would try these passwords, where "pass" and "Pass" never appear together, "word" and Word" never appear together, but all the other combinations are tried:Code:passPasswordwordpasspasswordwordPassPasswordWordWordpasspassWordWordPassPassWord)
Is that all on the first line? It can't be on any other line...Is there a space between the "#" and the "--" ? There can't be a space there... (actually I just now uploaded a fixed version that no longer minds extra spaces there so that nobody else gets tripped up with this). Hi.Could you show exactly what command you're typing in, and also exactly what the error message is please? Oops, silly mistake on my part, thanks.... TierNolan isn't wrong, but his answers are limited to BIPs which cause hard forks (on everyone's mind these days w.r.t. the blocksize limit...).BIPs which don't cause hard soft forks do not need 95% miner support. BIPs don't need to be suggestions for Bitcoin Core or even the Bitcoin network. They can be purely informational in nature, e.g. BIP-32.(Just some additional perspective....) Do you know if your wallet was created with version 4.0 or higher (Released Oct 3, 2014)? If so, there may be an easier alternative.... If your wallet was generated by Electrum 2.x, an alternative to dealing with individual private keys would be export your one master private key ("xprv"), and import it into another wallet.Unfortunately, you're limited in your other wallet options. The only one I'm aware of that this would work with is Mycelium for Android.(How to export your xprv from Electrum: http://bitcoin.stackexchange.com/questions/36839/electrum-2-0-non-bip39-32-standardisation-complicates-matters-immensely-why/36945#36945) Not trying to start an o/t flame war here, but Google and Apple (and even Ubuntu to some extent with their search provider deals) don't have the best privacy/security track records either.... I see no reason MS phones are much if any worse. You cannot (easily anyways) create a new wallet in Electrum 2.x that uses a 128-character mpk. You could, if you needed to, temporarily run an earlier version of Electrum to generate an old-style wallet though. Full instructions (for Windows) can be found here: http://bitcoin.stackexchange.com/questions/37386/error-in-checkout-while-using-bitcoin-payments-by-bitcoinway-with-woocommerce/37388#37388 Take a look at the spreadsheet listed in this post: https://bitcointalk.org/index.php?topic=1000544.msg10862297#msg10862297The second tab, labeled "mnemonic-compatible", lists wallets which use seeds compatible with one another. Specifically, you'll want one of the wallets listed in column L. If you used more than one account in Mycelium, you'll need to choose a wallet listed as "Yes", otherwise you can choose one listed as either "Yes" or "Partial". I would never suggest that a newbie try to directly handle private keys, there is far too much danger involved in messing something up. If physical loss of a phone is a concern (and I agree it should be), usage of a deterministic wallet plus properly backing up the seed is much better advice IMO.Aside from physical loss (which I addressed above), losses from malware are a real threat, and they are much smaller threat on mobiles than they are on desktops (at least for the time being...). IMO newbies should be steered towards mobile wallets, especially deterministic ones, not away from them.(I certainly agree with you that large amounts shouldn't be stored in any hot wallet though.) Why? And as opposed to what?Why?Why? Malware which targets mobile devices is considerably less common than PC-based malware, and some mobile devices are currently invulnerable to bitcoin-stealing malware (those which cannot yet be easily rooted such as iOS 8.3, most boot-locked android phones running 5.0.2, etc.). Oops, you're completely correct there, my bad... but thank you for seeing past my technical failures  Maybe....This doesn't address all of your questions, but for a partial answer take a look at this thread: https://bitcointalk.org/index.php?topic=1000544.0 Agreed.It's rather ironic that ATI couldn't, as things currently stand, host an armoryd-based service off of their own website at https://bitcoinarmory.com/.https://bitcoinarmory.com/ is (currently) hosted with the help of CloudFlare's anti-DDOS service. Although CloudFlare (as a for-profit company) has chosen to open-source some of their software (good for them!), their platform is not completely open source.Although I don't have a problem in general with "copyleft" licenses (and have used them myself), I find (just IHMO) the AGPL license to be far too restrictive for my taste (edited to add: especially ATI's interpretation of the AGPL license)....Having said all that, if that's how the Armory devs would like to see their code used, I can/will respect those wishes. You misunderstand what I was trying to say (or rather I wasn't being very clear).When you hit the "give me a new receive address" button, some wallets will [try to*] always generate a new address. Other wallets will choose a currently unused address, although it may be an address that's been displayed to the user previously. Electrum is of the latter typeÂ—it's easy to mistakenly give the same address to multiple people as long as the address has no current transactions associated with it.(I don't mean to pick on Electrum... it just happens to be a wallet I know which does this, there may be others as well.)* It'd be reasonable for a wallet to avoid generating new addresses that would violate the wallet's gap limit, however a privacy-conscious wallet should at least warn the user if it presents the same receive address a second time. The collection of factual data is nice, as are some of their ideas where existing wallets can improve privacy.Not IMO... the score weighting is completely arbitrary. It's not unreasonable, but it'd be easy to reach very different conclusions with equally reasonable but different choices in the weighting.Of course, people like to see a bottom line and generally can't be bothered to take the time to draw their own conclusions, so it's not surprising that the authors decided to create such a bottom line score (useless though it may be IMO)....I'm also noticing at least two points which they did not consider, but perhaps should have.1. Armory is I believe unique among popular wallets in that it still uses uncompressed public keys. This makes it possible to identify likely Armory-created transactions, and perhaps easier to correlate transactions to particular wallets.2. Some wallets, e.g. Electrum, do not consider an address as "used" until it is associated with a transaction with a certain number of confirmations. If a wallet user asks for a new receive address, they will be presented with the same address as previously displayed until it is considered "used" by the above criterion. (In the Electrum case, they can manually choose an address which they believe has not yet been given out, but they must keep track of this themselves.) I'm sure you're sick of hearing this , but any dev who developed a system like this in lieu of a signature scheme probably doesn't know what they're doing... I'd be very wary.Make sure you click the BIP44 tab. If you have multiple Accounts in your Mycelium wallet, you'll need to modify the account # on that page as well (the number 0 corresponds to what Mycelium calls "Account 1", the number 1 corresponds to "Account 2", etc.).Do you have the public key, or the address? A Mycelium address starts with a 1 (as I'm sure you know). A Bitcoin public key typically starts with a 02, 03, or 04, but it depends on the encoding used.If you have the address, simply find it in the displayed list. The WIF-encoded private key is to its right. Unless you choose to use, say, an armoryd instance to power your blockchain explorer or web store (these are not my words...). Was there ever a 0.91.2 release?There was a 0.91.2-rc1 release (available here: https://s3.amazonaws.com/bitcoinarmory-releases/armory_0.91.2-rc1_winAll.exe).I think following releases were all 0.92 testing (alpha) releases and then 0.92.0.Out of curiosity, why would you need it? On my Windows box, MultiBit (Classic) works perfectly fine with the most recent Java SE8.Agreed. The vulnerabilities you often hear about relate to the Java sandbox, not to Java itself. The sandbox is responsible for enforcing security rules on untrusted applications, typically run from inside a web browser. (Yes, the Java sandbox is infamous for its security bugs, and deservedly so).MultiBit does not run inside a sandbox because it is not an untrusted app (you do trust it, don't you?). It has just as much access to your PC as any other normal Win32 app.Also, if you have a need to, nothing prevents you from installing multiple versions of Java, in which case browser-based Java apps requiring the sandbox will use the most recent version by default.
That's great, I'm glad it helped!!You can use this escape sequence which will be replaced by a single "$": $S(You only need to use it if you want a $ at the end of a token.) Here are the docs on which special characters need escape sequences: https://github.com/gurnec/btcrecover/blob/master/docs/Limitations_and_Caveats.md#delimiters-spaces-and-special-symbols-in-passwordsAwesome, thank you so much!!! -Chris Well, your namesake certainly was I haven't timed it exactly, but it's somewhere around there even with my HDD. I'll pay closer attention next time I do a scan. For me anyways, 0.94 allows me to place the Armory DB on an SSD whereas before both it and the Bitcoin DB were on an HDD. Practically speaking, this has hugely improved the initial "reading blocks" and "building database" steps, down to about 14 minutes. The tx scanning phase is only slightly faster IIRC (possibly because the Bitcoin DB block files are still on HDD).In short, when 0.94 works, it's brilliant! That stack trace looks exactly the same as mine on Windows (some of the line #s are off, but I think that's just a symptom of using different debuggers). Even the most recent calls are showing a similar out-of-bounds pointer being passed. FYI I've had one additional crash, and the stack trace was the same (with pb.fmp_.current_->filemap_ and pb.fmp_.current_->mapsize_ in GrabThreadData::pullBlockAtIter() corrupted). Code:First-chance exception at 0x000007FEDFD63450 (_CppBlockUtils.pyd) in python.exe: 0xC0000005: Access violation reading location 0x0000000088067A8D.On Win 7 64-bit, I'm also getting an access violation while scanning txs. Running the latest in the ffreeze branch (578c072). Here's a stack trace (via VS 2013) from a debug build:Code:  _CppBlockUtils.pyd!memcpy() Line 356 UnknownÂ  _CppBlockUtils.pyd!BinaryData::copyFrom(const unsigned char * inData=0x0000000088067a8d, unsigned __int64 sz=80) Line 198 C++Â  _CppBlockUtils.pyd!BlockHeader::unserialize(const unsigned char * ptr=0x0000000088067a8d, unsigned int size=80) Line 31 C++Â  _CppBlockUtils.pyd!BlockHeader::unserialize(const BinaryDataRef & str={...}) Line 48 C++Â  _CppBlockUtils.pyd!BlockHeader::unserialize(BinaryRefReader & brr={...}) Line 54 C++Â  _CppBlockUtils.pyd!BlockHeader::BlockHeader(BinaryRefReader & brr={...}) Line 52 C++Â  _CppBlockUtils.pyd!PulledBlock::unserializeFullBlock(BinaryRefReader brr={...}, bool doFrag=true, bool withPrefix=false) Line 230 C++> _CppBlockUtils.pyd!GrabThreadData::pullBlockAtIter(PulledBlock & pb={...}, LDBIter & iter={...}, LMDBBlockDatabase * db=0x00000000003baa10, BlockFileAccessor & bfa={...}) Line 490 C++Â  _CppBlockUtils.pyd!GrabThreadData::grabBlocksFromDB(std::shared_ptr<LoadedBlockData> blockData={...}, unsigned int threadId=2) Line 279 C++Â  _CppBlockUtils.pyd!std::_Bind<1,void,void (__cdecl*const)(std::shared_ptr<LoadedBlockData>,unsigned int),std::shared_ptr<LoadedBlockData>,unsigned int>::_Do_call<,0,1>(std::tuple<> _Myfargs={...}, std::_Arg_idx<0,1> __formal={...}) Line 1150 C++Â  _CppBlockUtils.pyd!std::_Bind<1,void,void (__cdecl*const)(std::shared_ptr<LoadedBlockData>,unsigned int),std::shared_ptr<LoadedBlockData>,unsigned int>::operator()<>() Line 1138 C++Â  _CppBlockUtils.pyd!std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(std::shared_ptr<LoadedBlockData>,unsigned int),std::shared_ptr<LoadedBlockData>,unsigned int> >::_Run(std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(std::shared_ptr<LoadedBlockData>,unsigned int),std::shared_ptr<LoadedBlockData>,unsigned int> > * _Ln=0x0000000007d1d060) Line 196 C++Â  _CppBlockUtils.pyd!std::_LaunchPad<std::_Bind<1,void,void (__cdecl*const)(std::shared_ptr<LoadedBlockData>,unsigned int),std::shared_ptr<LoadedBlockData>,unsigned int> >::_Go() Line 188 C++Â  _CppBlockUtils.pyd!_Call_func(void * _Data=0x000000000f8b18b0) Line 28 C++Â  _CppBlockUtils.pyd!_callthreadstartex() Line 376 CÂ  _CppBlockUtils.pyd!_threadstartex(void * ptd=0x000000000f8b18b0) Line 354 CÂ  kernel32.dll!BaseThreadInitThunk() UnknownÂ  ntdll.dll!RtlUserThreadStart() UnknownI think there's something going on near GrabThreadData::pullBlockAtIter(); here's a locals dump after switching to that frame:Code:-  bdr {ptr_=0x0000000088067a8d "" nBytes_=155478 } BinaryDataRef+   Â  Â ptr_ 0x0000000088067a8d "" const unsigned char *   Â  Â nBytes_ 155478 unsigned __int64-  pb {stxMap_={ size=0 } nextBlock_=empty fmp_={current_=shared_ptr {lastSeenCumulated_={...} fetch_=FETCH_NONE (0) filemap_=0xec27b9f8692f2700 <Error reading characters of string.> ...} [1 strong ref] [default] ...} } PulledBlock &+   Â  Â DBBlock {dataCopy_={data_={ size=0 } } thisHash_={data_={ size=0 } } numTx_=4294967295 ...} DBBlock+   Â  Â stxMap_ { size=0 } std::map<unsigned short,PulledTx,std::less<unsigned short>,std::allocator<std::pair<unsigned short const ,PulledTx> > >+   Â  Â nextBlock_ empty std::shared_ptr<PulledBlock>-   Â  Â fmp_ {current_=shared_ptr {lastSeenCumulated_={...} fetch_=FETCH_NONE (0) filemap_=0xec27b9f8692f2700 <Error reading characters of string.> ...} [1 strong ref] [default] ...} FileMapContainer-   Â  Â  Â  Â current_ shared_ptr {lastSeenCumulated_={...} fetch_=FETCH_NONE (0) filemap_=0xec27b9f8692f2700 <Error reading characters of string.> ...} [1 strong ref] [default] std::shared_ptr<FileMap>-   Â  Â  Â  Â  Â  Â [ptr] 0x000000005ad12f50 {lastSeenCumulated_={...} fetch_=FETCH_NONE (0) filemap_=0xec27b9f8692f2700 <Error reading characters of string.> ...} FileMap *-   Â  Â  Â  Â  Â  Â  Â  Â lastSeenCumulated_ {...} std::atomic<unsigned __int64>   Â  Â  Â  Â  Â  Â  Â  Â fetch_ FETCH_NONE (0) FILEMAP_FETCH+   Â  Â  Â  Â  Â  Â  Â  Â filemap_ 0xec27b9f8692f2700 <Error reading characters of string.> unsigned char *   Â  Â  Â  Â  Â  Â  Â  Â mapsize_ 15458524216405398507 unsigned __int64   Â  Â  Â  Â  Â  Â  Â  Â fnum_ 82 unsigned short+   Â  Â  Â  Â  Â  Â [deleter and allocator] default std::_Ref_count_base+   Â  Â  Â  Â  Â  Â [Raw View] 0x000000004186a2f8 {...} std::shared_ptr<FileMap> *-   Â  Â  Â  Â prev_ 0x00000000154bf8e0 shared_ptr {lastSeenCumulated_={...} fetch_=FETCH_ACCESSED (2) filemap_=0x0000000021b70040 "Ã¹Â¾Â´Ã™\x1ef\x2" ...} [941 strong refs] [default] std::shared_ptr<FileMap> *-   Â  Â  Â  Â  Â  Â [ptr] 0x0000000069977950 {lastSeenCumulated_={...} fetch_=FETCH_ACCESSED (2) filemap_=0x0000000021b70040 "Ã¹Â¾Â´Ã™\x1ef\x2" ...} FileMap *+   Â  Â  Â  Â  Â  Â  Â  Â lastSeenCumulated_ {...} std::atomic<unsigned __int64>   Â  Â  Â  Â  Â  Â  Â  Â fetch_ FETCH_ACCESSED (2) FILEMAP_FETCH-   Â  Â  Â  Â  Â  Â  Â  Â filemap_ 0x0000000021b70040 "Ã¹Â¾Â´Ã™\x1ef\x2" unsigned char *   Â  Â  Â  Â  Â  Â  Â  Â mapsize_ 134020078 unsigned __int64   Â  Â  Â  Â  Â  Â  Â  Â fnum_ 81 unsigned short+   Â  Â  Â  Â  Â  Â [deleter and allocator] default std::_Ref_count_base+   Â  Â  Â  Â  Â  Â [Raw View] 0x00000000154bf8e0 {...} std::shared_ptr<FileMap> *+  iter {iter_={db_=0x00000000003baaa0 {env=0x000000000038f000 {dbenv=0x000000000581ed80 {...} threadTxMutex_=...} ...} ...} ...} LDBIter &+  db 0x00000000003baa10 {baseDir_="C:\\Users\\Chris\\AppData\\Roaming\\Armory\\databases" genesisBlkHash_=...} LMDBBlockDatabase *+  bfa {blkFiles_=shared_ptr { size=270 } [3 strong refs] [default] blkMaps_={ size=2 } lastSeenCumulative_=...} BlockFileAccessor &  fnum 82 unsigned short+  brr {bdRef_={ptr_=0x0000000065ebbb90 "R" nBytes_=16 } totalSize_=16 pos_=16 } BinaryRefReader  offset 555597 unsigned __int64  size 155478 unsigned intFirst off, fnum, offset, and size look good. I verified that they point to the beginning of block 258860, and that the block file doesn't appear corrupted. At the very least, the merkle root is correct.Here are two things that pop out at me though. pb.fmp_.current_->filemap_ and pb.fmp_.current_->mapsize_ are clearly invalid, perhaps something is overwriting them? IIUC, bdr.ptr_ is calculated from filemap_ and offset, and so bdr.ptr_ is invalid, and it's what eventually gets passed to memcpy() which causes the access violation.Another thing that looks strange is that I thought (I could be wrong) that bdr.ptr_ == filemap_ + offset, but in the locals above it's not (or multiple things are getting overwritten?).I'm not quite sure where to go from here.... whatever happened, it may be too late at this point in the debug to find. Glad you found it!Electrum is definitely not compatible (and as jim618 already mentioned, MultiBit HD only works with the first account).The three wallets which MZ mentioned above should have worked, even with multiple accounts. If you're missing an account in one of those wallets, you could have tried manually adding new accounts and it should pick up the transactions in the accounts as you add them. If it doesn't, I'd consider it a bug... Do you mean as a stop-gap prior to implementing an HD wallet (specifically in Bitcoin Core), or in lieu of implementing it [HD]? That's very generous of you (especially considering I haven't actually helped yet )! The amount doesn't matter (much ), the sentiment absolutely does! Thank you!!If you're dealing with really big sets, there are a few things that can help (if you haven't noticed them already).the "--no-dupchecks" command-line option: saves a lot of RAM. Doing duplicate checking isn't very effective for MultiBit Classic .key files anyways.the "--max-tokens #" command-line option: if you limit the max # of tokens per guess, it can drastically reduce the # of permutations.the "--threads #" command-line option: the # defaults to the number of cores your CPU has, but sometimes using number_of_cores + 1 is a bit faster.That number sounds right. My Desktop (an c. 2012 quad-core) would take about a week to run through that. Painful, but not impossible IMO.If you're running into memory issues or crashing, definitely use the "--no-dupchecks" command-line option I mentioned above. If there's some other sort of crash, could you post the full error message you're getting? Got it.You can actually use the same method as in the first post you referenced, with a few small changes.1. Use at least 13 words (more is OK too).2. Enter the result into Electrum 2.x to see if the result is valid (via a wallet restore). If it's invalid, the button to continue will be grayed out.3. Use one of these two methods to modify your seed, and return to step 2 to see if it's valid:Add a 1 digit to the end (with or without a space, doesn't matter), or increment that digit.Re-roll the last word.On average, you need to perform step 3 about 130 times before before you end up with a valid Electrum 2.x seed, however it's possible that you could need fewer or many more. For example, there's about a 14% chance you'll need to do step 3 500 or more times....Also, be sure to take note of my response in that other thread, which remains important for generating an Electrum 2.x seed: Here is a way to do this: https://bitcointalk.org/index.php?topic=973997.msg10644190#msg10644190 As I'm sure trasla and the other Mycelium devs know, exporting a single private key has hidden dangers which can lead to a loss of some or even all funds stored in the account. The conscience decision to not support this feature is a very wise one.EstefanTT, if you're not familiar with using external tools as trasla mentioned, you're likely not aware of the dangers involved (so just don't do it ) Fair enough, but "Grow up" is about as offensive as "you guys are mean". IOW, it looked like shots returned. You could have just said "don't feed the adolescents"  The first mildly offensive thing fabiola! has posted amongst a sea of puerile adolescent testosterone, and you think fabiola! is out of line?! Wow....Welcome to the boy's club, fabiola. I believe one thing valiron is talking about is the practice (which I recall reading about, I've no idea if it's still in use, or ever has been) of pool operators sending out work for empty blocks to their miners immediately after a new block is found, to get the miners working on the new chain ASAP, and then creating a non-empty block & merkle tree at their leisure and updating miners once it's ready. Yeah... unfortunately, MultiBit Classic is one of only two popular wallets that uses no key stretching to improve brute-force resistance (well, I suppose that's "fortunately" for you ). Electrum is the other one. MultiBit HD (still in Beta) for the most part fixes this.It also helps that btcrecover by default spawns one worker process per CPU core on your machine.Encoded in binary, 32 out of the 33 bytes of a private key are uniformly distributed (the first is typically a flag byte to indicate whether or not the corresponding public key is compressed). However, MultiBit chooses to write the private keys into a .key file not in a binary format, but in a WIF-encoded format (which is then stored in plain ASCII). (This is to maintain compatibility with Bitcoin Core's import/export format.) It's easy to check for such a key, and extremely unlikely for such a correctly formatted key to appear at the beginning of an incorrectly decrypted .key file. It's so unlikely, that's why btcrecover only bothers decrypting the first 16-byte block.I'll be around tonight (it's now early evening where I live), so let me know if you have any questions!-Chris FYI Electrum implements SPVÂ—Electrum servers cannot "invent" non-existent transactions.Electrum servers could withhold one more transactions, however because there are multiple servers operated by (allegedly) independent parties, multiple parties would have to collude to pull this off (or someone would have to control your Internet connection). +1 for MZ's answer.However, Coinbase does have a new multisig option (which isn't the default, you have to go looking for it). I haven't checked it out yet, but if it's what it says it is, I'd consider it a good option if you use their multisig wallet, and only that. It seems to be a work in progress: https://github.com/bitcoin/bitcoin/issues/5761 You're right, the merkle root spans both SHA-256 (512-bit) blocks, so you must recalc the entire SHA-256 from scratch.Byte lenÂ  Â Byte posÂ  Â Bit posÂ  Â SHA blockÂ  Â Field4001version324321previous block header hash32362881-2merkle roothash4685442time4725762nBits4766082nonce80640(end) Electrum handles passwords with non-ASCII fairly well. (It never crashes, but it (as well as most wallets, even Bitcoin Core) has a problem in that it doesn't normalize them.)It also seems to handle non-ASCII wallet file names OK too.It doesn't handle non-ASCII usernames, but when I tested it, it just crashed on startup, so it didn't behave the way bitokman described.I couldn't figure out exactly what was wrong. If bitokman responds with their operating system, I'll try to describe how to run Electrum from a terminal in order to get a more specific error message.
That's a good first step, you've just admitted that you are capable, like the rest of us, of making mistakes (nobody should be respecting 10 people all of whom are easily bribed).Absolutely not! However your rational are choices are limited. As with any argument based in science or logic, you can either:Educate/fund yourself to the point where you can make investigations and an assessment on your own, orAsk someone you trust who has the relevant education/funding for their opinion.I have never, not once, been into space. Yet I still believe there is (practically) no air in space. This is mostly as a result of the second choice above.When it comes to this particular thread, I have enough of a background in math to easily follow gmaxwell's reasoning, and to largely dismiss valiron's.The larger problem is the hubris which valiron seems to be displaying. If valiron were a troll, this would be expected. If valiron is simply having trouble following gmaxwell's reasoning, s/he should take a moment to consider that maybe s/he wrong, given the number of opponents there are. So.....key files are encrypted with AES-256 (in CBC mode), which is a block cipher. It operates on blocks of exactly 16 bytes.In order to deal with the case where a plaintext isn't a multiple of 16 bytes long, encryption tools often append additional padding bytes to the end of the plaintext to make it a multiple of 16 before encrypting it.A very common padding standard (at least in the Bitcoin world) is standardized in PKCS7. MultiBit and openssl both use this style of padding.When openssl decrypts a ciphertext, its exit status is zero (as you already know) if the decryption "succeeds", and non-zero otherwise. When a (properly encrypted) ciphertext is decrypted with the wrong key, the output should appear completely random. To check if a decryption succeeded, the only thing openssl can check is whether or not the padding at the end appears valid as per PKCS7.After reading the description of that padding standard (linked above), you may notice if a plaintext is one byte short of being a multiple of 16 bytes long, the padding that must be appended is a single byte of value 0x01. That means that any ciphertext that happens (by random chance) to decrypt into a plaintext which ends in a 0x01, openssl has no choice but to assume that the decryption succeeded.In short, about 1 in every 256 (actually slightly higher) decryption attempts will result in positives from openssl, even though they may be false positives.btcrecover uses additional knowledge about what's in a decrypted .key file to throw out these false positives. Actually, btcrecover only bothers decrypting the first 16-byte block (in the interest of speed), and then it looks for a properly "WIF" encoded private key. This also has a chance of false positives, but it's on the order of 1 in 300 billion... much more palatable .Thanks! Tips always appreciated!  I don't understand.... I was trying to imply "we're all alts of of gmaxwell" as being the third option (however unlikely IMO).Into my "chart"? I'd rather think that if a government wanted to pollute this thread with puppets, they'd all be in support of valiron's FUD, not against it. They are, for the most part, very different.Miners (partially) calculate a double SHA-256 hash of some input.Vanitygen is based around a bunch of much slower elliptic curve based math (plus also requiring an SHA-256 calculation, which takes relative little time).Mining ASICs would unfortunately not be useful. I can't directly answer your question as I'm unfamiliar with that bash script, but I can offer an alternative.This sounds exactly like what btcrecover was designed to do. Instead of calling them "stems", it calls them "tokens".There's a tutorial available here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorial. As the quick start says, it's a big tutorial, but you can skip a lot of it. It sounds like the first two or three parts of The Token File section would be relevant, and so would the section on Expanding Wildcards for adding numbers onto the end.If you have any questions, please feel free to ask (full disclosure: I'm the dev of that tool).And of course, good luck! valiron,Nobody's perfect. Everyone is wrong sometimes, even gmaxwell, and even you. But consider for a moment this bar graph:Either:You are wrong, and everyone else is rightYou are right, and everyone else is wrongSomeone has launched a Sybil attack against youIt takes an enlightened individual to conclude that they are likely in err despite that they may not realize why. If 10 people I respect tell me I am wrong, I have to accept that conclusion even if I do not understand why.Of course, I would seek to understand why I am wrong, but it is not the onus of these other 10 people to be my teacher. (The fact that gmaxwell has voluntarily chosen to try to teach you, and has shown so much patience in the process, certainly says something about his character.)I mean no disrespect. I only hope that you can be this type of enlightened individual. Wumpus (a Bitcoin core dev) noticed the same thing last year: http://bitcoinstats.com/irc/bitcoin-dev/logs/2014/09/11At the time, he identified them as connections from Blockchain.info, and suspected that it was a bug (of Blockchain.info's custom software).It seems likely that the connections with that "/BitCoinJ:0.12SNAPSHOT/Satoshi:0.2.0/" user-agent are (still) from Blockchain.info: here's one (edit: oops, forgot the evidence link, here it is) from March with an IP of 37.187.136.15. Note that markets.blockchain.info currently resolves to that same IP.That was my first thought too, however the log messages are a little misleading. That "us" IP is the IP which the remote peer claims to be connecting to, however this IP is simply added to the payload of the version message by the remote peer. Nothing restricts the remote peer from lying or being buggy (as seems to be the case here).(FYI it's there to help bitcoin clients identify their "real" public IP in the case that they're behind NAT). It has something to do with using a non-English letter somewhere, maybe a non-English letter in your username? I'm not sure yet.What is your operating system? democrite,If you want to start messing with your MultiBit folder, you must be careful with what you do and don't deleted.These three items are safe to delete:Code:"multibit CHECKPOINT File""multibit SPVCHAIN File"the "log" File folderThese critical items you must back up:Code:Every WALLET Filethe "multibit-data" File folderThere are some other files in there too, they contain preferences and transaction notes you've added. They're not critical to back up, but there's no reason to delete them either; just leave them alone.If I were you, I'dÂ 1. close MultiBitÂ 2. take a copy of the two critical items above, just in case (right-click & copy, then go to another folder e.g. My Documents, right-click & paste)Â 3. delete the three deletable items aboveÂ 4. re-install the latest version of MultiBit (v0.5.18) from here: https://multibit.org/ I thought it was going to be a lot shorter when I started on it.... oh, well  If you've never set a password, you should be able to open one of your wallet backup files (they're ".wallet" files). If that doesn't work, you can try creating a new empty wallet, and importing one of your private key backup files (they're ".key" files).More info on where to find your ".wallet" files and your ".key" files is available here: https://multibit.org/en/help/v0.5/help_fileDescriptions.html Also, much better alternatives can be purchased for about the same.... I wouldn't worry too much.... but here's some more detailed info. TL;DR: just read the bolded parts.Armory's KDF & encryption for SecurePrint looks approximately like this:(in short, it generates a random SecurePrint code, runs that through a KDF with good key stretching, and then encrypts your master private key.)constant_pi = SHA-256(SHA-256('3.1415926...'))Â  # an arbitrary constantconstant_eÂ  = SHA-256(SHA-256('2.7182818...'))Â  # an arbitrary constantStep 1/3: create the SecurePrint code from the master privkey and chaincode--------ext_master_privkey = master_privkey + chaincode# ext_master_privkey is now 64 bytes long and has# 32 bytes of entropy (the chaincode contributes zero entropy)code = PRF(key=ext_master_privkey, message=constant_e)# where PRF is similar to HMACSHA-512; it requires 2 SHA-512 computations.code = code[0..6]Â  # truncate to 7 bytes longcode = code + SHA-256(SHA-256(code))[0]Â  # append a single check bytecode = base58_encode(code)# code now has 7 bytes of entropy (not 8 as the code comment says inside Armory)Step 2/3: key stretching--------key = KDF(passphrase=code, salt=constant_e)# where KDF is similar to ROMixSHA-512 using ROMix# (a memory-hard mixing function) as defined in the scrypt paper;# it's hardcoded here to use 224 bytes (16 MiB) of RAM# and require 224 / 64 * 1.5 = 393216 SHA-512 computations.Step 3/3: encryption--------encrypted_privkey = CBC-Mode-EncryptAES-256(encryption_key=key, salt=constant_pi[0..15], plaintext=master_privkey)So, brute-forcing a SecurePrint code would take, on average, about:Â  Â  224 / 64 * 1.5 * 27*8 / 2 = 1.5 * 273 â‰ˆ 1.4 * 1022 Total SHA-512 operationsWhat you'd probably like to do next is use these results to approximate how long / how much $ it would take to brute-force a SecurePrint code. Unfortunately, that's really hard (for me, anyways) to approximate.You can't compare Armory's KDF to SHA-512 (Bitcoin) ASICs because Armory requires 16MiB of memory to do its work. Comparing Armory's KDF to scrypt (e.g. Litecoin) ASICs might seem better, but... Litecoin uses 128x less memory than Armory's KDF. It also uses the much faster Salsa20/8 hashing algorithm, somewhere around 15x faster per block (but it uses more of them). Finally, Armory doesn't use the full scrypt... it uses a portion of scrypt (ROMix), and a modified portion at that.To make things even more complicated, you can tweak the numbers above via a space/time tradeoff according to this formula:table_sizeÂ  Â = 224 / 64Â  # number of hashes stored in RAM when no space/time tradeoff is usedmem_required = 224-nÂ  where n is in 0..18 (mem_required is in bytes)SHA-512 operations per guess = table_size + 0.5 * table_size * (1 + (2n-1) / 2)For the sake of a comparison to the Bitcoin network, let's pretend we can build an Armory KDF ASIC that holds just 16 hashes (has 1024 bytes of memory per parallel attempt, so not much more than 0), you set n=14, and get:SHA-512 operations per guess = table_size + 0.5 * table_size * (1 + (214-1) / 2) = 262144 + 131072 * (1 + 8,191.5) = 1074069504SHA-512 operations to brute-force = 1074069504 * 27*8 / 2 â‰ˆ 286 â‰ˆ 7.7 * 1025If we apply the entire Bitcoin network's hash capability of 3.5 * 1017 H/s to this problem (and it's all been magically converted to Armory ASICs, and we assume that SHA-256d costs roughly the same to calculate as SHA-512), we get:7.7 * 1025 HÂ  /Â  3.5 * 1017 H/sÂ  â‰ˆÂ  2.2 * 108 sÂ  â‰ˆÂ  23 years (on average)Of course, maybe we can build ASICs with more RAM than this and speed things up, but presumable there'd be a point of diminishing returns; I really have absolutely no estimates on that topic, and my guesses on time/spcace tradeoffs in ASICs are probably wildly off.All of the above is missing several important assumptions:Â 1. The encrypted printout was stolen (e.g. by a snooping printer), but the SecurePrint code was not.Â 2. Either:Â  Â a. The encrypted wallet file was also stolen (we need access to the chaincode, which is always stored unencrypted, to figure out if a guess is correct), orÂ  Â b. We can do EC scalar multiplications and address lookups in the blockchain at the same order of speed as the code guess rate (3.3 * 108/s in this wild example), which is yet another very tall order; figure around 10,000 32-core servers, or additional specialized ASICs.The reason for (2) above is that there's no way, just by looking at a decrypted private key, if the guess we tried for the code is correct unless we have something to check it against (either the chaincode or the blockchain, and the latter would require EC math which is also hard). Kudos to the Armory devs for not using any padding during private key encryption, which is different from every other wallet I've ever looked it.I, for one, am not particularly concerned (but of course, keep your backups safe and offline! ) I'd only consider non-custodial wallets (where you control your own private keys) and HD wallets (for easy backup).I like GreenAddress.it. It has packaged apps (which are all just packaged HTML & JavaScript) for Android, iOS, and Chrome for desktops, as well as being accessible from any modern HTML browser. They also have a still somewhat experimental SPV wallet for Android called GreenBits, although it's missing some features available in the (non-SPV) GreenAddress.it apps/web page. It does support QR codes, even w/o one of the apps.It may not be convenient enough for you though.... they never store your copy of your keys on their servers, so if you want to use it on a new device which doesn't have the keys already cached (and encrypted) locally, you need to type in (or scan) your full mnemonic. I see it as a security feature, but others may see it as an inconvenience.The only other option I'd consider is Hive Web. It also has packaged apps for Android and iOS (but not for any browser), and can be accessed from any modern HTML browser. It also doesn't store your keys online (for better or worse).Comparing the two, Hive has a simpler (IMO) interface than GreenAddress.it. On the minus side, it's not multisig and therefore can't offer 2FA nor GreenAddress's optional centralized "instant confirmations". It has no QR/camera integration, although it can display QR codes and it does support its "waggle" address sharing feature with other nearby Hive users. It also doesn't support multiple accounts based on a single mnemonic, nor does it support read-only logins as GreenAddress.it does (which is nice for public terminals, as long as your OK with the potential loss of privacy). (FYI Hive for OS X is something completely different & incompatible.)I wouldn't touch blockchain.info (for security reasons) nor BitGo (for philosophical reasons).Finally, although both Coinbase's and Coinkite's default wallets are custodial, they also have multisig options you may want to consider (I've never used either and so can't comment).Just my 2Â¢.... Certainly there isn't (and I'm happy that some people realize this); there isn't even an "official" desktop wallet.I'm sorry that I'm not directly answering your question, but web wallets have at least one big disadvantage. Even if they're non-custodial (if you control your own private keys), they're still auto-updating.With iOS (actually I'm not entirely sure about iOS) or Android, the application author must log into their Apple/Google account in order to upload a new version of their wallet (which then gets reviewed, signed by Apple/Google, and then finally published to the store).With web wallets, no such extra layer of security exists. If a hacker manages to break into the web-wallet's website, they can upload their own version of a web wallet which steals your password and/or your private keys.In other words, with apps or browser plugins, a hacker has to first break into a Google/Apple server or a Google/Apple account. It's not an insurmountable goal by any means, but it is more difficult. That's why I'd avoid them if I were you.Of course, there's always a security/convenience trade-off. It's just that whatever convenience you gain in using a web wallet (vs. a mobile or brower-plugin wallet) is pretty small IMO compared to the security you gain from using a mobile/browser-plugin wallet. The Cisco 2900 XL series is painfully outdated... they're not even GigE capable (well, there are GigE modules you can plug in, but your module is a 100BASE-FX module). If memory serves, they also don't have per-VLAN bridging tables, which can be a very confusing cause of problems in certain setups.IOW... I don't mean to be rude , but this thing is pretty much worthless. It'd probably cost you more in just power to keep something like this plugged in for a year or two than to just buy a new or lightly used cheap 24-port switch in its stead.(also, this is quite off-topic for this subforum....) Looks like you can blame this one on Google pip versions prior to 1.4 (which you three apparently have) will inadvertently install pre-release versions of libraries uploaded to PyPI, and Google uploaded a broken pre-release of Google protobuf on May 1st (here's the bug report).Luckily, the are two easy work-arounds. (1) upgrade pip (this option will overwrite the system-provided pip):Code:sudo pip install --upgrade pipor (2) force pip to install the most recent stable version of protobuf:Code:sudo pip install protobuf==2.6.1After doing one of the above, just install Electrum normally. You might find this thread on the topic of some interest: https://bitcointalk.org/index.php?topic=682842.0;allPersonally, I'm fine with a well-shuffled deck of cards. I agree with the latter half of your statement, but not the former. Please read this earlier post.... Have you tried sideloading it from the windows store here?
In other words, whenever Electrum saves the wallet file, it does a normal delete, and then creates a new wallet file. If OP shredded his wallet file, he only shredded that most recently saved file. Other older copies of the wallet, as deleted by Electrum, might still be on the drive somewhere. Even if he did, that doesn't mean his seed is definitely unrecoverable as you imply.Electrum, until recently, truncated the wallet file before writing to it for each wallet save. This could leave the (possibly encrypted) seed in multiple blocks on the drive, depending on how often Electrum saved the wallet file, even if he shredded it. (Newer versions of Electrum create a new wallet file, and then unlink the old one, again leaving the seed in potentially multiple blocks).MZ's questions are good ones. democrite,There are two good suggestions by shorena and jim618 which you seem to be ignoring.Meanwhile, you've responded to a possibly dangerous suggestion by Rude Boy. Exporting/importing private keys isn't necessarily a bad idea, but it's possibly dangerous if you don't know how to securely handle sensitive data, or if you don't know what Rude Boy means by "shred" (which has a very specific meaningÂ—it doesn't mean delete). IOW, if you're not an IT person, I probably wouldn't follow Rude Boy's advice.Please be careful.... A short FYIÂ— as of Python 2.7.9, setup tools/pip are (finally!) bundled w/Python (see PEP 477). Right, it doesn't increase the entropy, it's there to make it possible to detect if a seed is valid or not. If you mistype a word during a restore, it can (with a 99.6% probability) detect that your seed is invalid and warn you.Because I'm old and forgetful? Seriously though, I only meant that I think it's foolish to depend only on your memory to protect your bitcoin funds. I see no problem if you also have it stored (in hard copy) safely. It is referring to that, but the format that MultiBit HD expects isn't at all obvious.Here's a short Python one line script which creates such a timestamp, but be sure to estimate your wallet creation date on the older side when asked for it.Code:python -c "from datetime import *;r=lambda s:int(raw_input(s));d=((date(r('Year: '),r('Month: '),r('Day: '))-date(2009,1,3))).days;print '{}/{}'.format(d,d%97)"If you don't already have Python installed, just visit here and press the run button: http://repl.it/mHe Quoting from that very same post (which had already been linked by grue above, BTW):Also, for Bromium Labs: Sounds to me like that might be a bug....Just a suggestion: if you're only using different accounts for keeping funds separate, it might make more sense to use the built-in multiple accounts feature (near the bottom of the settings page). pedrog,Your post is irrelevant because OP was never infected by CoinVault, but rather by TeslaCrypt which is completely unrelated.Had you read either the very first post or the very last one (above), you would have seen this, but you did not. Do you not have a "Show other logins" option just below the PIN field? That's not good. Do these return anything? (don't post anything sensitive / anything that might be a key!)Code:ls -l ~/.electrum/wallets/strings ~/.electrum/wallets/default_walletAlso, you didn't answer if you have your seed written down, do you? That's cause I messed it up (and didn't even bother testing it) Can you give this a try?Code:python -c "import ast;import sys;ast.literal_eval(open(sys.argv[1]).read().replace(\", '\",\",\n'\"))" ~/.electrum/wallets/default_wallet This should give a more specific error message:Code:python -c 'import ast;import sys;ast.literal_eval(open(sys.argv[1]).read().replace(", '",",\n'"))' ~/.electrum/wallets/default_wallet(FYI I'm assuming 1.9.x based on OP's initial traceback.)Also, do you have your seed? When an update occurs, the result is a hash of the entire tx history.To determine what changed, you need to do a get_history.The idea is that wallet software can cache the result from watch_address, and only issue a get_history when the hash changes. Did you do a permanent delete? If not, it might be in your Windows "Recycle Bin".Even if it's not, for 0.2 btc, I'd try a freebie undelete utility like Recuva. May as well, it's easy to try, and it can't hurt....FYI restore points in Windows don't typically cover the %appdata% directory.Not very convenient with Bitcoin Core, considering you'd need to update all of those backups for every 100 new addresses or outbound transactions you make.... If you click on the "?" next to the Amount field, it will tell you that you can type a "!" for the amount, and Electrum will fill in the correct Amount and Fee for you. Although you could export your private keys from Bitcoin Core and then import them into a new Electrum wallet, you'd be missing out on a number of important features.A likely better option is to create a new Electrum wallet, write down the seed (very important! it is your backup), and then send your bitcoins from Bitcoin Core to an address in your new Electrum wallet.For example, one benefit of doing it this way is your seed backup: it is all you'll ever need to restore a corrupted/lost wallet. If you export/import your private keys, you can't use a single seed to backup/restore your wallet.Also, just FYI, Bitcoin Core version 0.11 will (sometime around July?) probably include pruning support. When enabled, it'll reduce the storage requirements by a factor of about 30x. If you want to remain a bit more standards-compliant, it sounds to me that what you'd want is wallet software which:Â  1. Creates multiple BIP-44 accounts from a single seed, and allows you to export the account extended private keys.Â  2. Allows the import of an individual account extended private key.In practice, this doesn't get you very far today. The only wallet software I'm aware of which can easily do (1) is Mycelium for Android, and the only wallet software which can easily do (2) is Mycelium for Android and Electrum (on the plus side, the two are compatibleÂ—you can export an xprv from Mycelium into Electrum and result in the same keys/addresses).If you'd like to stick with the Bitcoin Wallet for Android, I think what you're doing is about as good as you can get.I'd be a bit worried too.How does it respond to a protobuf with no deterministic seed at all (it's an optional protobuf record, after all)? That should be a bit safer if it works, yes?Also, I wonder if you could "trick" Bitcoin Wallet into accepting a BIP-44 account? In other words, generate a BIP-44 account at m/44'/0'/#', and then create a protobuf with m/0' equal to the generated xprv, and also include m/0'/0 and m/0'/1'. Do not include either the deterministic seed nor the key at path m (just to make sure Bitcoinj doesn't overwrite m/0' with the wrong xprv). toddball,It's great to hear you managed to recover most of your files w/o even having to pay a ransom!Although you may not need it now, did you see grue's post?It links to a decryption utility for TeslaCrypt posted just yesterday by researchers over at Cisco, which may or may not work depending on which version of TeslaCrypt you have. It might be worth a try to recover your remaining files.Even if it doesn't work, they're trying to improve it to work on newer versions of TeslaCrypt as well, so you may want to keep an eye on their blog for future updates. Translation contributions are handled via Transifex: https://www.transifex.com/projects/p/bitcoin-wallet/As improvements are made in Transifex, they are eventually copied down to a new version of the app (but it takes some time).I checked the translations you mentioned above, and they are all either (1) already translated in Transifex and waiting to be copied down to the app, or (2) untranslatable due to current software limitations. IOW, you can sign up for Transifex if you like and make a request to become a translator for Bitcoin Wallet, however there's not currently any untranslated French text.If you're interested, here are the two translations that are pending (I've no idea if they're correct, and don't have access to change them even if I knew better):again = de nouveauTo protect your privacy, your address will change once it receives a payment. = Par souci de confidentialitÃ©, votre adresse changera aprÃ¨s avoir reÃ§u un paiement.The other three are the untranslatable ones (due to current software limitations).I don't mean to be discouraging.... I'm sure there are other projects that would be delighted to have some help with translation. For example, Lighthouse doesn't have any French translation yet: https://www.transifex.com/projects/p/lighthouse-app/
Your degree clearly wasn't in reading comprehension. OP stated the exact virus name in the first post  Regarding localbitcoins.com, were you looking in the "Buy bitcoins online in United States" section here, which typically works anywhere in the U.S. via Western Union, Moneygram, or branch cash deposits (ignore OKPay, Perfect Money, WebMoney, etc., they'll probably just make things more complicated)?Also, DannyHamilton suggested he may be able to help you out directly: https://bitcointalk.org/index.php?topic=1037805.msg11193629#msg11193629. He's a widely trusted user on Bitcointalk.org, see here (and also a trusted escrow agent, see here), you should consider his offer.P.S. I'm very sorry this is your first experience with Bitcoin , but I do hope you'll stick around once this mess is settled. Sounds like you have a pretty good handle on things .It depends on your use case, but yes there can be an incentive. If someone you're sending a tx to also controls your exit node, they may be able to convince you that a tx never went through, and that you need to send another. If Electrum chooses different UTXOs for the second tx, then you've been successfully scammed. It's probably more a theoretical attack than a practical one for most people....That's a good idea, assuming that 2 of 2 or 2 of 3 is flexible enough for OP. Your welcome It is a valid concern. I don't know about Windows, but on Linux and BSDs the good news is that it's very much understood as a valid concern, and as much as possible is done to prevent deterministic RNG results: https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/char/random.c?id=refs/tags/v3.15.6#n52Is it enough? I honestly don't know, it's a difficult problem.... I'm not clear if TAILS + Electrum is a good thing. Electrum servers do not require TLS. A malicious Tor exit node could spy on your transactions (but of course not trace them back to you easily), and I believe it could also prevent you from seeing transactions (whichever one(s) it chose). It can't easily fake the existence of transactions, nor lie about transaction contents/values though. Assuming your 128 bits of entropy are from a good source, there's no significant known difference in security between the two today.However, Electrum 2.x's master private key -> individual private key derivation process (a.k.a. BIP-32) is more conservative/paranoid then Electrum 1.x's derivation process. I don't think anyone knows if this more conservative approach might one day be an actual security advantage or not. I certainly don't know the answer to that one....BTW, all this talk of seed security pales in comparison to the use of cold storage. IOW, if you're not already planning on cold storage, 128 vs 256 or 1.x vs 2.x just doesn't matter. It's like worrying over how lock-pick-proof your door is even though you leave your window open....  are you planning on cold storage? Electrum 1.x binary seeds are 128 bits long. They are (AFAIK) the only format that Electrum (1.x or 2.x) can easily restore from which is that short.You could download Electrum 1.9.8 and have it create a wallet for you (after creating it, you can upgrade to Electrum 2.x), and then run the get_seed code above, or if you wanted to generate your own by hashing with SHA-256 a well-shuffled deck, I think either would be fine. Keep in mind that it's a bit dangerous since any malware that manages to get access to your binary seed as you manipulate it can steal your BTC, e.g. you don't want it accidentally stored in your .bash_history, or anywhere else for that matter. For old-style (Electrum 1.x) wallets, type this in the console:Code:wallet.get_seed(gui.password_dialog())For new-style (Electrum 2.x) wallets, it's:Code:wallet.get_master_private_key('x/', gui.password_dialog())Please note that for new-style wallets, if you keep only the master private key (and later restore from it), there's no way to get the mnemonic (seed words) back. This isn't a problem from a bitcoin funds point of view, but it might be an inconvenience in the future if you ever want to use your mnemonic as a backup later.A Bitcoin private key has at most 128 bits of security. There's no advantage of using more than 128 bits of good entropy, however it's very hard to know if your entropy is good or not.If you're not certain of your entropy source, it might be beneficial to use more entropy. IOW, if you have 256 bits of entropy from some source, and if that source actually (unbeknownst to you) has only one bit of entropy for every two bits of output, then you end up with a 256 bit number with only 128 bits of entropy. In short: longer can't hurt, especially if the entropy source is questionable, though it may be inconvenient.Using the --entropy option with poor entropy does hurt: entropy entered via this method replaces some of the entropy (or all of it for the restore method) normally gathered from the OS. If your provided entropy is worse than what the OS can provide, this could be a problem.Note that you can use the --entropy option with, say, a deck of cards (which is easier than dice IMO), see here: https://bitcointalk.org/index.php?topic=973997.msg10644190#msg10644190. If you're truly paranoid, you could ask for a 256 bit seed, and use the method in that last URL to provide 128 bits of entropy from a shuffled deck. That way, you'd get 128 bits from the deck, and 128 bits from the OS. In addition to the OS's CSPRNG (either /dev/urandom or CryptGenRandom), it also mixes in:Please note that it only uses the sources above if you're creating a wallet via the GUI. If you're using a simple script (e.g. the one I posted a couple of days ago for creating a wallet from a deck of cards), it only uses the OS's CSPRNG for additional entropy.FYI Bither is the only other wallet I know of which goes to similar lengths for collecting additional entropy like this. First off: pretend that "IANAL" is added to every single opinion you see below. With that said....Is the AGPL enforceable? I've absolutely no idea. It's probably the most copylefty license out there, though.Is ATI's application of the AGPL to armoryd's JSON-RPC interface enforceable? Again, no real idea, although it seems like a stretch to me.Is ATI's desire clear? Yes, unless a principal at ATI steps forward with a different statement, I'd say it's pretty clear. They don't want anyone using armoryd with an Internet-facing service unless you open-source that service, or seek an alternate license from ATI.Will I ever use armoryd for such a project? Almost certainly not; I find the terms of such use far too burdensome. (not that this is a threatening a statement... I have no particular uses in mind as I write this)Perhaps, but there are plenty of options released under a multitude of licenses out there. Some are completely closed-source (I don't touch those), some are source-code-available but not open source (I avoid them too), some are copyleft and some are permissive. ATI is free to make it's own choice. I think the marketplace is fully capable of choosing winners and losers from the bunch.Although I didn't read his post that way, the fact is that every piece of copyrighted content (rightfully) carries this inherent threat if misused. Of course I'm happy to argue that copyright law needs a major overhaul in my country (U.S.), but that doesn't change the current state of things.Just in the interest of not starting a flame war , is it OK to limit this thread to ATI's particular choice of license, and leave out the more general copyright/left/permissive debate?Still not a lawyer here, but I'm nonetheless quite confident that your licensing terms are unenforceable, and so I'm daring to ignore them.We do share a similar opinion, though: the thought that everything which touches armoryd's JSON-RPC interface is tainted by AGPL is too copyleft for my taste. I was personally less interested in a legal interpretation, and more interested in ATI's intent when choosing the license they've chosen (so that I and others can respect that intent). You've made the intent perfectly clear.Thank you for taking the time to respond, it's much appreciated. They've been doing a good job keeping people up to date over on Reddit: http://www.reddit.com/r/Bitcoin/comments/31o5zn/mycelium_ios_wallet_status_update/cqkglk1 Do you mean that you had two accounts set up in Mycelium, both from the same seed?If so, and if you're desperate, there is a way to import your second account into an Electrum 2.x wallet. I'll write up some instructions if you like, however:it's not very safe, since you'll be dealing with your seed and an extended private key,therefore after doing this sort of import, you should probably transfer all your btc to a new wallet and stop using the old one.Let me know.... Armory is released under the Affero GPL v3 software license.According to the GPL FAQ:(emphasis mine)IOW, it seems likely that software which uses armoryd's RPC interface is probably a separate program which can have a different license or even be closed source, but short of some new court decision, it's not entirely clear. If such software isn't considered a separate program, then it must also be licensed under Affero GPL v3. Furthermore, if such software is accessed over the Internet (e.g. an armoryd-based block explorer, storefront, etc.), then the entire source code must be made available for download (as per the Affero GPL).So, I'd like to make a small request: could this be clarified one way or the other, perhaps right in the armoryd.py file itself? It is possible to extract your mnemonic (seed) from an Android Wallet backup file, and then use it to create a MultiBit HD wallet (via its restore option) which has the same addresses/private keys. However....messing around with your mnemonic can be dangerous (from a loss-of-funds/malware point of view)MultiBit HD is still in Beta and not yet recommended for everyday useit requires the latest version of MultiBit HD (Beta 8, it won't work with earlier versions)If you still want to proceed, see here for more info on extracting your mnemonic: https://github.com/gurnec/decrypt_bitcoinj_seed Along the lines of what picobit was thinking, here's a Python script to do this.It will ask you for a new wallet password, your entropy (e.g. "3s ad 9h tc 4d"....), and whether or not you'd like it to add additional OS-supplied entropy, and then it will ask Armory to create a wallet file (in its usual location).It needs to run on a machine which already has Armory installed. If you choose not to add additional OS-supplied entropy, be certain you only run this on an offline/cold storage machine. Please close Armory before running it, and when you start Armory after running it the new wallet will be listed in the GUI.Code:import sys, os# Try to add the Armory libraries to the path for various platformsif sys.platform == "win32":Â Â  Â progfiles_path = os.environ.get("ProgramFiles", r"C:\Program Files") Â # default is for XPÂ Â  Â armory_path Â  Â = progfiles_path + r"\Armory"Â Â  Â sys.path.extend((armory_path, armory_path + r"\library.zip"))Â Â  Â # 64-bit Armory might install into the 32-bit directory; if this is 64-bit Python look in bothÂ Â  Â import structÂ Â  Â if struct.calcsize('P') * 8 == 64: Â # calcsize('P') is a pointer's size in bytesÂ Â  Â  Â  Â assert not progfiles_path.endswith("(x86)"), "ProgramFiles doesn't end with '(x86)' on x64 Python"Â Â  Â  Â  Â progfiles_path += " (x86)"Â Â  Â  Â  Â armory_path Â  Â  = progfiles_path + r"\Armory"Â Â  Â  Â  Â sys.path.extend((armory_path, armory_path + r"\library.zip"))elif sys.platform.startswith("linux"):Â Â  Â sys.path.append("/usr/lib/armory")elif sys.platform == "darwin": Â # untestedÂ Â  Â sys.path.append("/Applications/Armory.app/Contents/MacOS/py/usr/lib/armory")from armoryengine import PyBtcWalletfrom CppBlockUtils import SecureBinaryDatafrom hashlib import sha256from getpass import getpass# Hack to prevent Armory from overwriting an existing wallet filedef open_noclobber(name, mode='r'):Â Â  Â if 'w' in mode:Â Â  Â  Â  Â if os.path.exists(name):Â Â  Â  Â  Â  Â  Â raise IOError("won't overwrite existing file '{}'".format(name))Â Â  Â return open(name, mode)PyBtcWallet.open = open_noclobberpassword = getpass('Password>')if not password:Â Â  Â sys.exit('A password is required')if getpass('Verify password>') != password:Â Â  Â sys.exit("Passwords don't match")cards = raw_input('Cards> ')if len(cards.replace(' ', '')) < 50: Â # 2 letters per cardÂ Â  Â sys.exit('Requires a bare minimum of 25 cards')entropy = sha256(cards).digest()if raw_input('Also add additional OS-supplied entropy (Y/n)? ').lower().strip() == 'n':Â Â  Â wallet = PyBtcWallet.PyBtcWallet().createNewWallet(plainRootKey=entropy, securePassphrase=password, doRegisterWithBDM=False)else:Â Â  Â wallet = PyBtcWallet.PyBtcWallet().createNewWallet(extraEntropy=SecureBinaryData(entropy), securePassphrase=password, doRegisterWithBDM=False)print 'New wallet created with ID', wallet.uniqueIDB58(consider it released under The MIT License) I didn't interpret OP's post way... I thought OP was saying that Electrum somehow found their wallet even though OP didn't copy it from the old HD to the new and didn't do a restore. I also think cards are the easiest way, but they do have some pitfalls. See here for a good discussion on how to shuffle well enough to provide sufficient entropy: https://bitcointalk.org/index.php?topic=682842.0 ...and...Don't put your faith in password estimators (read the rest of this thread), but if you insist on doing so, at least use one of the others mentioned here. howsecureismypassword.net isn't very good.edit: actually, it's terrible. For the password "passwords99", it has an estimate of 1 year! zxcvbn estimates that same password at 16 seconds, much better. I admit I didn't read the referenced papers, however that conclusion is ridiculous. A simple 8+ byte random salt as already used by most* Bitcoin wallet software today easily defeats rainbow table attacks.* Electrum (1.x and 2.x) and MultiBit HD are two notable exceptions of wallets which don't use salt.
I don't understand.... when I try "my name is" in the one I linked above (zxcvbn), I get back 5 hours. More on point, it turns out the first one (my1login.com) is using the same underlying zxcvbn javascript library (but maybe a different version of it).Regardless, the answer to "who is right" is: nobody. As the article I linked above discusses, estimating crack times of a password is very hard, and often attackers have access to resources (e.g. gigantic n-gram tables) which are just too impractical for javascript checkers like these to include. I agree, however "strong enough password" is a difficult thing to measure. Also, the list of transactions is not password protected for most wallets (there are exceptions).WEP and Wi-Fi Protected Setup PINs are both completely broken, and have been for a number of years.WPA1/2-TKIP (uses an RC4 cipher) has a number of weaknesses, including a practical data injection weakness and an almost-practical plaintext recovery weakness.WPA1/2-CCMP (uses an AES-128 cipher) has no serious weaknesses, however it doesn't use a very good KDF which lends itself to offline brute-forcing attacks when weak passwords are used. This is especially true if a common SSID is also used (because it makes rainbow table based attacks possible).(The AES cipher is believed to be very secure; there are no known practical attacks against it, although there are some concerns about the key scheduler in AES-192/256 (but not 128) possibly being vulnerable to related-key attacks one day; good news is that only poorly designed software uses related keys). As long as we're talking about favorite strength checkers, here's mine: https://dl.dropboxusercontent.com/u/209/zxcvbn/test/index.htmlIt's the open source javascript-only checker used by Dropbox. There's a description of its strengths and weaknesses here: https://blogs.dropbox.com/tech/2012/04/zxcvbn-realistic-password-strength-estimation/ What versions of the OS are/were on both hard drives?Did you use any migration tools, such as Windows Easy Transfer?Do you use any backup tools?Is you PC in a domain (is it a business PC)?Are you using Windows Server Essentials (Small Business Server) on your network?Do you have both hard drives plugged in at once? Which HD is the new one and which is the old one (I mean their names, e.g. "C: is the old one, D: is the new one")?What is the result of doing this (feel free to X out anything sensitive if you'd like, such as your username):Â 1. Start, type "cmd", press enter.Â 2. type "set", press enter. Aside: Great post, Bizmark13!How fast an "ordinary" computer can try passwords varies greatly depending on the wallet software and the brute-forcing software. Here's a spreadsheet which has some comparisons of several popular wallets & two open source brute-forcers running on a mid-range quad-core desktop machine:https://onedrive.live.com/redir?resid=584f122ba17116ee%21295Guess rates vary between 20 per second (Armory, CPU only) all the way up to 4,000,000 per second (older blockchain.info wallets, GPU accelerated). Some wallets would be even faster (Electrum, MultiBit Classic) if an open source GPU accelerated version were available.For Bitcoin Core, guess rates vary between roughly 40 and 2,000 per second depending on whether or not GPU acceleration is used (and of course depending on the CPUs and GPUs). This is called a "known-plaintext attack". Every wallet I've seen to date uses the AES cipher which is believed to be invulnerable to this type of attack, sorry: https://en.wikipedia.org/wiki/Known-plaintext_attack#Present_day Do you have any recollection of your password? If so, you might be able to use one of the tools in this thread, or you could hire a service to try to recover your password. The first message about 'ecdsa' isn't the big problem, the second one about 'A mandatory option is missing' is a problem. pywallet is expecting another '--some-option' at the command line to tell it what to do.... so the question is what would you like pywallet to do?(Also, like MZ said just above, --help gives you a list of all things it can do, one of which you need to add after --wallet="wallet.dat") Thanks, that's a great diagram.Please excuse my ignorance, but does the plus to the right of Ch have three inputs, and is this considered a single operation on an ASIC? I think that's the 6 vs 7 additions per round discrepancy.Also, should the message expansion step be included (creating Wt, the 48*3 from above)?Should the final hash value creation be included (the 8 from above)? Are you sure of those numbers? For example in a naive implementation, I'm counting 48*3 + 64*7 + 8 = 600 additions for a single SHA-256 block. There could be better ways of doing SHA-256 that don't naively follow the standard though... I wouldn't know.... That's perfectly fine, even if you use the same wallets (created from the same seeds) on both systems.nerioseole alluded to one aboveÂ—Electrum 2.x uses a different wallet format. If you give it a 1.9.8 wallet file, it will upgrade it to the new format behind the scenes (the seed remains the same). If you ever want to copy this 2.x wallet file to a machine that has Electrum 1.x on it, you'll need to instead either:Use a backup from Electrum 1.x, orsimply restore from the seed. We're comparing 5 seeds tracking thousands(?) of full nodes vs 14 Stratum servers... 14 > 5, and 1000 > 14Â—it's difficult to judge which is more decentralized IMO.That's a good point, but conversely collusion among Stratum servers, with their small count, is easier (and likewise for dns seed servers).I think it's too hard a comparison to reach a conclusion of one method being more "secure" than the other. Of course, the factoid doesn't say "more secure", it more carefully uses "perhaps somewhat more secure", so if you still think "or header-only clients" should remain, I'll just drop this  Isn't the source of the block headers and Merkle branches for SPV the Stratum servers?IOW, with Electrum you're registering your addresses with one or more Stratum servers (out of 14 I think globally, if that matters) for tx notification purposes, and you're asking for blockchain headers and Merkle branches from those same servers for SPV.With P2P clients, you're submitting bloom filters to one or more full nodes (out of thousands globally) for tx notification purposes, and you're asking for blockchain headers and Merkle branches from those same servers for SPV.I'm definitely not an expert on Stratum, so I could be wrong here, but these two methods appear fairly similar to me (except for registering individual addresses vs. a bloom filter). Newly created Electrum 2 (and its betas) wallets now conform to BIP-32, including the key serialization format. Electrum 1 wallets and wallets restored using seeds created by Electrum 1 continue to use the old serialization format.In the new format, serialized extended keys are always 111 characters long (the linked standard incorrectly states "up to 112 characters" for some reason). Thanks for clarifying, I didn't realize that. I suppose if it's effectively an ad, and is accompanied by the standard ad disclaimer, then it's not really a big deal if it's a bit inaccurate.  I just happened to come across a "factoid" (actually MZ pointed it out) that seems inaccurate to me:That last clause "or header-only clients" is what seems inaccurate to me. Could someone point me to a rationale for that clause, or alternatively recommend how we could get it removed?I find it a little bit concerning because it might encourage Electrum's use over a P2P SPV client, and AFAIK there's no tx-validation-security reason to do this. There may be a reason to prefer P2P SPV clients when it comes to privacy issues vs Electrum/Stratum. I like GreenAddress/Greenbits too, FWIW, although I do find it a bit confusing for beginners. Of course for mobile use, its 2FA is only effective if you have a separate phone/laptop/PC for the 2FA bit. They have in the past covered users' losses when the fault was bc.i's, but nobody knows if they would have been able to do so during the last big one if not for johoe's saving 870btc on behalf of bc.i, nor if they'll be able to afford their next big one (which of course I hope will never happen!).That's the whole problem. People who don't know any better trust that bc.i is both honest and competent. While the former seems likely IMO, the latter does not, and you need to have both to prevent loss.I agree, and that's what I find unfortunate. There are more secure online alternatives.Electrum's model would have some security benefits over a P2P SPV model if the Electrum servers were required to use SSL, but they aren't. As it is, I see no security benefits. P2P clients d/l headers & merkle branches from 8-ish full nodes (out of thousands globally), and Electrum clients d/l headers & merkle branches from 8(?)-ish Electrum servers (out of 14 globally). Could you or Adslot be more specific on why you think otherwise?Electrum's model does have a privacy disadvantage when compared to P2P SPVÂ—AFAIK, Electrum doesn't use bloom filters for monitoring addresses. That's a version 1 (what the code refers to as version 0 IIRC) encrypted wallet. There have been several different encryption schemes used for this wallet versionÂ—the only way to differentiate them is to try them all, and see which one works.The schemes have some shared attributes: the payload is stored base-64 encoded, the first 16 bytes is used as both the KDF's salt and the encryption mode's IV (and the rest is the ciphertext), the password is UTF-8 encoded (it's not normalized), and the KDF is PBKDF2-SHA1. The scheme differences, in most recent to oldest order, are:the KDF iteration count is 10, encryption is AES-256 in CBC mode with ISO 10126 padding (same as version 2 wallets, but with a hard-coded iteration count)same as the above, but the iteration count is 1the iteration count is 1, encryption is AES-256 in OFB mode with ISO 7816-4 paddingLikewise, the second-password encryption has gone through a number of schemes; I think they parallel the ones above, but I'm not sure and don't have the details readily available.The second password is also stored hashed inside the wallet file, and I do have the details of the various hashing schemes (again, password is UTF-8 encoded, most recent to oldest):the salt is the sharedKey field (the literal string, not the underlying UUID bytes), the hash is PBKDF1-SHA256 with an iteration count of 10 (same as version 2 wallets, but with a hard-coded iteration count)same as the above, but the iteration count is 1the hash is SHA256(password) (unsalted) I don't understand why ppl still still trust bc.i. They've had more than their fair share of bugs[1][2][3], some of them serious and/or inept which have lead to actual btc loss.All three of the wallets I mentioned above are SPV and decentralized: the Schildbach wallet, breadwallet, and Bither. Electrum is also SPV, but it's not as well decentralized/worse privacy (no bloom filters). Greenbits is also SPV; it adds 2FA in exchange for being centralized, and it's a good (if somewhat confusing) option.[1]: https://bitcointalk.org/index.php?topic=581411.msg9888800#msg9888800[2]: https://bitcointalk.org/index.php?topic=581411.msg9940868#msg9940868[3]: https://github.com/bitcoin/bitcoin.org/pull/663#issuecomment-64975087 The very definition of spam.
The kernel version has absolutely no effect on the build output (as long as it supports LXC, which has been around for several years).Both.... Bitcoin Core hasn't always used Gitian, but I was guessing (tbh) that it would be possible to find an older version that was using Gitian but wouldn't be easy to reproduce today.I know he's discussed it in an issue on GH at least once as a desirable feature, but I've no idea if it's under serious consideration. (He is happy accepting pull requests, tho ) The terminology gets confusing because I think you and I are use the word "guest" in different contexts.... but yes that all sounds right. The "guest" of the hypervisor can be anything that you can run Gitian on, including Debian, Gentoo, etc. If this guest machine is a Linux machine, the build machine which runs underneath it can be an LXC container (otherwise it needs to be an "inner" KVM or VirtualBox). If using LXC, these two machines share the same kernel.The build machine's OS must be whatever the project says it is.Perhaps you're right, it shouldn't, but it does. When you first run make-base-vm, it does the equivalent of an 'apt-get dist-upgrade' on the build (innermost) machine. Each time you run gbuild after that, a new clone of the base-vm is created (and not updated again) and used for that build.Builds are reproducible, and multiple people, if they run make-base-vm within a reasonable amount of time of one another, will generally see the same results. However builds are not completely deterministicÂ—if you try to build today a particularly old version of, say, Bitcoin-Qt, you may end up with a different result than is available for download. It's unfortunate, but it's just the way it currently is.This is partly vmbuilder's fault, which creates VM images by downloading and installing (via debbootstrap) .deb files from the package archives (as opposed to say using .deb files from an ISO), and perhaps partly the fault of Canonical who doesn't guarantee that old versions of updated packages will always be available in the archives.On the plus side, builds from newly created base-vms will pick up security fixes pushed out by Ubuntu. There seems to be a bit of guessing going on in this thread.... regardless OP, you are unfortunately right. The Schildbach wallet will not import private keys. It can sweep the current UTXOs, after which it discards the private key.Regarding whether or not the Schildbach wallet is solid: I certainly think so. While there may be other wallets that offer some useful features not offered by this one, the Schildbach wallet offers superior privacy compared to any other android wallet (that I'm aware of). Only breadwallet for iOS offers similar privacy features. Edit: I forgot about Bither, sorry.... Perhaps you missed something above? You can use Wheezy as the Gitian host, you just need a workaround as mentioned above by josephbisch.The instructions for building Bitcoin Core contain two very relevant sections:Setting up Debian for gitian buildingInstalling gitian (includes the mentioned workaround)After that, gitian handles downloading and creating the Ubuntu guest LXC, which runs fine on Wheezy. You could try Xen -> Debian/Ubuntu host -> LXC guest *sniff* *sniff*....Nope, completely fails the smell test.Also, it doesn't help that you rudely crossposted (a.k.a. advertised) in at least three different subforums?! There are (at least?) two proposals mentioned.This one is more about how a payee can prove that an address they give to a payer in fact belongs to the payee (and hasn't been modified by a malicious third party), and at the same time:the address can be generated in a "complicated" way, such as from an HD and/or multisig wallet;the payee does not need to publicly publish something new for each new address (they only need to publish a single "master verifying key"*)the "master verifying key" is not a BIP32 master extended public key; in other words it can't be used to violate the privacy of the payee / generate other addressesThe method of publishing this "master verifying key" isn't detailed in the above proposal, but DNS is mentioned as a possibility, in which case the spec recommends it be signed by a DNSSEC zone signing key.This proposal is is about the DNS side of things. It mentions some of the concepts mentioned in the above proposal, but doesn't really detail them. It does detail the DNSSEC issues though.The two seem like they should be linked to one another, but they're (currently) not (just because they're still drafts? don't know...). For example, the first proposal talks about BTCA DNS resource records (for which google can't find any spec), while the second details PMTA records.* I just made that "master verifying key" term up, the spec uses more precise terms That sounds like a frequently asked question to me  Oh... you're using ecryptfs-style home directory encryption. That makes things a lot more difficult and also a lot less likely to succeed. I just tried running a test where I overwrote 5 encrypted files and deleted 5 others, and then tried to recover them, and it didn't succeed for any of them. Short of a professional service, I doubt you have much recourse (and even then it seems unlikely).  I'm actually glad to see you post this. You might recall the PM I sent you back in October? What I didn't say is that I had a second identity in mind of who I thought you might be...: David. Of course I hoped I was wrong about that (and think I am ). You are entering your password when asked, correct? After that, it should take 10s of minutes before it completes and displays another shell prompt (if I got it right).Are you copying and pasting the line (there are a number of different quote characters, it'd be easy to get one wrong if you're not copying and pasting)?What does this give you?Code:df ~It should give you two lines like this, or is it different?Code:FilesystemÂ  Â  Â 1K-blocksÂ  Â  Used Available Use% Mounted on/dev/sda1Â  Â  Â  Â  8640920 6298256Â  Â 1880688Â  78% / Do you mean that you created a new empty Electrum wallet, and the code doesn't find it?Does it take a while to finish running, or does it return right away?Is your wallet file saved in the default location? pywallet will not find Electrum seeds or xprvs.For Linux, run this in a terminal to search your drive:Code:sudo strings -100 `df ~ | tail -1 | cut -d' ' -f1` | egrep '"x/1?": "|"seed": "' | egrep -v '"xpub|strings'If it outputs any lines, save them and let us know how many "seed" or "x/" lines it found. On Win 7, it should look something like this (note the path at the top); does yours look different? It sounds to me that OP only ever set one password for this wallet, and forgot it... if so, that wouldn't help...(Also for the most part the Windows "previous versions" feature only works for documents if you've set up Backups, which isn't all that common....)And now for a somewhat on-topic shameless self-promotion: btcrecover (a password recovery tool) supports Armory, and has some advantages (and disadvantages) compared to the script supplied with Armory (faster, more flexible, harder to use), although it's not any more useful in this case, sorry....edit:That's great! You can just ignore all the rest above  Yes, as of version 4.0, but please be aware that if you used to run a 3.x version and then upgraded to a 4.x version, your wallet and its backup will contain both HD keys and "loose" keys, the latter of which are not backed up by the seed.If you run it as so, it prompt you for info in the terminal and will not do any GUI.Code:./decrypt_bitcoinj_seed.pyw bitcoinj-wallet-fileIf you'd rather use it as a library, you can do something like this:Code:import decrypt_bitcoinj_seedbackup_password = '...'Â  # or None if you've already done the OpenSSL-style decryptionspending_pinÂ  Â  = '...'Â  # or None if there is no spending PINwith wallet_file as open('bitcoinj-wallet-file', 'rb'):Â  Â  wallet = load_wallet(wallet_file, lambda arg_ignored: backup_password)mnemonic = extract_mnemonic(wallet, lambda arg_ignored: spending_pin)print mnemonic This is an open source tool that will extract the HD seed from a wallet backup file: https://github.com/gurnec/decrypt_bitcoinj_seed (please note that this tool is not endorsed by anyone.... but me -- and it's none too wise to download and run stuff like this from strangers).Given the seed, you can use tools such as this one to derive addresses and keys from it: https://dcpos.github.io/bip39/. Use the "Hive Wallet" derivation path for external addresses/keys. Use "BIP32" with a derivation path of "m/0'/1" for your internal/change addresses/keys.You can also use the seed with a compatible wallet (MultiBit HD, Hive web or mobile, or breadwallet).tspacepilot: I realize you know this already, but it's worth repeating for anyone else reading this... messing around with your seed and keys in such a manner is just asking for trouble / bitcoin loss. It's fine for educational purposes, but that's about it. If you made a typo when recording your seed, this open source tool may be able to help you correct it: https://github.com/gurnec/btcrecover/blob/master/docs/Seedrecover_Quick_Start_Guide.md#seedrecoverpyA warning, though: because it's working with your seed, you need to fully trust the author of that tool (me...), or you need to run the tool on an offline PC (one that's always offline) to ensure that you maintain exclusive control over your seed. Asked and answered over in this thread: https://bitcointalk.org/index.php?topic=981765.0 OP's particular issue doesn't look like it was fixed, but the fix is just a small change. Modify this line:Code:addrStr = str(self.widgetTable[row]['QLE_ADDR'].text()).strip()to something like this:Code:addrStr = unicode(self.widgetTable[row]['QLE_ADDR'].text()).strip().encode(errors='replace')or this if you'd rather use Qt's whitespace stripper instead of Python's (both seem to work for OP's example):Code:addrStr = unicode(self.widgetTable[row]['QLE_ADDR'].text().trimmed()).encode(errors='replace')If an Armory dev doesn't happen to notice this thread, it'd make sense to open an issue on GitHub.
That's definitely not a normal Electrum wallet fileÂ—a normal one would contain a bunch of readable text.I'd suggest you look over here: https://bitcointalk.org/index.php?topic=998480.msg10842688#msg10842688As an aside: this is the third or fourth time in just three weeks that someone has posted about a corrupted Electrum wallet file... I wouldn't call that a pattern just yet, but it's getting close.... Of course, please heed jim618's advice. But that aside for a moment...The "WIF" format encodes whether or not the public key generated from a given WIF-encoded private key should be compressed. See step 2 in the wiki: https://en.bitcoin.it/wiki/Wallet_import_formatAs a result of that step, the WIF-encoded private key will always start with a 5 if the public key should be uncompressed, or with an L or K if the public key should be compressed.If you're dealing with old or unmaintained software, you might find that importing a private key for a compressed public key may be misinterpreted as uncompressed, or may be broken in some other unpredictable way, so please be careful.... I can't speak to why it's not currently working, but if you just want to get the funds out of your wallet and transferred to a different one easily, there is an option for you.Install MultiBit HD Beta from here: https://beta.multibit.org/When you first run it, choose "Restore wallet" (not "Restore password from seed", that's something different), and in the next screen be sure to choose Mycelium in the "which wallet created this seed" drop-down box.Just please be aware that:Multibit HD is still in Beta, and the devs don't advise using it for much beyond testing purposes (although it works for me FWIW)If you've created multiple accounts in Mycelium, this will only recover the firstMultibit HD isn't free; it has a 0.00001 BTC per transaction fee which helps support developmentThere are other ways to get to your bitcoin, but this way is probably the easiest option.Electrum is not compatible with Mycelium seeds. MultiBit HD and Mycelium for Android are the only wallets I'm aware of which are compatible (see here: https://bitcointalk.org/index.php?topic=1000544.0) Do you have your seed words written down somewhere?Are you only using the one default account, or did you create more than one? This sort of question has been asked and answered quite a bit (not trying to be rude) -- there are a lot of bits of code in various wallets / products that will do this sort of thing if you know where to look.If you don't want to deal w/a compiler, what language did you have in mind? If for example your answer's Python I could probably point you to a few places to look. If you're paranoid (like me), you may want to look for a zero-knowledge backup provider. I use SpiderOak myself; their software has always been a little bit twitchy (I probably spend an hour or so troubleshooting it every 6 months), but their security model appears to be pretty good, and their pricing is fair but there are cheaper ones out there. (I do let my wallet files get backed up to them). Exactly.Yes, with the same caveats as most other wallets--Weak passwords can be brute-forced (but Armory's KDF is one of the best among Bitcoin wallet software, so it takes longer/costs more to perform brute-force attacks).Your privacy is lost / transaction history is viewable (this is true of most, but not all, wallets).If your wallet file is stolen by malware, that same malware can probably wait for you to type in your password and then steal it as well.If you lose your wallet file with its encrypted private keys and any single private key associated with that wallet, then all of the private keys in that wallet are compromised (can be computed). This is true of many deterministic wallets. Generally things are easier when using Linux (Host-wise or Guest-wise) thanks to its better coverage of different filesystems and generally easier scripting (PowerShell works great if you're dealing with all Microsoft products (e.g. HyperV), but bash is probably easier in other cases).Also, just about all modern virtualization technologies are designed to be fairly easily scriptable.Having said that, I suspect that running a Hypervisor such as Xen (open source) or vSphere (closed source but free for some uses) with no IP interfaces / no remote management, and then running multiple guests under that (e.g. one for bitcoin and one for general use) probably would add a decent amount of security. Hypervisor breaks aren't unheard of, but Hypervisor devs attempt their best to prevent them.I'd never heard of Qubes before CB mentioned it above, but it looks like this is its approach -- it's definitely something I'll be taking a look at. The receive tab displays the oldest unused address, but if you need to give out a bunch of addresses at the same time, you should give out different ones. In that case, you can choose from the 20 addresses displayed on the addresses tab (IOW yes it's normal). As you use addresses, they will be moved to a subsection of the addresses tab labeled "used" and new ones will be generated to replace those that have been used once.For your password question (and several other FAQs), see here: https://electrum.orain.org/wiki/Frequently_Asked_Questions#Why_can_I_open_the_wallet_without_entering_my_password.3F The armory_xxxxxxxx_.wallet file is your "normal" wallet file; it's what's used by Armory. Its private keys are always encrypted by Armory.The armory_xxxxxxxx_encrypt.wallet file is an private-key-encrypted "digital backup" file which you made at some time in the past; you probably simply forgot that you (manually) made this backup (check its last modified date, it will be whenever you created that backup). It is safe to move this file to another location if you like (or delete it... you did make a paper backup, right? )You can also make a completely unencrypted "digital backup" (by default it would be called armory_xxxxxxxx_decrypt.wallet); if you choose to do so, you'll get a strongly-worded warning about the dangers of making it unencrypted.The wallet format (the "1.0" format) is pretty well documented over here: https://bitcoinarmory.com/wallet-format/The optional encryption (which is always used for normal wallet files and for encrypted digital backups) individually encrypts each 32-byte private key (and only the private keys). Each private key is encrypted with AES-256 in CBC mode with no padding, and a randomly generated IV (stored alongside each private key). The single encryption key is derived from the user's password with a custom KDF based on Colin Percival's ROMix function, except it uses SHA-512 as the mixing function instead of BlockMixSalsa20/8 as originally specified in Percival's scrypt paper (and it also has a few other tweaks compared to ROMix). The KDF uses 16 bytes of salt. (ROMix is the memory-hard part of scrypt.) I don't think this has been answered yet; apologies if I missed it.See here for details on the importwallet RPC command, which imports a bunch of privkeys from a single file at once, and does a single rescan for them at the end: https://bitcointalk.org/index.php?topic=712047.msg8051822#msg8051822 I believe this is a known issue with the standalone executable on some individuals' Windows PCs. It's only a cosmetic problem -- Electrum should otherwise work fine. If it bothers you, you can AFAIK use the Windows installer to install it locally, and this issue should go away.Everything else you described sounds normal to me. No bright ideas from me....The only other troubleshooting step I can think of would be to extract the shared secret from Google Auth, and check to see if it matches the shared secret on GA's side. Doing so would require your phone be rooted, and would require some work on your part (and on GA's).First step: log in, go to Settings -> Security, and click the "Send all nLockTime transactions by email", and save the nlocktimes.zip file you receive via email in a safe place (and be sure to keep your mnemonic around somewhere too, it'll also be required later).Second step: figure out when you can perform the recovery. Use a block explorer to determine the date and the tx height (in blocks) of your most recent tx (inbound or outbound). Assuming you haven't changed the defaults, add 12960 to this tx height, and add 90 days to the date. Set a reminder on your calendar for this +90 days date.Step three: visit here: http://greenaddress.github.io/gentle/, and do a "File -> Save as" to save the web page recovery tool to your PC. Keep it along side the file you saved from the first step.Step four: Wait.... when your reminder date comes nears, check the block height of the most recent block at your favorite block explorer, and if it exceeds the the height you recorded in step two, open the page you saved in step three and follow the instructions. You'll need your full mnemonic at this point as well.The recovery page only works with Firefox and Chrome (but see here to work around a problem when using it with Chrome). I've tested this procedure once in the past, and had no trouble getting it to work (except for the Chrome issue I just mentioned). See here: https://bitcointalk.org/index.php?topic=712047.msg8055660#msg8055660As I said above, I believe that the MultiBit key export format is the same as the Bitcoin Core dumpwallet/importwallet format. Sorry, my bad, I have the pro version and didn't remember it wasn't available without it. Titanium Backup is the exact method I was going to suggest if they were both rooted, but if you're uncomfortable with it, then your last method above seems best to me. (FYI Titanium Backup offers encryption, but only for the paid "Pro" version.)Also if they're rooted, you may want to consider SuperSU as your su app, it can PIN-protect root access which may be more secure if you're using it for 2FA or with an Android wallet. Just be sure to read the docs if you ever decide to uninstall SuperSU to avoid losing root. At least for Beta 7 the "Multiple Accounts" column is correct. I updated the sheet, and while I'm sure you're technically correct, I think it's slightly more confusing now, but I've no strong preference either way. Agreed that Authy vs Google Authenticator (or FreeOTP if you prefer, which is open source) is a convenience vs security & privacy decision.I don't think there's any way to replicate your Google Authenticator into another device unless your first device is rooted (and even then, it might be a little tricky unless your second device was also rooted). No issues that I'm aware of.FYI there's a thread over here whose OP asked a similar question: https://bitcointalk.org/index.php?topic=997474.msg10837889#msg10837889 So this kinda rubbed me the wrong way. I mean nothing personal when I say this, but calling a VM "a lot safer" is IMO a really dangerous statement. Even if it's true that today's malware doesn't try to reach inside VMs to extract sensitive info (and I'm not so sure about that), trying to guess about how sophisticated malware is a year or two down the road is awfully difficult.To prove a point over just how "specialised [a] piece of malware written for the specific setup" needs to be, here's a (PowerShell) script which *almost* grabs all wallet.dat files from any (unencrypted) VirtualBox VMs on a Windows host (whether they are currently running or not). It's got plenty of limitations (it requires that Vagrant and Git for Windows are already installed, it has zero error-checking, etc.), but it's just a proof of concept which hopefully gets the point across.Code:# Add VBoxManage and Git for Windows ssh to the path$env:Path += ';' + (Join-Path $env:ProgramFiles Oracle\VirtualBox)$env:Path += ';' + (Join-Path ${env:ProgramFiles(x86)} Git\bin)# Retrieve the UUIDs of all current VirtualBox VMs$vm_uuids = VBoxManage list vms | Select-String '{(.*)}$' | ForEach-Object {Â  Â  $_.Matches[0].Groups[1].Value}# Configure Vagrant to prepare a CoreOS VM (relatively small, ~200MB)mkdir coreoscd coreosvagrant init yungsang/coreos# Modify the CoreOS VM to use a 30-port SATA controllerAdd-Content Vagrantfile @"Vagrant.configure(2) do |config|Â  Â  config.vm.provider 'virtualbox' do |vb|Â  Â  Â  Â  vb.customize ['storagectl', :id, '--name', 'SATA Controller', '--portcount', 30]Â  Â  endend"@# Download and start the CoreOS VMvagrant up$coreos_uuid = Get-Content .vagrant\machines\default\virtualbox\id -Head 1$next_portÂ  Â = 1Â  # the next available SATA portforeach ($uuid in $vm_uuids) {Â  # for each VMÂ  Â  # Create a (copy-on-write) clone of the VM (works even if it's currently running)Â  Â  VBoxManage snapshot $uuidÂ  Â takeÂ  Â  Â $uuid-snap --liveÂ  Â  VBoxManage clonevmÂ  $uuid --snapshot $uuid-snap --options link --name $uuid-clone --registerÂ  Â  # Add all of the clone's SATA drives to the CoreOS instanceÂ  Â  VBoxManage showvminfo $uuid-clone | Select-String '^SATA .*\(UUID: ([^)]*)' | ForEach-Object {Â  Â  Â  Â  VBoxManage storageattach $coreos_uuid --storagectl 'SATA Controller' --port ($next_port++) --type hdd --medium $_.Matches[0].Groups[1].ValueÂ  Â  }}Start-Sleep -Seconds 10Â  # give CoreOS some time to finish recognizing the new drives# Try to mount every partition foundvagrant ssh -c 'cd /dev ; for D in sd[b-z]?* ; do mkdir /media/$D ; sudo mount -r $D /media/$D ; done'# Record all found wallet.dat filesvagrant ssh -c 'sudo find /media -name wallet.dat -ls' > ..\wallet-files.txt# Remove the CoreOS VM and the Vagrant cached image and configvagrant destroy -fvagrant box remove yungsang/coreos -fÂ  # comment this out if you intend to run this multiple times to avoid the download steprmdir -Force -Recurse .vagrantrm Vagrantfilecd ..rmdir coreos# Remove the VM clonesforeach ($uuid in $vm_uuids) {Â  Â  VBoxManage unregistervm $uuid-clone --deleteÂ  Â  VBoxManage snapshot $uuid delete $uuid-snap}Get-Content wallet-files.txtWrite-Host -NoNewline Press any key to exit ...$host.UI.RawUI.ReadKey('NoEcho,IncludeKeyDown') > $nullSo in just 66 lines of Windows shell code, it lists out all found wallet.dat files -- just one step away from actually uploading them somewhere. This plus a keylogger on the host, and it's game over.Now I'm not even a software dev by trade (or at least haven't been one in a while), so I have to assume that proficient malware authors are going to be a lot more sophisticated about this sort of attack.I don't mean to claim that there's zero advantage to using VMs (more so when their encryption requires an interactive password), but advocating them as a lot safer (or as any kind of alternative to cold storage) sounds really troubling to me.
breadwallet is compatible with Hive (mobile and web, not Hive for OS X), but that doesn't help much since Hive can't sign messages.breadwallet will be compatible with MutliBit HD once MultiBit HD Beta 8 is released (or if you want to compile it yourself), but it is not seed-compatible with Beta 7 due to this bug.Edited to add: those are the only wallets I know of that are compatible with breadwallet. Electrum 2.x is definitely not seed-compatible with breadwallet (Electrum 2.x has chosen to not use BIP-39).In general, compatibility between deterministic wallets is a complex issue. There's a compatibility table available here if you'd like more info: https://bitcointalk.org/index.php?topic=1000544.0 That's a pretty big stash IMO, I don't blame you...Providing this thread to the recovery service (and in particular the example file, and the post about what strings to search for) could help.Best of luck to you.... Here's my best recommendation.If you had a large amount of Bitcoin stored there, I'd shutdown the machine ASAP and send the drive to a recovery professional.If you didn't have enough to justify that, I'd shutdown the machine ASAP, and then boot it off of a Live Linux CD or USB to search the hard drive for the master public/private keys (I'm not sure what the easiest way to do this is because I'm not much of a Linux desktop guy, so no instructions included for this option, sorry...).If you just had a little, download and install HexEdit, (preferably to a drive that's different from where your wallet file is stored), run it and then open your C drive (or which ever drive had the wallet file) using File -> Open Special. Please note that installing anything or continuing to use your PC decreases the chances of a successful recovery. Search for these two text strings one at a time, (no spaces, but double-quotes and colon included):"master_private_keys":"master_public_keys":Just as in the example file I posted above, you're looking for one master_private_keys with the label "x1/" and three master_public_keys with the labels "x1/", "x2/", and "x3/" (you need to keep track of which key which label). Even if you find the bare minimum, I'd keep searching for more until the entire HD has been searched, just to be thorough.If you manage to find them, it may be possible to recover your funds. Let me know, and I'll post the final instructions for recreating a wallet file once you have all four keys.Good luck.... If there's no readable text (like in the example file), then whatever file it is that you have isn't an Electrum wallet file (perhaps due to HD corruption of some sort).If you have no wallet file backups, and no seed backups, recovery will be difficult or impossible.First: you didn't answer an earlier question: was your wallet a 2FA wallet or a standard wallet? If you're using a 2FA wallet (are you?), the seed cannot be recovered from the wallet file (it's not stored in there). Electrum tells you this when you first set up the wallet.You need either your seed or a working wallet file to recover your funds.If you have a completely corrupted / missing wallet file, you might be out of luck.If your wallet file is only slightly corrupted, you may be able to fix it.First (very important), make a backup of it so there's no chance of making things worse.Next, open your wallet file in a text editor (such as Notepad on Windows).It should look something like this:Code:{Â Â  Â "accounts": {Â Â  Â  Â  Â "0": {Â Â  Â  Â  Â  Â  Â "change": [Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03ac0342c7c8f92d41458bdb22f0abec55eedd5aa8f982e8c91318d68631337812", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "021b939f6db543de61e6c18b037c0aea1279a9c47b35b0f5ad6a45060487a99cc9", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03ecc8024843d6da37c1b4a6096f7a30d67518402369d3cbbd8c893ee65672f8af"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02407ab9bd1c32aceb0e42aea0e1ac69ac06fcb070ff8fcacbacb7b08d29cb8cba", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "028d07f31a64365bd63eaf6c3fe8379142264d468975a86376cf9bf861986c1824", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03ffd76f226ccd257a015c9c437b693a5d2edf34e6f2e27d7a0c5ba8c33ac00670"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03f1bbdfe1be7c533e7e789b04b6da25f74a8dcf4c2a2239fc867f63a32965cc64", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02b7b63d7fc1d61124ad9ae0e97c15725c439d6e4d61bb3a3e9c958ebca43ea7e7", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02979116cfc78f395719a5bd8ded064b49e6b5bf89963a5a1d817e8869b459aa7f"Â Â  Â  Â  Â  Â  Â  Â  Â ]Â Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â "receiving": [Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "037f4e76573fb495b0d96d7961e99b588c2bcf58bce2baef094156d62fc0a8cd45", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02d082c279324b606dd925b77daed33a7a9b01355b7d653d0cdfa1e4d4f72eba8d", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03f6e932c7e25f5e40c72c7d981ca76235c0b38f65b7858d41356472549a4c9790"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "025330a72b7311f94e519c679641f783e4f8efc3f9b8b146ba1f03b0689d0e6e5f", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02881777cd44bf1cd724bccdf1a9b2f695b689c2da373b0c842a1ea64522eae277", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "035000d2b358b19566a4ea074a29f9095bb3c15b551783bc5bb632ab8a8a7686c1"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "036b1a078c412f7961eecb49bba365c279c4567ba937805dd9ac34e157f0b47e5a", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "038f22a1e99351b2aa9a482bfebc43890e8f5ac9be7d150d758f063b56ac647715", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02175a44e790b3f3c8e41b8d5275e68f3aa0332f3d6631cbc99842ca723bfd7dab"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0258cc18d2843702bde79bbcf4df74b2aee88ddf9fb4fae03005e7367196a4f69b", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02f3f0237562f79bc95321b7d2c8ca2e946602e29939d9ac87a4cac534e4ca469e", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0388246d6a3c73e9f3aa1e4370ad4f3dd9f20c67ec0fcfabc931151464adda090f"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "025bf61d138fea2e5868049d69bf627de5ed8e4e11daef757b19d1c6ce94f87a5c", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02066c0e6ca63122f8a9e7413658d87dc04814236e999fa6cc6a5da0188ad4f2b9", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02a63fd35ee7373d0b79fee31075d02ff53f11639fbf23a02c6d27fdab9acaf9e9"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "022ae832008e773d2126aadbfee6750827e4ed0d698e2d4700cc4f3c968bf51dee", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03716958ed0073e38584a95d2ec9dad71884e93d8fa482c609ad702fe4157180bf", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "028a8b8f82d97fa5dfc61f065276acd63cca8eb45e9cb4101219db64bf4b1957b0"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "020decc7b97b3e8e355b8dcaa9cf66b2c6d56665d89abc46990d405a634efeeda4", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03b90f527d22a3ac69114ef1646ede9d31bf83fb154f551f0645acdf8a2f581c7f", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "026c59a9fc1c16dc6efc6cac1caa0c1998e9c7a3ce09c0d6cc63a379bf55552f81"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02b300cd992b2020b0a03954191ba8bef1a091cdc468b99212fb1070ad05f8560c", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02038dca3242db4d107b6cf0ac7c5a66b9a9996e14522d8ef3cd836157618e82c8", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03578b8f14ce86902213352da549f985b205800b533a1d1a447d6185ea90848de5"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "038a02fa807574173baa1f13dba508d26958417f209cb8d9564276c9ff05fd3377", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02123ae61fb2dc5f134abf14c217b79c556f65ebe00ea344a54931c118afe663d7", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0324f09a257fe5d583083bbc398495d4f3ecdcf2918a6499dde991262daf270f2b"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0231dfa361f1f805067b7f2846c4fa62d793179f36af0b28ce32ac1cb775e76ae9", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02e8eb42d24274473e3581609a3e7537ac8472fb8ac63e61fda074bf7ca57d5e47", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03d3dd7b39b5fb812e1d8088f5ccc0a50c00cd9f9539a10d1155e71407d609b623"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03b9e4444488511abeb992b682637e971f45d43e1f3256fe9377ac937313c9ec32", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02593b49a6cd93ae929a2ffb14fc97977b144a692b40d4e01da4f43aede8cf4276", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "032412b8383bbd10a2d00ca1fbbc0887c5407e0dc7d0220c61623b8a84df54e6fd"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03db584f5b6d5f7af655b525c800b7826b61f9fd8ba597371a286419a1ebfced73", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0302d0d83b68a618d618a59a2fdb860634fcfc36314b11afd6ac44669101183ae6", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03a1153c84ec94c702e148cc032cfefe17530674ea26568c799cb3a6aea3cdb672"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03db20128d0ba7b1de844663e4072009c9a309cf3405171487dbd56752d99315a0", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "028aba0ea4fb17eb6de96e93c23b3299e4c07d5751cf4782fc73f3dff46542dd2c", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03f30d88ce7743054046c75b558a136a6616a111e48b216e9d81caa5594593ebe4"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "022294e54daa3cb03dc264963fe2697e8372e81882d5b81222f728c1f7f2c1714a", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03f0c9b27946dd3460c2261b6769c3cfbf256eb1dc108965377b9179ada8ee717d", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0310a35c633e14cd3b94021b9928d2a3a71892940df47294e4e5bda52cc60b007a"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "034cb8e3e6b58a123d83882e6c45e86c2ff5eb16fd47c1f1feab7ad177782aafcc", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "022eb76270b1ac47e7701a0d77232446a8406671db39160a086c6740ab35d41c0d", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0347a903bea538bf9e800f1ac59072ae0038bea30e8c3ac3b56c08ab35c9e672c1"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03e565a126627b3ea1e4e5f2ce6064447c9ee2ca37543e27da36cf8dab7355d132", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0279e9538ce91a7386fbec166b17bb42e4ecaba2de8db785b83bb70db6e4db21f7", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "021ec3738cd8889424768babaa46f77a69db027651c90e4132c82f68b8e0b90deb"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "023346f43393acdf93a2ccf92d9f44b4213f6e2aa7a1d9a5b5812ce85ddc6d45a6", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "0238a4deb9f67bf0b8f4bb6045a0ce17782d43a84875c2f4f90742ce745f6a46bf", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02de5065f947ff944114fcc8fb5896efc9712beb7d148c073763de26fb2a9197b4"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02d9e049b552386a66eb08e1ead8f4b55432df9002a7aa3269ae7ff146ab5fd040", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "020983271bc3ea8c466743997d29279e242fbb3c5456b78bc488b657f32079623b", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "022faf4d3d33cbe2b5cc1f20f8750941a4960a58a4c9e8d116801b43f82ebf8b4f"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "020d9ebff72467155429b16ff0042d05b23ce48dcbc1a49f1c47eab18fa1a724ac", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "036fd3c3e38834202c58dc28dba042756bb2d6b87c7b463a570f525a2e7f780226", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "023629847b9e38ef40d5b80526c1ec85dbc793f29026682537794ea7f1a4db2390"Â Â  Â  Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â  Â  Â [Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "03e04943a31bd43d0bd112e59525aa5cc535b26ad9f32ebc92b3424e784cfd28fb", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "02c1fdf9ea0e4a82ba62eeb223b5c114b2190cde7a6578a38e1d3e462d2f9f8018", Â Â  Â  Â  Â  Â  Â  Â  Â  Â  Â "027046fe6d8d01629e48afc5d04d53ef843cfe5378f8550217aeab2434961c4dee"Â Â  Â  Â  Â  Â  Â  Â  Â ]Â Â  Â  Â  Â  Â  Â ], Â Â  Â  Â  Â  Â  Â "xpub": "xpub661MyMwAqRbcF7S3zTDZ1QBaDKi8eUjSETyxtajGrbNKHHoMv8vWt1yiamfQGvRaxcHRovmUzeGqPeySjRL6pKTb57Cu3dSrDaGkFbx7LaB", Â Â  Â  Â  Â  Â  Â "xpub2": "xpub661MyMwAqRbcFTQiUpNzWsZLa9tSpW1ut3Xet7gFUWzydmRzvfr8So9vkhseiftjuCAiMs6X8APqUf2VMp13XEU7fBAmhYoFXpTqxvVupwd", Â Â  Â  Â  Â  Â  Â "xpub3": "xpub661MyMwAqRbcGTQ1T3H5pmertr31JLddqwqVcWedoSFHY3AnjYQUnqiGAhNzofPf22kJXAtJQhmsFXin4T41k4xGLLzCt3RvskGmja4Buoj"Â Â  Â  Â  Â }Â Â  Â }, Â Â  Â "accounts_expanded": {}, Â Â  Â "master_private_keys": {Â Â  Â  Â  Â "x1/": "lvZ5FCGXcS6+qhc2aq9nENE6uEe6DdUJmEruIg30pdKS4doc5at50W5+aH0pkIYVJY1UM3QGoClTCFPxKJXJ/nkP9Vzn3sFHDdie/EbSMKmUDevhj8Wvf3ttfQ3NHTZuXq5twD2mTOLFDuKgcirEFPSp5FzDOQVXvypUhbiVUSg="Â Â  Â }, Â Â  Â "master_public_keys": {Â Â  Â  Â  Â "x1/": "xpub661MyMwAqRbcF7S3zTDZ1QBaDKi8eUjSETyxtajGrbNKHHoMv8vWt1yiamfQGvRaxcHRovmUzeGqPeySjRL6pKTb57Cu3dSrDaGkFbx7LaB", Â Â  Â  Â  Â "x2/": "xpub661MyMwAqRbcFTQiUpNzWsZLa9tSpW1ut3Xet7gFUWzydmRzvfr8So9vkhseiftjuCAiMs6X8APqUf2VMp13XEU7fBAmhYoFXpTqxvVupwd", Â Â  Â  Â  Â "x3/": "xpub661MyMwAqRbcGTQ1T3H5pmertr31JLddqwqVcWedoSFHY3AnjYQUnqiGAhNzofPf22kJXAtJQhmsFXin4T41k4xGLLzCt3RvskGmja4Buoj"Â Â  Â }, Â Â  Â "seed_version": 11, Â Â  Â "use_encryption": true, Â Â  Â "use_trustedcoin": true, Â Â  Â "wallet_type": "2fa"}You're looking for missing syntax. For examplemake sure all of the braces and brackets ( the {s and }s and the [s and ]s ) match up and that there's a closing brace at the very end of the filemake sure there's nothing following the last closing bracemake sure there a comma after each pair of items, except for the last item in a listmake sure there's a colon between each pair of itemsmake sure the double-quotes match upIf you find an error, try correcting it, saving the file and loading it in Electrum. If you can't find an error, you'll need to find someone you trust who understands JSON (that's Electrum 2's file format) who can look at the file for you.If you can't find any problems, you could try getting a more specific error message by doing this:Â 1. Move your default_wallet file to a different directory.Â 2. Start Electrum and let it create a new wallet for you (you don't need it for anything).Â 3. Go to the console tab and type in this:Code:from PyQt4.QtGui import QFileDialogutil.json.load(open(QFileDialog.getOpenFileName(gui)))It will ask you for your wallet file, and then print an error message that may help you find the problem.If you get it fixed, you should create a new 2FA (or standard) wallet to transfer all of your funds to, and this time write down the seed! FYI the new version of Electrum can read either wallet format. If it finds an old format wallet, it converts it to the new format (which actually isn't a whole lot different). There's also an importwallet RPC command that I think can directly read the key export file (with all the addresses at once) created by MultiBit, but I haven't tried it in a while and I could be wrong. Got your PM. It's not obvious what's going on, though.Confirmed that your node is accepting connections on TCP 8333, 3-way handshake succeeded.After the initial connection, my node sent a version message as expected. Your node ACKed receiving the message at the TCP level.At this point, your node should have sent it's own version message to mine, and it should have ACKed the version message at the app level with a verack message. My node received neither.There are no MTU issues (yet) -- all of the initial messages are far under 1481 bytes (the point at which MTU issues might rear their ugly head on an older PPPoE connection).There was no obvious evidence of a transparent proxy (no differing TTLs), but it's always possible.What Bitcoin node software are you running? Do you have any familiarity with tcpdump (I'd be interested if your node was responding at all, and if the response was getting lost, or if it's not responding at all)?Anything interesting in the logs? Are you OK posting (or if not posting, at least PMing) your public IP? Which OS? I'm going to assume Windows 7 or earlier.Try this. To to Start -> Run..., type this and then press OK: Code:%appdata%This will open up an Explorer window. Find the Electrum folder and rename it to Electrum-old (right click, Rename). Then start up Electrum again.If you don't have any BTC in your old Electrum, you can delete Electrum-old at some point (at your own risk). You can't convert an old-style seed with 12 words into a new-style seed with 13 words -- the two are completely different beasts. AFAIK, the old-style seeds will continue to be supported indefinitely.The only potential advantages I could see (and they're pretty minor) of a new-style seed from an end-user's point of view would be:A larger gap limit, by default (not all that useful, given that you can increase the gap limit manually if you have a need for it).Some compatibility with other wallets, for example you can export a master public key from a new-style wallet into a Mycelium for Android wallet (to create a watching-only wallet)... not really much advantage since you can already do that with Electrum for Android.Easier to recover a mistaken word or two; if you're in the habit of trying to memorize your seed (not something I'd ever suggest), new-style seeds are easier to recover if you're off by a word or two.Of course there are many other improvements in Electrum 2.x in terms of other new wallet types, but if you're only interested in having a standard wallet, there isn't a strong argument to create a new-style wallet to replace your old-style one (I stand to be corrected though). Do you mean BIP-39 passphrase support? That's a good idea (It'd probably be a requirement for "full" compatibility, but not for "partial" compatibility).Would it also make sense to add one line for each software/hardware combination, e.g. Electrum/TREZOR, MultiBit HD/TREZOR, myTrezor/TREZOR, etc., since they might offer different levels of support? Or are all TREZORs pretty much the same? (and all btchips, etc.)Unfortunately I don't own any hardware wallets, so that makes it more difficult for me. No worries Sort of.... mSIGNA requires that you install Bitcoin Core (either on the same machine or on some other machine in your LAN) in order to use it. mSIGNA doesn't do any validation itself, it depends on Bitcoin Core for that. So it's a full-validation wallet in practice, even though it shouldn't get "credit" for doing validation. Given that multi-sig is a key component for good 2FA, I couldn't disagree more.... I do believe you both have some reading comprehension issues... GreenAddress.it is an online service.This post just above lists three desktop clients which support multi-sig, one of which (Electrum) is also available for Android. FYI the Developer Options are only visible if you've gone through the unhiding procedure. If they're not visible, then USB debugging is disabled, and you're safe from this attack vector.This is a good list IMO. To help you decide:Some wallets do strong (server-assisted) encryption of the wallet stored on your phone. If you lose your phone, a determined thief who is able to root your phone can steal wallets without strong encryption.Strong encryption: GreenBits, Hive Wallet. Brute-forcible encryption (takes longer than no encryption, but still stealable): Bitcoin Wallet. No encryption (just a PIN check): MyceliumSome wallets offer better privacy than others. Bitcoin Wallet is the best in this category; the other three share your transaction history with a centralized service as part of their operation.Some wallets need to trust a centralized service to tell them about new inbound transactions, and to broadcast outbound transactions on the wallet's behalf. A centralized service could theoretically lie to the wallet -- it could withhold an inbound transaction or make up a fake inbound transaction. Mycelium and Hive Wallet fall into this category. Bitcoin Wallet and GreenBits do not depend on a centralized service for transaction verification.Of those listed, only GreenBits offers two-factor authorization. (Of course, for 2FA to be effective you'd need a second device, e.g. a different phone or a laptop.)All of the listed wallets are shared source, i.e. their source code is published and viewable. However Mycelium is not open source, you may not modify it nor redistribute it yourself. The other three are open source. I'm not sure how you'd go about implementing a watch-only wallet using Armory without having the entire blockchain. Armory is designed to require it. If you want some Python software to implement a watch-only wallet, something Electrum-based might fit your needs better.FYI you don't need to build Armory from source in order to use its libraries, you can just use one of the distributed packages (unless of course your target platform isn't among those supported).I know that doesn't answer your question, though.... sorry I don't know the answer, but my guess would be most of the .py and .pyd files except the BitTornado stuff, although I really don't know the details. You might want to make the distinction between multi-sig providers, where a trusted third party controls one key, and standalone wallets, where you and/or your associates control all of the keys.You might also want to make clear that some online wallets offer optional multi-sig, whereas others require multi-sig.Additional mult-sig providers (whom you need to trust in some ways):https://www.bitgo.com/https://trustedcoin.com/ (also available as part of Electrum's 2FA)Standalone wallets:ArmorymSIGNAElectrum It is... it means it is possible (although a small bit painful) to recover your funds, even in the worst case.tryexcept is a GA employee, I'd wait for his response, perhaps he can help. (edited: oops, looks like he beat me to the punch)I agree, if someone enables only a single 2FA method that offers no recovery option, it would be nice to warn them of potential issues. All of the change addresses (and normal addresses) are covered by the original seed. Hmm... the one time I emailed them, they got back to me the next morning....I'm not sure what the technical issue might be. FWIW it's working for me at the moment.The whole point of 2FA w/multisig wallets is that you can't access them without your 2FA... if there was a simple recovery procedure, that'd mostly defeat the purpose. I take it you only set up one 2FA method, with no backup method?Did you ever add an email address to your GA account (you can't add one now because it requires a 2FA code)? If so, it is possible to regain access to your funds even w/o GA's help but there will be a pretty long delay (probably around 90 days). Let me know and I'll point you towards the directions to do this, in case GA doesn't get back to you.
(26 lowercase + 26 uppercase + 10 digits) ^ 12 = over 3 thousand billion billion permutations (for comparison, that's somewhere around the number of grains of sand on planet Earth). If it was in fact generated randomly, it's completely unbruteforcible.It's somewhere around there, but it depends on the details. For example, if it was only lowercase letters and 10 letters long, and if it was for a wallet that doesn't use key stretching (e.g. MultiBit Classic, Electrum), then it would cost me somewhere around $2,500 - $3,500 USD in compute resources & power to brute force, and it could be done in a few weeks. It might be even cheaper to create specialized software that'd run faster and cost less to run, but that's harder to estimate. You can use software such as this to run bitcoind as a Windows service. If you decide to do so:Use the stopargument/stopexecutable feature to run "bitcoin-cli stop" to shut down bitcoind gracefully.For added safety, you may want to consider changing the user account that bitcoind runs under to either your normal user account, or a new user account dedicated to this purpose. You'll need to add the "Log in as a service" user right (with secpol.msc) to the account, and change the Service config (with services.msc) to log in as that account.Once it's been set up, you can use the standard Windows service recovery options (with services.msc).Edited: I tried to follow my own advice in this post, and I couldn't get it running (it was crashing for some reason shortly after start up). Just a warning, YMMV.... Sorry for my initial flippant response.jackbox is correct (except that there are "only" 2 billion change addresses). After a change address receives its first transaction, a new change address is created, and the original change address is not used again. There's currently little reason to increase this gap limit from its default of 3, it won't effect the way Electrum works with change addresses. (Old change addresses are moved to the Used section once they no longer have a balance.)Note that Electrum will occasionally reuse change addresses. A change address is only considered "used" once it has at least one transaction with two confirmations. If you create two transactions without waiting for two confirmations in between, and if both transactions need to use a change address, then the same change address will be used for both. There's no simple way (without mucking with the console for every transaction) to avoid this in Electrum aside from waiting for two confirmations in between transactions. I suggest that you use the most recent version of Electrum (2.x).... That would give you about 2 billion change addresses. Hopefully that would be sufficient  Close, I think... there are still some wallets which can't import/store private keys with compressed public keys (Armory is the only popular one I can think of).And of course there are plenty of wallets that choose not to include an import function, for example mobile ones, strictly HD ones, etc., but I'm sure you know that already.I'd agree with everything else you said. Thank you for checking, I appreciate it.There's already a comment attached to MultiBit HD's BIP-39 cell which mentions Beta 8 being a requirement. (I'm the same Chris who opened that issue on GitHub ) Offline? Absolutely. It has zero network-related code.You sound like the paranoid type (like me ), so here are some tips.btcrecover doesn't require any binaries for the most part, but for some wallet types, installing some pre-compiled binaries can greatly speed things up (see the Installation Guide for details). I didn't compile any of the binaries, so even if you don't trust me (and you've got no reason to), you only need trust the source of the binaries.But all of that doesn't even matter much if you want to run it offline. Just download the btcrecover .zip file, and the various binary installers you need according to the installation guide, throw them on a USB stick and install them on your offline PC.What does matter, for the truly paranoid like me, is whether or not btcrecover has direct access to your wallet file (ideally, it shouldn't need it). To "fix" this issue, download one of the extract scripts listed here, and follow the directions in that doc to give only that one small script access to your wallet file (also offline). Once you get the extract string, you can give that to btcrecover instead of a full wallet file.The advantage is that the extract script which has access to your full wallet file is small, simple, and self-contained. Even if you're not a Python programmer, you can probably verify that it's not doing anything "funny", has no network code, etc. (as opposed to the rest of btcrecover which has over 5,000 lines of code....) If someone has one of your private keys, they can steal some of the funds in your wallet. If they have one of your private keys, and your wallet file (even if it has a good password), they can steal all of the funds in your wallet.No, not without the wallet file. MultiBit HD isn't (yet) compatible with Mycelium seeds, but it will be once MultiBit HD Beta 8 is released.Another option (which works today) is exporting an account's master private key (its "xprv"), which can then be imported into Electrum 2.x (just paste it into the Restore Wallet dialog). The two downsides here are that the seed is not compatible with Electrum (so you'll need to keep your xprv somewhere safe as a backup), and that you'd need to export each Mycelium account individually to a separate Electrum wallet file (if you have more than one account set up, that is).(More details on wallet interoperability is available here: https://bitcointalk.org/index.php?topic=1000544.0) That would be better, thanks. Fixed. I'm relatively unknown in the Bitcoin world, but I do distribute bitcoin-related software via GitHub written mostly in Python (and some OpenCL). One of the nice things about scripting languages is they're easier to check for shenanigans, as opposed to binaries.None of the bitcoin-related software I distribute via GitHub is in binary form; I wouldn't expect anyone to trust me that much. Instead I ask users to install binary components (such as Python) from sources they do trust.As another example, for EC math that needs to be fast, I ask users to install Armory which comes with some Crypto++ libraries on the assumption that most users trust Armory.Having "official" dynamic libraries available could be useful, especially for Windows or OS X users where the compilation process isn't particularly easy. (Of course, only when they're actually ready for distribution.) If you really want no wallet (e.g. if you're using it with an SPV wallet), you should add the -disablewallet option. Also, I find it less ugly (and easier) to not keep the command prompt window around, so instead you could click Start -> Run (on Win 8, you need to right click on Start, then click Run), and then enter in this whole thing at once and it will start in the background (with no command prompt window):Code:"C:\Program Files\daemon\bitcoind" -disablewalletIt's safer to shut it down using bitcoin-cli stop, e.g. in a command prompt:Code:"C:\Program Files\daemon\bitcoin-cli" stop It does by default, however MultiBit HD calls peerGroup.setUseLocalhostPeerWhenPossible(false) to disable this. Thanks. I don't quite understand yet, but it doesn't surprise me that I'm wrong.... Physical theft is an issue (as I mentioned above), but if you don't understand the security model used by mobile devices, you really shouldn't be offering advice on the subject.... Generally speaking, Android wallets are a bit more secure than PC-based wallets because they're generally less vulnerable to malware. On the other hand, they're easier to lose (so make sure you have a copy of your Mycelium seed somewhere safe).Lots of people claim that a rooted phone is something terrible. It's actually not, if you're careful. A rooted Android phone will ask you before giving an app root permissions (and if you use SuperSU it can even be configured to prompt you for a PIN). If you're the type of person (and you don't sound like it ) that always clicks "Yes" whenever they see a prompt, then rooting isn't for you. But aside from that, as long as you're careful with only installing very popular/trusted root-using apps, and you make sure any root security prompts are from a trusted app that you're expecting, you'd be fine.The real issue isn't is your phone currently rooted, but rather can your phone be rooted? In other words, is there a known Linux kernel vulnerability that makes it possible to root your phone? If the answer is yes, then you have to be very careful about all apps that you install (it sounds like you already are), because any one of them could root your phone without your knowledge, and then it would be free to steal your btc. Practically speaking, this type of attack doesn't seem very prevalent today, but I suspect that will change as Bitcoin becomes more popular....I do, I use GreenBits / GreenAddress.it (same devs, GreenBits is their newer semi-beta app; GreenAddress is their older one).Honestly, the fact that you're asking these questions already puts you head and shoulders above many others.... This is a first attempt at creating a compatibility matrix for deterministic wallets. In other words, it tries to answer the questions:When using two different wallet apps from different devs, will I have the same list of addresses and the same balance if I:use the same mnemonic sentence (seed) in both?export a master private key from one into the other?export a master public key from one into the other (creating a watch-only wallet)?For now, it's an Excel file available for viewing or downloading here: https://onedrive.live.com/redir?resid=584F122BA17116EE%21313.It has four tabs. The first, "Details", lists out (hopefully) all relevant details of various wallets that might make them compatible or not with one another.The next three are calculated from the first; they try to answer the three corresponding questions above. (Sorry, but Excel Online doesn't render vertical text correctly, so they look a bit ugly online. Either download a local file, or hover over the wallet names in the first row to read them; they're in the same order as the wallet names in the first column.)I'm definitely interested if anyone has any input; in particular I'm not at all confident that the Details tab has everything correct, and it's probably missing some deterministic wallets that I'm unaware of. If there are any wallet devs who could take a quick look at their wallet on the first tab to see if I got anything wrong, that'd be great!I'm also not sure that the list of requirements (spelled out on the three right-most tabs) is sufficient to guarantee compatibility.(Also: don't rely on this without doing your own testing first!)I'm not sure where, if anywhere, this is headed, but it'd be nice to turn this into a set of web-based tables on GitHub, perhaps something jekyll-based like this. Again, input is most welcome. I think it would be nice if MultiBit HD allowed you to specify a single full node (out of the 8) as a hint. Specifically I'm thinking of circumstances where someone is running a full node on the same host or local LAN, and would like to make use of it.To a small extent, it could encourage people who are already somewhat interested in running a full node towards doing so (and conversely, not having such an option may encourage people to stop running a full node after upgrading to MultiBit HD from Classic). I think (gentle) encouragement such as this would be a good thing.Alternatively, an option that calls peerGroup.setUseLocalhostPeerWhenPossible(true) would be almost as good IMO.I'm off-topic here... but Electrum connects only to somewhat-centralized servers; it doesn't participate in the P2P network (it does do SPV on what it downloads, though). Can you verify (or refute) that Mycelium checks these 20 lookahead addresses for transactions once every 24 hours? I was trying to read through the code yesterday, and I'm not sure I got it right.Thanks! Doesn't much matter.... even if it's lower-case ASCII characters only, that's still 2616 possible passwords; over 43 trillion billion, putting it far out of reach of any recovery / brute-forcing tool....
Thanks (again) for recommendation, onemorexmr!So what?Now that's different.... luckily:andAgreed: if OP is a thief, or if OP doesn't have any idea of what the password is, then nothing can help. That's not good....If you have no wallet file backups, and no seed backups, recovery will be difficult or impossible.If you had a large amount of Bitcoin stored there, I'd shutdown the machine ASAP and send the drive to a recovery professional.If you didn't have enough to justify that, I'd shutdown the machine ASAP, and then boot it off of a Live Linux CD to search the hard drive for seeds or master private keys (I'm not sure what the easiest way to do this is, though, so no instructions included for this option...).If you just had a little (you're on Windows, correct?), download and install HexEdit, (preferably to a drive that's different from where your wallet file is stored), and then open your C drive using File -> Open Special. Please note that installing anything or continuing to use your PC decreases the chances of a successful recovery. Search for these two text strings one at a time, double-quotes and colon included:"seed":"master_private_keys":If you manage to find one or both of these, along with the string that follows them (as in the example file I posted earlier), it may be possible to recover your funds.Edited to add: if you find one of them, keep searching to see if there is more than one, and save them all in a text file. Your wallet file has for some reason become corrupted.First (very important), make a backup of it so there's no chance of making things worse.Next, open your wallet file in a text editor (such as Notepad on Windows).It should look something like this:Code:{Â  Â  "accounts": {Â  Â  Â  Â  "0": {Â  Â  Â  Â  Â  Â  "change": [Â  Â  Â  Â  Â  Â  Â  Â  "0226e2a67847df6a7f46efe9da8b9f6fc7f7d8023f63eef8d636b38203bc56a2d3", Â  Â  Â  Â  Â  Â  Â  Â  "0389e77e92ca2ab3d721630d2eeef7efc1556fec72dcf0f52b74bf5286a5c4fe94", Â  Â  Â  Â  Â  Â  Â  Â  "03a31d53b340f76a006984638e5260365cf25f8a49beae1dd29e2606d48f3b498c"Â  Â  Â  Â  Â  Â  ], Â  Â  Â  Â  Â  Â  "receiving": [Â  Â  Â  Â  Â  Â  Â  Â  "039bb38c166e55c595891b78325da2025d013ecd5d9694b05e210b48a01168065c", Â  Â  Â  Â  Â  Â  Â  Â  "0351940ad5247586c6dbfbaeadd38dec431cf97ca7af71fa0552e4c77482dfa640", Â  Â  Â  Â  Â  Â  Â  Â  "03b75f7d34f2130983e10127d66377eb1f2b1278db96da33dd390779573b405f87", Â  Â  Â  Â  Â  Â  Â  Â  "03db37551e0dfa2a4c499cd8f64ff3d1f8375fdb7bb8a14af73c6afa7f7a6152b2", Â  Â  Â  Â  Â  Â  Â  Â  "037777a308fa5bb9bb12bd5de31b6a5d21eb0d94067002236a58dd1787504f1bed", Â  Â  Â  Â  Â  Â  Â  Â  "02f86a3fd6a2ea654c1ebc65ce01b13c9a700bf77bcd1742b865e223574047f87a", Â  Â  Â  Â  Â  Â  Â  Â  "03eeb6bd840b2d309254df79cd4554bec50634a897c6f4ff81fbcd87d4f336c8b5", Â  Â  Â  Â  Â  Â  Â  Â  "02a95c72dd2c5e8a7ef70c764e1a51c0f8910abb23201be0a01c47b091d1fb1bf3", Â  Â  Â  Â  Â  Â  Â  Â  "03393270a21090a27c84cab77bb94eaf9ef7e1194ccab43e47c031abdacb840aac", Â  Â  Â  Â  Â  Â  Â  Â  "02fd90ef85469e265326a2a3994daa7d489d2c981d09155021eb58e7bf790ca474", Â  Â  Â  Â  Â  Â  Â  Â  "03c4cc88a3243d663f92350f58a625c94319b210411d75c4ba10e02dceaedd20c7", Â  Â  Â  Â  Â  Â  Â  Â  "02ccf9ee6a6cc63cb28e2ff6e46f3a9fe4d14f8efd139fafd3e91d657670da527f", Â  Â  Â  Â  Â  Â  Â  Â  "0253b5a73f453976414747f1cf0ab6eadabf632d7c51f2504f725fb6fb528516d4", Â  Â  Â  Â  Â  Â  Â  Â  "03ae45504521514c0a675150937a95775abbaee5e99d85b0e7c91231090de55b8a", Â  Â  Â  Â  Â  Â  Â  Â  "0349aa147502380ad458648fb535381a902a05938dfbaee4c75dfe4267a28660f2", Â  Â  Â  Â  Â  Â  Â  Â  "02e22d7e9bdde58ce16627af385df1956091a5e5d0047f356df168df96796adf2c", Â  Â  Â  Â  Â  Â  Â  Â  "03e560201fbf19a32d7de762a49d50d0c20889a2d509d8ba2fd6a45a296c8d61f1", Â  Â  Â  Â  Â  Â  Â  Â  "0310fac886fe32afafedb3183f97c836470bc12610c50915797fd2e729d2eb1d78", Â  Â  Â  Â  Â  Â  Â  Â  "03c800b16bf5787662adfda8dcf0fc99c0f68936c80346c50ec033cf79f0e4ed9c", Â  Â  Â  Â  Â  Â  Â  Â  "028ac1a7dea5856d201405cc8802fb1198b3dc50884c65c7ae4c79e4ae9da369fb"Â  Â  Â  Â  Â  Â  ], Â  Â  Â  Â  Â  Â  "xpub": "xpub661MyMwAqRbcGsUXkGBkytQkYZ6M16bFWwTocQDdPSm6eJ1wUsxG5qty1kTCUq7EztwMscUstHVo1XCJMxWyLn4PP1asLjt4gPt3HkA81qe"Â  Â  Â  Â  }Â  Â  }, Â  Â  "accounts_expanded": {}, Â  Â  "master_private_keys": {Â  Â  Â  Â  "x/": "9B961mYKYFV7Bg1zRYZ8ZGw4cE+2D8NF3lp6d2XPe8r87EE8qxVnv/8UA9PxSopPF41RKg9VWR4iyd/rSA6CusnLvkzU8+5Zy9Gb8Fgnu2HpYc7SXHNhiJp8maQjxMCBo8nhXqU3f855ALJGgVlaZflBN06k8XKgOENtCOLrrP0="Â  Â  }, Â  Â  "master_public_keys": {Â  Â  Â  Â  "x/": "xpub661MyMwAqRbcGsUXkGBkytQkYZ6M16bFWwTocQDdPSm6eJ1wUsxG5qty1kTCUq7EztwMscUstHVo1XCJMxWyLn4PP1asLjt4gPt3HkA81qe"Â  Â  }, Â  Â  "seed": "CBjg2RyTk91VOCO9O+X0XlqUoiiBPrTqMcSIOAlJpBP2N9sSgCABTSli5ecy8vpi8JEG3Tkg6aU0wAj0hs74PadfYjpobJLGkR7bDUH5NwZT16DnKzcdsLhnsuHqK+Qp", Â  Â  "seed_version": 11, Â  Â  "use_encryption": true, Â  Â  "wallet_type": "standard"}You're looking for missing syntax. For examplemake sure all of the braces ( the {s and }s ) match up and that there's a closing brace at the endmake sure there's nothing following the last closing bracemake sure there a comma after each pair of items, except for the last item in a listmake sure there's a colon between each pair of itemsmake sure the double-quotes match upIf you find an error, try correcting it, saving the file and loading it in Electrum. If you can't find an error, you'll need to find someone you trust who understands JSON (that's Electrum 2's file format) who can look at the file for you.If you get it fixed, be sure to write down your seed! Good luck.... Towards the bottom left of the page there's a "lock topic" link you can use if you like (only visible to the OP and to Admins). Good catch, and good point.... it'd be trivial to code up a closed-source app that produced a list of addresses (potentially different for each phone) whose keys are exclusively controlled by the app's dev. There's some truth to that, but...I couldn't agree more, that's some shoddy coding that allowed this. My condolences.... I take it you're not in IT Keeping software (especially security, financial, and web-browsing related) up to date is very important if you don't want to get infected or hacked (and lose your funds). Running old versions of Bitcoin QT isn't "fine", some versions had major bugs: https://en.bitcoin.it/wiki/Common_Vulnerabilities_and_Exposures.I'm not aware of any built-in way inside the Electrum software, but there is a workaround.1. Sign up for a GitHub account if you don't already have one.2. Visit gh-release-watch.com, click Login with GitHub, and authorize gh-release-watch.com to view the email address in your GitHub account.3. In the Watch field, type in this, and then toggle the Not Watching button to Watching: spesmilo/electrum4. Make sure a valid email address has been set.Note: I've never actually used this service before, so I've no idea if it's reliable or not....It's not necessary, but it doesn't hurt either.That's always a good idea, but it also shouldn't be necessary. The only thing to be aware of is that Electrum 2.x will upgrade your wallet format. In order to downgrade to a 1.x version (not that you ever should need to), you'll either need to restore your wallet from it's seed or use a backup from before you upgrade.Side note: if you do remote backups, be sure you've got a strong password on the wallet, or use a zero-knowledge backup provider such as SpiderOak (and a strong password with them). TL;DR - you're probably out of luck....To anyone else reading this: ELECTsUM is apparently a watching-only Electrum 1.x compatible wallet for iOS; I don't own any iOS devices and have never tried it.I'm very confused. I can't think of any way GPG could export anything that looks remotely like an Electrum 1.x master public key, so I can't figure out how you managed to do this....I assume you mean addresses (not that this matters)?Whatever it is you're pasting in, if you got it from GPG, it's surely not a valid Electrum master public key -- that's why the button remains gray. If ELECTsUM accepted what you pasted in as a master public key, then that sounds like a (pretty egregious) bug in ELECTsUM.Regardless of all of the above, if you didn't get a master public key from the official Electrum client, any funds you sent to the addresses displayed inside ELECTsUM are likely lost forever Edited to add: and if ELECTsUM accepts as input something that isn't at least in the right format of an Electrum 1.x master public key (128 hex digits), then shame on ELECTsUM!  Green address at MtGox was the same thing that MZ linked to (what a surprise that MtGox chose to implement something that was a bad idea.... ) FYI a just committed a version with an --exclude-passwordlist option. I'll take a look, but FYI it probably won't be for a day or so. Yes, that's the other "green address" I alluded to; it was a bad idea and isn't related to GreenAddress.it or the Electrum plugin. OK, I didn't realize that. seedrecover.py should be able to read an Electrum wallet file, but maybe there's a bug.Two more questions for you....1. So, seedrecover.py is for when you have an Electrum wallet file, and most of a seed (and you don't have the password), but the seed you have isn't quite right. Is that what you're trying to fix?2. Do you think your password is pretty strong? If so, you can PM me your entire Electrum wallet file and remain safe, and I can try to figure out what the bug is. If your password isn't strong, giving me your wallet file would be dangerous for you.... I completely missed something from your last post, sorry about that....I've got two questions for you.1. Are you trying to use this: (A) https://github.com/gurnec/decrypt_electrum_seed,or this: (B) https://github.com/gurnec/btcrecover/blob/master/docs/Seedrecover_Quick_Start_Guide.md ?2. Can you please post (or PM) your entire wallet file here, but (very important, of course) remove about half of anything that comes after seed or master_private_keys? I have the same issue... it's really not a big deal, and I'm sure there are bigger fish to fry, but it is slightly annoying.Another option might be to change the NSIS script so that it does a IfFileExists before a CreateShortcut, that would at least fix it for me if it didn't overwrite any custom options I've added to the shortcut in the Start menu on Windows.(But again, it's a pretty minor thing....) Great, I'm glad you're closer...It probably means that you're not loading an Electrum wallet file. If you created a text file yourself, can you please double-check that it looks like this:Code:{"seed": "hGt+sQGFlt7Dhgb3a1kHetNJmlxrMQrZ3D8mheYgVr79ZEGOZK1btAzv44QMwGQ2K+1a/1ct10abxrX56OtvFA==", "use_encryption": true}It must have a { at the beginning and a } at the end, and it must use double-quotes, ", everywhere except for around the last word (true). I think a better answer is a combination of the two answers above.As long as you have a working version of Armory on some PC, this is true. It doesn't even need to be online, or be compatible with any version of Bitcoin Core. As tspacepilot goes on to say:And as long as you have a working version of Armory, you can do this. You need to do a Wallet Restore using your paper backup, and then go to the Backup Wallet option and choose "Export Key Lists" as your backup type. This will produce a text file, and although you may need to change the formatting of the text file a little bit to get it to import into another wallet client, it shouldn't be too difficult.It should be noted that you can't export the entire wallet and expect some other wallet client to be able to generate addresses/keys the same way that Armory currently does, instead you have to ask Armory to generate a list of addresses and keys as described above, and import the entire list into the new wallet client. I didn't because doing so seemed redundant... it's dependent on Bitcoin Core for all if its networking needs, so if Bitcoin Core gained split routing, Armory would "inherit" it.Completely agree, e.g. with MultiBit HD and/or other bitcoinj-based wallets if bitcoinj adds Tor & split routing support.I think the situation isn't quite that bad. Mycelium uses a 'fully trust the server' model, and Electrum uses a 'query the server for an address' model (but Electrum does do SPV). Even with these two, Tor could help a little (although if they maintain long-term connections to the server, then they're leaking information related to addresses that are associated with one another, despite not leaking the actual IP addresses).On the other hand, MultiBit (Classic and HD), Bitcoin Wallet for Android, and breadwallet are all pretty popular, and they're all "real" bloom-filter-using SPV clients.Also to be fair, multisig wallets w/2FA trade privacy for security, and for some people that's a fair trade. E.g. GreenBits, even though it's a "real" bloom-filter-using SPV client, still needs to get the GreenAddress.it servers to sign their half of a 2-of-2 tx. GreenAddress.it (practically no relation to the "green address" term you may have seen elsewhere) is a multisig wallet provider. They have an option for their 2-of-2 wallets (which is their default wallet type) that you can enable when sending transactions called "instant confirmation". If you choose to enable it when you send a transaction from your GreenAddress wallet to someone else (the recipient doesn't need to be a GreenAddress wallet), then that transaction is added to a publicly-queryable database which they maintain.The Electrum GreenAddress plugin allows you to query GreenAddress to see if a given transaction has been flagged as "instant". Keep in mind that it's a 2-of-2 wallet, and that GreenAddress exclusively controls one of the two keys. GreenAddress publicly agrees to never sign a double-spend transaction if the user chooses the "instant confirmation" option. As long as you trust GreenAddress to stand by that policy, you don't need to trust individual users. This provides a certain amount of assurance that an "instant" transaction cannot be double-spent (as long as you trust GreenAddress). Practically speaking, if some wallet were to implement D&T's split routing, it would probably be a wallet which currently takes privacy seriously. AFAIK, there are only three wallets which seem to fit into this category:Bitcoin CoreMultiBit HDDarkwalletThese are the only wallets I could find which avoid address reuse, can be used relatively easily with Tor, and do not depend on any centralized service. (I don't think Darkwallet has implemented Tor/SOCKS yet, but it's on their roadmap.)So if anyone were serious about this, that's where they should probably be looking.Also worth noting that the latter two aren't yet considered stable enough for general use by their devs, so I'd guess (it's just a guess) that a new feature request such as split routing probably wouldn't be very high on their priority list....Edited to add: It looks like bitcoinj might consider adding support for this one day...
Weary, how?Just to be clear, the BDM issues have nothing to do with your wallet or your funds. If you run into them (I have only once), they are inconvenient, and they can cause a delay if you need to send funds right away, however they shouldn't ever lead to a loss of funds.If the potential delays of having to do a rebuild/rescan before being able to send out funds make you weary, I can understand that. In this case it might be best if you stick with 0.92.x until you're comfortable with 0.93.x.Edited to add: I just noticed your comment in the "0.93 testing release" thread, and that you [opentoe] know all this already, so sorry for implying otherwise....BTW, Carlton Banks seems to have a slightly unusual setup which could be why he runs into this issue more often then others. goatpig has said that CB's many issues have been helpful to him [goatpig], but I don't think this many issues is common for others (it certainly hasn't been for me). Do you have an Electrum wallet file?If not, can you create a text file like this, except put your real encrypted seed in it?Code:{"seed": "hGt+sQGFlt7Dhgb3a1kHetNJmlxrMQrZ3D8mheYgVr79ZEGOZK1btAzv44QMwGQ2K+1a/1ct10abxrX56OtvFA==", "use_encryption": true}If you can, you can follow the instructions I posted above to download and run a decryption tool, here:https://github.com/gurnec/decrypt_electrum_seed Actually that's not true.The message being encrypted is a hex-encoded string of the 16 random bytes; it's 32 hex digits. On top of that, it's PKCS7 padded, which for a 32-byte string results in 16 bytes all of value 0xf being appended to the end of the string before encryption. This makes it very easy (and fast) to test passwords against Electrum 1.x wallets (with 2.x you can use a similar trick by trying to decrypt the master private key which is encoded in BIP32 xprv format before encryption).Source: I have done so.... https://github.com/gurnec/btcrecoverOut of all of the wallets btcrecover supports (roughly 10 depending on how you count), the only wallet where I actually have to go so far as to derive a pubkey from a privkey to check if a password is correct is Armory. All of the others offer similar tricks to prevent having to doing so.That's not to say that they're all insecure. Although it's true there are a surprising number of wallets with non-existent key stretching, there are a few that do it right (from a key stretching point of view, anyways, some of these have other encryption issues): Bitcoin Core, Armory, MultiBit HD, Hive for OS X (vanilla bitcoinj), and to a much lesser extent Blockchain.info's most recent version as of roughly late last year. Sure, just follow the instructions here: https://github.com/gurnec/decrypt_electrum_seedIf you don't have an Electrum wallet to use the script on, you can create a minimalist one containing this (it's just a JSON text file):Code:{"seed": "hGt+sQGFlt7Dhgb3a1kHetNJmlxrMQrZ3D8mheYgVr79ZEGOZK1btAzv44QMwGQ2K+1a/1ct10abxrX56OtvFA==", "use_encryption": true}If you do need to create your own, the Python script will spit out a bunch of warnings which you can mostly ignore.FYI the KDF is sha256(sha256("password")), and the encryption is AES-256 in CBC mode with PKCS7 padding. Electrum 1's own mnemonic.py library is included and used if it's an Electrum 1 seed to finish the conversion from seed to mnemonic sentence. Just wanted to add that failing memory can cause file corruption as well; you might want to consider running memtest overnight just to double-check.I had a bad RAM stick with just a single bad bit. Just one bad bit out of 64 billion was enough for me to get DB corruption issues every couple of days (and there were no other obvious symptoms anywhere else on the PC). I'd try logging in with the next few paper codes, and maybe a couple of the most recently used-up codes too.If nothing works, you'll probably have to go through the two-factor removal process, which takes 2 weeks: https://localbitcoins.com/twofactor_reset_request/ So here's what I'm thinking.New feature 1: add an "--exclude-passwordlist [FILE]" command line option. Passwords read from the FILE will be skipped. FILE defaults to stdin.This allows you to run btcrecover along these lines:Code:btcrecover --tokenlist old-tokens.txt --listpass | btcrecover --exclude-passwordlist --tokenlist new-tokens.txt --wallet wallet.datYou could even combine multiple old runs, e.g. (Linux / OS X only):Code:( btcrecover --tokenlist old-tokens-1.txt --listpass ; btcrecover --tokenlist old-tokens-2.txt --listpass ) | btcrecover --exclude-passwordlist --tokenlist new-tokens.txt --wallet wallet.dat(maybe) new feature 2: add an "--exclude-tokenlist FILE" command line option (FILE is required).Code:btcrecover --exclude-tokenlist old-tokens.txt --tokenlist new-tokens.txt --wallet wallet.datIt's a little more convenient than the first feature for common cases, but it's less flexible and more difficult to implement.(BTW I definitely liked your idea of multiple sections in a single tokenlist file, but keeping the files separate would be easier to code.)What do you think? That hurts my head to even think about.... btcrecover supports (depending on how you count) between 10 and 15 different wallet formats, and for many of them it only understands the bare minimum required to test passwords (and not nearly enough to read or write an entire wallet file).Cool library though (keyring), I haven't heard of it before.That's an interesting idea. Keep in mind it's not just the token / typos-map files that that I need to keep track of, it's also the command-line options too. Still, that could be doable.(FYI I'm signing off for the night.) Agreed that could work, but I've intentionally avoided saving any sensitive information inside the autosave file. I save the command-line arguments in plaintext, but I only save an SHA1 of the tokenlist file in the autosave. It's bad enough with all of the insecure handling of password information that I do (see here), so I really wanted to avoid surprisingly saving any sensitive data inside the autosave file. (I only bother saving an SHA1 of the tokenlist file to ensure that someone doesn't try to resume a session with a changed tokenlist file, which would be a pretty bad idea...) Really sorry to hear that...  if it makes you feel any better, the reason I started working on this in the first place was to recover my own password... and despite a sh*tload of effort, I still haven't gotten it back yet. Thank you!I think this is a great idea. It would also help people who use passphrases with space-separated words. It's sort of possible to do today (by being clever with anchored tokens), but it's pretty painful. I'll definitely give this some thought.I think I understand what you're saying. If you run btcrecover with expanded parameters, it would be nice if it didn't check passwords that it checked during the last run, is that correct?It does have some limited ability to do that with --min-typos and --min-tokens, but it's not ideal. TBH, I'm not sure how to improve it... I'm pretty late in responding here, but I thought I'd do so anyways.There is (at least) one tool that can attempt brute-forcing an Electrum wallet, it's available here: https://github.com/gurnec/btcrecover.The Quick Start is here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialOf course, it's pretty much useless if you have no idea what your password is, but if you do have an idea it might help. (Full disclosure: I'm the author of that tool.)If anyone has any questions about it, just let me know. If you'd like to try to recover it yourself, here's the Quick Start for an open source (free) tool called btcrecover: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorial. It does take a bit of work to get it set up and running, though. (Full disclosure: I'm the author of that tool.)If you have any questions about it, just let me know.Although I've never dealt with Dave personally, he's gotten nothing but good reviews from what I can tell, so that seems like a good option too. Hi, onemorexmr. By all means, if you have a question or need a hand with something, just let me know (here in this thread or via PM if you'd prefer).Uhhmm... wow.. I'm not even sure my wife would describe me so nicely  (Thanks!) First thing: if you think that is your seed and your password, it's a really bad idea to be posting it on the Internet. Luckily for you, it seems it's not.I don't really understand the chain of events you described, but the "seed" you posted above is definitely not an Electrum 1.x seed (and it's too short for a normal Electrum 2.x seed).It can be decrypted with the seed_password you posted using Electrum's kdf and cipher, and the result is "This is just a test for AES decryption!", but as an Electrum seed it's meaningless, so I couldn't say where it came from. FreeOTP (which is OSS) is available for both Android and iOS: https://fedorahosted.org/freeotp/. I've been using it for a little less than a year now with no problems.It is maintained by a Red Hat employee (I'm not clear if it's actually sponsored by Red Hat, not that it matters to me). FYI I ran into... something. Running 67759a9 (will upgrade to the most recent now).I just now noticed that Armory wasn't running, it apparently crashed this morning.Code:-DEBUG - 1426162994: (..\Blockchain.cpp:211) Organizing chain -INFOÂ  - 1426162994: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 74249660-INFOÂ  - 1426162994: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 74606873-WARNÂ  - 1426162994: (..\BlockUtils.cpp:1116) Scanning from 347295 to 347295-DEBUG - 1426163115: (..\Blockchain.cpp:211) Organizing chain -DEBUG - 1426163116: (..\Blockchain.cpp:211) Organizing chain -WARNÂ  - 1426163116: (..\Blockchain.cpp:317) Reorg detected!-DEBUG - 1426163116: (..\Blockchain.cpp:211) Organizing chain w/ rebuild-INFOÂ  - 1426163117: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 74606873-INFOÂ  - 1426163117: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 75038837-WARNÂ  - 1426163117: (..\BlockUtils.cpp:1633) Blockchain Reorganization detected!-INFOÂ  - 1426163117: (c:\bitcoinarmory\cppforswig\ReorgUpdater.h:257) Reassessing Tx validity after reorg-INFOÂ  - 1426163117: (c:\bitcoinarmory\cppforswig\ReorgUpdater.h:180) Invalidating old-chain transactions...-ERROR - 1426163117: (..\BlockUtils.cpp:1658) Error adding block data: Cannot get undo data for block because not full!-DEBUG - 1426163138: (..\Blockchain.cpp:211) Organizing chain -INFOÂ  - 1426163138: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 75038837-INFOÂ  - 1426163138: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 75080650-WARNÂ  - 1426163138: (..\BlockUtils.cpp:1116) Scanning from 347297 to 347297-DEBUG - 1426163193: (..\Blockchain.cpp:211) Organizing chain -INFOÂ  - 1426163193: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 75080650-INFOÂ  - 1426163193: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 75098598-WARNÂ  - 1426163193: (..\BlockUtils.cpp:1116) Scanning from 347298 to 347298-DEBUG - 1426163215: (..\Blockchain.cpp:211) Organizing chain -INFOÂ  - 1426163215: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 75098598-INFOÂ  - 1426163215: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 75098810-WARNÂ  - 1426163215: (..\BlockUtils.cpp:1116) Scanning from 347299 to 347299-DEBUG - 1426164532: (..\Blockchain.cpp:211) Organizing chain -INFOÂ  - 1426164532: (..\BlockUtils.cpp:1531) Loading block data... file 242 offset 75098810-INFOÂ  - 1426164532: (..\BlockUtils.cpp:589) Reading raw blocks finished at file 242 offset 75906414-WARNÂ  - 1426164532: (..\BlockUtils.cpp:1116) Scanning from 347300 to 347300Code:2015-03-12 08:23 (INFO) -- Networking.py:215 - Received new block.Â  0000000000000000142c8fa8984becbe71c90658c89c3f77490bc40ad2b9be0b2015-03-12 08:23 (INFO) -- ArmoryQt.py:6242 - New Block! : 3472952015-03-12 08:23 (INFO) -- ArmoryQt.py:6250 - Current block number: 3472952015-03-12 08:25 (INFO) -- ArmoryQt.py:6242 - New Block! : 3472962015-03-12 08:25 (INFO) -- ArmoryQt.py:6250 - Current block number: 3472962015-03-12 08:25 (INFO) -- Networking.py:215 - Received new block.Â  000000000000000006a4096ac98c907a3354fdf2dae617739c588a80bf0b54d42015-03-12 08:25 (INFO) -- ArmoryQt.py:6242 - New Block! : 3472972015-03-12 08:25 (INFO) -- ArmoryQt.py:6250 - Current block number: 3472972015-03-12 08:26 (INFO) -- ArmoryQt.py:6242 - New Block! : 3472982015-03-12 08:26 (INFO) -- ArmoryQt.py:6250 - Current block number: 3472982015-03-12 08:26 (INFO) -- Networking.py:215 - Received new block.Â  0000000000000000018a2949009fe75921bb6737cb2c1bc887a8ea6bf5ce056f2015-03-12 08:26 (INFO) -- ArmoryQt.py:6242 - New Block! : 3472992015-03-12 08:26 (INFO) -- ArmoryQt.py:6250 - Current block number: 3472992015-03-12 08:29 (INFO) -- announcefetch.py:271 - Fetching: https://bitcoinarmory.com/announce.txt2015-03-12 08:48 (INFO) -- ArmoryQt.py:6242 - New Block! : 3473002015-03-12 08:48 (INFO) -- ArmoryQt.py:6250 - Current block number: 347300 I'm with you, but then where would the .ini file be (and what if it were located in a path with non-ASCII characters)?The "right" way to do this is of course to store settings in the Windows registry, however the Armory devs have to support multiple OS's, and it's understandable that they don't want to have to maintain different code paths for every OS.On the plus side, an Armory dev did say that they plan to fix the non-ASCII-path issue over here: https://bitcointalk.org/index.php?topic=984101.msg10727929#msg10727929Another way to go about this would be to migrate all of the settings storage to QSettings. They already use Qt, and QSettings abstracts away the "right" thing and does it pretty well (it does use the Windows registry for example). Of course, every minute they spend fixing these types of issues is a minute they don't spend implementing something more important.... I was assuming that the attacker need only pay for completed machines (that reach a halted state).If everyone pays for cycles regardless of whether or not the machines halt, could a malicious miner DOS the network by operating machines up until their final state minus one cycle?(I'm asking dumb questions that are all answered in the referenced paper, just like ppl do when they don't read the original Satoshi paper, aren't I? Be honest....) Actually (just FYI) most of the Win32 API accepts either forward or backward slashes as a path separator (both of which are disallowed in file names), and that extends to most programming languages including the C/C++/Python used by Armory. There are some frustrating exceptions though, so backslashes are safest (e.g. paths whose length exceed 260 characters must us a special format which requires backslashes).Then there's the legacy cmd.exe and the various legacy command-line tools which get confused with forward slashes (because they often indicate an option, akin to Unix's dash). These issues thankfully did not make it to PowerShell which behaves much more sanely. I don't know anything about Ethereum, so this is probably a stupid question, but what prevents the contract writer from offering a huge per-cycle fee and then providing an algorithm which (non-trivially) doesn't halt?
I really doubt that Armory can deal with file paths (on any OS) that include non-ASCII characters (Unicode support in Python 2 is a real pain, something that I'm happy was fixed in Python 3).You'll probably need to create two folders that have only ASCII characters in their entire path, and then start Armory with two command-line options like this:Code:armory --datadir=C:\Armory-datadir --satoshi-datadir=C:\Bitcoin-Core-datadirIf you've already downloaded the blockchain, you should move the entire contents of %appdata%\Bitcoin to the new Bitcoin-Core-datadir (or you could make the Bitcoin-Core-datadir a symlink instead).Edited to add: it looks like some work has already been done to make Armory more Unicode friendly, so you might not need to move the Bitcoin Core datadir. If I were you I'd try moving just the Armory datadir first (and get rid of the --satoshi-datadir option). There are many reasons to avoid Blockchain.info, but to be fair this isn't one of them. As long as you back up your wallet (whenever you create a new receiving address), you can regain access to your funds should they one day disappear. The release notes are included in the downloads (and are in your install directory), or available online here: https://github.com/spesmilo/electrum/blob/master/RELEASE-NOTESThe two issues mentioned in the release notes for 2.0.2:https://github.com/spesmilo/electrum/issues/1066https://github.com/spesmilo/electrum/issues/1054 In a perfect world that'd be true, but realistically speaking it's too optimistic.There's always a delay in the cat-and-mouse game of malware vs antimalware. Sometimes it's days, and sometimes it's months... antimalware is never 100%.Also, just for the record Blockchain.info's 2FA is almost useless when it comes to protection from malware. It's perhaps useful against online brute-forcing, but that's about it.Yup, in which case your wallet is only as safe as the strength of your password, so use a really good one (even less safe if an attacker replaces the JavaScript app with one that steals bitcoin).Good advice. It's very difficult to convince someone that they're not as smart as they think they are.What it really comes down to is this: if you're not a cryptographer, you shouldn't be coming up with your own cryptography (and that definitely applies to coming up with your own RNG). To do otherwise is simply hubris.I don't mean any disrespect in what I wrote above, it's just that cryptography (and by extension CSPRNGs) is an extremely complex subject which is studied by experts who devote their entire professional life towards that study (and even they frequently make mistakes!). I know I'm not in that league, and I can only presume you're in the same boat, therefore the best advice is to follow the advice of people who know better than either of us.All of this is why using /dev/urandom is a good idea: it was developed by experts, and it's also why any scheme developed by you or I is fraught with serious risk. (I did not develop the "feed a shuffled deck into a hash function" scheme by the way, i just wrote that simple python script.) Electrum 2.x HD wallets may not contain loose keys. You can still create a separate wallet which contains loose keys, but it will not be an HD wallet and you're on your own when it comes to maintaining backups (there's no seed).To create a loose-keys wallet, go to the restore wallet option, and enter one or more private keys (base58check strings starting with L or K). You can import additional keys into this wallet later if you like (the Import Keys menu item won't be disabled).I suspect this was done to avoid any confusion where a user might believe that imported keys in an HD wallet might somehow be protected by the seed, when of course it's not. GreenAddress and Coinbase Vault are both intended for individuals, or for individual employees (the multisig for these wallets is intended to keep individuals safer from malware, it's not intended to prevent embezzlement).There is multisig software designed for companies or groups of individuals though. You may want to look at Armory (lockboxes), mSIGNA, or perhaps the recently released Electrum 2. And thank you for the kind words That creates-4-billion-addresses thing was sure a surprise to me. I actually just opened a PR on their repo with a one-line type check to catch anyone who happens to try passing in a string. Does any wallet use hardening at the internal/external (change) level? That's the only level there.... (if you're disappointed by the lack of account support, that's more understandable)Yikes, you meant this with no single quotes:Code:wallet.change_gap_limit( 100 )(Yikes because Electrum doesn't type-check the argument, and will surprisingly try to create all 4 billion addresses if you pass it a string )Just FYI you can also start a wallet restore, and paste the master public key into the place where you'd normally paste a seed. This version of HashCheck (full disclosure: this is my repo1) supports SHA-256, and can be used to check hashes on Windows: https://github.com/gurnec/HashCheck/releasesJust download the .asc file from https://bitcoin.org/bin/bitcoin-core-0.10.0/SHA256SUMS.asc and/or https://bitcoin.org/bin/bitcoin-core-0.10.0/SHA256SUMS.asc into the same directory as the installer or archive, and double-click it.Verifying the PGP signatures (as Blazr detailed) is more secure, though.Agreed.[1] It's my repo, but all credits for HashCheck go to its original author, Kai Liu. I only added SHA-256 support. I don't understand what you're asking.... OP never mentioned anything about importing a wallet, and restoring from a seed does not require a password. Just create a new wallet and choose restore, then use your seed and set whatever password you'd like for the new wallet. 'Star Trek' fans told to stop 'Spocking' Canadian $5 billYou just can't stop a die hard fan.  Makes sense, thanks for explaining. Just wondering, has that been tagged on GitHub yet? Unfortunately, it requires that you download the current source code and build it yourself with Visual Studio on Windows or some other compiler on Linux (g++ I'd imagine). I don't know how long it will be before an official release, but I get the impression that it will be on the order of several days, and not several weeks (again, I'm not an Armory dev and I could be wrong). Waiting for an official release would be safest.... It looks like this issue, it's being worked on:Users experiencing the BDM error message I've been running a4561d1 since my last post. No issues, however no "repair" log entries either (nor any other unusual log entries). Please be careful if you use this feature. The entropy integer replaces some of the entropy which Electrum would normally use; if the entropy integer is long enough (39 digits for a 128 bit seed), it will replace almost all of the entropy which Electrum normally uses.If your integer comes from a good source of entropy, then none of this is any concern. But if not, you're asking for trouble.If by gibberish you mean dice roles, a well-shuffled deck, or similar, I'd say that's a very good way to generate a wallet. If you mean "banging on the keyboard for a while", I'd be concerned. If you're going to go through all the effort to make your own entropy and store it cold, please take the extra step of using a real entropy source. Otherwise, your "banging on the keyboard" may end up making your wallet weaker than if you had just used the default OS-provided source of pseudo-entropy in the first place (as most wallets do, including Electrum).If you're getting your entropy from a good source, you can do something like this do convert it to an integer for use with Electrum 2.x (at the command line; if you're on Windows, you need to download Python 3 first, and it's called python.exe instead of python3):Code:python3 -c "import hashlib;print(int.from_bytes(hashlib.sha256(input('entropy> ').encode()).digest()[:int(input('bits> '))//8],'big'))"entropy> ks 3s 9c jc kh 3c td tc 4c 9h 4h 7c 2c 6d ac 9d qc 3h as ts 8s 5d ad 2h 5sbits> 128183982767129046887860016900583690846407In that case, I used a well-shuffled deck. You only really need the first 25 cards, but a few more wouldn't hurt. I entered "128" for the estimate of bits, this number should be somewhere between 8 and the seed length in bits, usually 128. If you're using a well-shuffled deck, entering 128 is fine, but if you're using something else and if you overestimate how much entropy you've got, you'll end up decreasing the security of your wallet (because of what I described above), so just be careful . For 6-sided dice, you'd need 50 rolls for 128 bits. For 20-sided, 30 rolls. If you're feeling lazy, you can decrease this, but you must decrease the bit count proportionally (and then Electrum will fill in the rest from the OS's pseudo-entropy). There are alternative solutions for this if you want to try one.I've been using RBTray for years now for this, you may want to check them out (no affiliation). It's open source, and works on XP all the way up to 8.1.You simply run it, and then right-click on any window's minimize button to send it to the tray.
Greenbits should be faster since it's written in Java instead of Javascript. You'll need to enter your entire mnemonic the first time you use it, after that you can set a PIN if you prefer, just like the original app (or continue using the entire mnemonic each time). There's no trouble having both installed at the same time if you like. It's more a github term than a twitter term, it just means the source code has been finalized and the installers are just around the corner.Congrats!! Yes. I didn't, sorry, but I would guess it wasn't. I shut down Armory just before sending out those log files. I started it back up shortly after (and the symptom did not reoccur). Here's the log from that start:Code:-INFO Â - 1425231061: (..\BlockUtils.cpp:1597) Reading headers from db-INFO Â - 1425231062: (..\BlockUtils.cpp:1623) Found 345730 headers in db-DEBUG - 1425231062: (..\Blockchain.cpp:211) Organizing chain w/ rebuild-WARN Â - 1425231063: (..\BlockUtils.cpp:1285) --- Fetching SSH summaries for 417 registered addresses-INFO Â - 1425231063: (..\BlockUtils.cpp:1298) Left off at file 237, offset 47797915-INFO Â - 1425231063: (..\BlockUtils.cpp:1301) Reading headers and building chain...-INFO Â - 1425231063: (..\BlockUtils.cpp:1302) Starting at block file 237 offset 47797915-INFO Â - 1425231063: (..\BlockUtils.cpp:1304) Block height 345607-DEBUG - 1425231063: (..\Blockchain.cpp:211) Organizing chain w/ rebuild-INFO Â - 1425231065: (..\BlockUtils.cpp:1339) Looking for first unrecognized block-INFO Â - 1425231065: (..\BlockUtils.cpp:1488) Loading block data... file 237 offset 47797907-ERROR - 1425231065: (..\BlockUtils.cpp:536) Next block header found at offset 47797915-INFO Â - 1425231065: (..\BlockUtils.cpp:564) Reading raw blocks finished at file 237 offset 86249538-INFO Â - 1425231065: (..\BlockUtils.cpp:1356) Wrote blocks to DB in 0.029s-WARN Â - 1425231065: (..\BlockUtils.cpp:1074) Scanning from 345607 to 345717-INFO Â - 1425231065: (..\BlockUtils.cpp:1450) Scanned Block range in 0.86s-INFO Â - 1425231065: (..\BlockUtils.cpp:1453) Finished loading at file 237, offset 86249538-INFO Â - 1425231065: (..\BlockDataViewer.cpp:155) Enabling zero-conf tracking The unscanned block numbers 345607 to 345717 roughly correspond with the timestamps in the log file I sent you, that's why I'm guessing it wasn't on the top block.Edit: sorry I'm wrong, 345607 was the most recent block after initially starting Armory (in the logs I sent). The odd logging symptom didn't start until a couple of hours later, so I'm not sure how to interpret the log pasted in above. Sorry, I should have been more specific. Ticket: ARMORY00000469, I did mention your name in the ticket body. I don't have any of the "repair" messages yet, but something odd did happen. I've no idea if it's related to this branch, but I sent you the full logs just in case. The only thing odd was the content of the armorycpplog file, there were no other symptoms. (Slightly OT) FYI BIP39 wordlists aren't guaranteed to use unique words wrt each other; in particular the two Chinese word lists share over 50% of their words so you'd probably need to choose one over the other (or neither). I don't know the first thing about ASIC programming.... but if you're writing software that requires a large iteration count (PBKDF2, etc.) I'd probably take the "easy" way out and just do the first iteration in software, and do the rest with a single hash block and a hard-coded data length in the ASIC (what I lazily do with GPU/OpenCL-based stuff). If you convince a miner to accept an invalid tx, and it includes it in a block, the block will be ignored by all full nodes, wasting the miner's time. Although you could (probably?) create a client that validates transactions w/o a full copy of the blockchain, it seems pretty inefficient to me (you'd have to query other nodes for each new tx you intend to place in the new block I'd imagine?).There are known weaknesses and attacks against SPV clients. Although they don't appear easy to pull off in practice, if you're dealing in high value transactions then you can afford to run a full node and be "better safe than sorry." (Cold vs hot wallets is a different issue. There's no reason you can't use a cold wallet with a hot watching-only full-node-based wallet.) I wonder if the revenue from TrustedCoin (Electrum 2.x's optional two factor authentication partner) will be shared with the devs. I sincerely hope so. Thanks, done.Will do (nothing yet). I thought we agreed that it didn't meet both "Easy to set up/maintain" and "No address re-use" at the same time, given that BIP70 isn't easy to run on your own (or it fails "Decentralized" if you use a 3rd-party processor which implements BIP70)? FYI Hive for Android has been HD for a few months now. It shares the same (Cordova-based) JavaScript source as the iOS version. There are no bitcoin-payout incentives for operating a full node, but that are less tangible ones.Operating a full node means you can do full bottom-up validation of all transactions, instead of relying on height-based validation. It also prevents evil nodes which you may connect to from withholding transactions from your view.In other words, if you're regularly dealing in high-value transactions, running a full node is definitely a good idea. If not, than the only other incentive I can think of is that warm-fuzzy feeling from helping out a good cause. I don't think that's a fair analogy.(I think) OP's desire was to make it easy to create or reference a receive address in informal situations without carrying anything with you (e.g. splitting a bill with a friend). Traditional transaction mechanisms do that just fine today (cash: don't need to remember anything; checks: just need to remember your own name; centralized e-money (e.g. PayPal), just need to remember your email address/account ID).I think such a mechanism for Bitcoin would be great, but I'm skeptical that any such mechanism would meet a reasonable set of minimum requirements. My own set of requirements would include:Easy to rememberEasy to set up/maintainDecentralizedNo address re-useIf you can't achieve all of the above, than you need to prioritize. I'd nix either the first or the second, and that's what we already have today (base58check or BIP70). I think nixing either of the other two would be a worse idea, but that's subjective. I hit the BDM error yesterday. I'm running the 0.93-bugfix branch as of this afternoon. The initial rebuild finished without issue.I'll post back if I see any of the new log messages in armorycpplog (none so far). OP specifically said he wasn't interested in altcoins, but in interesting forks which haven't been merged into Bitcoin (and presumably have some chance of being merged in the future):Read the whole thread... the referenced forks are interesting.If Satoshi had agreed with that point of view, it seems unlikely he would have released Bitcoin under the MIT License. 'Course it's hard to disagree with your sentiment regarding the quality of most altcoins.... That's kind of the point though. If Joe can't run his own payment server (and wants to avoid address re-use), then he's stuck with a centralized solution anyways. And if he's stuck being centralized, there doesn't seem to be much reason to use the blockchain to look up some account ID if the centralized provider he's chosen can do it instead.If the payment processor implements an easy URL scheme with a short checksum, than that's great. It doesn't require encoding anything on the blockchain, though.Maybe there's more merit to the static-address solution you've described. I'm skeptical that it offers much improvement over firstbits, but I could be wrong.  R.I.P. It sounds like your scheme (in the BIP70 case) is simply a URL shortener, except that in some cases it will end up being more of a URL lengthener.... remembering a few random English words seems harder to me than simply remembering a domain name that one creates for that purpose.At least one online wallet does this, for example if you'd like to send me a tip, visit here: https://greenaddress.it/pay/GAMiQ3yzZFD6djdqpYo4YGdRHrMot/ (they have only my xpub, assuming of course that you trust their client software isn't malware).
It's way too long, though... I'm thinking of breaking it up into smaller pieces so it at least doesn't seem so intimidating. Haven't decided yet. In any case, thanks for the kind words, they're much appreciated! That depends... do you like it?  (yes, I am) Glad to hear it, that's always the easiest solution  I've bolded it above....Although it is possible to use btcrecover against a MultiBit wallet file, it's much slower and it's harder to install the prerequisites on windows (I haven't even added instructions for this in the tutorial yet, but will eventually). Instead use one of your .key files, see here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#finding-multibit-wallet-files Here's a password recovery tool that might help (open source, written in Python): https://github.com/gurnec/btcrecoverJust a warning: it may take you a bit of reading to get it up and running. The quick start is here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialPlease take special note that it works on MultiBit .key files, not on the wallet files themselves (more details are in the Tutorial linked above).If you have any questions about it, please feel free to ask me.Good luck! Are you sure you're running 0.93 (this is the 0.93 thread after all...)?0.92 and older had a Building Databases step, 0.93 replaced this with a much faster (1 - 2 hours long) Organizing Blockchain step AFAIK. Speaking of updates to the dllinks.txt file  (that's the file that would need updating and re-signing for 0.10.0 to become available). You may want to consider some updates to the online dllinks.txt file at some point to reflect all of this...E.g., removing the 32 (bit) flag from all of the Armory 0.93 versions (keeping it for ArmoryOffline though), and removing 12.04 from the Armory & ArmoryOffline Ubuntu lines until/unless you intend to distribute your own libstdc++6 (FYI a newer version isn't in the backports repo unfortunately).It's a judgement call though.... If you think there's any chance of a hardware issue, I'd avoid copying anything besides the wallet files if I were you.... I had an issue that turned out to be bad RAM causing Armory database corruption issues each time I tried a rebuild... copying a potentially bad database might propagate whatever problem you're having.Also, with the 0.93 just around the corner, you can either wait for 0.93 or grab the most recent beta from the 0.93 thread which offers much faster database rebuild times thanks to goatpig's efforts (I recently did a database rebuild and it took about 1.5 hours on a HD, not even an SSD).Even Bitcoin Core blockchain downloads with 0.10 are much better, if you choose not to copy over its data directories. It can still take a number of hours, but that's a whole lot better than the day or two it used to take. Yup, I meant only for the future. And if you've never done it in NSIS before, it's as easy as "!include x64.nsh" and then "${IfNot} ${RunningX64}" to check... Thanks for the detailed response.You meant no x86 releases for online Armory, correct? (otherwise I'm confused)You should probably be sure to point this out the download page (and in future download links here) so that people stuck on 32-bit machines do not inadvertently overwrite their 32-bit versions with non-working 64-bit versions... just a suggestion. I notice that this version is 64-bit only (I haven't checked earlier 0.92.99 releases though). Was that intentional? Historically the installs have been 32-bit executables, even on 64-bit Windows. Do you plan to drop support for pre-built Win32 binaries? Just wondering...(also, an extremely minor nitpick: the installer installs this 64-bit executable into the x86 Program Files directory, probably because the installer itself is a 32-bit app and its directories are being virtualized by Windows) I guess my post was too long, sorry disablewallet=1 disables the wallet cache, which is 1MiB. It won't save you much, but it doesn't hurt.dbcache=4 decreases the other caches to 4 MiB, which by default total 100 MiB. Setting this too low might decrease performance, though... I don't know what a good number would be, but if DnT and shorena both say 4 is a good starting point, I'd trust them, and then maybe tweak it up a bit if you have any spare ram. It used to be that Berkeley DB was used for the wallet, block indexes and tx indexes. -dbcache affected the in-memory cache for Berkeley DB. Version 0.8.0 moved the block and tx indexes to Google's LevelDB (it's faster), and kept the wallet in Berkeley DB format (presumably so that the wallet.dat format remained unchanged for backwards compatibility). In 0.8.0, -dbcache affected both the Berkeley DB and LevelDB caches.The patch referenced above was introduced in 0.8.2, and it modified the -dbcache option so that it only affected the LevelDB caches (since the wallet is relatively small, there shouldn't be any need to adjust it's cache size, so it was hard-coded to 1 MiB). The default -dbache in 0.8.0 was 25 MiB.Version 0.9.0 increased the default to 100 MiB. It has a hard-coded minimum of 4 MiB (and a maximum of 1 GiB on 32-bit machines, 4 GiB on 64-bit machines). I'd imagine setting it down to 4 MiB would have a noticeable affect. Interesting, and also quite controversial A (slightly related) interesting fork: Tom Harding's Double-Spend Relay and Alerts. It actually made it into Bitcoin Core's master for a short while before being reverted (which I think is a shame; he put a lot of work into it and it had at least some chance of being very useful, but there were some legitimate concerns as well). Are you talking about Blockchain.info wallets? That's the only wallet client I can think of that uses AES encrypted JSON. Or something else? btcrecover supports searching for blockchain.info passwords, including double encryption/second passwords (you must use the --blockchain-secondpass command-line option). It's free and open source, but it does require a bit of reading to get it up and running. The tutorial is available by clicking here.Let me know if you have any questions about it.Edited to add: a number of individuals have commented that blockchain.info support will be able to help... unfortunately that's not true. Blockchain.info claims (and I have no reason to disbelieve them) that they have no access to either your main nor your second password. Assuming, of course, that your adversary does not have access to your master public key, deducing that the two addresses were produced from the same seed is roughly as difficult (mathematically) as stealing bitcoin from those addresses. It would involve solving four SHA256 preimages and the two discrete logarithms (which is what secures transaction signatures in bitcoin), and would in the process give the attacker access to your master private key as well.If it were possible, there'd be far worse problems to be worrying about.... Yes.No.Even if they chose to use both bip32 & bip39, that would not be sufficient to guarantee mnemonic interoperability. I said something fairly bone-headed above:I don't know what I was thinking.... Even if wallets supported bip39+bip32+bip44, it would be close but it still wouldn't be quite enough to guarantee a mnemonic could be moved easily from one wallet software to another. I've written (and have been improving I hope) a password recovery tool for a while now, and it includes support for Armory (that was the first wallet it supported as a matter of fact). You can find it here (it's open source): https://github.com/gurnec/btcrecover; the quick start is here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialAlthough it's not the easiest to use, it is fairly well documented, and it doesn't required that you send your wallet information to anyone else if that's a problem (if you run it offline, of course).It's also probably faster than any alternative -- it's multi-threaded, so if you have a quad-core CPU, it'll run about four times faster than most alternatives. It also supports GPU-accelerated searches, although it's not very effective on that front for Armory.*That would be excellent. Of all of the wallets currently supported by btcrecover, Armory is the only one where I couldn't find a way to extract enough information from a wallet file to test for passwords without putting funds at risk.Armory encodes private keys as 32-bit blobs with no padding (which is not a weakness by any means, just an inconvenience when it comes to this particular task). Every other wallet I've encountered so far offers some form of "trick" that allows me to extract only a portion of a private key (or a hash thereof) for password testing purposes. For example, many wallets add PKSC7 padding to the end, which allows me to extract just 16 bytes of key material (50%) plus the (useless) 16-byte padding in order to search for passwords. Others encode their passwords in hex or base58 prior to encryption, which allows a similar trick of extracting only a portion of any private key/seed material. It's not that Armory is inferior for being more concise (by not including padding and by using binary instead of unnecessary encoding) -- it's just that it's the only wallet I've encountered so far where you need an entire private key to test for password validity.*** It depends a whole lot on your GPU memory size and the KDF parameters used during wallet creation to determine whether or not GPU-based acceleration can help in password searches. Armory's excellent use of ROMix makes GPU acceleration hard (even with btcrecover's time-space tradeoff), so a GPU might help by a factor of 5x or so, or it might not help at all....** which in combination with the (unencrypted) chaincode and master public key does put funds at risk
That's a shame, but thank you for the correction. For starters, Armory doesn't currently support any form of mnemonic....That aside, there is a standard (called BIP39), although Electrum 1.x was created before BIP39 was envisioned. Electrum 2.x (and many other wallets I hope) will be interoperable and support BIP39 in the not-very-distant future. I don't care for the idea of completely restricting a newbie's ability to send PMs either, but a very visible warning is definitely something I'd support.Yes, at least in my limited case. People don't often like discussing their password details publicly (for the purposes of attempting to recover a wallet with a forgotten password; see btcrecover). I'd be lying if I said I've received tons of such PMs (I've only received a handful), but at the same time I'm sure that newbies who have contacted me are appreciative that they can.(Full disclosure: although btcrecover is open source, I've rarely (exactly once) agreed to a paid password recovery at the unsolicited request of another.) There are some brute-forcing tools out there available for Electrum (assuming you have a decent idea of what your password is).I rather like btcrecover (tutorial is here). It's free and open source; of course, being the dev of that one I'm a just a little bit biased...You can also find a tool towards the end of this thread for Electrum: https://bitcointalk.org/index.php?topic=85495There are also paid services that can help you out, although I'm unsure of which ones support Electrum. Here are some starting points for the paid services:https://bitcointalk.org/index.php?topic=85495.0http://www.walletrecoveryservices.com/https://bitcointalk.org/index.php?topic=717334.0If you have any questions about btcrecover, please just let me know.Good luck! There is an open-source tool which can extract the mnemonic (seed words) from a Bitcoin Wallet for Android 4.x backup file. The mnemonic is a standard BIP39 mnemonic using the English word list. Although there aren't a whole lot of wallets which directly support the importing of a BIP39 mnemonic yet, that's likely to change in the upcoming months. You're really not giving the core devs enough credit IMO by claiming their only significant contribution (even if filtered to "mainstream" promotion) is the Bitcoin Core client itself. Where would Bitcoin as a whole be without BIP32, BIP7x, mutlisig, P2SH, etc. despite that fact that some of those are only partially (if at all) implemented in Bitcoin Core (not to mention contributions to the bitcoin.org website as well)? Charging for the service hopefully decrease the likelihood that they will go out of business, but ultimately it's a judgement call: is the added protection against malware (although not bulletproof) worth the extra transaction fee and the inconvenience should they go offline? I rather think so (although the fee is a bit high for my taste), but to each their own. You mean this command...?wallet.change_gap_limit(200) grendel25,To put it in a less technical way, any 2FA-style device has to provide a way to prove to someone else that it is in the operator's control. This is done by the 2FA device providing a code.For Google Auth, YubiKey, and the like, both the device and the someone else (a centralized online service provider) have a common "shared secret", and this secret can be used to generate short codes that are just a few digits long. The shared secret can't be stored in the blockchain because then anyone could generate the codes.Hardware wallets (and Bitcoin in general) use public-key cryptography and can use a publicly-viewable blockchain to prove that the codes they generate (called signatures) are valid. Unfortunately, the codes that they generate as proof are 155 digits long (or 88 if encoded in Base58), so it wouldn't be very practical to ask a user to type these codes in. That's (one reason) why they transfer these codes via USB.The point is that you can't have the advantages of both: you can't have a 2FA device which uses public-key cryptography and would be publicly verifiable via the blockchain which also provides short codes. This means we're stuck with either centralization, or hardware wallets which need a digitial connection (USB today, possibly Bluetooth or audio in the future?).Incidentally, Electrum 2.x does plan on implementing both styles of 2FA, with Trezor and HW.1 on the hardware wallet side, and with TrustedCoin on the centralized short-code side. Just for future reference, you can use change_gap_limit() instead which doesn't require a restart, e.g.:Code:>> wallet.change_gap_limit(200) You're in a tough situation, pretty much your only option is to attempt to a brute-forcing solution.There are free (but not necessarily easy) options, and there are paid options. To make matters more complicated, you'll need to decide if you want to try to brute-force your wallet password or your seed. Here's the break-down, as far as I'm aware.Free options:Â  Brute-forcing an Electrum seed: see this thread.Â  Brute-forcing an Electrum wallet password: see btcrecover (tutorial is here) or this thread.Paid options:Â  Brute-forcing a seed: ??Â  Brute-forcing a wallet password (I don't know which if any of these support Electrum):Â  Â  - https://bitcointalk.org/index.php?topic=85495.0Â  Â  - http://www.walletrecoveryservices.com/Â  Â  - https://bitcointalk.org/index.php?topic=717334.0FYI I can help out with the btcrecover option if you choose to try it. Good luck.... I know I'm not exactly answering your question (sorry, I don't really know ruby either), but if you'd like to try btcrecover (if someone with ruby experience doesn't respond), I can help you with that.You'd basically need to download it (from the "download zip" button at the page linked above), and then take what's below and save it to a text file named "btcrecover-tokens-auto.txt" in the same directory as the Python script, and then follow the instructions under Quick Start in the Tutorial.Code:#--pause --wallet /home/lapa/.electrum/wallets/default_walletguili%1,6dLet me know if you have any questions... You do need to be more careful when it comes to storing Electrum wallets online compared to many other wallets.As others have already noted, nearly all wallets are open to brute force attacks. However, given a strong-enough password, any wallet can be safely stored online. The big problem is in determining whether or not your password is strong enough to resist brute forcing attacks, and there's no easy way to be sure.This javascript site is the best I know of (thanks to Newar) at estimating password strength: https://dl.dropboxusercontent.com/u/209/zxcvbn/test/index.html. There's an accompanying article discussing its method's strengths and weaknesses here (spoiler: it might be very good, but it's definitely not perfect): https://tech.dropbox.com/2012/04/zxcvbn-realistic-password-strength-estimation/.What's different about Electrum is that it doesn't use any key stretching, so if you don't use a very strong password, you're much more vulnerable to brute force attacks than some other wallets such as Bitcoin Core or Armory. Here's a quick overview of how many cryptographic operations must be done to check a single password for these two wallet formats:Electrum: 2 SHA-256's (each a single block long) and 1 block of AES-256 decryptionBitcoin Core: approximately 100,000 SHA-512's (each a single block long) and 2x blocks of AES-256 decryptionsTL;DR: use a strong-enough password, and you'll probably be safe from brute force attacks, but it's really hard to know what "strong-enough" means. I think the question is did you run the second tool created by jonald_fyookball which assumes your seed is off by one word, and tries all possible seed combinations starting with that assumption (and takes a few hours to complete). To elaborate a bit, if you follow the advice next to the "News" alert at the top of every bitcointalk.org page, you don't need 0.9.4. It's a minor update whose main reason for existence is to work around the OpenSSL change mentioned in the News alert (plus a few other pretty minor bug fixes). There was an issue  opened on the bitcoin.org repo (to update the increasingly impressive developer docs) stating that 15-of-15 P2SH transactions have been standard since 0.9.0, and it included this link to the bitcoin repo as evidence of a 1650 maximum byte scriptSig: https://github.com/bitcoin/bitcoin/blob/0.9/src/main.cpp#L543So it appears that they're already standard unless something else is in the way (in which case I'm sure the bitcoin.org folk would want to know so they can correct the developer docs)... Do you have any older backups of your wallet file? Likewise on Windows -- if you lock your account either explicitly (shortcut: windows-L) or implicitly (starting a Remote Desktop session with user #2 while user #1 is logged in), all programs will remain running in the background (except Win8 Metro-style apps, but that's irrelevant). I think shorena's option of running a single Bitcoin Core instance w/o a wallet and then configuring mSIGNA or Multibit clients to connect to localhost is probably the best option. That would seem to indicate that you either no longer have the correct password for the wallet file, or that multiple bytes in the wallet file have changed. Between these two options, the former seems more likely....If only a single byte were corrupted, then at least the PKCS7 padding would be valid or the count of valid hex-encoded digits would be 16 or greater (because at least one of the three 16-byte AES blocks would still be decrypted successfully).I can think of three things you might want to try:1. Have you tried to run jonald_fyookball's (excellent) tool yet with a higher numberofreceivingaddresses and numberofchangeaddresses to see if any of the generated addresses are yours (if any of them exist on the block chain)?2. Attempt to brute-force your wallet password with either an open source bitcoin password recovery tool or using one of the paid services in the Services section of the forum.3. Attempt to brute-force your mnemonic on the assumption that one of the words is wrong or swapped with an adjacent word (although I'm not aware of any tools or services that exists to do this). What are all of the error messages it produces? I've no idea why that is....
Sorry about that; there was a bug related to ASCII/Unicode conversion, now fixed. Could you download a new copy and try it again? This is a tool that might (emphasis on might) give a more detailed error message on why your password isn't working. It simply displays your Electrum seed if the password is correct, and if not it prints one or more error messages.If you choose to run it, post the results back here and I'll let you know what I think (it's a Python script which I wrote).(Obviously, if it reports back any actual seed information, don't post it!) I've written MultiBit wallet manipulation tools in the past (in Python), so it shouldn't be too difficult to take one of those tools and change it to simply load and decrypt a wallet and print out a bunch of debugging info in the event of a failure. That may help (or maybe not...) in getting to the bottom of this.Unfortunately, it requires installing some Python libraries, and doing so is very difficult in OS X (although for the specific libraries that are needed, it's usually easy under Windows or Linux).tonyClifton13, I believe you're on OS X, correct? If you know someone you can trust to manipulate your wallet file and password who is on Windows or Linux, or if you have access to a Windows or Linux box yourself, let me know and I'll write such a tool when time permits. (If not, it doesn't make sense for me to go through the effort if all you've got access to is OS X though...) If I understand you correctly, you're saying that more sophisticated malware with keylogging isn't slowed down at all by good key stretching, and such sophisticated malware has become fairly commonplace. I couldn't agree more...Good key stretching is still important if you ever intend to keep wallet backups stored anywhere online (e.g. a backup services), and it can help protect against stupid malware (which still exists), but I agree it does nothing against sophisticated malware. In short: good password key stretching can sometimes help, and there's no reason for any wallet software to use weak key stretching (except of course that it requires development effort, and developers have limited time and long lists of new features to be added). As I'm sure you've guessed, BC.i requires each browser/OS combination to be email-authenticated (just once, unless you nuke your cookies regularly) for all accounts that have a registered email address, even those which haven't enabled 2FA. This is a fairly recent change (a few weeks ago).If you don't have a backup, and can't locate a browser with a cached copy, your only choice is to open a support request as others have already pointed out.... I can try, hopefully the language difference won't be a problem...Please describe everything you remember about your password. Creating a bunch of example passwords will also help. PM me if you'd rather not post the information publicly.Can Google translate the Quick Start section (just #1 and #5) and the Installation section of the Tutorial well enough for you to understand and to follow it? Did you have 2FA enabled? If you didn't, there's some chance your wallet is still cached in your browser (unless you've logged into it successfully in the last few weeks -- BC.i disabled caching a few weeks ago).To find out if you do have it cached, visit the login page (don't try to log in), press F12 to open the debugging tools, choose the Console tab at the top of the debugging tools, and in the console window type (depending on the browser, the console field where you can type things may be at the bottom of the console window):Code:localStorage["payload"]If you get something back in the console besides "undefined", copy the entire thing into a text file for safe keeping in case BC.i support can't/won't restore your access. Maybe I can... but no promises.I wrote btcrecover exactly for this purpose, but I've found that the biggest challenge to password recovery sometimes isn't technical, but instead it's the language difference.There's a Tutorial here, but it's in English which I'm sure will make it difficult to understand (and I don't speak French, sorry).If you can provide more specific details on the password you're trying to find (PM me if the password details shouldn't be public), I'll try to help out (but it would still be up to you to download btcrecover and run it on your own computer).... To help illustrate some of the excellent posts above, I've made a quick-and-dirty estimate of how often you might expect to find such seemingly common phrases in an Electrum seed. Intuitively, it may seem that it should only happen rarely if the seed is truly random, but in fact it's not all that uncommon.I downloaded the 1,000,000 most common 2-grams (phrases of 2 words) from BYU's Corpus of Contemporary American English. There were 61,721 common 2-grams on this list where both words were from Electrum's list of 1,626 possible seed words. So:Let w be the count of all possible 2-grams of words taken from Electrum's word list.w = 16262Out of these w possible permutations, 61,721 are on the downloaded list of common 2-grams.Let S be the event where a single pair of randomly chosen words is in the common list.P(S)Â  = 61721 / w â‰ˆ 2.3%Â  (probability a single random pair is common)P(S') = 1 - P(S)Â  Â  â‰ˆ 97%Â  Â (probability a single random pair is not common)Let T be the event where all consecutive pairs of words in a list of 12 words are not common.P(T)Â  Â = P(S'1 âˆ© S'2 âˆ© ... âˆ© S'11)P(T)Â  Â = P(S')11Â  â‰ˆ 77%Â  (probability that all 11 consecutive pairs of an Electrum 12-word seed are not common)P(T')Â  = 1 - P(T) â‰ˆ 23%Â  (probability that at least one of the 11 pairs of an Electrum seed is common)So there's an almost 1 in 4 chance that a randomly generated Electrum seed will have a pair of adjacent words on the 1,000,000 most common list. Since that list isn't all that big (for comparison, it includes "green screen" but not "velvel cage" nor "nerd paradise"), it's probably even more likely that a random seed contains uncommon but grammatically correct (and sensical) pairs of words like "nerd paradise". Although this really isn't related to OP's question, it may be worth mentioning anyways. One Electrum weakness (compared to Bitcoin Core) is its poor key stretching when password-protecting the wallet file (against brute-force attacks). Bitcoin Core aims to require about 0.1 seconds of CPU time per password attempt which results in around 100,000 SHA-512 iterations, whereas Electrum uses just 2 SHA-256's.This makes brute-forcing the password of an Electrum wallet much easier, and therefore requires the use of a stronger password (vs. Bitcoin Core) to achieve the same level of brute-force resistance. I went ahead and wrote a python script which can extract the seed from either a backup file or from the raw wallet file (which you can only get to if your phone is rooted). Feel free to give it a try, instructions and download links are at GitHub: https://github.com/gurnec/decrypt_bitcoinj_seed. You'll of course need your backup password (if it's a wallet backup file) and your PIN, if any.I've verified that the seed I get from the script can be used to generate the same sequence of addresses/keys as are in the app (I just went here and plugged in my seed -- obviously if you choose to do something similar with anything but a test seed, you should use an offline copy of that page). Technology-wise, they check off a number of boxes which Blockchain.info misses.I don't think they have any black marks in their history (BC.i has a number of them), but they're also much younger than BC.i. Short of an independent audit... it's awfully hard to say.Having said that, they are the mobile wall that I've chosen to use, so I at least think that they're a safe option.If you do go with them, please be certain to:Write down your "mnemonic" as soon as you can. It's your backup, your password (PIN) recovery, and it's the only way you can log into your wallet from new devices. Don't save it to your PC (or learn how to use strong encryption if you must).Don't be afraid of using the PIN quick login option, it may seem like weak security but it's actually quite strong (and convenient). (If you enter your PIN in wrong just 3 times, it becomes useless and you'll need your mnemonic which you wrote down earlier.)Enable email notification for both inbound and outbound notifications. Each email notification contains a special recovery file which you'll need should GreenAddress ever disappear from the net (heaven forbid, of course).If you intend on using GreenAddress from a desktop, enable two-factor authentication. For a mobile, I'd be less concerned about two-factor.That's my 2 satoshis... There are two ways of creating a bitcoin transaction. The (generally considered older) way requires a very secure RNG (an unpredictable random number generator), and for this reason it's considered a bit more risky. This is the method that Blockchain.info uses, and a recent change inadvertently broke their RNG for a little while.The other way is what tryexcept mentioned -- it doesn't need any RNG for creating a transaction, and is generally considered safer (although since it's also newer, not every wallet uses it). It's also much easier to write tests for, if the developers use an automated testing tool to make sure that no bugs creep in.(There are other ways too, but they're worse than the methods above, so they're rarely used.)(You do still need a good RNG when you first create your wallet though.) That's odd... when I try this, it works fine for me. Is this exactly what you're running?Code:pywallet.py --recover --recov_size 120Gio --recov_device \\.\PHYSICALDRIVE0 --recov_outputdir d:\You are on Windows, correct? Are you running it from an elevated ("Run as administrator") command prompt? Are you running the same version as I am (downloaded Sept 8th or later from https://github.com/jackjack-jj/pywallet)?Also, is your hard drive less than 120 gigabytes in size? It's just a directory name where a wallet.dat file with the recovered keys will be created. You shouldn't choose a directory that's on the same drive that your trying to recover keys from. If you only have one drive, you could plug a USB stick in and use it as the outputdir (e.g. "--recov_outputdir e:\" or similar).(edited to add: also you may want to move this thread over to the Tech Support forum... the "move thread" link is towards the bottom left) That's true, but it's not the most limiting factor.The effective strength of ECDSA is roughly half the private key length, so 128 bits for secp256k1 used by Bitcoin. 2^128 is still a staggeringly big number, so it's probably nothing to worry about anytime soon.128 bit seeds are easier to write down (BIP39 style), and 256 bit seeds probably aren't much stronger. This all assumes those 128 bits are actually generated from good entropy -- 256 bits of mediocre entropy are definitely better than 128 bits of mediocre entropy (and probably would make a practical difference).Incidentally, I keep inserting "probably" everywhere because I'm not an expert, so take all this with a grain of salt.... Positive error codes returned by Berkeley DB library are C errno codes, and error 1 is EPERM: Operation Not Permitted. Try checking the file and directory permissions on the machine that's having trouble to ensure whichever user is running bitcoin-qt has read/write permissions to wallet.dat. If it's just your ID you're missing, and you still know your password, you're probably OK.Open a support request here: https://blockchain.info/support-deskBe sure to include as much information as you can -- your previous wallet IDs, your IP address, your recent transactions, your balance (I wouldn't include your password but do mention that you still have it).Good luck.... Blockchain.info is a strictly non-BIP32 wallet (an older method of creating addresses which requires frequent backups), and with the exception of vouchers*, GreenAddress.it is a strictly BIP32 (newer backup-friendly address creation) + multisig (much better malware protection vs. non-multisig wallets after enabling two-factor auth) wallet. There is no way to import/export between the two of them. If you'd like to switch from one to the other, you'll have to send btc from one to the other and stop using any old addresses (or continue to use both).* Although I think you could technically create a voucher at GreenAddress and import its private keys into Blockchain.info, I have no idea why anyone would ever want to do this.... Try this to get the same list of addresses that's displayed in the GUI (they all have a reserved:0 in the wallet dumpfile):Code:python -c "import sys,json;s=open(sys.argv[1]).read();print '\n'.join(k['addr'] for k in json.loads('{'+s[s.index('keys')-1:])['keys'] if not k['reserve'])" THE_WALLET_DUMPFILE.TXTThe other addresses with keys are a result of change and the key pool.
findftp and aliveonearth:This is certainly the ugliest python one-liner I've ever written... but here it is anyways Code:python -c "import os.path as p,urllib2 as u,json;n='wallet.aes.json';assert not p.exists(n),n+' exists';i=raw_input('ID: ');r='https://blockchain.info/wallet';o=u.build_opener(u.HTTPCookieProcessor());d=0;exec '''while d==0:\n try:d=json.load(o.open(r+'/%s?format=json'%i)).get('payload')\n except u.HTTPError as e:raw_input(e.read()+'\x5cn\x5cnRetry...')''';m=d or raw_input('2FA: ');d=d or o.open(r,'method=get-wallet&guid=%s&payload=%s&length=%d'%(i,m,len(m))).read();open(n,'wb').write(d)"1. Copy and paste the one-liner into a terminal (command prompt). In Windows, you'll probably need to add "C:\Python27\" to the beginning.2. After pressing Enter, it will ask you for your wallet ID.3. If you have an email address associated with your account, it will display a (very long) error message which starts with this:Code:{"initial_error":"Authorization Required. Please check your email."Â  Â  You'll need to follow the directions in the email you receive from BC.i and click on the "Approve" button. Only after doing so, press the Enter key (at the "Retry..." prompt in the terminal window).4. If you have two-factor authorization enabled on your account, you'll receive a prompt asking for your 2FA code. (If it's an email or an SMS 2FA, you should receive it from BC.i shortly).5. Once the above is complete, a wallet.aes.json file will be created in the current directory (the script will fail with an error message at step 2 if such a file already exists).Let me know if this works (or doesn't)! Although I sympathize with your frustrations, you should realize that the BlockChain.info folk are trying to improve their security for the benefit of all of their users. There's absolutely no reason to believe that there are any malevolent intentions in their recent changes.BC.i doesn't have the best security track record (and if you'd like to "jump ship" to a more modern alternative, e.g. an online multisig wallet, I'd have no objections), but the fact that they're trying to improve is overall a good thing. The encryption for the wallet backup is AES-256, which is nice and strong. The entire wallet is encrypted (including the public keys, addresses, and transactions). The key derivation function used is rather weak, it's basically 3 MD5's. This means that the wallet backups aren't resistant to brute-forcing attacks (compared to say Bitcoin Core, Armory, or GreenAddress.it's PIN), so using good/long passwords is advised if you plan on storing them anywhere online. (Presumably the choice of KDF was to make it compatible with openssl's command-line tool for decryption).The PIN encrypts the private keys (and the seed), but not the public keys/addresses. These encrypted keys are part of the wallet backup, so you need both the wallet backup password and the PIN to perform a restore and then spend any funds.It should be noted that enabling the PIN option does not encrypt the initial on-device backups made shortly after install. This means that malicious apps which have root access can gain access to your private keys, even after you set a PIN. This is not a problem on an unrootable device, and at the moment it's not a problem on a rooted device as long as you don't give root(/SuperSU/SuperUser) access to any questionable apps, however malware will continue to become more sophisticated, so this may one day be a problem... (to be fair, a malicious app that acquires root access could find other ways to eventually access your private keys even if they were encrypted, so encrypting them may not help much anyways).Edited to add: regarding that last paragraph, it is a problem if you lose your phone, and if it's rootable (as many Android phones are). A PIN would not protect your funds from a knowledgeable thief in this particular case, but hopefully nobody stores large quantity of bitcoin on their phone.... To both aliveonearth and findftp:Blockchain.info has been somewhat improving their (formerly very lax) security as of late (make no mistake: this is a very welcome change!), so it's not surprising that the Python one-liner isn't working. The wallet format hasn't changed (not enough to affect btcrecover, but the defaults have changed enough to affect JtR). On the other hand they are being more strict about who(/what) can and can't download the encrypted wallet files.If you already have a wallet.aes.json file, btcrecover will still work.If you don't, getting the wallet.aes.json file might be more difficult (and may be impossible if you don't have access to the email address associated with the BC.i account).I'll post back here once I have more info (probably not for a day or two though). btcrecover, which I mentioned above, does support GPU-accelerated password searches for wallet.dat files (or for dumpwallet.py files like you also partially posted above).It's still pretty unclear (to me anyways) if this is a password you remember most of, or if it's a KeePass or similar password which you don't have any of. If it's the latter, and if it's a complex as you've stated, than there's absolutely zero chance you'll ever be able to recover it without recovering it from KeePass. Here's a link to the time it would take to brute-force a random 30-character long password (upper + lower + digits) using 4 high-end GPUs. There are some options available that may help.This thread has a lot of good info in it, you may want to take a look.btcrecover is a tool that can help you recover your password, if you remember enough about it. The Quick Start is here. It's not necessarily the easiest to get configured and running, but it is free and open source (FYI I'm biased... I'm the author of that tool, let me know if you have any questions about it).There are also a few individuals in the Services section that are willing to help for a fee, you may want to search over there too (and also search around for their reputations; there are some with some good past history). It's pretty hard to say... it seems pretty likely that Linux's and BSDs' CSPRNGs for the most part have a lot of randomness from the environment to use. Of course it's much harder to predict when it comes to closed-source implementations (Microsoft, Intel).Why use OPs method unmodified when simple changes remove the bias (or when alternatives exist with no bias)? Well, I thought the whole point was to replace a potentially faulty OS-provided CSPRNG with true entropy that has near-perfect uniformity.I don't really see the point with replacing it with one that has obvious bias (even if it's not a lot of bias). In other words, an OS-provided CSPRNG, especially if it's an open-source one, is probably better than any method that definitely has some bias (and it's not like removing that bias is all that hard).edited to add- practically speaking I think you're right in that it probably doesn't matter, but I'm no cryptographer, so I'd personally prefer to err on the side of safety and not use a method that introduces bias... I don't understand what you're asking.... (edited- sorry that I called OP's method yours, my mistake)In case you don't realize this, Electrum's seed isn't a sequence of words, it's actually a sequence of 16 bytes. When you ask Electrum for the current wallet's seed, it takes its binary seed of 16 bytes, and converts it to the sequence of words (the mnemonic) you see for convenience. Likewise when you restore a seed, it immediately converts the mnemonic back to the original 16 bytes, and saves that to the wallet.The source of the bias is that some mnemonic sequences (like the example I gave above) convert to the same internal 16 seed bytes, and therefore generate the same list of addresses. These internal seeds are more likely to be created by you algorithm unless you "throw out" the extras using the steps from this post above. Am I being any more clear now? As the redditor eventually figured out, it's vulnerable to modulo bias (even after the improvement, albeit less so). Using a truncated SHA-256 of enough truly random data (e.g. 50 dice rolls or a deck of cards (at least the first 25 cards cards of a very well shuffled deck)) as the initial seed would eliminate any bias (at least any predictable bias, so long as SHA-256 isn't broken, and if it were there'd be much bigger Bitcoin problems).More concretely, I'd do this (25+ cards seem easier to me than 50+ dice rolls, but pick your poison...)Â Â 1. Shuffle a deck of cards very well.Â Â 2. Record at least the first 25 cards in the deck, e.g. if the first three are king of spades, 9 of diamonds, and ten of hearts, you'd have: ks9dthÂ Â 3. Plug your random data into this one-liner in Linux (assuming you have Electrum installed):Code:python /usr/local/lib/python2.7/dist-packages/electrum/mnemonic.py `echo ks9dthac3d7d4s... | sha256sum | cut -c1-32` I did, but it was a bit vague...This mnemonic: "weary weapon unseen like like like like like like like like like" and this one: "sister glide dude near muse sent like like like like like like" both produce the same binary seed (which is this in hex: 0x1003ca7a7000000000000000000000000) and they both produce the same address list (starting with 17A2fgCpcKEbg7CbfiJwAb8sjdEzUWD2y2). Feel free to try restoring both. That means that this address list is two times more likely to be created via your method. If you follow those three steps I mentioned, you eliminate this bias.4/1000 number comes from this: (# of mnemonic permutations / # of binary seeds) - 1 == (1626^12 / 2^128) - 1 == about 4/1000. So about 4 in 1000 mnemonics correspond to two binary seeds / two address lists.edited to add: it's much like your REROLL lines. When Electrum goes from a mnemonic to a binary seed, instead of choosing to REROLL (and declare the mnemonic invalid) when it hits a duplicate, it just "rolls over" to the next binary seed instead (via modulus math, it's like saying your NR 1627 would be "like" instead of "REROLL").When Electrum creates a seed, it starts from the binary seed (one of 2^128), and creates the mnemonic from it, so it doesn't introduce any bias when creating a seed (assuming its CSRNG is good of course).Fair enough, but in my experience (not IMO, but rather what I think most people believe them to be) the defining feature of a brainwallet is something human-created and possible to remember (which leads to poor entropy and danger). I have no trouble with a randomly-created brainwallet such as yours, though.  Definitely not Armory unless your wallet.dat file is older than April 2012.... (most wallet software has moved to compressed public keys except for Armory). This looks pretty good, but it has a couple of issues...First, you need a deterministic way to decide which die is #1, which is #2, etc. For example, you could roll them each one at a time, or you could use six different colored dice with each color always representing the same die #, or you could just always read the dice from left-most to right-most however they happen to fall (easy to do objectively if you have Travel Yahtzee). If you don't have some such deterministic method, you will almost certainly introduce bias as you read off the dice in your own personal order.Second, although your method does create a uniformly distributed mnemonic (sequence of 12 words), a uniformly distributed mnemonic does not produce a uniformly distributed binary seed. That's because about 4 out of every 1000 seeds can be represented by two different mnemonic sequences even though they result in the same list of addresses & keys. To avoid this without changing your method much, you need to:Â  1. Create a new wallet from the randomly created word sequence.Â  2. Retrieve the seed (from the Wallet menu).Â  3. If the word sequence you generated is different from the one you checked in step 2, discard the wallet and start from scratch.There's a less than 0.4% chance you'll need to do this. If you don't believe that this can happen, restore any wallet whose seed starts with "weary weapon unseen" (and then any 9 words from the list), and you'll see that the seed you later retrieve differs from the one you restored.Finally... please don't call it a brainwallet. A brainwallet is something that's easy to remember, and typically has very little entropy (bad). Your method has plenty of entropy (good), and is definitely not in the same category as a brainwallet. There are quicker methods, but your method is simple and transparent which I like. See over here, in particular the posts by DeathAndTaxes and the ones that mention TitaniumBackup (root only). Unfortunately, it's not that simple (and it's a bit misleading IMO).When you log into Blockchain.info (even if you use good 2FA such as Yubikey), the private keys for your wallet are sent to your computer. This means that your computer (and any decent malware that's running on it) has access to those private keys, and can use them to relieve you of any funds.By default, Blockchain.info doesn't save those private keys to disk (if you have 2FA enabled), and that does protect you against stupid malware, but it remains much less secure than per-transaction 2FA used by multisig wallets (where only a portion of the necessary key material is ever on your computer and available for malware to abuse). Not to put too fine a point on it, but blockchain.info doesn't support any (decent) 2FA.Logon-only 2FA (such as supported by Blockchain.info) does help protect against online password brute-forcing attacks, but it does practically nothing to help protect against malware (e.g. keyloggers), which seem to be the more ominous threat.Per-transaction 2FA (such as supported by GreenAddress.it and BitGo.com) means that each transaction that sends bitcoin out of your wallet must use a new 2FA code. This type of 2FA offers very effective protection against malware (although it's not necessarily perfect).You should keep all this in mind when weighing your wallet options.... I've been bugged once or twice to create a thread in Tech Support for it so it's easier to find... I should, and I will one of these days :-)  If you think there's a chance you have you're password wrong (e.g. a typo) you could try a brute forcing tool. btcrecover supports Electrum-LTC, it might be of some help.Ignore that, I didn't read the OP very well, and it probably won't help any. There are also open source (free) solutions. btcrecover is one, although it's more difficult to use... If your wallet is protected by a password that you type in, than a keylogger can grab it -- there's no way to protect against this. If you're worried about malware and keyloggers, you should be looking at solutions that aren't simply password-based, e.g.:1. Web-based multisig wallets with two factor authentication, e.g. Greenaddress.it or BitGo.com.2. Desktop-based multisig wallets, e.g. Armory or mSIGNA (and another trusted individual running the same).3. Cold storage solutions, e.g. Electrum or Armory.4. Hardware wallets, e.g. Trezor or Ledger (a.k.a. HW.1).(Of course, each of these also has its downsides.)The seed is enough.
The decryption part isn't too hard because you can use the fairly standard openssl command-line tool, however starting with version 3.47 the decrypted format changed from a text file containing WIF-style privkeys to a Google Protocol Buffer format. There are some advantages to the new format, and there's plenty of documentation on Google protobuf, however until someone writes some software to handle the new format, it's not particularly easy to deal with. I'm sure that feature is available, but I'm afraid I know next to nothing about OS X and so I probably can't help you very much...Just like on other OS's, you do need Bitcoin Core installed and synced. Have you done that yet? The Armory file format is the same across platforms, so you should be able to use the 'Wallets -> Import or Restore Wallet' menu option to import an Armory .wallet file.This will tell you where to find your wallet file on your old hard drive for most operating systems: https://bitcoinarmory.com/faq/#q3 Do you mean that when you created your wallet, you chose a password that was the same as your seed?Although there shouldn't be any problem with that, I have to ask... how do you remember it? The point of having a separate password is so that you don't need to remember the seed....In any case, if you have the full seed (it should be twelve words long), you can just do a File -> New/Restore, create a new wallet file, choose to Restore from its seed, and then paste it in. Assuming that the address you want to remove was created prior to version 4.0 (roughly the beginning of October), and that you're running a recent version today (3.47 or later), it is theoretically possible but would be a giant pain, not to mention fraught with peril. (If you're currently running a version older than 3.47, it's actually much easier. If the address you want to remove was created after version 4.0, it may not even be possible).So, how important is it to keep your old addresses? Is it worth a few hours of your time? More importantly, is it worth paying somebody else for a few hours of their time to figure out and document how to do this (would involve decrypting a backup (easyish), modifying a protobuf-format wallet file (not so easy...), and re-encrypting it (easyish) so that it can be restored in the app)?If you're an IT person and would like to try figuring it out yourself, I could give you some starting points, but like I said it won't be easy.... Although bitcoinj has a full node option, I don't think MultiBit can be configured to use it (I could be wrong though).You can run bitcoind or btcd on the same machine (or on another) and then force MultiBit to connect to it and only it. This gives you the benefit of using full height-based transaction validation. To do so, locate your multibit.properties file (in the %AppData%\MultiBit folder on Windows) and add this (it's just a text file):Code:singleNodeConnection=127.0.0.1(or some other IP or DNS name) I hope you'll understand that I will not... that's up to silverfuture to decide.Although if you have a set of password criteria in mind, I might be able to estimate such a thing for your circumstances, but you'd need to be fairly specific (about the password, about your wallet software, and possibly about your PC as well). I have a favor to ask of someone who already has MultiBit HD built and installed.I'd like to get a copy of a newly created & empty wallet file. I could d/l the JDK and build it myself.... I'm just being lazy and hopeful that someone might take a few minutes to help me out.If anyone's willing, specifically I'd like a:Newly created wallet,this password used to protect it: btcr-test-passwordnothing else added to it or changed.FYI this is so that I can test bitcoinj support I recently added to btcrecover.If anyone's willing, please email the wallet file to cenrug-mbhd@yahoo.com. I'll lock this thread if I get any takers.Thanks!n/m A lot of people on this forum choose to help out just for the heck of it, or just because they believe that Bitcoin has a future. For me, it's also (in part) because I hope to learn something new. So, for whatever it's worth, you're helping me  (and by the way, I'm actually older than 32 by a little...)Sorry, I really know almost nothing about OS X. I suspect that OpenSSL comes pre-installed on it, so that should actually make your life easier, it's just a matter of navigating the command line interface. There are many pitfalls here, e.g. the caps lock key (as VanityMemory already mentioned), the input method editor, using different keyboard layout languages, and just plain-old-typos. However, if there's something wrong with the wallet file itself, there are two ways you can attempt a recovery. (These are Windows-specific instructions; Linux will differ.)Method 1 - restore from digital backup1. Open Armory and take note of the ID of the wallet you're having trouble with.2. Close Armory.3. Go to the Start Menu, click Run (or hold down the Windows key and press R -- on Windows 8 this is the right alternative).4. Type this in the text box: "%appdata%\Armory", and then click OK to open the wallet storage directory.5. Right click on the wallet file that has the ID you noted in step 1 (and doesn't contain "backup"), and click "Cut".6. Minimize your windows, right click anywhere on the Desktop, and click "Paste" to move your wallet file to the Desktop for safe keeping.7. Open Armory.8. Click the "Import or Restore Wallet" button (you'll have to wait until Armory reaches an "Online" state).9. Choose the "Import Digital Backup" option.10. Type this in the Filename text box: "%appdata%\Armory", and click the "Open" button.11. Select the wallet file that has the ID you noted in step 1 (and does contain "backup"), and click the "Open" button.12. Click "Yes" when prompted.If this doesn't work, you'll need to restore from your paper backup (you did print one out, right? )Method 2 - restore from paper backup(This method may not restore all of comments you've added to your wallet, but it should recover all of your bitcoin funds.)1. Follow steps 1 through 8 above, if you haven't already.2. Click the "Import or Restore Wallet" button.3. Choose the "Single Sheet Backup" option, and then just follow the instructions.If neither of these options work for you, there might be a typo in your password. There are tools that can try to search for typos in your password (e.g. btcrecover), but they they do require some effort to use....Let us know how this turns out (hopefully well!) That sounds like a good idea I agree... I'm grasping at straws here.Thanks for the link, I added a note to that issue a short while ago. It appears that clubshaft was using the correct password, but more than one of his .wallet and .key files were corrupted, and he eventually was able to recover an older .key file he retrieved using a file restoration utility. I'm not sure I agree with his conclusion that the file corruption was the result of a bug in MultiBit, but I've no way to tell. It would be interesting to examine both his corrupted and uncorrupted files to look for differences... that might give some insight as to the source of the corruption (or it might not).Have you tried following gary-rowe's advice regarding openssl yet? I'll repost it below (slightly modified for a default Windows install):Now that you have a .key file do the following (I've made the instructions step by step for Windows):1. Ensure you have OpenSSL installed. Specifically, you should choose "Win32 OpenSSL v1.0.0o Light".2. Copy your multibit key file into the C:\OpenSSL-Win32\bin folder, and rename it to "multibit.key".3. Open the command prompt and navigate to C:\OpenSSL-Win32\bin (on Windows type "cd \OpenSSL-Win32\bin" at the command prompt).4. Enter the following at the command prompt on a single line:Code:openssl enc -d -p -aes-256-cbc -a -in multibit.key -out decrypted.txt -pass pass:yourpasswordChange "yourpassword" to your password (but leave the "pass:" prefix in there).OpenSSL will attempt to decrypt the file and will tell you if it is successful. The decrypted keys will be placed in decrypted.txt and should now be considered compromised. You'll need to sweep funds out of them as soon as possible into a safe area. If you have those keys you have your bitcoins.If you open the decrypted.txt file in a text editor like Notepad, you should see one or more lines like this, one for each key:Code:L3BdsUEuHb15LgPp8ZpEhckMdRj4bPnrj352RgqgUUVKvngnBDph 2014-05-20T18:38:41ZYou can see the key file format here: https://multibit.org/en/help/v0.5/help_exportingPrivateKeys.html Agreed. Spam-- as in the junk that people like awesome31312* add to their sig in the hopes of netting a few pennies. (yeah I know I should just enable the "Don't show users' signatures" option and stop complaining)* nothing personal, I just hate sig spam Correct.At first glance, that seems... silly. But if you consider how it works, and how it might work if there wasn't a reshuffle before each hand, it makes more sense.Right now, at the beginning of each hand you're given access to a hash of the shoe. At the end of a hand, you're given access to the entire contents of the shoe. This supposedly* makes the game fair because the server can't change the shoe after the game has begun.Obviously, once the shoe is revealed, it can't be used for the next hand, so a reshuffle is in order. An alternative would be to only show the entire contents of the shoe right before a reshuffle, e.g. once 66% or 75% (or some other %) of the shoe was used up and a reshuffle would be "normally" required.But what happens if the player wants to leave before the next reshuffle? In other words, if the player wants proof that the game isn't rigged, should they be forced to continue playing until the next reshuffle?One option might be to allow the player to view the contents of the shoe at the end of any hand of their choosing (which of course would be followed by a reshuffle), but this isn't any better. A card counter could use this to their advantage and force a reshuffle whenever the count gets too low. (This sort of strategy is possible IRL but more difficult because it involves moving between tables under the watchful eye of security.)So there probably isn't a better option; had I been the coder I probably would have made the same decision.* I haven't actually looked at CoinJack's provably fair algorithm, so I don't claim it actually is provably fair, I'm just taking their word for it. If all they provide is a hash of the shoe and nothing more, there would definitely be some problems.... I get the same impressions (not that I'm any sort of BJ expert though... I haven't played in years). There's a lot of good information available on the topic, though.Regardless of shoe size, a reshuffle occurs before every hand. (Implementing it any other way would be problematic due to the the provably-fair requirement.) The two are incompatible with one another, but there would remain no way that an outside observer (who doesn't have the privkey used for a signature) to determine if k was generated deterministically or it was "mined", so your method remains possible (and it's pretty cool that you went and implemented it ). Yes, and it's quite salient that you brought up TrueCrypt -- it has some leaky side channels which (before the ongoing audit began) were pointed out as avenues for exactly this kind of evil-implementation attack (and yes the source code was examinable at the time, but there wasn't a reproducible build process for Windows). Here are the rules of a version that I tested a little while back (I don't know what's changed since then).number of decks: configurable according to OPdealer wins ties (very uncommon, typically it's a push)double after hit allowed and on any card values (fairly uncommon)can't split more than once (split 3 times for up to 4 hands is more common)double after split allowedhitting (and/or doubling) after splitting aces allowedBJ pays 3 to 2 or 6 to 5: configurable according to OPdealer peeks (if dealer starts with 21, the hand immediately ends)can't double for less (uncommon)dealer hits on soft 17: configurable according to OPno insurance Sorry, I wasn't very clear.The "attack" I was trying to refer to involves an evil (and closed source) ECDSA implementation that intentionally leaks X successive bytes of a privkey in each signature it creates. Only someone aware of the leak, e.g the authors of the implementation, would able to take advantage of it. Given multiple signatures, the evil authors could reconstruct privkeys of those using their implementation.An advantage (perhaps not the main advantage though) of a deterministically generated k is that one can validate the output of a closed-source implementation without needing the source code (assuming the method of generating k is published). If for example ProprietarySoft Corp. published an ECDSA library, researchers could verify that it wasn't using this channel to leak privkeys.I was just bringing up that point -- none of this really applies to open source implementations. I thought that the ability to create subliminal messages in a security protocol was generally considered a flaw of that protocol.For example, an evil ECDSA implementation could leak a user's private key to the implementation's authors. Isn't that (one) reason that newer ECDSA implementations deterministically generate k?(I'm just repeating what I've read elsewhere on the forums and on the web, e.g. DJB's blog.)
I hate to say it, but that makes it seem like a mistake in the password you're using (I'm still not 100% sure though). You've already tried a bunch of combinations, but did you follow bitbaby's advice regarding the use of an Input Method Editor (if you've ever used one)? Do you ever switch keyboard layouts (e.g. between English/ASCII and Cyrillic)?If it is a typo in the password, you'll have to look into a password recovery tool (or a paid service). This one can try different combinations of typos in a starting password, it's free but it's tricky to get working if you're not familiar with using the command line: btcrecover. The Quick Start is here. What??Having Java enabled in your web browser may not be safe, but there is absolutely nothing wrong with having Java installed on your PC.Dangers occur when there are vulnerabilities discovered in Java (happens too often...), and you or your browser runs a malicious app. There is no reason to believe MutliBit is a malicious app, so as long as you disable Java in the browser (which in Windows can be done easily via the Java Control Panel app) you are safe from these types of attacks.Maybe there are other reasons not to like MultiBit, but the fact that Java in the browser might not be safe? That isn't a reason.... New competition in the multisig wallet provider space is a good thing."Calvin", however, has made a number of fairly dubious claims, and that's left me, at least, feeling rather uncomfortable with FrozenBit.It will be interesting to see how things progress from here. I think you'll have a tough time getting over the negative image he's left FrozenBit with, but for what little it's worth I wish you the best.If I might offer a small bit of advice: the more open you are, the better. For example, even if you don't choose to open source all of your code (which is perfectly fine when it comes to the server-side code IMO), placing the code which you do decide to open source up on GitHub (or similar) earlier rather than later would be a good thing.Best of luck... If the number of transactions validated per node is inversely proportional to the number of nodes (even if it's a manually configured constant), we're at O ( txs ). I agree.Now I'm confused-- did you create a new wallet with no password first? The idea was to try importing the .key file into a brand new wallet with no password, but the error message "The wallet password is incorrect" only occurs for me if I try to import a .key file into a wallet that already has a password. Dooglus is right, and I was wrong. Thanks for the correction, dooglus. (I should have known better, I've read that code before....)mricha, my sincere apologies for the false sense of hope. I'd suggest you start by reading one of DannyHamilton's excellent posts in this thread, perhaps this one: https://bitcointalk.org/index.php?topic=85495.msg6591146#msg6591146. If you can remember enough details of your password, it may be possible to find it, but what you've remembered so far probably isn't specific enough.I'd be happy to help you try a brute forcing tool (such as those mentioned above) if you can remember enough details.Code:bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)...Â  Â  Unlock(strWalletPassphrase);Â  Â  NewKeyPool();Â  Â  Lock();...bool CWallet::NewKeyPool()...Â  Â  BOOST_FOREACH(int64_t nIndex, setKeyPool)Â  Â  Â  Â  walletdb.ErasePool(nIndex);Â  Â  setKeyPool.clear();... With 1 being least and 10 being most screwed... around 8ish I'd guess, maybe higher... As long as you didn't create a bunch (100ish) of new addresses or outgoing transactions, restoring from your backup has a much better chance of restoring your funds if the backup isn't encrypted.Take a backup of your existing wallet.dat file first, and then restore the older backup. If there is zero balance, close Bitcoin and try running it with the -rescan option, e.g. go to Start -> Run, and type "C:\Program Files\Bitcoin\bitcoin-qt.exe -rescan". Hopefully this helps... Wow... I was a doubter that this would happen, and I'm very happy to be wrong!Thanks! When you say "the government", you're implying that the US, the Netherlands, and Belgium will join forces to extort all of the core devs (to say nothing of other eyes on the project) to insert a back door? If that's likely to happen (it's not), I doubt any additional audits (which could also be influenced in the same way) would be of any help. (I agree you're correct in principle though.)Putting aside the unlikelihood that all versions, forks, and clones of Bitcoin Core have been backdoored (in a way that apparently can't be reversed), btcd is at least one full-node alternative, re-implemented from the ground up, which supports getblocktemplate: https://github.com/conformal/btcd/wiki#Mining. It's quite an ambitious project, you should take a look. If you haven't already, I would:1. Try to locate and open your backup wallet, see here: https://multibit.org/en/help/v0.5/help_fileDescriptions.html2. If that doesn't work, create a new wallet (and give it a description just so you don't confuse it with the original).3. Hopefully locate one of your private ".key" backup files (see link above).4. Import the keys into the new wallet (Tools -> Import Private Keys).If either of these work, could you compare (just out of curiosity) all of the addresses in the non-working wallet and the working one to see if there are any differences? (except for the one new address that's automatically created for you in a new wallet, that is) Looks like they changed it two days after initially posting it. Your only fault was updating the Armory links too quickly after release  A "bitcoin enthusiast" is not everyone. See Gavin's definition I just quoted above. Without at least some limit, bitcoin nodes become centralized. Also, the suggested exponential upper limits seem very unlikely to limit bitcoin growth. (Text in brackets added by me to indicate what I understood you to be saying.) Agreed.We lose nodes per hashrate, which is bad and leads to (or rather continues the practice of) miners selling their votes to node operators, but I don't see how we lose hashrate, we just centralize control of hashrate to amortize node maintenance costs (still bad).So long as the grandma-cap can be maintained, it seems like all of your discussion would already be covered. The hope has always been that new techniques (IBLT, tx pruning, UTXO commitments, etc.) will keep this possible.However there is no way to see into the distant future. Any chosen grandma-cap could be incorrect, and any cap more restrictive than that to meet #3 could also be incorrect. I don't disagree that #3 is desirable, only that it may not be implementable. Having said that, as long as a more restrictive cap has little to no chance of interfering with #2 (never prevent a miner from including a legitimate tx), I'd have no problem with it.TL;DR - This goal implies the "only permit an exponential increase in the max blocksize during periods of demand" rule in your initial example, correct? Actually I picked the term up from NewLiberty's post, but yes that's what I was assuming it meant. Should the term "grandma-cap" make it into the BIP? It seems to me that (1) and (2) could both be implemented with either the static (Gavin's) method or some reactive method, although the I suspect the reactive method can do (1) more safely/conservatively. If a reactive method can do (2) safely enough (I suspect it could), I'd prefer it. A reactive method seems much more likely to meet (4).If I understand you correctly, (3) takes us back to an artificial cap on block size to prevent a perceived, as Gavin put it, "Transaction Fee Death Spiral." I've already made my rant on that subject; no need to repeat it.I'm of the opinion that reaching consensus on (3) is more important, and possibly more difficult, than any static-vs-reactive consensus. (3) is an economic question, whereas static-vs-reactive is closer to an implementation detail. Although we can argue about details, we (or at least I) have been using "grandma" as shorthand for "Bitcoin hobbyist", which Gavin had equated to "somebody with a current, reasonably fast computer and Internet connection, running an up-to-date version of Bitcoin Core and willing to dedicate half their CPU power and bandwidth to Bitcoin." Is that reasonable? I think your first alternative looks better since it would cover more use cases, but either would work for me. Of course there's also the Windows registry, but that seems an unwise option for multi-platform software...This is OT, but has someone noticed this easy-to-fix bug which could use some attention? Speaking of database locations...With Armory, I know that either --datadir or --settings would have to remain a command line option so that ArmorySettings.txt can be located, but it would be kinda nice if --dbdir could be settable via File -> Settings and stored in ArmorySettings.txt. That way I wouldn't have to remember to update all the start-up shortcuts each time I upgrade Armory. Just a thought... NewLiberty, thanks again for taking the time to explain your point of view.The reason, by the way, I was asking the earlier questions was because I actually didn't know the answers. In particular, this answer (happily) surprised me:Regarding Nielsen's law:I don't disagree that Nielsen's law is inaccurate, however I remain quite skeptical that there's something in the blockchain that can more accurately predict grandma's computing resources. Having said that, I think I'm misunderstanding your goal here (and I'm maybe OK with that): it seems as though you're not interested in using grandma's computing resources as a block size limit, you'd prefer a much lower bound at times when transaction volume isn't growing.My biggest concern with the alternatives discussed in this thread isn't the potential for unchecked growth, but rather the potential for miners creating forced artificial scarcity (hence my first question, for which I expected a different response).For example in the first algorithm you suggested, a majority mining cartel could artificially limit the max block size, preventing a mining minority from including transactions. It's this lack of free-market choice that I'd disagree with.If the difference between average block size and max block size were a magnitude or two of order away, I'd find it much more agreeable.My (ideal) goals, in particular, would be to (1) never kick out grandma, and (2) never prevent a minor from including a legitimate transaction. (edited to add: those are in priority order) Very well.No metric that can be gleaned from the blockchain has a causal relationship with "the bandwidth and disk space an average enthusiast can afford", and therefore any such predictor has a high danger of being either too restrictive or not restrictive enough.Using Nielsen's Law also has a danger of being inaccurate, however given that it has at least been historically accurate, I find this danger much lower.Do you disagree? (let's leave ossification out of this just for the moment, if you don't mind)
Fair enough- block size may not be the best parameter to tweak to maintain the stated "bandwidth and disk space" goal, but it is a technically simple parameter to tweak.Do you believe that there exists somewhere in the blockchain a metric, let's call it X, which would serve as a good predictor of "the bandwidth and disk space an average enthusiast can afford"?I think this is the same question, though you may disagree: Do you believe that this metric X has a causal relationship with "the bandwidth and disk space an average enthusiast can afford"? ThankÂ  you.Would you agree, if it were possible (although it is not), that the blocksize limit should somehow be automatically tied to "the bandwidth and disk space an average enthusiast can afford"? NewLiberty, I have a quick question for you which will hopefully clarify your position in my mind.Excluding DOS flooding or other malicious actors, do you believe it would ever be a beneficial thing to have the blocksize limit hit? Any such scheme would lead to exactly the same attacks mentioned above. An attacker would only need to DOS the other servers such that the attacker's server is the only working server that remains (this is similar to what can happen with Electrum clients that don't do full SPV; the Electrum client does do full SPV but there's at least one client I'm aware of that uses Electrum servers but doesn't do SPV). My thoughts exactly. My 3 year old GPU can generate SHA256 hashes at a rate of about 70M/s. 6 hex digits == 2^24 combinations. 70M / 2^23 (combinations on average to find a collision) equals about 0.1 seconds time to fake a paycode.The signature doesn't seem to help, either. It only proves that an invoice is signed by someone. Of course if a paycode server were to fake an invoice, they would create a perfectly valid signature signed by themselves.Maybe, if the invoice and the paycode both covered the exact same set of data, such an attack would be more difficult, but at first glance this doesn't seem very safe from MITM. Except for that last clause perhaps, no arguments here.More structure can cut both ways. If done well (big if), it can reduce centralization by better distributing "votes." But you're right that you can't convince everybody.My first assignment after college (20ish years ago) was with a defense contractor maintaining a codebase written in... BASIC. In any case, point taken. Fair enough.Asside: did you preview your post at any point? It's in your draft history if so... It does indeed look like the OS X download link in Armory is wrong.You can view the download links Armory uses here: https://s3.amazonaws.com/bitcoinarmory-media/dllinks.txtThe link for OS X on that list points here: https://bitcoin.org/bin/0.9.3/bitcoin-0.9.3-osx.dmgHowever the correct link is this: https://bitcoin.org/bin/0.9.3/bitcoin-0.9.3-macosx.dmgClose, but no cigar.In their defense, it looks like it used to be the correct link, but then the link was changed post launch: https://github.com/bitcoin/bitcoin.org/commit/5ebee77e56222d717ffc3606b8ed6c8c3687e384Of course you can always download it yourself; other than that we'll need to wait for a kind Armory dev to fix this (which happily won't require a new version of Armory I believe). There's nothing magical about the number 6, as I'm sure you're aware. 7-confirmation reorgs or attacks could happen, they're just less likely than 6 (and more likely than 8 ).I don't think your idea is bad per-se, I just don't think that the advantages it confers outweigh the new vulnerabilities it introduces, but that's just my opinion. Consensus does not imply unanimous appeal. Although threads such as these help to flesh out different ideas and opinions, they do very little towards determining where consensus lies. This thread could represent a vocal majority just as easily as it could a small but vocal minority (on either side).This is exactly where a more formal governance model (as I mentioned) could help. It too would surely be imperfect, but just about anything would be better than determining consensus based on who writes the most posts, thoughtful though they may be.A formal governance model could draw distinct conclusions: yes the BIP passed, or no it didn't. If it didn't, it can lead to compromise. If, for example, I knew that there was little support for gavin's version, I for one would be much more willing to compromise. But I simply don't know.... instead, I choose to assume that people who support Bitcoin do so because they support the ideals of a free market, but I could be wrong.I'm having trouble imagining a use case where embedded hardware with difficult-to-update software would connect to the P2P network, much less having anything to do with handling the blockchain, but my imagination isn't all that great. I also have trouble in general with any device whose purpose is highly security related that isn't software upgradeable. (Such things do exist today, and they're equally ill-advised.) It's a free attack for a miner, and can arbitrarily kick anyone off the network (even if temporarily) who doesn't have sufficient bandwidth or ultimately enough disk space. I don't think that this completely eliminates casascius's attack.Evil miner M finds a lucky block, and withholds it. During this period, evil miner M prepares double-spend attacks, and can point his mining power to his new (secret) chain.Once good miner A publishes her new (but less lucky) block, M can take advantage of his double-spends (which now have only one confirmation), wait some short period of time and then announce his superior block.M can therefore trick anyone who chooses to accept 1-conf transactions (which admittedly isn't all that smart, nor does M have that long to do so), plus they've also been able to mine on a secret chain while the rest of the network was wasting their time on A's shorter chain. Not that I was asked, but I'll offer an opinion anyways.At worst harder, but not impossible.Today we have a sort of self-enforced (by the core devs) consensus system, plus of course the ultimate ability to vote with your node and with your mining capacity. I wouldn't expect the latter to ever change (indeed some blocksize limit is required to maintain this goal). For the former, however, I doubt that having this little governance around important changes to Bitcoin will last forever -- 20 years hence I would expect a much more regimented procedure, somewhat more akin to a standards organization than what we have today (perhaps with a combination of academic, miner, and corporate interests represented, but that'd be an argument for a different thread).More governance is both bad and good-- in particular on the good side, bright lines can be drawn when it comes to voting in a way that doesn't happen so much today. If the ISO can finally manage to crank out C++11, despite the contentious issues and compromises that were ultimately required (and C++14 just two months ago too!), pretty much anything is possible IMO.If you're that worried about a ossification, perhaps you'd prefer a dead man's switch: in 20 years, the blocksize reverts to its current 1 MB. We all agree that the current max block size is too restricted.What seems obvious to me is that different people have different opinions on the underlying purpose of any blocksize limit.At the risk of putting words into his mouth (for which I apologize if I'm wrong), Gavin sees it as a technical anti-DOS measure: to prevent miners from DOSing voting enthusiasts out of the network. If this is true, the best solution would be for an automatically adjusting limit that tracked the speed of residential connections and of residential hard drive capacities (enthusiast residences). Since that seems impossible, gavin's limited-exponential growth seems like the best educated guess that can be made today.Others see it as a as an economic issue, and would like to tie the limit to some economic aspect of Bitcoin to solve this perceived economic threat. I'm no economist, and I certainly don't know if they're right. But guess what: I personally don't care if they're right.Any restriction on blocksize is an artificial one, a regulation determined by some authority who believes (perhaps correctly) they know better than I. I'm OK with technical restrictions, and those that improve the ability to vote, but I am completely against any restrictions whose purpose is to alter an otherwise free-market system.To but it bluntly, I would rather see a restriction-free Bitcoin crash and burn in the hands of a free-market system, than I would participate in a regulated Bitcoin. To me, Bitcoin should be a free market experiment (as much as is technically feasible), even if this leads to its eventual failure. Of course, that's just my personal opinion, but it's the basis for my dislike of more-limited blocksizes.I mean no disrespect to some of the clever alternatives presented in this thread-- but I personally wouldn't want any of these "regulations" in Bitcoin.Let me ask a question: is there anyone here who both (a) favors additional blocksize restrictions (more strict than Gavin's), and also (b) believes such restrictions are not additional "regulations" that subtract from a otherwise more-free-market system? You're proposing that the total work be based on the value of the individual hashes, instead of the hash targets, is that correct?This could incentivize a miner who happens to find a hash with an unusually low value to refrain from immediately broadcasting it. See, for example, this attack proposed a few years ago by casascius, which becomes viable with this proposed change. Nobody here denies that pretending-to-be-a-female-and-scamming is common. But gender is not irrelevant: if it were, it wouldn't bring with it the hostility we've seen in this thread.Let's consider some IRL analogies. If a woman walks into my church, I don't think anything unusual about it. If a woman walks into my basement and wants to play WoW with me and my male nerdy buddies, that is unusual.*Now I could care less if the playership of WoW is mostly male, but substitute math club in for WoW, and suddenly I do start to care. A hostile environment for young women interested in math is something to be concerned about (and, for the record, back when I was in a math club in high school (yeah I was that kind of nerd), there were no women in it).Bitcoin compares most closely to that last example. If it's ever going to be taken seriously, it has to have the same gender balance as, say, the USD. I don't think it's particularly relevant whether or not any single individual (e.g. fabiola) is male or female, but the existing gender imbalance of Bitcoin and the occasional hostility that goes along with it absolutely is relevant.* Those were just examples, I'm neither religious nor a WoW player, nor do I live in my parents' basement  Great to hear, but don't thank me, thank jackjack!  You'll need to run bitcoin-qt with the -rescan option, e.g. close Bitcoin Core, then go to Start -> Run, and type "C:\Program Files\Bitcoin\bitcoin-qt.exe -rescan". Hi, jackjack.You may want to at some point consider adding the fix-wallet-creation-crypto patch from the original pywallet in -- it looks like new pywallet is affected by those same bugs. You'd also need to re-add append_PKCS7_padding().https://github.com/jackjack-jj/pywallet/commit/b52c955f8c93a75745166ebf281448016e1f22e2-Chris
Responded to you in the pywallet thread over here.You should probably take it easy with posting to 4 different threads on the same issue... 2 threads (one in the Armory section, one in tech support) are plenty... Responded to you in the pywallet thread over here. Earlier versions of pywallet prior to September 8th had a bug which would, under some circumstances, cause it to create a recovered wallet with a password that didn't work in Bitcoin Core. It might be possible that you were affected by this bug.I'd try this:Â Â 1. Close Bitcoin Core, and then make a backup of all of your current wallet files (preferably onto a different drive or USB stick).Â Â 2. Download the current version of pywallet from here (the download zip button is on the right): https://github.com/jackjack-jj/pywalletÂ Â 3. Choose a wallet.dat file that was showing the correct balance in Bitcoin Core, but whose password wasn't working, and run a pywallet recovery on it.Â Â 4. Check if you can send a transaction, or simply sign a message, in Bitcoin Core with the recovered wallet.Let us know if this works with one of your wallet files, or if it fails with all of them. Good luck.Edited to add: I agree with those responding to you in the Armory thread that you probably never created an Armory wallet, and that Armory is probably unrelated to any of your Bitcoin funds (because you're able to see your balance in Bitcoin Core). I just wanted to share this quick anecdote.I've been using GreenAddress as my preferred mobile wallet for a little while now, and I've been quite happy with it.I ran into a small issue on Friday that was preventing me from creating a transaction. It was easy to find a workaround though, so it wasn't tying me up. I did a little bit of troubleshooting, but eventually gave up.I sent an email to their general support box on a Friday at 6pm (my local time) along with the steps to reproduce the issue, and I explicitly mentioned that it wasn't really affecting me, so it didn't matter how long it might take for a response.To my surprise, I received a pretty detailed response back by 8am Saturday morning listing out a few different bugs (all relatively minor) that they had found and fixed, as well as an expected release timeframe for the updated version (about a week).I just wanted to post here to commend them -- I was really impressed that they took the time to read my email and reproduce the issue, and that they got back so quickly (even though it wasn't a big deal to me). All this , and it's a free service.So anyways, thanks for a great piece of software and a great service!All the best,Chris And I just noticed now that we're both responding to a post made in November 2013  (a spammer necroposted, but the spammer's post was since deleted by the mods). This shouldn't happen... the server for some reason is not sending your browser enough information to permit the login process to complete.If it continues, you'll either need to submit a support request, or restore the wallet from a backup. To submit a support request, visit: https://blockchain.info/support-desk Yes, but the hash target doesn't necessarily move from 135 bits to 136 bits, it moves from 135.1 to 135.4.The total difficulty of a chain (for the purposes of determining which chain is longest) is the sum of the difficulty targets, and has nothing to do with the "luck" of the miners / block hashes. That depends on how much you remember about the password... if it's long enough and you don't remember much or anything about it, there's pretty much no chance.If you do remember a lot about the password, you can try to use a tool that will go through various combinations to recover it. One such option is btcrecover (I'm the dev of that tool, so naturally I'm biased), it's a free & open source password recovery tool you could try. You will need to do a bit of reading to get it set up and running though. The Tutorial and the Quick Start are here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialIf you have any questions about it, feel free to ask.There are also people in the Services forum who offer assistance with password recovery, so you could check there too.Good luck... It seems to be missing the coat of arms of Mexico... we're not going to have another big argument here, are we?  Please don't paraphrase what I said... what I said was "we already have a way to slow down hash generation: increase the difficulty. Keep in mind that difficulty is not a bit count [emphasis added], it's more finely granular than that."In other words, I completely agree with deepceleron. I have to disagree with you, but this part is a matter of opinion.I think Bitcoin should strive to be as decentralized as possible. It's not perfectly decentralized now, but I see no reason to add additional potential points of failure or points of control. Rather I'd prefer the opposite -- remove what few remaining centralized points are left.I suspect that the majority of nodes on the network are not miners, and therefore have no concept of best-block-so-far-in-my-pool, and remain susceptible to a DoS.I think you just described a PoW system... hard to generate and easy to verify. How this add-on PoW is any improvement of the PoW already in use? Cryptography is a complex subject, and cannot always be discussed in 5-word sentences (I even bolded the parts that actually needed addressing). I will try, but you may not like the results.1. You claim nearly all CSPRNG is flawed. Then, as a workaround, you recommend vanitygen, which uses a.... CSPRNG (a fairly common one, OpenSSL). Can you explain the difference?2. Your dartboard scheme for creating entropy is slow and biased, the sort of thing no cryptographer would ever come up with. Why did you?3. You claim that "paperwallets" are superior because they use entropy from a mouse. You cite a bunch of wallet clients you claim to have found "through heavy testing" to be faulty, and yet every one that you cited also uses real-world entropy, just like "paperwallets". Armory, in particular, uses mouse input plus several other sources of real-world entropy. How could a cryptography expert miss this fact?4. You've made extraordinary claims. If you are unwilling or unable to provide extraordinary proof (which is understandable for a work-in-progress), you will likely be ridiculed unless you can at least provide extraordinary professional credentials for your "few dozen mathematicians, statisticians, and even a half dozen cryptographers with over 45 years combined education." Why have you done neither?Is that better? A node does not send a recently received block (or rather, it does not notify connected nodes that it has a new block to send) until after it has fully verified the block, including the hash target, so the only way to flood the network with blocks is if you can generate them (with the current difficulty).As I understand it in your proposal, every X minutes, all nodes will need to see all potential blocks before a consensus can be achieved, which seems to be open to DoS.Adding a new restriction to the target hash would slow down hash generation, but we already have a way to slow down hash generation: increase the difficulty. Keep in mind that difficulty is not a bit count, it's more finely granular than that.I'm afraid I don't understand what you're saying here. Nice production values, and easy to understand, but I can't say much positive about the content of the latter half of the video.For one thing, it's very one-sided, claiming that proof-of-stake is strictly superior to proof-of-work. The link to the forums below isn't very useful, either. I might suggest a more recent thread which includes more enlightened views on proof-of-work and proof-of-state (and proof-of-idle too): https://bitcointalk.org/index.php?topic=776541.0There's also a strong implication that Bitcoin is on its way towards switching to a proof-of-stake system, which seems extremely unlikely to happen given the problems it has (see that link for details). Why can't you tell if they're the same? Couldn't you look up some of the addresses in a block explorer to check if they have any transactions (that match up with what you remember)? If they don't have any transactions, it seems likely that you typed in the wrong seed.Also, be sure to read the rest of this thread if you haven't already... A hash is just a big integer (in this context), there's no need to do something this complicated if all you're after is changing the hash-target scheme to an exactly-one-block-per-unit-time scheme. Just compare the hash's integral values, and the value closest to zero wins.However do you think it's a good idea for the Bitcoin network to flood itself with one or two hundred fully solved blocks every 10 minutes? How would you implement an anti-DOS scheme to prevent an attacker from flooding the network with thousands or millions of solved-with-low-difficulty blocks? It's rather telling that he claims a "paperwallet" (I assume he means bitaddress.org) has a safer RNG for key generation than Armory (which, among others, has undergone "heavy testing" by his team) because "paperwallet" uses mouse input.... Hash Hyena, I have a couple of questions / points which I hope you can address. The first is related to your interim key generation recommendations.Given that vanitygen is just another CSPRNG, and therefore flawed by your reasoning, why would you recommend it over any of the others you mention above (all of which use, exclusively or at least in part, the same OS-provided source of entropy)? In fact, vanitygen intentionally decreases entropy when it throws out generated keys which do not match the predetermined pattern, which would (slightly) decrease the security of the generated keys.First of all... how did you generate the random pattern of digits on your dartboard to begin with?Regardless, any single set of random data is of course itself randomly biased, including your dartboard, and re-using it naively like this (I assume you don't create a new dartboard for each throw) combined with human bias will introduce that bias into its output. For example, it's very likely that there exists a hex digit on your dartboard which occurs less frequently on the periphery than it does towards the middle. Since I presume you'd avoid aiming your darts such that they might miss the dartboard, this hex digit is more likely to occur in your generated output.In fact, a much better approach which would lead to less biased random numbers (assuming that the individual target boxes are small enough) would be to use a regular repeating pattern for the dartboard, where each 4x4 section contains exactly all 16 hex digits. How is it that nobody on your team caught this?(This is to say nothing of the fact that throwing 64 darts at a dart board is silly-inefficient compared to just shuffling (well) a deck of cards...)Next, moving back to your assessment of alternative clients:First it should be noted that all of the clients you mention above (including BitAddress.org, which is I assume the paper wallet to which you refer) begin with the same source of OS-provided entropy (/dev/random on Linux/BSD or CryptGenRandom on Windows). Even though these two sources of entropy are in part provided by deterministic processes, they also use external human-influenced sources to maintain their internal state, e.g. the starting of programs, the initiating of or receiving of network traffic, the timings of writing to or reading from disks, etc. It is inaccurate to claim that the wallet clients you mentioned do not use significant amounts of human-source entropy.Next, let's move on more specifically to your assertion that "through heavy testing that Armory ... has the same problems." Given that Armory gathers entropy from some of the same sources [github.com] as "paperwallet" (in fact it gathers entropy from many more human-influenced sources than "paperwallet"), can you explain why Armory has a flawed CSPRNG, whereas "paperwallet" does not?Given that you've saidI find it extremely discouraging that you can make such basic errors as those outlined above. The net effect is to make me exceedingly skeptical of not only your overly-broad claims (which cannot be proven nor refuted due to their vague nature), but also of your abilities as mathematicians and cryptographers and even your intentions. Posting your team's professional qualifications (names, degrees, and peer-reviewed publications) would go a long way toward alleviating some of these concerns, even if you choose not to be more specific regarding these alleged vulnerabilities still under investigation.I also hope that you can specifically address the questions above. You're welcome, and thank you for the kind words.I'll definitely be starting a new thread (in the Tech Support section). I'm waiting until I have a bit of time to finish up some documentation on Unicode support, and then I'll start one. Thanks for the advice! They attempt to block Tor, but that doesn't mean they're successful. See obfsproxy.
If you have both of the "xor" files, file.x and file.y, than the additional "key" is simply an XOR cipher with a static repeating key on top of that. To quote Wikipedia:Scary, but unfortunately not surprising...That would probably be best. Remaining open to constructive criticism is always a good thing. Yeah, sorry if it seemed too harsh, I really should have added a smiley... I hope you don't find my lack of smileys disturbing. Well, I've got some feedback if you'd care for any...1. It's not obvious that "encryption" automatically deletes the just-encrypted file.2. The deletion of the original file is not a secure delete. Because there's no way to inhibit the deletion, the just-encrypted data is guaranteed to still be present on the hard drive.3. The deletion of the original file fails on Windows (because you don't close the file first).4. If the "out" file already exists, "encryption" mode is assumed, and file.x and file.y are silently overwritten if they exist.5. The "key", which additionally "encrypts" the file, is naively implemented and does not add any additional protection. Your statement that the two files can be "stored in separate secure locations--which is unnecessary" is inaccurate; the key feature leads to a false sense of security and should be removed entirely or re-implemented.Finally, I'm not entirely clear what advantage this scheme has over creating two files using well-established cryptography, one with the ciphertext and one with a passphrase, and storing them apart from each other.I'm sorry for being harsh, it's not my intention to be mean or discouraging. The fact that you're releasing this open source indicates a willingness for peer review, and that mentality should be applauded. However, it's almost always a bad idea to try to implement cryptography yourself unless you're a cryptographer (I'm not one, and I'd certainly hesitate to do so myself). Even just using existing well-written crypto libraries can be very hard to get right....Best of luck! No arguments here when it comes to being able to mine in a pool without having to sell your vote, that's definitely a topic that doesn't get the attention it deserves. That refers to a specific stop-all-or-nearly-all-the-transactions attack, however a stop-some-but-not-all-transactions attack, or enough double-spend attacks would probably work just as well in crashing the market if it went on for long enough.Edited to add: He also mentioned in that same blog post that someone willing to spend enough money could continue to pull off a stop-all-or-nearly-all-the-transactions attack even with the countermeasure in place. I don't know where you get your delusions, laser brain. The fair shuffling article you mentioned actually explains why, but you may have missed it. PRNGs are typically seeded with either 32 or 64 bit numbers. Let's say we choose a PRNG that has a 64-bit seed (the article went with one using a 32-bit seed). That means it has about 1.8 Ã— 10^19 different starting points, so at most that many different combinations of hands can be dealt.Single-player blackjack, assuming an 8-deck shoe (very common) and a 4-hand split limit (also common), can consume at least 68 cards (that's the best I could figure, anyways). Producing 68 choices from an 8-deck shoe yields 1.5 Ã— 10^79 different combinations (around 15% the count of atoms in the visible universe Wolfram|Alpha tells me) edited because that's all wrong, it's closer to, but larger than 2.7 Ã— 10^114 different permutations (20ish million billion billion billion times the count of atoms in the visible universe). This analysis isn't entirely fair, because many of those combinations would never be chosen when hands bust early, but suffice it to say that if you start with only a 64-bit seed, you are immediately eliminating the the ability to generate the vast majority of possible combinations. Their solution was: (1) server shuffles first, using a long-running CSPRNG that does not have this limitation, and then (2) we both identically shuffle the result, using a simpler PRNG with a smallish seed.Edited to add: if you're using a 32-bit seed, as they were in the article, it's also more likely than it should be that you deal the exact same hand multiple times.Regarding your random card selection algorithm, I'd suggest that read up on the Fisher-Yates shuffling algorithm instead. It's actually a bit faster than your proposed algorithm (because it never has "collisions"), and like yours it does not need to shuffle the entire deck if it's not required (although it's much faster to do so if desired). I suspect that a gambling site would prefer to go ahead and shuffle the entire deck anyways just because it would appear more transparent to the average user even if it's not really necessary.Does this answer some of your questions?Also, to Tetraplay Casino: congratulations on being the very first user I've ever added to my ignore list. Your obnoxious off-topic 100% spam response fully qualifies you for this honor, thanks. I happily see that the mods have nuked said spam, thanks! Surprisingly not a bad article, thanks. In briefly describing the history of girls (or rather of "no girls") on the Internet, it almost exactly parallels what we see today on Bitcointalk (and it's a good read for you young folk who've never heard of MUDs, MOOs, etc.)Unfortunately it looks like Bitcointalk has only reached the 4chan phase, a.k.a. the "TITS or GTFO" phase. Hopefully, as (and if) Bitcoin gains popularity, this forum will be able to drag itself into the new millennium (easier said than done, since scammers will always be here with us...) One thing not yet mentioned in this thread is the difference between per-transaction 2FA and logon-only 2FA.Logon-only 2FA (such as supported by Blockchain.info) helps protect against password brute-forcing attacks. Unfortunately, it does practically nothing to help protect against malware.Per-transaction 2FA (such as supported by GreenAddress.it and BitGo.com) means that each transaction that sends bitcoin out of your wallet must use a new 2FA code. This type of 2FA offers very effective protection against malware (although it's not necessarily perfect).You should keep all this in mind when weighing your wallet options. There exist tools (such as the one here, although it's not intended for newbies: https://github.com/petertodd/replace-by-fee-tools) that will create double-spend transactions which may work some of the time. By "work", I only mean that it can "fool" recipients who choose not to wait for confirmations.(FYI many people don't consider the term "double-spend" to ever apply to 0-conf transactions...) I hadn't replied yet because I don't know an answer to your problem, and was hoping that someone else did.I think that this should be very unlikely to ever happen. I think it means that a 48-byte encrypted private key was decrypted and had the correct 16 bytes of padding, but then the derived public key didn't match the public key stored in the wallet. This all seems very unlikely to happen unless the public key alone in the wallet file was corrupted. But if that were the case, I wouldn't expect your wallet balance to be correct, so I must be missing something here...How many addresses are in your wallet?Are you certain that all of the addresses displayed are correct?Are any of the addresses in your wallet completely unused? That's a great article, thanks.Good points. I hope you're not suggesting that you should type your brainwallet into google to check its password strength....Â   Just a thought, but another possibility might be that the Linux out-of-memory killer was tripped. Many VPS providers don't create a swap file by default, which might be a cause of this (but be careful, creating a swap file might cost you $ depending on the provider and on where the swap file is created). People already do it for other brain wallets, so I don't see why it would be any different for Armory brain wallets.That sounds pretty good to me. Since it's no longer a brain wallet, there's no reason to call it a "brain wallet pass phrase", right? I do believe that in suggesting that (or any) entropy estimation tool, you just contradicted yourself...Entropy estimation tools such as the one mentioned can provide, at best, an upper bounds estimate, and therefore provide a false sense of security. They assume password crackers only use particular predetermined techniques when generating password guesses, however crackers are forever improving their techniques (furthermore these techniques are not necessarily public knowledge).The (nice, thanks for that) article you pointed to exactly demonstrates this. I took the first "difficult" password mentioned in the article (which has been successfully cracked using the described techniques), and plugged it into the estimation tool, and got this:Code:password:Â  Â  Â  Â  Â  Â  Â  Am i ever gonna see your face again?entropy:Â  Â  Â  Â  Â  Â  Â  Â 100.857crack time (seconds):Â  1.1482519836189682e+26crack time (display):Â  centuriesscore from 0 to 4:Â  Â  Â 4calculation time (ms): 7It seems awfully unlikely that the article's authors were able to crack a password with 101 bits of entropy, hence the estimate is a bad one. So, just to reiterate: estimating entropy is really hard... I'm not familiar with pandacoin, but here's the best advice I can give you. Basically, you'll need to create a test wallet with a known password, and test one of the password recovery techniques in this thread to make sure it succeeds, and then try your real wallet:First and foremost, close the wallet software and then make a backup (or two!) of your wallet file.Rename your wallet file, and restart the wallet software.I'm presuming that a new wallet file is created during startup (which is common). If not, create a new wallet.Add a password to the new wallet.Find and install some software from this thread that can attempt to recover passwords from bitcoin wallets.Configure the software to check your known password against the newly created wallet from above, and see if it succeeds.Assuming it does, use this software against your backed-up wallet.I realize it's a pain, so you might rather enlist the (paid) services of someone in the Services Discussion section. Maybe someone with pandacoin experience will reply, but until then, this is the best I can offer... Let's just say that she has more to hide than it might first appear.... (google reverse image search is your friend ) Wait, you're not a native English speaker?? Your English is much better than many (most?) native speakers I've seen on this board...Sorry, I actually don't know that much about JtR... but I think that the --wordlist option just takes the input file and uses each line as a single password, so nothing at all like btcrecover's token file. JtR can make all sorts of alterations to each line, but I don't know much about making JtR construct whole passwords the way btcrecover does.You can however use both programs together: you can run btcrecover with the --listpass option (and with no --wallet), and it will generate and output whole passwords to test, one per line, and then you can use JtR (with it's better cracking speed) to actually try the passwords. I imagine there's a way for JtR to accept passwords directly from it's stdin, so you could pipe the output of btcrecover directly to JtR, e.g.Code:btcrecover.py --token tokens.txt --listpass | john --options...Oops, my mistake, thanks. Sure, here's a token file:Code:housetree%2,5dThat third token becomes all combinations of numeric digits, between 2 and 5 digits long, and can appear in the beginning, end, or between the other two tokens. It's described here in the tutorial: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#expanding-wildcardsIf you'd like to restrict that wildcard token to the end, you'd use this:Code:housetree%2,5d$That "$" forces it to be at the end (if present at all, it doesn't make the token required in every try). That feature is described here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#anchors Yup, that's the one. I don't know if you've finished compiling the bleeding version yet, but it might be worth getting an OpenCL or Cuda version compiled and working, it runs around 8ish times faster than the CPU-only version (and FYI CPU-only JtR runs about 6 times faster than btcrecover with Python 2.7.8+).What do you mean by "bruteforce any unknown characters"?
I agree it seems like a nice long passphrase, but this is exactly the problem.We humans (myself included of course) are really bad at estimating how much entropy something has by just looking at it, and we're just as bad creating things with lots of entropy using only our brains. If it turns out the passphrase was in fact good enough, you'll know in 10 or 20 years because your key was never stolen. If, on the other hand, you were wrong, your bitcoin could disappear at any time between now and then.If you're that worried about losing your paper backups, you can be nearly as paranoid as you want, e.g. print a 2-of-6 backup, and store them all in safety deposit boxes at different banks. (or how about just a standard/1-of-1 backup that you tattoo to a, uh, private area of your body? that should be hard to lose and, depending on your profession, hard to get stolen too ) serje is probably hoping fabiola! is Fabiola Campomanes (links possibly NSFW). Won't he be surprised when he finds out that she's actually Fabiola Boulanger  Which "this" did you mean?Most of the methods in this thread will work on most altcoins which were originally based on Bitcoin software (and that's most, but not all, altcoins). So in short: probably, but it depends on the details... I don't recall this thread being started by fabiola! with the intent to prove her gender. She started it by asking if there are other girls into Bitcoin, and why it seemed there are so few.It was, in point of fact, the "scam-alerters" who shifted this towards a well-then-prove-you-are-a-female thread. I don't see any reason she needs to (it's not like she's posting pictures of herself in exchange for loans or something).I happen to think that this kind of thread is perfectly fine in the Beginners & Help section. It demonstrates the wide variety of attitudes towards women on this board, and can inform newbies on the subject (although, granted, those attitudes aren't all that different from many other online communities). It also servers as a warning to newbies on the methods of some scammers. I'd like to think it's at least somewhat welcoming towards woman new to Bitcoin, too. Seems on-topic to me... Nothing personal, but a wide-sweeping statement like this is completely inaccurate.There are a number of (hot-storage) wallets which are nearly as or more secure than the Bitcoin Core client, and offer important features lacking in Bitcoin Core (not to mention cold-storage solutions and hardware wallets, which are considerably more secure for BTC funds). I thought I might be able to help out a little bit here...To download the (encrypted) wallet from blockchain.info, run this from the command line (Linux or Windows, but for Windows you need to install Python 2.x first).Code:python -c "import urllib2,json;f=urllib2.urlopen('https://blockchain.info/wallet/9bb4c672-563e-4806-9012-a3e8f86a0eca?format=json');print json.loads(f.read())['payload']" > wallet.json.aes(Obviously you'll need to change the UUID to match yours first.)For brute-forcing the password, I'd recommend one of two options.If the downloaded file doesn't start with these two characters: {" , and if you've created or modified (e.g. added new receiving addresses) to it at sometime after March, 2012 (when the wallet format changed again), and if you're on (or have easy access to) Linux and are comfortable compiling software, then I'd recommend John the Ripper ("bleeding-jumbo" version). It's faster than the alternative (and much faster with a GPU).Otherwise, I'd recommend btcrecover (course I'm biased since I'm the dev of that one...). It supports some blockchain.info wallet formats that JtR doesn't, and it's easier to set up (no compilation necessary), especially on Windows. The Quick Start is available here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorial. Let me know if you have any questions about it... I'm not sure what to suggest.All of the key and wallet files you have found so far are eitherfor the older wallet, orare corruptedis that correct?If you've never made any external backups, than you are at risk for losing a wallet file (that's the same for any wallet software you use), for example, if the HD starts to fail, if the OS has a bug, if malware deletes or encrypts them, or if MultiBit has a bug (I doubt that last one, I'm just listing it for completeness).I think the only thing left to consider is getting some form of professional help.For example, wrt that corrupted wallet file: It's barely possible that someone with protobuf experience might be able to manually resconstruct one or more private keys from it.Another possibility: a professional HD recovery expert might be able to recover additional wallets or key backup files from your HD which your file recovery software missed. If you're interested in this possibility, you should really stop using this HD for anything ASAP; any continued use reduces the chances of finding existing file fragments (especially if it's an SSD).I know this isn't what you wanted to hear... but if a file is gone, and there's no external backup of it... then it's gone. Instead of worrying about the import process, you really need to worry about that second password first.If, for example, your password is 12 characters long, and only has lowercase letters and numbers in it, but is completely random (e.g. generated by a password generator of some sort), than I'm afraid there are far too many combinations (4 billion billion of them) to successfully brute force. Using the fastest available open-source software (John the Ripper with a GPU), and it'd still take you around 10,000 years...Code:36^12 = 4,738,381,338,321,616,896So before anything else: Do you have your second password? If not, was it random? You're right, you don't need it, I was just trying to guess what might be going on such that you have bitcoin running from the PPA at the same time as having the bitcoind stub from the Ubuntu repo, and this was the best reason I could imagine...As marcus_of_augustus already noted, it shouldn't affect you much. If you want to keep troubleshooting anyways, please run these three commands (while bitcoin is running) and paste the results back here.Code:COLUMNS=120 dpkg -l bitcoin*file `which bitcoind`pgrep bitcoin | xargs -Iz ls -l /proc/z/exe When I installed the bitcoind package from the PPA in LM17, it installed to /usr/bin (so that's the installation directory for the PPA version).My fresh install of Armory was able to automatically locate it there, so it's a little strange that your Armory didn't automatically locate it, but maybe you're not doing a fresh install?Regardless of all of this, I'd just follow etotheipi's instructions, they look best all around to me. There are very very few people who fully understand Bitcoin (I know I certainly don't), regardless of their sex... there are plenty of people who may think they do, but most of them are wrong I think it's possible for most people to understand enough about Bitcoin (with some effort of course) to be capable of using it responsibly. I think you maybe misunderstood? Instead of trying to clean up the dust by sending yourself a single transaction with 1000 dust inputs, try sending yourself 10 separate transactions each having 100 dust inputs. I've had experiences go both ways, using the same PC and ISP. Part of the problem is that blocks are only downloaded from a single peer, and connecting to a peer with a good (or poor) upload capacity is pretty much a matter of luck. (There are plans to improve on this.)No arguments with respect to MultiBit, but you don't have anything to worry about when it comes to downloading a bootstrap.dat file (it's just a data file, not something you "install"). For more details on why it's safe, take a look at the thread I mentioned earlier. The important parts are that you can follow Steps 1 (Installation) and 5 (Running btcrecover) from the Tutorial. The other steps I can try to help you out with.Try to describe everything you remember about your password, and anything you think you may have messed up while typing it in (in other words, any typos you think you may have had). Don't use specifics, e.g. if you know your password contained the word "secret", just substitute in another word in your description.I'm familiar enough with btcrecover that I can finish the other steps off without too much difficulty (I hope ). Ah, much better (iamanewbie: to create a wallet file, just copy and paste the text, including the "{", everything in-between, and the "}", from your email into a notepad file.) I think crazy-pilot is partly right.The wallet isn't encrypted with a main password, but it is still encrypted with the second password.In order to import the wallet, it looks like you'll need to:Â  1. Add a second password to the new blockchain.info account, this second password must match the second password of the wallet you're trying to import.Â  2. Import the wallet as described above. One option is btcrecover, it's a free & open source password recovery tool you could try. You will need to do a bit of reading to get it set up and running though.If you'd like to try recovering it yourself, the Tutorial and the Quick Start are here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialIf you have any questions, feel free to ask (I'm the dev of that tool).Good luck... Did you see my question and comment above?I think this will replace whichever wallet you currently have in your account. It's a new account with nothing in it, is that correct? Do you have the entire text (starting with "{ guid" and ending with "}"? If so, you should copy and paste the entire thing into the "Import Wallet" page. You'll still need to figure out your second password before you can access your funds, of course.Edited to add: if you do have the entire text, than you do have your identifier. It's immediately following the "guid" Pretty sure. It's Base64, so it's not in a "standard" format, and it's exactly the same length as a blockchain.info encrypted private key that I have here in a test wallet.
In addition to your second password, you will also need something called your "shared key" which is stored on the Blockchain servers or in a full wallet backup (it is used as an encryption salt). I assume that Blockchain will require you to somehow prove ownership of your account before they will provide this.Do you know your second password? Did you use any of the Blockchain options to take a backup of your wallet? In that case, it's the right length to be a private key encrypted using blockchain's "second password" method. You won't need the main password, but you will need the second password.Did you make any changes to the "Debugging" settings in your account? In particular, if you changed the "PBKDF2 Iterations" setting, you will also need that. That looks like an encrypted blockchain wallet, except that it's too short. Is it longer than this? (don't post it here...)If this is the only form of backup that you have, you will need your two passwords to gain access to your funds. If the password was long and random as you've said, there's no way to retrieve or guess it... In short: bc.i wallets are json files. The "main" password AES-encrypts the entire file (including all addresses and private keys), which is then base-64 encoded. The "second" password, which is optional, AES-encrypts each individual private key. I assume the point is to allow logging into bc.i with your main password from untrusted locations to check your balance without having to risk your funds (as long as you don't type in your second password of course). I'm not sure you know what you have, but I could be wrong...This "private key" that you have, how long is it? What are the first 3 letters? If it actually is a private key, then it will be easy to help you import it. If it's something else, it may not be easy (or possible)... With it being that far behind, it would almost certainly be faster to delete the blocks and chainstate directories and start from scratch with a bootstrap file.(Bootstrap info is here: https://bitcointalk.org/index.php?topic=145386.0; latest available bootstrap torrent is Armory's, and a link to it can be found here: https://s3.amazonaws.com/bitcoinarmory-media/announce.txt) I would guess (just a guess though) that something was messed up before you installed the new .deb, and that installing the .deb triggered something. In other words, it seems unlikely that this is an Armory issue...I don't know much about desktop environments/X on Linux, but maybe this will help. After booting, switch to a terminal screen with Ctrl-Alt-F1 and log in. Take a look inside these logs to look for anything suspicious:Code:less /var/log/syslogless /var/log/boot.logless /var/log/Xorg.0.logLike I said, I probably can't help, maybe someone else here can... my honest opinion: you're probably better off seeking support in a Mint or Ubuntu forum. Do you have both bitcoin-qt from the PPA and bitcoind from the Ubuntu repo installed? Do a "dpkg -l bitcoin*", if you have both "bitcoin-qt 0.9.3" and "bitcoind 0.3.24" installed, then do a "sudo apt-get upgrade bitcoind" to upgrade it to the PPA version. I've no doubt this is true, but at what point is it acceptable to use statistics such as these to make libelous claims such as "you're a scammer"?  you have my condolences, for whatever they're worth...I was trying to make two points: (1) although there's a need to prove yourself before being trusted, there should be no need to prove yourself to avoid being called a scammer; (2) even though both fabiola! and samaricanin have not "proven" themselves by sending pics to someone, only fabiola! was called a scammer (due to her gender). Sorry if the way I tried to make these points inadvertently caused offense... Please read this, it probably answers your question: https://en.bitcoin.it/wiki/Change Uhh... no I wasn't asking you that question, I was asking Vod if he had ever "verified" a guy before... If shorena's good advice doesn't work, and if you want to try to brute-force the password yourself (assuming you know mostly what it is), you can give btcrecover a try: https://github.com/gurnec/btcrecover. It's an open-source recovery tool that's compatible with Electrum wallets. The Quick Start is here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.mdFeel free to ask any questions, and good luck... Have you tried to locate and then import your private key (".key") backup files yet? See here: https://multibit.org/en/help/v0.5/help_fileDescriptions.html Then clearly you (just like fabiola) must be a scammer.Â  [that was sarcasm/irony, and not personal...] Have you ever done this for a guy before? Have you ever offered to? No.An ASIC is just a computer. It's more specialized than a general-purpose computer, but in the end it's still just a computer.Any algorithm that can be implemented in a general purpose computer can be implemented in an ASIC, there's nothing "magical" going on.A relatively simple algorithm, like SHA-256, can be implemented in a general-purpose computer, or in an ASIC, with relatively little cost. This makes mining relatively accessible (though not necessarily profitable) to everyone.A more complicated algorithm would take more effort to implement in a general-purpose computer, and likewise more effort to implement in an ASIC. In the beginning, this makes mining more accessible to those with general-purpose computers. If there's enough demand (if the coin in question becomes popular enough), then eventually the algorithm will be implemented in an ASIC, but due to it's complexity it will be accessible to fewer people.In other words, the more complex the coin, the larger the start-up costs, and the less accessible mining becomes. This is exactly the opposite of what I assume is your goal. Not that my opinion accounts for too much... but YES, absolutely this ^^^At the risk of being argumentative, the problem of mining pools, or rather of poorly implemented mining pools, does exist. It's not something that I've pointed out, but rather something that gmaxwell (et al.) has pointed out many times (most recently here).This has nothing to do with ASIC vs "ASIC-resistant", but it has everything to do with centralized mining, and the way in which most miners unfortunately choose to participate in it today.You're welcome to propose a superior alternative, but you must back that alternative up with more that just your personal opinion. Why is that useful? What I'm trying to ask is, why does this one purported advantage outweigh the security negatives?I'll bet we could come up with some cool sounding use case for it for which traditional wallets fail (I've been unjustly imprisoned with temporary access to computers but no access to paper, and with no friends on the outside, but still I want to let people send me bitcoins....) But are there any real-life use cases where a brain wallet would actually be an advantage, and not just a security risk?Fair enough -- you need to be good at creating impressively random stuff in your brain, and you need to be able to remember that stuff.The problem I continue to see is this: how are you sure that you have such a brain? We (humans that is) do a good job of overestimating our own abilities -- it's just human nature. This is especially the case when it comes to estimating our ability to create entropy. I may think I'm pretty darn smart... but who doesn't?I'm sure there are some people who can pull this off, and it's entirely possible that CIYAM is one of those people, but CIYAM would be in a large minority.If you can't be certain that you have such a "good brain", what would be the advantage gained by taking this risk? If you haven't made a backup manually, do you remember if you enabled this option (by default it's turned off): "Always Keep Browser Backup"?If you don't have a backup, you're pretty much at the mercy of blockchain.info....
Agree -- if it's not truly random, it's always less secure than a traditional wallet.Disagree -- there may be three ways that you (or that I) can think of, but people who are more experienced/smarter than you or I may have many more ways. This is why the level of security of a brainwallet can't be well determined.Why? What is it that you like, that makes it worthwhile for you to give up some amount of security? If the passphrase has structure to it, than a sophisticated attacker can take advantage of that structure to reduce the search space. Just to be clear though... I'm not a sophisticated attacker, so please don't ask me how such an attack might actually work, or how successful a sophisticated attacker would be in attacking this particular style of password... I just don't know.My "not knowing" is the point, though. Given these two options, which is better?A private key generated from a good random source, which has a known amount of entropy and a known likelihood of compromise via private key brute-forcing (practically none).A private key generated from someone's brain, with an unknown amount of entropy and an unknown likelihood of compromise via private key brute-forcing.The former is always safer exactly because the latter is an unknown quantity. Unless there's some real benefit for using brain wallets, the fact that they might be insecure (definitely so in many cases) is enough reason to avoid them entirely. After all, why make life easier for an attacker, even if it turns out to only be a little bit easier?(If there were some other security advantage to brain wallets, this might be a different story, but there aren't any...) Your passphrase probably isn't more secure than Electrum.A nice thing about an Electrum seed (or a BIP39 mnemonic) is that we know exactly how it's created, and therefore we know that it contains very close* to 128 bits of entropy. That means that brute-forcing it would take, on average, about 170 billion billion billion billion operations.Code:2^127 = 170 141 183 460 469 231 731 687 303 715 884 105 728It's not as much entropy as some wallets, but it's still a whole lot.The problem with your scheme (nearly all schemes for that matter) is that we don't know how much entropy it actually contains. Unless you describe exactly how you created your conlang, and then describe exactly how you construct your passphrase, there's no way to know (and even then it could be difficult to figure out).This is at the heart of why brainwallets are bad. Humans are bad at creating entropy using just our brains, and we're really bad at estimating how much entropy something has, and in the end it's the amount of entropy in a key that makes it difficult (or not) to brute-force.So is it possible that your scheme is safe? Maybe, but it's unlikely (given the last sentence above) and impossible to say for certain (given that you didn't describe your exact scheme). It's always safer to go with a solution whose strength we know -- there's no real reason to invent your probably-unsafe own.* Electrum is only as secure as its underlying source of entropy, which is /dev/urandom on Linux/BSD/Mac OS and CryptGenRandom() on Windows. Although there are no known weaknesses in current versions of either, both have had problems in the past, so it remains possible that the actual amount of entropy could be less. I've no idea... none has admitted doing so. At least one of the recovery services predates the initial release of btcrecover, but that doesn't mean that a recovery service couldn't be using btcrecover today, if they felt it was better than whatever the used to be using.(Not that there's anything wrong with a commercial service using btcrecover -- it's released under GPLv2 which means that anyone is welcome to use it, even for commercial purposes, as long as it's not redistributed in closed-source form. Of course, a mention is always nice ) Hopefully not lost....Try running bitcoin-qt with the -rescan option. E.g. if you're on windows, close the app, and then go to Start -> Run, and type:Code:"C:\Program Files\Bitcoin\bitcoin-qt.exe" -rescan It sure makes you wonder....http://usatoday30.usatoday.com/tech/science/discoveries/2007-02-07-neolithic-love_x.htm I don't know the full answer, but I can give you a handful of pointers.The mailing list is a good place to discuss Bitcoin Core implementation specifics, especially non-trivial changes. (It's not a good place for arbitrary questions / thoughts about Bitcoin Core....)The coding guide is an essential read.There's also a lot of discussion that goes on in the GitHub repo, especially in pull requests -- if you're thinking of implementing something, I'd check here to see if someone might already be working on it, or if the idea has already been tried but had some issues. This is not a link to JackJack's new pywallet. This is an attempt to distribute malware.Do not use the fake pywallet software in this link, it is malware. It will steal your wallet file and upload it to the attacker.Ignore any pywallet download links which are not posted by JackJack himself.edited: the scam post has been deleted; removed yelling. I thought we were having a discussion about comparing the pros (just one: 100k less disk space) and cons (significantly worse security) of a brain wallet compared to a traditional wallet. What you're saying is that it's more about the coolness factor.I agree, it seems pretty cool to be able to store a bitcoin wallet entirely in wetware. However I stopped using "coolness" and started using logic to help me make decisions somewhere around the age of 15.If we can't agree on an underlying method of reasoning to use for the decision making process, then I don't think there's anything left to discuss. It'd be like trying to prove evolution to a creationist.For individuals who do believe in deductive reasoning, traditional wallets are always superior to brain wallets, and therefore brain wallets should never be used. Others are welcome to use whatever method of reasoning and whatever wallet they like. vanobe,I (for one) appreciate your interest in this, and I agree it could theoretically lead to a wallet theft, but it would do wonders for your reputation if you didn't reference articles that arefull of alarmist FUD,technically inaccurate in some aspects (e.g. the claim that PHP is completely invulnerable),not a respected source of security information,full of advertisements.For example, the Red Hat security blog would have been a much better choice. (edited to add: oops, which I see you did include, silly me) Yes, and in some distros bash is the default /bin/sh shell (but not all, e.g. recent Debians / Ubuntus uses dash).In order to be vulnerable, an attacker must:(a) convince a process to set an environment variable to a value of the attacker's choosing, and then(b) convince either that same process to spawn a copy of bash, or convince a child process to do so.I don't think there's any way to convince Bitcoin Core to do (a), so it seems unlikely that Bitcoin Core could be an attack vector for this (but I'm not positive). If that's the only advantage, it's a pretty small one compared to the inherent decrease in security.Can you really not afford the storage space of a 100 kilobyte wallet file? That's not a stupid question at all...See this thread for a discussion on methods to transfer your private keys from a blockchain.info wallet into other wallets: https://bitcointalk.org/index.php?topic=594570.0 That depends on what "did a MtGox" means, since we still don't know exactly what happened there...I thought I answered all of these in my first post here, but maybe I was unclear.If blockchain.info is hacked or if they have a crooked employee, there's some chance they will be able to steal your bitcoin (see my first post...)If blockchain.info disappears, than as long as you have a recent* backup, (via one of the backup mechanisms on their web page), than you will be able to recover your bitcoin.*by recent, I mean you haven't created any new receiving addresses since your last backup.(ignore the generalization from Velkro which doesn't apply to blockchain.info...) As long as your password is strong enough, I wouldn't have an objection to either (or even better, both).By default, blockchain.info wallet passwords use poor key stretching. Before backing up your wallet online, I'd go into Account Settings -> Debugging, and change the PBKDF2 Iterations setting from its default of 10 to the max available of 20000. (For comparison, Bitcoin Core typically uses an iteration count that's about 10x higher than this). I agree with most of this, but I have to disagree with "it can actually keep your coins safer than a desktop wallet."One disadvantage of desktop wallets (as I'm sure you know) is that they are vulnerable to malware. Some types of online wallets (and mobile wallets in some cases, too) offer very good resistance against locally installed malware, but only if the online wallet implements per-transaction two-factor authentication. Blockchain.info only offers login two-factor authentication, which can protect against online (but not offline) brute-force attacks, but it doesn't prevent locally installed malware from stealing bitcoin after a user has logged in.More technically speaking, malware can wait for you to log in, and then capture your password (it doesn't need to capture your 2FA code). Once you've logged in, your PC downloads the encrypted blockchain.info wallet. At this point, the malware has access to both your just-downloaded wallet and the decryption key (your just-captured password), and that's all it needs to steal bitcoin. In this manner, blockchain.info is essentially the same as a desktop wallet, except that the software and the encrypted wallet file are loaded from a remote server during each use. There are several different ways you could lose bitcoin stored at blockchain.info.1- Hackers break into blockchain.info's servers, steal your encrypted wallet, and then brute-force the password (if the password isn't strong enough).2- Hackers break into blockchain.info's servers, steal your encrypted wallet, and replace the website with a look-alike which then steals your password. This type of password-stealing attack would eventually be detected, but it's impossible to guess how long it would go undetected. You would be vulnerable if you log into your wallet while the attack was still undetected.3- An insider at blockchain.info executes the attack described above. Also as above, the attack would eventually be detected.4- A piece of malware finds it's way onto your PC which targets blockchain.info. The next time you log into blockchain.info (even if you've enabled 2FA), the malware can steal your bitcoin.5- You do not maintain backups of your blockchain.info wallets, and blockchain.info loses your wallet or closes up shop. By maintain, I mean that you need to back up your wallet after each new receiving address is created.It's impossible to estimate the likelihood of any of the above happening... are there one or more of the above that particularly concern you?Can you be more specific? Is it that Bitcoin Core is too resource-heavy? Are you talking about malware? Something else?The only wallets which approach 100% trustworthiness are cold storage wallets and hardware wallets. If you're (like me) unwilling to deal with the inconvenience or cost of these solutions, you'll need to make some compromises... Regarding "a virus embedded in various wallets": In order to send a transaction from any wallet (brain or traditional), you need to run software. It's then just a question of where you get the software, and do you trust the software's authors. Because traditional wallets are more popular, they have many more eyes on them, and there is much more peer review. Due to this, I'd argue that popular traditional wallets are safer and less likely to have embedded viruses than less popular software.Regarding stolen wallet.dat files, and malware in general: Brain wallets offer no additional protection over traditional encrypted wallets.If your brain wallet password is weak, your brain wallet is vulnerable to anybody (which I'm sure you already know). If your traditional wallet password is weak, your traditional wallet is vulnerable only to locally installed malware. In other words, having a wallet.dat file on a hard drive is not less secure than using a brain wallet, as long as the password is strong, and given a weak password, a brain wallet is far more vulnerable.Both wallet types are equally vulnerable to malware the instant you type your password in order to send bitcoin.Regarding hardware failures: Backing up an HD wallet is no more difficult than backing up a brain wallet. You simply write it down or print it out (once). Such a backup will protect you against any type of hardware or wetware failure.Regarding ease of use: this is more a personal opinion -- if you think brain wallets are easier to use, that's your prerogative. However you should weigh this ease-of-use against the inherent security risks of using a brain wallet: is it really that much easier to make it worthwhile? I agree it's likely if you're doing a lot of audio editing that you probably would have noticed a hardware issue, but it's still possible that there's a hardware issue. The only way to be certain is by testing (e.g. an error scan with HD Tune or a "Scan for and attempt recovery of bad sectors" in Windows...)From my own personal experience: when my DRAM died, the only applications I had trouble with were Armory and Bitcoin Core. Everything else (for example compilers and games, both of which are hardware-intensive) seemed fine. It was only after I ran Memtest86+ that I was convinced it was my hardware's fault, and not Bitcoin Core's. Another possibility is a DRAM memory problem. Memtest86+ can help to rule this out (or in): http://www.memtest.org/#downisoAlso, just FYI, because Bitcoin Core can be both disk and memory intensive at times, it wouldn't be surprising if it were the only app that was having problems. In other words, there might be a hardware problem even if all of your other apps are running just fine.No guarantees it's a hardware problem, but it's definitely a good thing to check for.
Well, although I'm kinda happy (sorry) that something weird and mysterious isn't going on, I'm unhappy that this could make things more difficult for you...On the (small) plus side, you already have JtR compiled, so if you'd like to use it to search for your password, it's a great option.btcrecover is faster if you have a discrete video card, in terms of guesses per second (and JtR is faster if you don't have one). I also think that btcrecover is the easier option if you already have a good idea of what your password is, but I'm just a teensy bit biased (I'm the author of btcrecover)....If you do choose to try btcrecover, the tutorial and quick start is here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialLet me know if you have any questions. (this response is a little OT from OP's thoughts, but regardless) That pretty much works, except that you have to mark the one address that's created before the password is added as unsafe, because it's already been saved unencrypted to the hard drive. It's also not very user-friendly, compared to creating a wallet that's encrypted before ever being saved. You could be right: nobody knows if this experiment called Bitcoin will stand the test of time.Regardless, if you're sick of bitcoin, my advice to you is: leave. (Please leave.) One other note regarding bip32.org: if you have a good source of randomness, it's probably safe to use this page. Please read and follow the advice here first: https://en.bitcoin.it/wiki/Paper_wallet#Producing_safe_paper_walletsFor ideas on a good source of randomness, this thread talks about good ways to shuffle a deck of cards to get good randomness out of it: https://bitcointalk.org/index.php?topic=682842.0. Don't come up with your own scheme to create randomness, though. There are many things which seem random, like mashing on a keyboard, which have very poor entropy. I'm sorry, but this reply is providing more problems than solutions. Hopefully someone more knowledgeable on the state if BIP32 software will come along and help...Re bip32.org: I'm not familiar with them, but I took a quick look. They are producing BIP32 brain wallets, which is something you really don't want.Re terminology / printouts: you'll want to save your "master extended public key" on one sheet, and your "master extended private key" on the other. Because the master extended public key can be derived from the master extended private key, you don't need to have both on the private sheet. It's up to you if you want to encrypt your master extended private key, but if you do, you should make sure it's encrypted using the BIP38 standard (simply because it's a standard likely to be supported by many wallets).Although you shouldn't use bip32.org to create them, just for the sake of completeness: your master extended private key is next to the label "BIP32 Extended Key", and your master extended public key can be found by choosing "Info: m" next to "Derivation Path", and then looking next to "Derived Public Key"Unfortunately, there's a lot I can't answer, e.g.:Easy and secure way to generate a BIP32 paper wallet (and not a brain wallet)BIP32 mobile app that's not in beta (there are several that are still in beta testing)BIP32 mobile app that supports a watching-only walletIf you have an iPhone, you might want to look at breadwallet. I don't know anything about it, but I do see that it's apparently not in beta, and it supports BIP32. I don't know if it supports watching-only wallets.Good luck.... As you noted it's all just obfuscation, and so I assume you know how much better encryption is at privacy protection over obfuscation.So what is it you're really trying to accomplish? Given an answer to this, the better solution is to apply encryption to what you're trying to accomplish instead of obfuscation, isn't it?For example, are you trying to improve privacy (to make it more difficult for malware to read pubkeys, txs, and the like)? Then (as you already noted in your follow-up post) a better solution would be to add a second password, let's call it the "watching-only" password, which encrypts the entire wallet. The "privkey" password would continue to work as-is. The watching-only password would need to remain in memory, so it wouldn't protect against malware that has acquired root, but it would help otherwise.This I like, given that it will prevent plaintext privkeys from ever seeing a hard drive platter. Some wallets already implement this, and it'd be nice to see Bitcoin Core do so as well. This is mysterious....First, a little background (if you're interested, if not just skip to the questions):Bitcoin Core makes two checks when validating your password.A. Run the password through a key derivation function (PBKDF1-SHA512) to generate a derived_key.B. Use the derived_key to decrypt (with AES256) the 48-byte long encrypted_mkey (from the wallet) into a decrypted_mkey.C. Check (1): make sure the decrypted_mkey is exactly 32 bytes long plus 16 valid padding bytes at the end.D. Use the decrypted_mkey to decrypt a single (arbitrary) encrypted_privkey (from the wallet) into a decrypted_privkey.E. Mathematically derive from the decrypted_privkey a derived_pubkey.F. Check (2): make sure the derived_pubkey is equal to the pubkey stored in the wallet file.JtR doesn't bother with check (2) in the interest of speed. This should be OK, because the likelihood that check (1) passes, but check (2) fails should be extremely small (something like 1 in 2^128).pywallet doesn't bother with check (1) (in other words, it always "accepts" the password at first), it simply truncates the decrypted_mkey to 32 bytes in length and ignores any padding (even when the padding is invalid). It only uses check(2) (running that check against every encrypted_privkey if you answer "y" to that question it asked).If JtR thinks you have the right password, but pywallet and Bitcoin Core disagree... than I'm not sure what's going on.So... questions...Could you try btcrecover (another Python script)? (use "--passwordlist --wallet wallet.dat" for its options.) It should use the same single check as JtR.Where did you get your JtR? If you compiled it from source, how recent is it (there were some recent Bitcoin-related updates to JtR)?Do you have any wallet.dat backups (even if they're encrypted)? The best advice I can offer regarding which wallet is the best is "don't follow anyone's advice."The reason is simple: different wallets are geared towards different goals. One person's personal favorite might not be a good choice for you.Instead, visit the Bitcoin.org getting started page here: https://bitcoin.org/en/getting-startedRead step 1, "Inform yourself" (don't worry, it's not long), then move on to step 2, "Choose your wallet." At the bottom of the choose-your-wallet page there's a link to "secure your wallet" which you should read before choosing a wallet. (edited; I think I misunderstood you) You've already said that "few resources" is a requirement, so don't choose a wallet that says it's a "full node."If you have any specific questions, please ask, I'm sure someone will be along who can help.Oh yes, and welcome! A brain wallet, with a given password, will always be significantly less secure than a traditional wallet encrypted with that same password. Hopefully this is self-evident to everyone here.Given this significant disadvantage, there would have to be some significant advantage a brain wallet could give you that no other wallet can before any reasonable person would prefer a brain wallet. So.... what is this advantage? The size option is there mostly for hard drive scans. For a wallet, just choose a size that's larger than the wallet size.You need to append a (strange) unit to the end of the size, so for example --recov_size=100Mo means 100 megaoctets.(Be sure to take a backup of the wallet file before running pywallet on it, just in case) Why are "more transactions with fees" desirable?If you start with the assumption that the purpose of Bitcoin is to make money for miners, then yes "more transactions with fees" would be desirable.But the purpose (or at least a purpose) of Bitcoin is to permit transactions and permit stored value. In other words, the decentralized transactions themselves, as well as the stored value of bitcoins, is the purpose of (capital-B) Bitcoin. Miners are just a necessary component in securing Bitcoin. Transaction spam, whether it includes fees or not, is still spam.Technical discussions aside, OP's idea has problems for at least two other reasons.First of all, I don't like lotteries. I like blackjack. I therefore think it would be unfair for zero-trust lotteries to be added to the blockchain unless blackjack is also added. Would anyone else like to add something? (Poker would be pretty cool I think.)Secondly, unregulated lotteries are illegal in many (most?) jurisdictions. Although transactions can be used for either legal or illegal purposes, unregulated lotteries would always be illegal in those jurisdictions. The fact that something is illegal isn't reason enough to avoid it, for example if it were added to right some terrible evil, but I really don't see lotteries as an inalienable human right that Bitcoin should concern itself with. This means that JtR was able to decrypt the mkey (and verify that the padding bytes were correct, which makes it extremely likely that the password was correct). JtR doesn't try to actually decrypt any private keys to check them against the stored public keys.If the first private key, or its associated public key, is corrupted, this will happen (although that seems unlikely to me...). If this is the case, `pywallet.py --recover` can help.CDNinATL, can you let us know how this turns out? I'm personally interested...Also, does your password contain any non-ASCII characters (any characters not list here: https://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart)? True, but most printers run close-source software that do things many don't know about and may not want, even home printers. For example it's known that many (most?) printers will refuse to print counterfeit money using various technologies[1], and some printers surreptitiously include nearly-invisible identifiers to link the printed document to the individual printer which printed it[2]. If they can do this, who knows what could be next (I know this does sound a bit tin-foil-hattish...)Printers can also be theoretically infected by malware remotely, although I don't think there are any documented cases of this outside a research setting[3] (not yet, anyways).Some paper wallets / BIP32 backups (e.g. Armory) allow you to encrypt before printing. If you write down the encryption password on the printout, you'll have everything you need to restore the wallet in one place, and you'll remain safe from such printers.[1] http://en.wikipedia.org/wiki/EURion_constellation[2] https://www.eff.org/issues/printers[3] http://www.bbc.com/news/technology-29203776 Farmer17, just who do you think you are, asking an on-topic question like this??Seriously though, it's a good question and I'm interested to see what Fabiola! thinks. There are a lot of if's here, but if you're sure it's your private keys that you wrote down, and if you're sure there are no typos, and if you never add any new receiving addresses to your wallet, than you should be safe.Edited to add: and also if they're either unencrypted, or you are sure you know their password. With blockchain.info, you need to create backups after each new receiving address you create. As long as you have a recent backup, you can reclaim your bitcoin.There are other online services (and also desktop wallets too) where you only need to create a single backup (either printed out or written down). You may want to consider one of these...(They include Armory, Electrum, GreenAddress, BitGo, and probably others.) I'd take issue with that statement... look at the choose-your-wallet page on bitcoin.org here: https://bitcoin.org/en/choose-your-walletThere are at least two or three other free online wallets that I'd rate at least as good, if not better, than blockchain.info. I just wanted to add that if you choose a full-node client for your online wallet (e.g. Armory), and if you also choose not to keep that full-node client connected most of the time, you could run into delays.Armory (the one you have running online) for will refuse to create a transaction until it has finished syncing. Do you have any older backups?Have you changed your password over time? If so, you might be able to try to import an older (automatically created by MultiBit) backup key file using an older password.There's also a free & open source password recovery tool you could try. You will need to do a bit of reading to get it set up and running though, so if you don't have the time, a wallet recovery service is a good option.If you'd like to try recovering it yourself, the Tutorial and the Quick Start are here: https://github.com/gurnec/btcrecover/blob/master/TUTORIAL.md#btcrecover-tutorialIf you have any questions, feel free to ask (I'm the dev of that tool).Good luck... inf,I think you've uncovered a bug in Armory's HMAC implementation. I very well could be (and in fact I hope I'm) wrong though....In particular, this doesn't produce what I'd expect:Code:import hmac, hashlibfrom armoryengine.ArmoryUtils import HMAC256# Test vector case 1 from RFC 4231keyÂ  Â  Â  = "0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b".decode("hex")dataÂ  Â  Â = "Hi There"expected = "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7".decode("hex")print "RFC 4231 HMAC-SHA256: ", expectedÂ  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .encode("hex")print "Â  Python HMAC-SHA256: ", hmac.new(key, data, hashlib.sha256).digest().encode("hex")print "Â  Armory HMAC-SHA256: ", HMAC256(key, data)Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .encode("hex")Here's the definition of HMAC256 in ArmoryUtils.py:Code:def sha256(bits):Â  Â return hashlib.new('sha256', bits).digest()def HMAC(key, msg, hashfunc, hashsz=None):Â  Â """ This is intended to be simple, not fast.Â  For speed, use HDWalletCrypto() """Â  Â hashsz = len(hashfunc('')) if hashsz==None else hashszÂ  Â key = (hashfunc(key) if len(key)>hashsz else key)Â  Â key = key.ljust(hashsz, '\x00')Â  Â okey = ''.join([chr(ord('\x5c')^ord(c)) for c in key])Â  Â ikey = ''.join([chr(ord('\x36')^ord(c)) for c in key])Â  Â return hashfunc( okey + hashfunc(ikey + msg) )HMAC256 = lambda key,msg: HMAC(key, msg, sha256, 32)I believe the problem is that this HMAC function takes and uses the hash size as a parameter (256 bits for SHA256), but it should be taking and using the block size instead (512 bits for SHA256).Could someone verify this, or hopefully correct me?
That last sentence is squarely on point.With respect to your point #2, it's something I think we'd all like to see change. I don't know exactly how to change it, but until it's changed, we'll continue to propagate the all-boys-club image. I don't know the stats -- I don't frequent the boards where most of these types of scammers hang out (only where the Trojan-peddling scammers hang out), so I'll take your word for it.That's a straw man. I'm arguing that calling a woman a scammer because she mentions she is one is not sufficient cause. You're arguing that individuals who obviously have no legitimate purposes on this forum (Nigerian princes) should be called out as scammers (about which we all agree).The analogy is inaccurate. Exactly 0% of the world's population today qualify as Nigerian princes. Just under 50% of the world's population are female, and so such a claim (of "I'm a girl") made on the Internet should not be met with such exceptional scrutiny.In my mind, it comes down to three things.1. How sure should you be that someone is a scammer before accusing them (or loudly warning others)?In other words, is it OK to accuse people if you're 90% sure (ChuckBuck's stats) if that also means you end up falsely accusing the other 10%? Should it make a difference if the accusation also has the potential to alienate a lot of others?2. What kind of evidence is acceptable to use? Simply being a female is clearly not acceptable evidence. Claiming to be a Nigerian prince clearly is acceptable. What about claiming openly to be a female (different from simply being one)? Is this acceptable to use that as evidence?3. What are the wider implications?I don't know or care if fabiola! is a scammer or not, but:Regardless of the scam%, what does it say about our community if we state that it's not acceptable to claim openly you are a female here on these forums? (of course, nobody cares if you claim openly you are a male)Is it important that we, as a community, attempt to be welcoming to the "other 50%", especially given the current imbalance?What if, in our attempt to be welcoming, we ignore potential scams? What if people lose real funds because they fall for scams about which some of us could have warned them?There are two sides to this. I don't think hilariousandco (or most of the other individuals in this thread, obvious trolls excluded) are sexist. But I do think the line is often drawn in the wrong place, in a place that makes Bitcoin seem like a nerdy-guys-only club, and that will benefit nobody in the end. I'm not aware of any way to do this without some risk. If your wallet file is ever compromised, even if it's password-protected by Armory, or even if it's a watching-only wallet, then whoever has both it and one of your private keys can gain access to all of them.It may be less convenient to use new addresses with a web wallet, but it's the safer choice.If you're 100% sure that nobody has or will gain access to your wallet, then it should be safe, but it's hard to be 100% sure... Originally, l.j2300 asked if it was risky to non-exported privkeys if some, but not all, privkeys were exported from Armory to a web wallet. My answer (even though I got the details all wrong and goatpig corrected me) was no, don't do that, instead just transfer some bitcoin from your Armory wallet to a new convenience web wallet.I'm not sure, but I think l.j2300 had a reason to want payments to some pre-existing addresses to go straight to a web wallet. For this, I said the best option is to go ahead and export/import the privkeys from Armory to a web wallet, but then stop using the old wallet entirely (and then create a new Armory wallet for additional savings not stored in the web wallet).As far as I know, these are the only two safe options. I don't see a safe option for using some existing addresses with Armory, and some with a new wallet. You should really use your existing addresses in one place or the other, and then create a brand new wallet in the other location. If you go against this advice (and use your existing Armory privkeys both inside Armory and in a web wallet), I don't think you'll be instantly compromised, but it's a bad idea... I have a quick question for you, having just browsed a bit of the GitHub repo. Are you using the Nymi SDK? Do you know what the licensing terms for it are? How redistribution of it works? I can't seem to find any info on their website....Thanks. The initial post, quoted below, after which you decided to respond with a "SCAM ALERT", did none of these things...I've already conceded that such behavior could indeed be relevant, but it's far from sufficient to start throwing around accusations, or even just warnings.I strenuously disagree. The fact that there are disproportionately few women interested in Bitcoin absolutely should be topic of conversation, as should the fact that so many women who do choose to participate in the forums choose to hide their sex. I don't claim to have a solution, but having such an unwelcoming post in the Beginners & Help section certainly doesn't help.Ultimately, I think we all need to decide what kind of community we'd prefer to continue building: one based on Assume good faith or one based on Fear, uncertainty and doubt. We should all have a healthy amount of fear (but let's call it skepticism), but there's such a thing as too much.In short, I think your initial post crossed a line, and does more harm than good. Pot... meet kettle....Take a look at these two recent threads, this one by user Supraman, and this one by user grumpyoldtroll (whose first word in his post is "Guys,"). Both are newbies, both are asking questions that have been asked a hundred times before that could easily have been answered by a web search, both are guys. They both got warm welcomes and/or informative responses.Now take a look at this thread, with someone asking a question that hasn't been asked a hundred times before, but a girl, and the first couple of responses (hilariousandco and serje) were anything but warm, in fact I'd call them downright disgraceful.As far as I'm concerned, anybody on this forum could be a scammer, and I'd never do business with anyone until being convinced otherwise. But it's completely inappropriate to throw up a red flag unless you have real concerns or evidence, and not just "but she's a girl! and lots of guys lie and scam pretending to be girls!" Even though I fully concede that statistics might support the latter, it's nonetheless perpetuating a sexist stereotype.There are no personal attacks intended here... it just saddens me when people who are clearly a significant benefit to the Bitcoin community come forward with posts such as those above.[/rant]fabiola!, welcome to the forums. Unless there's a good reason to keep things private, discussing them publicly is preferred because it can help out people later on with the same problems.Can you describe the problems you're having? Which wallet software are you using? Have you added a password to the wallet? So a wallet file of any type (even watching-only or encrypted) plus any single privkey from that wallet would compromise all of that wallet's privkeys... thank you for taking the time to correct me. I'll try to be more careful in the future.l.j2300,My sincere apologies for the misinformation, I should know better than to post "answers" if I'm not 99% certain.... This is normal behavior even though it is a bit confusing.Without rpcallowip, Bitcoin creates two separate listening sockets for RPC, one for each localhost address.When you create a listening socket with IPv6 that's not bound to a specific IP, you have the option to allow the socket to listen on IPv4 at the same time. With an rcpallowip option, Bitcoin does just that: it creates a single socket, not bound to a specific address, that is listening to both IPv4 and IPv6. Such a socket will only be listed once by netstat, which definitely is confusing, but it's just the way things are.In other words, you should be troubleshooting under the assumption that Bitcoin is listening to both IPv4 and IPv6. (Bitcoin Core 0.9.3 will have a way to specify which IPs to bind to, which if used will disable this behavior.)I don't know where the problem does lie, but it's not where you're looking right now....  It's not quite that bad. If one address is compromised, and your encrypted wallet file is also compromised (even if the password remains unknown), then some of the rest would be as well (addresses, including invisible change addresses, that are created after the one that's compromised).It's up to you to decide how risky you think this is...If you have a good reason to import some addresses to an online wallet, you could also create a new Armory wallet and try to keep most of your bitcoin in the new wallet, and treat the convenience wallet as less safe. As I assume you already know, the addresses you choose to export will be at more risk.In particular, Blockchain is an online wallet whose software is effectively "reinstalled" each time you visit their web page (because it's reloaded from their servers during each visit). This makes it easier for someone (presumably an outside hacker) to replace the software with a Trojan which steals your privkeys.There's also the possibility that a hacker might steal your encrypted privkeys directly from the Blockchain servers and brute-force your passwords if they're simple enough. You can guard against this by using a better password, and also by changing the iteration count from 10 (which is pointlessly weak if you ask me...) to something greater. (It's under Account Settings -> Debugging.)Finally, there's an issue inherent in HD wallets: if someone has both your watching-only wallet and a single (non-hardened) privkey, they have access to all of the privkeys which follow the one privkey they have (all Armory privkeys are "non-hardened".) Likewise, if an adversary has your encrypted Armory wallet, even if they don't have the password, this is effectively the same as having a watching-only wallet: that plus a single unencrypted privkey would be enough to access all of the privkeys which follow.If I were you, and I were interested in an online wallet for convenient access to a smaller amount of bitcoin, I'd open an account and transfer some bitcoin to the online wallet. If you prefer an online HD wallet to make backups easier (like Armory), you could consider GreenAddress.it or BitGo.com (I find the former a bit more secure, and the latter a bit easier to use for newbies, but that's just my personal opinion). Both of these are also multisig wallets, so they also offer additional protection against malware. Starting sometime around the late 1970s, the Mexican Peso started experiencing extreme inflation. By the late '80s, the price of a loaf of bread was thousands of pesos. The Mexican government introduced the "new peso" whose value was equal to exactly 1000 "old" pesos. In other words, they simply created a 1000-peso coin, but they called it a "new peso" instead of a "1000-peso" coin.Bitcoin might one day have the same problem, except in reverse (because Bitcoin is deflationary), but the solution is similar. Introduce a unit that's smaller than a single satoshi (maybe you could call it a dannyhamilton?). It would require a bunch of software changes, but it's entire feasible, and it's entirely fair. Could be bad RAM (this happened to me) or a bad HD sector (less likely).Head on over to http://www.memtest.org/, and either burn a bootable ISO or use the "Auto-installer for USB Key" to create a bootable USB flash drive, and then boot from it and let it run overnight.If that doesn't help, there are tools that can test for bad drive sectors too (although you probably shouldn't run them too often on SSDs...). Here are the steps. I'm assuming that you're running Windows 7 (or earlier) and the external drive is D:It looks really long, but it's not actually that bad. The only reason it looks so long is that I spelled out every step in detail assuming that you're not really a "Windows person" (if you are, I'm not being intentially condescending....)1. Create 3 new directories. D:\AppData, D:\AppData\Bitcoin and D:\AppData\Armory.2. Start Armory, go to File -> Settings, and change the Bitcoin Home Dir setting to D:\AppData\Bitcoin then click Save.3. Quit Armory.4. Click the Start (Windows) button, then Run, and type in this then click OK: %appdata%\Bitcoin5. You'll need to copy all of the files in this folder to D:\AppData\Bitcoin. One way to do this is by pressing Ctrl-A and then Ctrl-C, then typing D:\AppData\Bitcoin into the address bar (pressing F6 first will put your cursor in the address bar), and the pressing Ctrl-V.6. Return to the address bar, type in this then press the Enter key: %appdata%7. Rename the Bitcoin folder to Bitcoin-unused.8. Return to the address bar, type in this then press the Enter key: %appdata%\Armory\databases9. You'll need to copy all of the files in this folder to D:\AppData\Armory. One way to do this is by pressing Ctrl-A and then Ctrl-C, then typing D:\AppData\Armory into the address bar, and the pressing Ctrl-V.10. Return to the address bar, type in this then press the Enter key: %appdata%\Armory11. Rename the databases folder to databases-unused.12. Click the Start (Windows) button, then find Bitcoin Armory, but don't click on it yet.13. Instead of left-clicking on Bitcoin Armory as you normally would to start it, right-click on Bitcoin Armory, then click on Properties.14. In the target field, move the cursor to the far right (past this part: ArmoryQT.exe") and then add a space to the end and add this: --dbdir=D:\AppData\Armory15. Click OK.16. Click the Start (Windows) button, then find Bitcoin Core, but don't click on it yet.17. Instead of left-clicking on Bitcoin Core as you normally would to start it, right-click on Bitcoin Core, then click on Properties.18. In the target field, move the cursor to the far right (past this part: bitcoin-qt.exe") and then add a space to the end and add this: -datadir=D:\AppData\Bitcoin19. Click OK.20. Start Armory normally, and let it finish syncing, and then quit Armory.21. Back in Windows Explorer, return to the address bar, type in this then press the Enter key: %appdata%.22. Verify that there is no Bitcoin folder present. If so, delete the Bitcoin-unused folder.23. Double-click the Armory folder.24. Verify that there is no databases folder present. If so, delete the databases-unused folder.25. AT YOUR OWN RISK: empty your Recycle Bin.Anytime you upgrade Armory, you'll need to repeat steps 12 - 15. Likewise, anytime you upgrade Bitcoin Core, you'll need to repeat steps 16 - 19. Hopefully, that should be it. For people who would prefer a full node, but don't want to go through the extra hassle, you might want to consider Armory. It will help you download and install Bitcoin Core (which is required for Armory), and it will automatically download a bootstrap.dat (via its own built-in BitTorrent client). You could even uninstall Armory after this initial process completes if Armory seems too complex, and still be left with Bitcoin Core installed and synced. I rebased the pull request, it should be OK to merge now (it was just a conflict in the version number which I shouldn't have touched to begin with...)Thanks Mycelium PINs do not offer a lot of security, see here for more details.Some PIN schemes do offer decent security, for example GreenAddress PINs are quite secure (see here for more details). Got it, thanks.Also, are you a co-author of the paper? I didn't mean to exclude you by calling it exclusively "gmaxwell's blinding scheme"... I'm glad things worked out Keep your eye on MultiBit HD - it allows you to make a paper backup that can protect you against forgotten passwords and damaged hard drives. It's still in a testing phase though - if you can't wait, you could consider Electrum or Armory which both offer similar backup solutions.(I haven't tried MultiBit HD yet, but I have high hopes for it.)
I don't mean to be argumentative, but... Blockchain doesn't help against malware.Only online wallets which offer per-transaction two factor authentication have any meaningful protection against locally installed malware (and even then it's not perfect).Blockchain is pretty much a desktop wallet which happens to store both the software and your encrypted wallet on their servers. With this model, they couldn't offer per-transaction 2fa even if they wanted to. (I don't mean to bash them, that's just the way things are).As far as I know, the only online services that can offer per-transaction 2fa, and therefore improved malware resistance, are multisig online wallets, and online wallets who completely control your keys (e.g. Coinbase).Of these, I happen to know that GreenAddress.it does offer per-transaction 2fa, and I think that BitGo.com does too (both are multisig online wallets, and therefore share control of your wallet keys with you). I'll bet some of the online wallets that completely control your keys also offer per-transaction 2fa, however I don't know which do and do not. One of these is probably your best bet if you think you're not running in a secure environment. On my Win64 machine, Armory + bitcoind (which is required to run Armory in online mode) use a combined 800MB. I suspect they'd take up more during the initial download + db build, I'd personally recommend 4GB, but you might be able to get away with less.In offline mode for cold storage (no bitcoind required), Armory uses just 50MB. You can use a pretty old PC to run it offline... Is it safer? [link to Wikipedia] I think you've got a great analogy. Google/Dropbox/Onedrive are great for casual things you'd rather not lose, but aren't super important (your kids birthday pictures, a few hundred bucks of bitcoin, etc.). Under your mattress is great for things you'd rather not get leaked to the Internet (see the link above...). A safety deposit box is great for really important stuff (your will, paper backups of your wallets containing lots of bitcoin, etc.).It's all about learning how and where to store bitcoin, depending on how much value it has to you, and how much you can afford to lose (same as fiat: keep a hundred in your wallet, a little more under the mattress, and more in the bank). Bitcoin is still in its infancy. Most people have the common sense not to store $1000 in their wallet and then walk around on "the wrong side of the tracks." Bitcoin is still new enough that this sort of common sense is still... uncommon. Educating yourself is the best way to avoid such pitfalls, so kudos to OP for asking questions.Combine all this with the fact that there are no subforums here for "I just got robbed of my leather wallet" nor for "I've never had Bitcoin stolen from me", and it's easy to see why there are a disproportionate number of "I got robbed of my bitcoin" stories here.I think it is tricky to be secure, and you do need to educate yourself (it's not something like fiat cash that everyone has known about since they were 3), but it's also not as dangerous as this forum may make it seem once you've acquired some Bitcoin common sense. These "what's the safest" threads are starting to drive me CRAZY  (no offense meant to the OP though).There are a lot of different ways to interpret the word "safe". Go to the bitcoin.org choose-your-wallet site here, it does a good job of comparing the safety/security of different wallets. If you have a specific question regarding regarding that site, such as "what does Vulnerable Environment mean?", or a question regarding something that website doesn't mention, such as "what is the easiest to back up / protect from hard drive failure", we'd be happy to try to answer it.Although I mean no disrespect to the other posters in this thread, they all have their own interpretation (as do I) of the word "safe" and have answered accordingly... e.g. to some, safe means "safe from hard drive failure", and to others it means "safe from malware", and to others it means "safe from hackers" or even "safe from data collection/spying". None of them are right for every purpose (or wrong). Now seems like a good time to bug you (jackjack I mean, not tevayo) to consider this pull request. With PyCrypto installed, I don't think Pywallet will create a usable wallet.dat file without this patch... An encrypted wallet.dat remains encrypted on disk even when unlocked, it's only unlocked in RAM. Depending on your application design, this could improve security. For example if you have a 2-tier app plus bitcoind, where only the backend tier has access to bitcoind, then a vulnerability in the frontend tier which permited read access to the wallet.dat file would not on its own compromise the wallet.Unlocking a wallet takes about 0.1 seconds of CPU time, during which time most other wallet operations are suspended. The number of keys in the wallet does not affect unlock performance, a key is only unlocked when required (for as long as the wallet remains in an unlocked state). If performance is a concern, you should consider specifying a longer timeout when unlocking the wallet, and then anytime you need to perform an operation which requires an unlocked wallet, you should start off by assuming it is already unlocked, and handle errors where your assumption was wrong by unlocking the wallet and retrying the operation.I assume that unlocking becomes required once the key pool runs dry, correct?Incidentally, secure application design is really hard... if you're not an expert (not that I claim to be one), you might be getting yourself into trouble with storing a wallet on an Internet-facing server... It's even stronger than that, isn't it? If the signer used gmaxwell's blinding scheme, than none of the 1,000,000 (including the actual signer) are capable of proving that they either did or didn't sign it (even if any of them wanted to), correct? FYI the bug affecting 14.04 has been fixed in the current version of Gitian, you can use it as the host OS now (but you should continue to use "precise" as the guest OS as per the docs). I'm not a potential customer (so feel free to prioritize accordingly ), but I'm just throwing this out there anyways...Is your demo site running recent code? My current hand is consistently hanging for me...Site: http://www.btcircle.com/coinjack/Initial Array: c44f90201b8bffc3b8c416a81be6f4a9955473ac0efb515487fa2a92d5d50bccClient Seed: 575090165533Dealer: KS -Player: 4D 4DChoice: Click on HitResult: Buttons all gray out, and then nothing happensLet me know if you need the "unique" to reproduce... In short, no.If I understand you correctly, you're looking for one of two things:1. A "known plaintext attack" against AES: there is no known such attack (not any that are practical, anyways).2. Is it possible to figure out keys in a MultiBit wallet if you know some of the earlier keys: no, for MultiBit wallets the keys are each independently generated and are not related to one another in any way.If you know enough about the password, or if you think you managed to make the same typo twice, a password recovery tool might help (take a look at the other recent posts in this forum). (better a late response than never...)If you think the wallet file might be corrupted (and you have no wallet backups to try), you can try to import one of the private key backup files. They are located in a directory named walletname-data/key-backup, and have filenames which look like this: walletname-20140905084530.key (see here for more info). After you locate them, first create a new wallet (no reason to close the old wallet), then try to import one or more of the .key files into the new wallet (via the Tools -> Import Private Keys menu).If that doesn't help, you can try a password recovery tool (which only has a decent chance of succeeding if you remember enough about your password). btcrecover supports MultiBit key files. If you'd like to give it a try, you can start with the Quick Start section in the Tutorial here. If you have a key file which works with an older (or any) password, you should be able to create a new wallet and then import that key file. Hopefully the older key file has all of your keys that have a balance...btcrecover supports password recovery of MultiBit key files, however it's hard to tell from your description how many different combinations of passwords you'd need to check. If you'd like to give it a try, you can start with the Quick Start section in the Tutorial here.In particular, you'll need to know exactly which words you may have used, and you'll need to narrow down what those long numbers look like. If the numbers really are that long, and if you don't remember any other details on what the numbers were, then I'm afraid there are way too many possible combinations to try... For online wallets (which I wouldn't personally recommend for large amounts of BTC):I have nothing against Blockchain, they have a very good reputation, but everyone should realize that their two factor authentication is just about useless for protecting against malware (but it can help against phishing).Younger (but less proven) online services which offer per-transaction multifactor authentication such as GreenAddress.it and BitGo.com offer very good (not perfect) protection against malware. If malware is a concern to you (it probably should be), you might want to consider one of these for your online wallet needs....Or just go with a desktop wallet - I like Electrum and Armory for their easy one-time paper backups (and MultiBit HD is also nearing release). Been away for a while and I'm slowly catching up. I did get it, will hopefully reply soon... It's possible, but it can be a bit of a pain if you've never done it before. It's the way that the official binaries are built.On the plus side, it's very well documented here.If you're starting with an existing Ubuntu system, you can skip down to "Setting up Debian for gitian building". This particular section needs a few changes for Ubuntu (it was originally written for Debian 7.4). Specifically, the apt-get line should read:Code:sudo apt-get install apt-cacher-ng git python-vm-builder ruby1.9.1 lxcDon't run the "adduser debian sudo" line. The "set up LXC and the rest with the following, which is a complex jumble of settings and workarounds" section is partly unnecessary, and it should instead look like this for Ubuntu:Code:# the version of lxc-start in Ubuntu needs to run as root, so make sure# that the build script can execute it without providing a passwordecho "%sudo ALL=NOPASSWD: /usr/bin/lxc-execute" | sudo tee /etc/sudoers.d/gitian-lxc >/dev/nullsudo chmod 440 /etc/sudoers.d/gitian-lxc# make sure that USE_LXC is always set when logging in,# and configure LXC IP addressesecho 'export USE_LXC=1' >> ~/.profileecho 'export LXC_GUEST_IP=10.0.3.5' >> ~/.profileecho 'export GITIAN_HOST_IP=10.0.3.1' >> ~/.profileecho 'export LXC_BRIDGE=lxcbr0' >> ~/.profileThe section which talks about manually installing python-vm-builder can be ignored.The rest of this document should work on Ubuntu.One important note: if you're running this on a fully updated Ubuntu 14.04 system, it won't work due to a bug (see here). I think it should work on most previous releases of Ubuntu, or on an unupdated version of 14.04 (but not 14.04.1), but I'm not certain of this....(edited several times...) Offline-generated it good, but there's no difference between a "paper" wallet and a cold storage electronic wallet (e.g. Armory, Electrum, BIP32) with a paper backup, or is there? At some point, you have to hand your private keys over to a computing device (an offline computer or a hardware wallet) to do the EC math (unless you do it yourself on paper, good luck with that! ) You probably need to escape the braces, like this:Code:find ./ -type f -exec file \{\} \; | grep "Berkeley DB" Both Armory and Electrum offer (in fact they both strongly suggest) that you make a paper backup, and store that piece of paper alongside your other important documents (e.g. in a safety deposit box). If you follow this advice, either of those two offer excellent safety from hardware failures. This goes for any deterministic or BIP32 wallet.Cold storage (as already discussed) and hardware wallets (e.g. Trezor) are the safest options to protect against malware. For some people, cold storage is too difficult/inconvenient. For these cases, you have to make a judgement call: who do you trust more: do you trust yourself, and your ability to keep your computer clean from malware, or do you trust a third party to not run off with your BTC? Many people would probably choose the first, but there are some who would choose the second. Online wallets with per-transaction multifactor authentication (GreenAddress.it, BitGo.com) offer a pretty good (though not perfect) anti-malware alternative for these individuals.To anyone who chooses to keep an online or a (hot storage) desktop wallet, I'd strongly recommend that you only keep around as much Bitcoin as you can afford to lose. I know absolutely nothing about Chrome OS... but would any "app" on the Chrome Web Store work? If so, you could use GreenAddress.it (app is here). It's a web wallet, about which you might (rightfully) have reservations, but it's one of the better ones IMHO.
Hal Finney has been an inspiration to us all. Requiescat in pace. Each release version is tagged, so for example:Code:git clone https://github.com/bitcoin/bitcoin.gitcd bitcoingit checkout tags/v0.9.2.1 Just a heads up --There are some people that find signature campaigns really annoying, either because "who wants to see more ads?" or simply because some people who use them write tons of short useless posts just for the extra cash... try not to be one of them  As others have said, screen is your friend.Ubuntu Server 13 also has byobu (installed by default I believe), just run byobu-enable, and then choose your activation key (press Ctrl-a, and choose an option, I prefer the first). Then instead of logging out, use Ctrl-a d (on either an SSH session or the console).I'll bet that the underlying cause is that you enabled home directory encryption -- your home directory will only remain decrypted while you are logged in. You can relocate the datadir and start bitcoind with -datadir=/new/dir as another way to get around this. It gets pretty complicated from here... (and there are real experts who know far more than me that would make both our heads spin! )The wallet that's on your hard drive (or the KeePass file) is encrypted with a something called a "symmetric" key. That just means the the encryption key is the same as the decryption key, and it's always the same until it's changed, typically manually by you.With KeyPass, you can use your YubiKey in one of two different modes. In "static password" mode, the YubiKey simply remembers one portion of your password. The encryption/decryption key is created by adding the password you remember to the one the YubiKey remembers, and it's always the same (unless you manually change it). If there's malware on your computer, it can wait for both you and the YubiKey to input your passwords, and then the malware has all it needs to decrypt your KeyPass passwords (or your wallet file).The second mode is called One-Time-Password mode (which sounds good, but keep reading...). This mode is similar to "static password" mode, but it automatically changes the symmetric encryption key each time you log in. This means that if a piece of malware captures the full password (both the one you type in and the one from the YubiKey which is different each time you log in), and if the malware then tries to use this password, it's probably too late because the symmetric key has already been changed and is no longer valid.The problem is that there's a simple attack the malware can use to get around this. The malware takes a copy of the encrypted data before you or the YubiKey enter your passwords, and stores it temporarily. The next time you and the YubiKey enter your passwords, the malware records the password. As I said above, at this point the symmetric key for the encrypted data is now automatically changed... but it's only changed for the "legitimate" file. The temporary file which the malware took a copy of doesn't have its key changed -- its password is still the same, it's the one that was captured by the malware. Now the malware has both the decryption key and the older encrypted file that the decryption key will work on.With a good* online service, the malware never has access to the encrypted data because it's only stored on the server, and so it can't take a temporary copy of it for later decryption.The bottom line is that while a YubiKey makes things a little more difficult for malware, it's doesn't really help that much for local wallets. Local wallets are only safe if there's no malware present on the system. Good* online wallets on the other hand can have their security improved with a YubiKey (or similar).* A good/strong online service has Bitcoin keys stored in (at least) two places: partially on your computer and partially on the server. At no time are the keys both stored in the same place. Blockchain.info doesn't fit this description, because there is only one key -- if you're malware infested, this one key can be stolen by malware on your computer. Of course, all online services require a certain trust level on your behalf... Although Higheducation92 did get the script working, I don't know if he ended up finding his password. I don't think he ended up installing PyCrypto. The PyCrypto install is optional (it speeds up Electrum and MultiBit searches), and on OS X it might be tricky. I did update the Tutorial with instructions on how to install PyCrypto on OS X, but I don't know if the instructions actually work.... (On Linux and Windows, installing PyCrypto is a bit easier.)At any rate, if you have any specific questions, I'll try my best to answer them.-Chris (original quote is below before it was edited...)I don't begrudge you the fixing up of code, after all that's part of what open source software is all about.But a single Google search will clearly show who the original author is, and will leave no doubt that the original author is not choosing to distribute the code as open source. There's no excuse for intentionally burying your head in the sand (as it seems you're doing, but maybe you're simply unaware that this is not open source software?)It's not a matter of whining, it's a matter of supporting individuals who try to write code for a living. I may not want anything to do with gambling sites, but I certainly support the right of developers to write and sell software. If you choose to undermine that... well that's your choice, I doubt the copyright police will come knocking down your door anytime soon. But if you're doing it willingly and with full knowledge of what you're doing, then you're little better than scammers such as Theospaul.Edited to add: sorry if this came off as a personal attack... Theospaul is certainly scum, and it's unfair to group you in with that character. Hopefully your original posting of this code up on GitHub was just an honest mistake. In most countries, copyright infringement is illegal. There are plenty of people who do it anyways... as you are doing, and you're even going a step further. Your asking for donations sent to you for somebody else's code!You are distributing the code, the fact that others have done so does not make your actions any more ethical.I'm all for open-source software, but it's the original author's right to decide how they want to distribute their software. What you're doing is either woefully misguided, or intentionally malicious. Which is it? That would fix this one issue, but it's pretty clear that this is not a bug but an intentional scam. And where there's one scam, there could be others... I'd recommend everyone stay as far away from this software as possible. YubiKey does offer additional security for web-based wallets, especially those with per-transaction two-factor checks such as greenaddress.it and bitgo.com. In these cases, two-factor auth offers very effective (but not perfect) protection against malware.Two-factor tokens typically work by storing a shared key. The website also stores that same shared key. This allows both the token and the website to generate the same authorization codes, which are then simply compared during login (or during each new transaction). As long as nobody else has access to the shared key, it can provide additional security. Two-factor authentication is only to verify the user has the same share key -- two-factor tokens are not used to do any wallet encryption.With desktop wallets, there is no login process, only an encryption process. Desktop wallets store their private keys inside of files which are encrypted by the user's password. Encryption is not something that two-factor tokens can do. An attacker (or piece of malware) who has access to your PC has direct access to your wallet files. If the wallet files are encrypted, the attacker must either try to brute-force the password, or simply wait for you to type it in. At that point, they can gain access to all of your private keys.In short, two-factor authentication doesn't add any security to desktop wallets.(Hardware wallets are much different -- they can do encryption.) Or... maybe it wasn't an honest mistake and you are still a scammer?Just to be clear, this is (as has already been said) a straight ripoff of CoinDice with the deposit address replaced by Theospaul's address.This is a scam, it was intentional.Shortly after being discovered, Theospaul "fixed" this "bug" in this commit, and then an hour later Theospaul had the nerve to switch it right back. There's no way it was an honest mistake.Although we shouldn't be surprised since this isn't the first time Theospaul has run a scam. Thanks a lot!!! (or thank the alot if you prefer)It doesn't get a lot of attention (which is just fine), so I'm not sure about it's own thread... but if I do, do you think I should start it in the Tech Support forum? That seems like the right place to me. I'll take that as a compliment But as far as I know, nobody has done so. The Python code is long (approaching 4k lines mostly in a single file) and complicated, and "evolved" into its current somewhat messy state (as opposed to being well planned out, sorry...).However I did write some "extract" scripts that are short and fairly easy to understand documented here: https://github.com/gurnec/btcrecover/blob/master/extract-scripts/README.md. The idea was that you could run one of the extract scripts directly on your wallet file, copy/paste the base64-encoded results into a VM w/o network access, and then not worry about what btcrecover might do with it (assuming you read and understood the short extract script). At worst, it could waste a bunch of CPU/GPU time, but at least it couldn't steal you wallet.Of course, all that only really helps if you're already somewhat of a "techie" who knows how to set up a VM. I suspect that many people who choose to run btcrecover are not techies, and are putting themselves at risk (speaking as objectively as I can, of course as the code monkey who wrote it, I claim it's perfectly safe  ). You're welcome to PM me if you'd like. Please be as detailed as you can (without the actual words in your password though). If you include a couple of examples of complete passwords that btcrecover would guess, and a couple that it wouldn't guess, that would help.In particular, are 1, 2 and 3 from above always in the same order, or can they be in any order? The one or two special characters you mentioned, do they only appear once, or can they appear more than once between different words? Or do they always appear between words? I am interested, but only if you think such feedback would be helpful (not necessarily sufficient, but at least helpful).I was thinking of a simple test scenario such as this:Linux-VM-w/Bitcoin Â ----- Â VM-NAT-router-w/Public-IP ----- mainnetTwo tests with different Public IPs (likely never running Bitcoin before*), one where VM-NAT-router is running UPnP, one without. I could do a testnet-in-a-box, but it doesn't seem any easier to me...If I have extra time, I might do an additional tests with both 32 and 64-bit versions (so a total of 4 tests on 4 different IPs).I might be able to run a single Win64 or Win32 test as well, behind a residential cable modem NAT box, again likely never running Bitcoin before. I don't have the resources to run any OS X tests.Before each test, I should verify that UPnP is working (or is not working) as expected.I'd need to verify the existence of inbound connections, preferably on the VM-NAT-router. In the non-UPnP case, I'd need to manually forward a port first. I'll save the log files for future reference. I should probably save a packet capture as well. Anything else? Do I have to wait for a full blockchain download (I wasn't planning to)?For building, I'll probably rebase your branch from a month ago to master.* All of these IPs are dynamic, so although none have intentionally been running a Bitcoin node, I can't be sure. For the VM tests, I can leave the VM-NAT router running for an hour or so before beginning each test and check that no inbound connections are occurring before the test starts. That's some pretty good advice, thanks!PRIMEDICEÂ  PRIMEDICE 666 HAS LAUNCHED! Guaranteed returns! You can't lose! Click Here! pywallet can scan a file (or a hard drive) for mkeys and ckeys (everything required to recover encrypted private keys/addresses), try decrypting them in various combinations, and then reconstruct a wallet.dat file. It almost works, except that the reconstructed wallet.dat doesn't work right unless you choose for it to be unencrypted (which is an undocumented feature). I've submitted a patch which will hopefully be included one day, because aside from that last step it works quite well. I'm all for removing the check to dyndns.org, but it seems like the two pull requests which attempted this were trickier to get exactly "right" then was first imagined... it's too bad, but sometimes there are bigger fish to fry.Thanks to gmaxwell and laanwj for giving it a try, though. Please give this a try.Â  1. Go to Start -> Control Panel.Â  2. Click on Uninstall a Program.Â  3. Find everything that has "Python" in the program name, you should find at least two, maybe more.Â  4. Double-click each one to remove it.Â Â 5. Install Python 2.7.8 Windows X86-64 Installer from here.Â Â 6. Install PyCrypto 2.6 for Python 2.7 64bit from here.Let me know if you still get the "warning: can't find pycrypto" message... The wallet.dat password is seeded, rainbow tables wouldn't help.While there is a speed difference between Python and native code, for this particular application it's much closer than 20x. Most of the time is spent inside cryptographic code, and most scripting languages implement cryptographic primitives in native code.Here's a comparison between btcrecover and John the Ripper, including columns which show what language each cryptographic primitive is actually written in. The interesting comparisons are the Bitcoin Core lines, which show a speedup of 2.75x from 44 P/s to 128 when going from btcrecover to JtR, and the speedups that you get with GPU acceleration (pretty good speedups with Bitcoin, but a measly 4 - 6x speedup for Armory which uses a memory-hard KDF).All of these tests were run on my aging i5-2500k and 2x 560 Ti's. Wallets were created on the same system using default KDF parameters, except for the Blockchain.info wallet with 10,000 iterations (10 is the default).BBcode tables are pretty ugly, the original spreadsheet if you want to see it is here. WalletSoftwareLanguageKDFHashAES-256ECDSA? Iterations MemoryGPUs P/s ArmoryBTCRPython 2.7ROMixC++SHA-512C++C++Yes 4 2 MiB 20 ArmoryBTCRPython 2.7ROMixOpenCL (GPU)SHA-512OpenCL (GPU)C++Yes 4 2 MiB1 79 ArmoryBTCRPython 2.7ROMixOpenCL (GPU)SHA-512OpenCL (GPU)C++Yes 4 2 MiB2 128 Bitcoin CoreBTCRPython 2.7PBKDF1PythonSHA-512CCNo 67,908  44 Bitcoin CoreJtRC w/OpenMPPBKDF1CSHA-512asmasm w/AES-NINo 67,908  121 Bitcoin CoreBTCRPython 2.7PBKDF1OpenCL (GPU)SHA-512OpenCL (GPU)CNo 67,908 1 1,070 Bitcoin CoreBTCRPython 2.7PBKDF1OpenCL (GPU)SHA-512OpenCL (GPU)CNo 67,908 2 2,110 Blockchain.infoBTCRPython 2.7PBKDF2PythonSHA-1CCNo 10  27,000 Blockchain.infoBTCRPython 2.7PBKDF2CSHA-1CCNo 10  82,000 Blockchain.infoJtRC w/OpenMPPBKDF2CSHA-1C w/SSE4.1asm w/AES-NINo 10  533,000 Blockchain.infoJtRC w/OpenMPPBKDF2OpenCL (GPU)SHA-1OpenCL (GPU)asm w/AES-NINo 10 1 3,996,000 Blockchain.infoBTCRPython 2.7PBKDF2PythonSHA-1CCNo 10,000  41 Blockchain.infoBTCRPython 2.7PBKDF2CSHA-1CCNo 10,000  262 ElectrumBTCRPython 2.7PBKDF1PythonSHA-256CPythonNo 2  25,000 ElectrumBTCRPython 2.7PBKDF1PythonSHA-256CCNo 2  396,000 MultiBitBTCRPython 2.7customPythonMD5CPythonNo 3  26,000 MultiBitBTCRPython 2.7customPythonMD5CCNo 3  415,000 
First, just a reminder, if there was an umlaut over any of the vowels, btcrecover will never find it. It can't handle non-ASCII.The only option would be to try more passwords. I guess I'd try this:Code:#--pause --no-dupchecks --wallet multibit.key --autosave progress.sav%ia%0,5a%d %ia%6a This tries passwords that have a single number at the end, and also passwords that are 7 letters long. It will take 36 times longer to run, so it's pretty important that you install PyCrypto 2.6 for Python 2.7 64bit from here first.It will autosave to a file in the same directory, so you can close it and restart it without losing any progress (but only after the initial counting phase). I just added a small improvement related to autosave, so you should probably download a new copy of btcrecover first. You're right, Bitcoin keys cannot be feasibly brute-forced.But this thread is talking about brute-forcing the password on wallets. If the password is weak enough, or if you know enough about the password, it's certainly feasible (and a GPU can help, depending on the wallet).As far as using a scripting language goes: yes they are slower, but many scripting languages implement the time-consuming portions (e.g. SHA) in native code, so using a scripting language isn't as big of a performance hit as you may think (btcrecover is written in Python, for example, but most of the crypto uses native code libraries (not written by me) or OpenCL for GPU acceleration).Moral of the story is: use strong passwords.  It should look something like this:Code:Read additional options from tokenlist file: --pause --no-dupchecks --wallet multibit.keyCounting passwords ...DoneUsing 4 worker threads116668178 of 642544812 [#####--------------------------] 0:06:26, ETA:Â  0:29:01In this example, it's been running for 6 minutes so far, and it has 29 minutes before it's tried every combination.If it finds the password, it will look like this:Code:Read additional options from tokenlist file: --pause --no-dupchecks --wallet multibit.keyCounting passwords ...DoneUsing 4 worker threads116668178 of 642544812 [#####--------------------------] 0:06:26, ETA:Â  0:29:01Password found: 'Passwd'Press Enter to exit ...Or if it tries every combination and the password is something else (e.g. maybe it's longer, or has numbers), it will look like this:Code:Read additional options from tokenlist file: --pause --no-dupchecks --wallet multibit.keyCounting passwords ...DoneUsing 4 worker threads642544812 of 642544812 [#######################] 0:35:27, Time: 0:35:27Password search exhaustedPress Enter to exit ...Does that answer your question? I hope so too. If not, but you remember something new about your password, we can always try again. I'm not understanding you... can you describe in more detail? A bunch of examples would help.It also depends on which wallet you're using. Services like BitUndo can attempt to reverse a tx before the next confirmed block, but they remain very unlikely to succeed (even as per their own FAQ). BitUndo depends on miners running a customized version of bitcoind, and thus far the interest in doing so has been pretty low. I should have caught this sooner, but now I see the problem.You have Python 3 installed. btcrecover only works with Python 2. (They are similar, but different programming languages.)You can have them both installed at the same time, but it's probably safest to:Â  1. Uninstall PyCryptoÂ  2. Uninstall Python 3Â  3. Install Python 2.7.8 Windows X86-64 Installer from here.Â  4. (optional) Install PyCrypto 2.6 for Python 2.7 64bit from here. Thank you for the picture, it is very helpful.I understand what the problem is, but I can't fix it tonight, sorry about that.I'll post an update tomorrow sometime... The different languages thing is hurting us... but I'll try.From the Quick Start, follow Step 1 to install everything.Next, open Notepad, and then copy and paste this into Notepad:Code:#--pause --no-dupchecks --wallet multibit.key%ia%0,5aNext, save the Notepad file into the btcrecover-master folder you unzipped from Step 1. The file name must be btcrecover-tokens-auto.txtNext, follow Step 5 from the Tutorial Quick Start. After you find your Multibit .key file, copy it into the same btcrecover-master folder, and then rename the .key file to multibit.keyFinally, double-click btcrecover.py, and it should start.If you installed PyCrypto in Step 1 (optional), it will take an hour or two to finish. If you didn't install PyCrypto, it will take around 6 - 24 hours to finish.This will test every password from 1 to 6 letters long. The first letter is upper or lower case, the rest are all lower case. No numbers or symbols.Good luck! Bitcoin wallets all (that I know of) use strong encryption. The point is to protect you from hackers. This also means that if you lose your password, you could be in trouble.If you describe everything you remember about your password, I can try to help. You don't have to use specifics -- for example you could say "I know my password contained 3 - 5 of these words below, and then a 1 - 2 digit number" and give example words, but not the actual ones you had in mind.If you want to use Bitcoin in the future, look into a "deterministic" wallet, such as Electrum or Armory. They have easy backup-to-paper and recovery mechanisms that can help. btcrecover might help, but only if you remember a decent amount of your password. It does support Multibit, although it doesn't support non-ASCII letters, so if your password had any umlauts it won't help. There's a tutorial with a quick start here (in English, sorry).This thread has a lot of good information related to password recovery, but some of it is specific to Bitcoin Core (Bitcoin-Qt) wallets.If you have any specific questions about btcrecover, let me know and I'll try to help (I'm the dev). I'm going to generalize here, but it's not that far from reality.Let's divide all Bitcoin users into two categories: Computer knowledgeable: individuals who are either computer enthusiasts, professionals, or who are neither but have made a real effort to educate themselves on basic computer security.Not computer knowledgeable: not trying to be condescending, but everyone else...Likewise, let's divide malware into two categories.Simple Trojans: written by beginner programmers typically in a scripting or bytecode-compiled language, such as AutoIt, Java, .Net, etc., and does simple things such as scan for wallet.dat files in well-known locations and uploads them to FTP servers; is thwarted by wallet encryption with anything but simple passwords.Advanced malware: written by professional black-hats and sold on the black market to individual who customize and deploy the malware; is capable of exploiting one or more OS or application vulnerabilities, attempts to hide from anti-malware products and security sandboxes, and will patiently search for a variety of information to steal (or encrypt for later extortion) from a variety of locations (including typed passwords, screenshots of on-screen keyboards, and who knows what else). User Type  Likely to be infected by advanced malware?  Likely to encrypt their wallets?   Likely to follow your advice?  Likely to be infected by simple malware?  Computer knowledgeable  Yes  Yes  Maybe, but they know it wouldn't do them much good.  No  Not computer knowledgeable  Yes  Maybe  No, even though it would help them.  Yes In other words, I would argue that the type of user that this sort of security-through-obscurity would help (those who get infected by simple Trojans) is the same type who wouldn't know enough to implement this advice (or for that matter, to even encrypt their wallets in some cases which would help against simple Trojans). Glad to hear it, this was the only major concern I had.Â  I really should have made it clear what I was looking for, instead of suggesting some sort of solution first. I was mostly talking about a simple recovery mechanism for a lost 2fa that didn't involve email or one's phone. You're already considering a paper-based 2fa, which sounds like an even better way to address this, so that's great!I'm not sure what an "open" API is (please excuse my ignorance), but they do publish their API online. One method they support is OATH-HOTP based (very similar to Google Authenticator, except instead of the time they use a counter which is incremented after each new code). The only reason I thought of them is because I use them with LastPass (on my desktop). I was thinking they could be both a desktop and a mobile solution, but I don't really know anything about their mobile integration (it's NFC based).I should have realized that, thanks for correcting me. Adding such an option would only lead to a false sense of security, please pretend I had never mentioned it in the first place.Â  For what it's worth, I've been really impressed with your overall approach. I really hope GreenAddress gets the attention it deserves! OK, I'll buy that. So there's a non-zero chance that the scammer will get away with it scot-free (get their btc back), but in every scamming attempt, the scam attempt will result in a 587/600 chance that the receiver doesn't receive any btc (unless they want to try a cat-and-mouse game of some sort with the scammer up until the next block is found).A rational scammer will only try this scam if their expectancy is > 1, in other words if the refundable fee is < than some smallish %. But a scammer who places value on the thought that the receiver will not get paid can execute the attack at will (albeit in return for the surcharge), with the added bonus that they also might get their btc back.This means that the vendor needs a higher refundable fee to discourage such practice, and they also need to add a non-refundable surcharge to cover their losses. As long as this surcharge is less than 3-ish percent, it will be comparable to credit cards (which removes an advantage of Bitcoin from a vendor's point of view).Now that Bitcoin is gaining some public traction, explaining all this from a PR point of view would be just about disastrous, if you ask me. To consumers: you have to pay an extra 10%, but it's refundable. To vendors: any consumer who wants to can rip you off, even though they aren't likely to benefit financially, so it probably won't happen much.But more importantly, what is it that we'd be left with? A more complicated system (both technically and PR-wise) that that accomplishes the same thing as what we had before: instant payments still aren't guaranteed, and so they cost the receiver. So where's the advantage?If anything, I'd prefer a Pay by Fee that didn't include scorched earth. At least there I see some small advantage: nobody should trust zero-conf transactions (although I still don't like it). Hi tryexcept, I have a couple of suggestions re 2fa I'm hoping you can consider.The one thing that's keeping Google Authenticator a bit unsafe is that the same code can be reused (if it's within the same 30s window). This is something that could be abused by malware, and one of per-tx-2fa's biggest draws for me is safety from malware. I'm wondering if an option could be added to prevent the reuse of GA codes? I understand that some users would prefer not to have a once-per-30s rate limit, hence making it optional might be better than forcing it on everyone (although for myself the rate limit wouldn't bother me).Second, how about an OTP option for 2fa? For example, I enable OTP as a 2fa method, and then ask GreenAddress to generate two or three OTPs which I store on Post-Its. I enable Google Authenticator, but I don't enable any of the other 2fa options because I consider them less secure. Now I've got a few OTPs that I can use to disable 2fa (or for any other 2fa-required action) if at some point in the future I lose my Google Authenticator, and at the same time I don't have to enable any other 2fa method.Next, have there been any thoughts on 2fa hardware tokens, e.g. YubiKey NEO (which would work nicely with the mobile app w/o the silliness of having the second factor be on the same phone as the app)?Lastly, how about an option to require 2fa during the initial login? The intent would be to prevent a loss of privacy in the event the mnemonic were compromised (e.g. via malware).I look forward to your thoughts, thanks! The best place to start looking is the official choose-your-wallet page here: https://bitcoin.org/en/choose-your-walletThere's also a beginner-friendly chart that I've put up here which might be helpful: http://gurnec.github.io/btc-wallet-comparison. If you have any questions on why I rated something the way I did on that chart, just ask.Yes. Before starting Bitcoin Core for the first time, create a new folder on an alternate drive, and then modify the shortcut in the start menu (right-click, properties) so that the Target includes the newly created folder, like this:Code:"C:\Program Files\Bitcoin\bitcoin-qt.exe" -datadir=D:\BitcoinAlso, by placing a "bootstrap" file into this folder before staring Bitcoin for the first time, you can significantly speed up the initial download process (from days to hours). This bootstrap file can be downloaded via BitTorrent with this torrent: https://s3.amazonaws.com/bitcoinarmory-media/bootstrap.dat.torrent. (I can't believe I'm letting myself get dragged into this, I should know better...Â   )Let's see, how about:this server we're all posting toGooglethe phone in my pocket (IDC says Android has a 78% market share as of 4Q13)the TomTom in my carthe wireless router under my desk (and possibly your wireless router too)485 out of the top 500 supercomputers (as of June 2014)the International Space Station (where it replaced Windows in 2013)It really is all over the place these days, despite it's low desktop OS adoption rate.Or maybe Safari, the browser built on top of the open-source (though Apple-backed) WebKit project? TL;DR: the main point is that Pay by Fee isn't a simple issue, and itÂ’s as much a technical issue as it is one of human nature.To be fair, I think (but am not sure) it was luke-jr who initially decribed this, and jdillon who expanded on it.Also, I don't think you have the description quite right.I think you mean, "If a scammer tries to double-spend their own Bitcoin by sending out two transactions, one legit and one back to themselves, there is some chance they will succeed and the receiver/vendor will be none-the-wiser until it's too late."I don't understand where the percentages you go on to quote come from, though. There is some chance that the receiver/vendor will see the legit transaction in their memory pool, and some chance they will see the scamming transaction (and react accordingly), but it's not 50/50. Likewise with the chances that one transaction will end up succeeding over the other.I think you mean, "If a scammer sends out two transactions, one legit and one back to themselves, the receiver/vendor will eventually (assuming a significant majority of the network/miners is using Replace by Fee) see the scam transaction, which is good for the receiver/vendor, so the receiver/vendor can send another transaction paying 100% of the output of the transaction to a transaction fee (to a miner). Scammer receives nothing, but neither does the vendor.No arguments from me here.You're assuming that all receivers/vendors will be smart enough to check for this situation and react to it quickly (which might be the case one day, but the reality is that there will be a transition period while this is not the case). You're also assuming that the scammer is choosing to act rationally.Even if the scammer only has a low likelihood of success, I don't see why a scammer wouldn't try anyways. Some percentage of the time the scammer would fail and would end up paying for their merchandise (although they'd be paying a miner instead of the vendor). Some other percentage of the time, the scammer would succeed and get their btc back. It seems to me that the scammer, at least during the transition period, has nothing to lose by trying, and is guaranteed to at least deprive the receiver/vendor of their payment.To be fair, jdillon also had a clever solution to this problem (linked above), but it involves requiring all senders/consumers to overpay for their merchandise/service, and then trust the receiver/vendor to refund them the difference after the tx has been confirmed, which seems unfriendly at best.The bottom line is that Pay by Fee seems likely to completely eliminate zero-conf transactions, or at least during the transition period. Some would argue that this would be a good thing, but I'd rather let receivers/vendors have the choice to make their own risk/benefit analysis. The admin over at cryptocointalk has responded here: https://cryptocointalk.com/topic/13908-zipcoin-zipc-information/?p=116770.Given the choice between believing an admin over at cryptocointalk versus a newbie here... well, I'll let everyone come to their own conclusions...The only thing I can imagine is that OP posted the legit link, waited for bitointa.lk to cache it, swapped it for the malware link for a period of time, and then swapped in the legit link again (or there's some sort of conspiracy against OP). Without a mod to check all this, we'll never know for certain how it happened, but in the mean time, I'd avoid this coin like the plague. I doubt thatÂ  Thanks for clarifying.
That's not the file in question. As far as I can tell, that file seems clean (but again, unless it's compiled via Gitian, it's very hard to tell).The file in question was allegedly originally available here, but as I said has since been remove: https://mega.co.nz/#!JAoyiajC!0ND16g-6qVDRGVuxnNBZmd-NInXzpbdaW9Pe9dDlDUoThe suspicious file, which as far as I can tell was first referenced by user oreoeater in this post: https://bitcointalk.org/index.php?topic=721306.msg8198136#msg8198136Â  is still available here: https://mega.co.nz/#!L1IBwTzB!sHUsuf3fLQ-PJrtScL7IZaT99DPNesSSrUfJ_ehFjkg. It's definitely malware, see here: https://bitcointalk.org/index.php?topic=721306.msg8201918#msg8201918. I think oreoeater may have uploaded at the request of others looking to investigate it, but I haven't read the whole thread so I'm not sure.Or did the admin simply copy and paste the link from somewhere else? Those are the questions, and I hope the admin will respond (over here). Not entirely... where did the virus-version come from, and was it created by the same author of Zipcoin?As far as I can tell, this link has been claimed to be the link where the virus version originally came from (although its content has since been removed): https://mega.co.nz/#!JAoyiajC!0ND16g-6qVDRGVuxnNBZmd-NInXzpbdaW9Pe9dDlDUoThe first reference I can find of that link is over in this forum by an admin, so I doubt it was created by them: https://cryptocointalk.com/topic/13908-zipcoin-zip-information/?p=116755I posted a question asking where the link came from, we'll see if there's any reply. There definitely is a version which contains a virus. What hasn't been decided is where that version came from, and if it was created by the author of the official Zipcoin wallet. So far, the currently posted version has not been found to contain any malware, but since any semblance of Gitian has been ripped out of it, it's very difficult to know for sure. (Gitian is what allows people to compile the software from source and see if the .exe is exactly the same as what's posted.)As of right now, I honestly don't know, but I'd err on the safe side if I were you. That stinks. I'm at least glad you found the source... Has any asked a mod to see if the original post had the malicious link (not that I really doubt it)? I can't verify that URL referenced above was in the original post, but I can definitely verify that it drops malware: My mistake, do not include the wallet file name, I should have said run "db_recover -cv" from inside the .bitcoin directory and it will attempt to do a recovery of all wallets in the directory. On second thought though, I don't think this will help. I think it only helps if there are BerkeleyDB .log files still present, and Bitcoin removes all BerkeleyDB logs before exiting, so this command probably won't do anything (but it doesn't hurt).I'd try the db_dump/db_load process instead, starting with the original wallet file (not the one which Bitcoin created in its attempt to do a salvage). If that still doesn't work, then it's on to pywallet... By the way, are you sure that it doesn't look like a normal change transaction (not normal/a stealing tx would be a whole bunch of inputs and just one output). If you're not sure, please post the transaction id up... Probably, Bitcoin will create 100 new addresses if wallet.dat is missing, and given that they got two different wallets, it sure doesn't sound like a technical glitch.I'm sure you don't want to hear this, but to be safest you should probably reinstall everything from scratch at this point. If your wallets were encrypted, it's very likely you have a keylogger on your system. This means: (1) don't log into anything, and (2) after your system is reinstalled (or better yet, from a different system), change all your important passwords, especially financial ones, cause it's a good bet someone else could have them now... I'm not sure it'll help you much, but here it is anyways (with the quotes, assuming you're on Windows):Code:dumpwallet "c:\walletdump.txt"Then you can double-click it (the file), and it will display the creation time of all of the reserve addresses (I think in the UTC time zone). That really stinks, I was optimistic it may have just been a technical glitch, so sorry if I got your hopes up. Is there any chance the transaction you're looking at was something you initiated, and you're just confusing a full-out transfer with a change address, or was there only one output?Regarding the log file: maybe. Most hacker victims just have their wallets or keys stolen, and then the hacker transfers the Bitcoin out later. If the hacker actually used your PC to transfer the coin out, then it would be in the logs. Also in the logs will be a bunch of "reserve" address creation messages around the time your wallet.dat was recreated.Did you have your wallet encrypted? Did you have RPC enabled?Have you installed or upgrading any software on your PC recently (especially from this or another Bit/Altcoin forum)? If all the saved addresses are gone, I'd guess that either the wallet.dat file moved or was deleted (by accident? technical glitch? a hacker? hard to say...), or the place where Bitcoin Core is looking for the wallet.dat file changed/got reconfigured.Usually hackers don't matter deleting the wallet.dat as far as I'm aware (they usually just transfer the Bitcoin out leaving you with a 0 balance but the same keys), so maybe that's a good sign....Have you installed or upgrading any software on your PC recently? Do you have a backup of the wallet.dat? Did you ever intentionally choose an alternate datadir?How much was in there (don't have to tell me, I just mean ask yourself)? If it was a lot and you have no backups, and if you're a techie yourself or if you're willing to enlist the aid of one (a friend or paid), you should probably assume a technical glitch (it's the best case) and do something drastic, like shut down your PC right now, and boot off of a rescue CD with some data recovery tools.Otherwise, I guess I'd start by searching the whole HD for any wallet.dat file, including the Trash/Recycle Bin, in the hopes it was just an accident/technical glitch. If you do a dumpwallet via the debug console / RPC, it would be interesting to see the creation dates of all of the keys. I'm guessing they were all created just now when you opened your wallet, which means the original wallet.dat file wasn't where it was expected and it got recreated.That's all I can think of for now... I'd guess that if your wallet software were smart enough to implement Replace By Fee (and if it was standard on the network), it would probably also be smart to not have caused this situation in the first place. In other words, I think the better option would be to get your wallet's developers to implement warnings when the transaction fee is too low, and also methods to remove stuck transactions, first (not to knock the devs, all things take time to work the bugs out).If Replace By Fee were standard, no transaction would ever be instant, even very small ones. Some see this as an improvement in security at the expense of convenience and choice, others see the improvement in security to be so minuscule, especially with small transactions, that the cost in convenience makes it not worthwhile (although I'm probably summarizing all this incorrectly).Have you tried the advice over on this support page of theirs?If that doesn't help, here's what I'd eventually consider.Transfer the remaining balance (via the Bitcoin network) from your old wallet to one of the new MultiBit addresses. This is just to ensure that you don't lose anything on the off-chance MultiBit didn't like the keys you imported (I really don't think that's the case, I'm just being safe).Once that transaction has confirmed, uninstall the old wallet so that it stops trying to broadcast the stuck transaction, wait a day or so, and try the advice on the linked page once again. Those commands were an example for Windows. I'm not much of an OS X person, so I might be wrong, but give this a try.Start in the Applications folder, then open the Utilities folder, then open the Terminal application. From here, type in this:Code:cd /Users/Ben/Desktop/btcrecover-masterpython btcrecover.py --wallet Wallet --tokenlist tokens.txt --other-options...You shouldn't need to, but if you're interested there's a Terminal tutorial for OS X you can read over here: http://blog.teamtreehouse.com/introduction-to-the-mac-os-x-command-line In both cases (javascript-crypto despite its many weaknesses vs server-stored keys), the level of trust you're required to give the developers is roughly the same*, as far as I'm concerned. However in the someone-hacked-the-server case, I'd argue that you'd be safer with javascript-crypto. As you pointed out a clever hacker should certainly inject difficult-to-detect malicious javascript (and javascript being a dynamic language only makes this easier to go undetected), but I'd argue that the developers/admins would eventually catch such an exploit, decreasing the count of affected users.In the end it's all shades of grey. A particularly clever hacker might do the same to a desktop client (e.g. a pull request whose true nature went undetected for some period of time), it's just a matter of likelihood. If that's true, the question then becomes what are the chances that someone could succeed in stealing any given wallet in such an attack? For example, maybe it's 0.1% for a particular desktop wallet, 25% for a javascript-crypto wallet on a compromised server, and 100% for a fully hosted wallet on a compromised server. Or maybe it's 0.1% / 95% / 100%. I'm sure I'm not qualified to guess, though.* You could argue that you need to trust javascript-crypto developers more, simply because creating safe javascript-crypto is somewhere between hard and impossible, and you have to trust that the devs really know what they're doing. Completely agree, with two caveats...I wouldn't have a problem if there was a by-default-off automatic update mechanism (although the type of user who would most benefit from this probably wouldn't know enough to enable it, which kind of defeats the purpose...).Blockchain-style wallets, while certainly less secure than desktop clients in most cases, shouldn't be compared equal to coinbase-style wallets, which is a phenomenon I see occurring all the time (not to imply that your doing so).Edited to add: it's not that there isn't a clear benefit to automated updates, it's just that IMHO the risks outweigh the benefits, especially for the type of user who I'd expect to be running the full-node clients. The important point is that online wallets are less secure than desktop ones, but at the same time not all online wallets are created equally.Some, like Blockchain, publish their in-browser code as open source (on GitHub) and do not do any private key handling on their servers making them somewhat safer. Others store your private keys on their servers, making the service more PayPal-like than Bitcoin-like.You could lose your Bitcoin in either scenario, but the former (Blockchain-style) service is the safer of the two. You'll need them in unencrypted format. The easiest way to get them is to log into Blockchain, go to Import / Export, then Export Unencrypted, and finally choose Bitcoin-Qt format. The private keys are the text that come after each "priv" element, and usually start with a 5 (but might start with an L or K).If you're running the "normal" graphical version of Bitcoin, you can go to the Help menu, choose Debug window, and then click the Console tab. You can type the importprivkey commands into this window. For an example, type in: help importprivkeyEdited to add: it's much safer to simply send your Bitcoin from Blockchain to you desktop wallet. The problem with exporting/importing is that you're dealing with unencrypted keys, which might get saved to the browser's cache for example, and might get later stolen by malware. It may sound far-fetched, but as they say, "better safe than sorry." It might, although Bitcoin Core is already smart enough to do an automatic rescan if it thinks the corruption is inside a transaction record.Check your debug.log file (Help menu -> Debug window, then click the Open button), and search for the text "Error reading wallet database" which should have a more specific error message following it, and let us know what you find. I'm glad things are working for you. This answer is a little late, but for future reference, MultiBit also creates encrypted backup files of the private keys as explained here which can be imported should the wallet file become corrupted for some reason.It's biggest advantage of course is that it's a deterministic wallet: as long as you write down/print out your seed, you can always recreate the wallet with all its keys should you run into any trouble.On the down side, it relies on a somewhat centralized system for checking transactions and balance (compared to MultiBit), and it doesn't scale well to thousands of addresses. These are pretty minor concerns if you ask me though.MultiBit HD which is MultiBit's deterministic wallet is getting closer to release (although it's downside is that it probably won't be entirely free...)
This has actually been done before, but not to the extent that the new researchers have reached.The basic moral of the story is "don't let someone else plug something into your PC, it might be dirty." (this rule works IRL, too, if youÂ  s/your PC/you/Â  )In other words, if you're using a USB stick to bridge the air gap, make sure it's one you bought yourself from a reputable seller, and then you'll probably be OK. I say probably because in theory, if your online PC is compromised, there are some USB sticks whose firmwares could be reprogrammed turning a clean USB stick into a dirty one.It will be interesting to see if any malware in the future tries to do this automatically.... There was a thread that talked about this not too long ago: Offline wallet - USB key alternatives - security concerns No, it installs the official .deb package (compiled and signed by the Armory devs). Is the receiving address visible in your wallet? If not, check the keypool size by running getwalletinfo in the debug console, and assuming the keypool isn't empty, creating a new address should result in the same address you created earlier.Have you tried a -rescan after the -reindex?If your current wallet is corrupted, try restoring the backup (but of course backup your current wallet first), and then check its keypool size. If its keypool isn't empty, your address should be in it (and should appear when you create a few new receiving addresses). Until something like this happens, if anyone's interested I just posted a script that will download and install/update Armory to the latest stable version over in this thread.Cheers This is an install script for Armory on Ubuntu. It's nothing real special, but I needed it for myself (for Travis CI) and thought I may as well share.It locates and automatically downloads, verifies, and installs the latest stable version of Armory plus all required prerequisites. Please note that on Ubuntu Server edition, there are a lot of GUI-related prerequisites that while technically required (and installed by this script), aren't required in practice, so you may prefer not to use this script in that case.Code:#!/bin/bashset -eDOWNLOADS="`curl -fsS --retry 10 https://s3.amazonaws.com/bitcoinarmory-media/announce.txt | awk '/^downloads/{print $2}'`"echo "$DOWNLOADS" | grep -q '^https://' || { echo "Can't find Armory downloads URL"; exit 1; }uname -m | grep -q '64$' && BITS=64 || BITS=32LATEST="`curl -fsS --retry 10 \"$DOWNLOADS\" | grep "^Armory [0-9.]* Ubuntu [0-9.,]*\`lsb_release -rs\`[0-9.,]* $BITS " | sort -k 2V | tail -1 | awk '{print $6}'`"echo "$LATEST" | grep -q '^https://' || { echo "Can't find latest Armory download URL"; exit 1; }curl -fsS --retry 10 -o '/tmp/armory.deb' "$LATEST"sudo apt-get updatesudo apt-get install dpkg-sig gdebi-coregpg -q --keyserver keyserver.ubuntu.com --recv-keys 98832223dpkg-sig --verify /tmp/armory.deb | grep -q 'GOODSIG.*821F122936BDD565366AC36A4AB16AEA98832223' || { echo "Signature verification failed"; exit 1; }sudo gdebi /tmp/armory.debrm /tmp/armory.debHere's a version for unattended installation (the one I use for Travis CI, more or less):Code:#!/bin/bashset -eDOWNLOADS="`curl -fsS --retry 10 https://s3.amazonaws.com/bitcoinarmory-media/announce.txt | awk '/^downloads/{print $2}'`"echo "$DOWNLOADS" | grep -q '^https://' || { echo "Can't find Armory downloads URL"; exit 1; }uname -m | grep -q '64$' && BITS=64 || BITS=32LATEST="`curl -fsS --retry 10 \"$DOWNLOADS\" | grep "^Armory [0-9.]* Ubuntu [0-9.,]*\`lsb_release -rs\`[0-9.,]* $BITS " | sort -k 2V | tail -1 | awk '{print $6}'`"echo "$LATEST" | grep -q '^https://' || { echo "Can't find latest Armory download URL"; exit 1; }curl -fsS --retry 10 -o '/tmp/armory.deb' "$LATEST"sudo apt-get -q updatesudo apt-get -yq install dpkg-sig gdebi-coregpg -q --keyserver keyserver.ubuntu.com --recv-keys 98832223dpkg-sig --verify /tmp/armory.deb | grep -q 'GOODSIG.*821F122936BDD565366AC36A4AB16AEA98832223' || { echo "Signature verification failed"; exit 1; }sudo gdebi -nq /tmp/armory.debrm /tmp/armory.debIt's not as thorough as the built-in secure downloader because it only checks the signatures of the very last download (the install .deb file itself), but it was good enough for my purposes. Silly question perhaps, but have you tried adding swap space?Code:cat /proc/swapssudo fallocate -l 1G /swapfilesudo chmod 600 /swapfilesudo mkswap /swapfilesudoedit /etc/fstab# Add the following one line to the end of fstab, then save & exit:/swapfileÂ  noneÂ  swapÂ  swsudo swapon -acat /proc/swapsJust be aware that this might cost you $ with some VPS providers, e.g. Amazon EC2 (although it's free with others, e.g. Digital Ocean). There's a Newbie DO'S and DONT'S thread which has some pretty good stuff in it, you should take a look. Most importantly, please be aware that the information which pywallet dumps is just as sensitive as the wallet.dat file itself, so they both should be treated carefully!If you have a decent idea of what the password contains, you have at least some chance of recovering the wallet file. There is an open source tool, btcrecover, over here that may help (full disclosure: I'm the author). The tutorial is here. Also, this thread has a wealth of information on the subject.If you're worried about transferring wallet information over the Internet, that tool has a potential solution for that issue as well. If you have any questions or need assistance with it, please let me know. Include the quotes.The import file is a normal ASCII .txt file, the kind you'd create with Notepad.You could check the debug log: Help menu -> Debug window, then click the Open button, or look for debug.log in the %AppData%\Bitcoin folder. It should have "Importing" lines if the imports succeeded.You didn't include "change=1" or "reserve=1" did you? If you did, you've effectively hidden them all.... If you were importing into an empty wallet, I'd create a new empty wallet and try again. If you were importing into an existing wallet, do you have any backups of the wallet that you can restore and then try the import again?Whatever you do, make sure to keep lots of backups of the wallet.dat before you start mucking around  Yup, that's how I came across it. It's a very helpful addition. It's just that the import format has to be reversed engineered from the dumpwallet file / the source code if you want to build your own file. Actually version 0.9.0 has an additional vulnerability not present in 0.8.x (so OP's version isn't affected). Version 0.9.0 added support for the payment protocol (BIP70) and for payment protocol URIs (BIP72). If an attacker could convince you to to click on a BIP72 payment link, Bitcoin Core would establish an SSL connection to a remote server under the attacker's control which could then exploit Heartbleed.The general advice is that if you've ever clicked on any payment link before while having version 0.9.0 installed, you should upgrade and then recreate your wallet, and stop using your old receiving addresses. Yeah it's not documented here where most of the other RPC commands are, but I thought I had already mostly answered you in the original thread over here. The only "official documentation" as far as I know is in the actual source code.Or of course you could use one of the better documented APIs as bitsta recommended. First off, I wonder if running bitcoin with the -rescan option would help?You can use the dumpwallet and importwallet RPC/debug window commands, e.g:Code:walletpassphrase "my-passphrase" 60dumpwallet "c:\exportedkeys.txtCode:walletpassphrase "my-passphrase" 60importwallet "c:\exportedkeys.txt"Just be aware that the keys in the export file are not encrypted, so you should probably use sdelete, shred, or similar to delete it once you're done. First off, this is only for importing wallets that were exported using the "dumpwallet" command or in the same format, it won't import an actual wallet.dat file (which you probably already know, but I'm just making sure...)Are you using the full bitcoin-qt.exe program, with the graphical interface for sending/receiving? Or the command-line bitcoind.exe?If you're using the full bitcoin-qt.exe, you'd start it up, click the Help menu, choose Debug window, and then click the Console tab. At the bottom of this window, there's a text entry box, and in this box you'd type exactly this, including the quotes, and then hit enter:Code:importwallet "C:\myfilenamehere"If you're using bitcoind.exe (I'm guessing you're not), you'd start it up first, and then type this at a Command Prompt, including the quotes:Code:cd \Program Files\Bitcoin\daemonbitcoin-cli importwallet "C:\myfilenamehere" Bitcoin Core does not make any automated backups. You need to either backup the wallet.dat file yourself (but only when Bitcoin isn't running), or use the Backup Wallet option in the menu. Backups should be created at least once for every 100 new receiving addresses created.Some clients do perform automated backups (of course, backups to the same hard drive aren't all that useful...):Armory maintains one backup file.MultiBit Classic creates new backup files after each new receiving address is created.Blockchain.info by default keeps a local backup in addition to encrypted wallet stored on their servers, and they have options for other types of off-site backups as well.Armory and Electrum, being deterministic, both have backup-to-paper options which only need be done once at wallet creation. I'd tend to agree with using Bitcoin Core, even though it looks like that's what you were using when the problem occurred. Bitcoin Core uses Berkeley DB as its wallet.dat format. Berkeley DB is a bit bloated, but it's mature, very scalable, and has some reasonably decent recovery tools. I'm not aware of any other client that would be equally scalable (not that I'm an expert on alternative clients though...).As much as I like Armory, I don't think it would scale as well (although it's wallet format is nice and simple and more error-resistant than any other wallet format I'm aware of).For importing, as an alternative you could use the RPC command: Code:importwallet "filename"The wallet import format is a bunch of lines like so:Code:Kx2GEDGhepMhkUnymSFtrU2Q59KMPY75oYjBVofYV9032p5L4a2b 2014-06-19T00:58:01Z change=1 reserve=1 label=label%20with%20spacesThe first two fields are required. If you don't have the address creation time, you can replace that field with something meaningless (e.g. "DATE-UNKNOWN") but something needs to be there. The last three fields are each optional. Only a single rescan is done at the end of the file import, and if you do have all of the creation times, the rescan will intelligently start at the right time instead of starting at the genesis block. Did you ever get this fixed?I think this error is related to the .lock file in the data directory.To open the data directory, go to Start -> Run, then type in: Code:%appdata%\BitcoinIf there is a .lock file in this folder, delete it. If this doesn't help, as others have already mentioned there might be a permissions problem with the directory. Go up one level, then right click on the Bitcoin directory, then click properties. Click on the Security tab, then click Advanced. You should have three lines listed that look something like this (a different order is OK):TypeNamePermissionInherited FromAllowSYSTEMFull controlAnything but <not inherited>AllowAdministratorFull controlAnything but <not inherited>AllowYour_UsernameFull controlAnything but <not inherited>Also, if you click on the Owner tab, next to Current Owner you should have Your_Username listed. If any of this is different, it might be the source of the problem. Actually the good news is that 0.8.x is only vulnerable to the Heartbleed bug if you're using RPCSSL. If you've ever used the -rpcssl plus the -rpcallowip option when starting Bitcoin, then you should probably consider your wallet compromised to be safe. This means you should create a new wallet.dat file, send all your btc to it (via the network), and stop using all of your old addresses.If you've never used those options, then you're safe from this particular bug.Having said all that, it's still a good idea to upgrade anyways (and of course keeping up to date with all of your operating system updates is even more important). Malware (viruses) has become very clever (it's big business these days). If malware does manage to find its way onto your computer, it can easily steal your wallet if you don't encrypt it. Even if you do encrypt it, more sophisticated malware can still steal your wallet (read up on "keyloggers" for more details).If this concerns you, and it should if you have a lot of Bitcoin stored in your wallet that you can't afford to lose, read up on how to use cold storage. You could give btcrecover a try (it's a Bitcoin password recovery tool which supports Electrum). I've never tried it on OSX before but I believe it should work (if you can find the wallet file that is...). Let me know if you have any trouble setting it up.Edited to add: I believe the default wallet filename for Electrum is called default_wallet on all operating systems, although I don't know where it's located on OSX...(full disclosure: I'm the developer of btcrecover)
It's complicatedÂ  The wallet.dat file itself is a set of key/value pairs in Berkeley DB BTREE v9 format. Most of it is not encrypted, except for certain values including the private keys themselves and the master key. More specifically:A 32-byte random master key or "mkey" is generated using OpenSSL's RAND_bytes(). This PRNG is seeded by /dev/urandom on Linux or by CryptGenRandom() on Windows. Additionally on Windows, Bitcoin adds additional entropy from a screen shot and from Windows perfmon counters (possibly because OpenSSL didn't use CryptGenRandom() in early versions?).The mkey is used as an encryption key to encrypt each individual Bitcoin private key using AES-256 in CBC mode with PKCS7 padding and an initialization vector of SHA-256(SHA-256(the respective public key)).Your password, plus an 8-byte salt which is initially generated using RAND_bytes() and stored in wallet.dat, is fed into PBKDF1-SHA-512 (normal PBKDF1 doesn't use SHA-512) with a certain number of iterations (stored in wallet.dat) to generate 512 bits of derived key data. The iteration count is initially set such that it will take about 1/10th of a second to run the iterations on whichever CPU the password is added (or modified).This derived data is divided into three parts. The first 256 bits are used as an encryption key, the next 128 bits are used as in initialization vector, and the remaining bits are discarded. This encryption key and initialization vector are then used to encrypt the mkey (again using using AES-256 in CBC mode with PKCS7 padding), and the encrypted mkey is stored in wallet.dat.Upon a password change, only the encrypted mkey needs to be recomputed and written back to wallet.dat, while it's unencrypted value and all of the Bitcoin private keys which it encrypts remain unchanged. Probably true if it's a human generating the key, but what if it's a website application that's generating the key? I could easily see a case where the key is generated, persisted only to the disk cache, then a page with the address is sent to some user, and then a crash occurs...Of course servers shouldn't be generating private keys at all, they should either be using a cache of public addresses or generating addresses deterministically from a master public key.Â   I don't know what the very best is, but they're definitely not all the same. I somewhat answered this over here: https://bitcointalk.org/index.php?topic=704771.msg7975168#msg7975168. What are your concerns / priorities?Strong random number generation? For this, my first choice would be Armory. In addition to the OS's random number pool (either /dev/random or CryptGenRandom), it also mixes in:It's also a deterministic wallet if that matters to you.Ease of use? For that I'd download a copy of https://bitcoinpaperwallet.com/ (download link is in the lower right of the live demo). It's not quite as thorough as Armory, but it does use window.crypto.getRandomValues which should in theory use the OS's random number pool, and it also uses mouse and keypress events. It's easy to use for paper wallet generation, and quite pretty too. https://www.bitaddress.org/, while not quite as pretty, uses the same random number techniques as bitcoinpaperwallet (actually I think bitaddress was first, and bitcoinpaperwallet is based in part on bitaddress). It's probably the way to go if you want an easy method of generating a lot of paper wallets all at once.Edited to add: both bitcoinpaperwallet and bitaddress support brain wallets, and bitcoinpaperwallet gives fairly decent advice on how to use dice or an extremely-well-shuffled deck of cards to generate the random keys, although there's better advice over in this thread. This error is DB_RUNRECOVERY.Assuming a simple restart doesn't fix it, there are two things I'd try.If you're on Linux, you probably have easy access to the Berkeley DB tools. On Debian/Ubuntu, they can be installed with "sudo apt-get install db-util". After closing bitcoind and making a backup of the wallet.dat file, try running "db_recover -c wallet.dat" from inside the .bitcoin directory. If that succeeds, you're probably all set.If you're not on Linux, or if the above doesn't succeed, try running "bitcoind -salvagewallet" (Bitcoin will make a backup on its own before trying to run the salvage routine).If this also doesn't work and you're on Linux, look over here for another option.If you're still having problems, pywallet is probably your next option, however it's got its own problems (that I mention in the post above).Good luck! I suspect you already have a good feel for the basic differences between wallet choices, but if not, this link might help: http://gurnec.github.io/btc-wallet-comparison/ I have to disagree with coinsolidation... that message doesn't apply to the database version, but rather the environment version which is something else entirely in the complicated Berekeley DB world.... The Bitcoin client typically creates the environment on startup, and deletes it before exiting (except for really old versions of Bitcoin).pywallet does not delete the environment before exiting, so I suspect that the warning message above is the result of running pywallet, and then running Bitcoin afterwards. In any case, I'm fairly sure it shouldn't cause any problems, and that it's just a warning.Since you're on linux, you could use the Berkeley DB command line utilities to see if they can do any better. In theory, they try to do the same thing as -salvagewallet, but they're more up to date versions than the 4.8 that ships with Bitcoin, so maybe this will help.On Debian/Ubuntu, they can be installed with "sudo apt-get install db-util". Then try this:Code:db_dump -r wallet.datdb_dump -r wallet.dat | db_load newwallet.datIf the first command produces a bunch of output, run the second one to create a newwallet.dat. If the first command doesn't produce output, try it again with a capital -R instead of the lowercase.If all this still doesn't work, I could come up with some instructions for using pywallet's recovery methods. It would be my last choice though... pywallet doesn't recover the address book, and it's encryption facilities are fairly well broken, so you'd have to use them to create an unencrypted wallet and then deal with the consequences... Here's the full error message, which python truncates to just the last line:Code:BDB2506 file <filename> has LSN #/#, past end of log at #/#BDB2507 Commonly caused by moving a database from one database environmentBDB2508 to another without clearing the database LSNs, or by removing all ofBDB2509 the log files from a database environmentTheoretically this should only happen if the wallet.dat file is copied out of the data directory while Bitcoin is still running or immediately following a crash.If this is the only problem, running bitcoin-qt with the -salvagewallet option (with the wallet.dat to recover in the data dir) should be able to recover most if not all of the wallet. Agreed... not that I'm claiming I'm knowledgeable enough to help, but I'll bet someone here is. This might be harder than you think, if you really want 100% foolproofness. Printers can run out of ink, hardware RAID can lie to the OS and claim that data has been written if it thinks its backup batteries are sufficient... there are a lot of what-ifs if you don't go into more details.What I'm trying to say is that even if there is a client that makes the appropriate sync call, things can still go wrong. At some point, it becomes more about risk management than about 100% guarantees...Also, for what it's worth, I can say that neither Bitcoin Core nor Armory (my two personal favorites...) force a sync after modifying a wallet file. I'd start with this:Open pywallet.py in a text editor that can deal with Unix-style lines endings (I'm a fan of Notepad++ if you're on Windows) and search for that error message. Shortly before it, you'll see this:Code: try:  r = db.open(walletfile, "main", DB_BTREE, flags) except DBError:  r = TrueReplace the "r = True" with "raise", being careful to keep the same level of indentation, and then re-run the --dumpwallet command. This should hopefully result in a more useful error message. This answer is sort of cheating, but any deterministic wallet (Armory, Electrum, MultiBit HD) should qualify (even if it's not because they do so explicitly), assuming you do a reboot or a sync after initial wallet creation. Not that it really matters, but that malware wasn't claiming to specifically be a MultiBit executable, it is claiming to be a multi-bitcoin wallet, whatever the heck that is... Hi, all.Every so often, there's a new "which wallet is best" thread that appears. The correct answer is almost always "it depends"... there are a lot of options out there, and the best wallet for one person may not be the best for someone else.It can be particularly confusing for beginners. With this is mind, I've compiled a very simple table which I've put up online here:http://gurnec.github.io/btc-wallet-comparison/There's not much to it so far... just 5 wallets listed, and a handful of columns that I thought would be most important for beginners. Note that I'm intentionally leaving out more complicated features (m of n, cold storage, etc.) because this is just geared towards beginners for now.I'm very much open to input. If anyone has additional experience with different wallets, or just thinks I'm flat-out wrong with something that's already on that page, please speak up. You can do the whole GitHub fork / pull request thing if you like, but it seems easier to just respond in this thread or open an issue on GH.I'm hoping that in the end, this will be a good starting point for answering the "which wallet is best for me" question for beginners. The second half of that post talked about how to be safer when it comes to downloading suspicious executables... in other words, software that might actually be a trojan. As others have said, it sounds like you're off to a great start!Which version of Windows? Do you mean using EFS (where you right click, go to Properties, Advanced, and then check off Encrypt), or BitLocker?There's nothing wrong with MultiBit's encryption, as long as you realize that running brute-force guessers against MultBit wallets is quite a bit faster than against many other wallet types. Brute-forcers can guess around 500,000 to 1,000,000 passwords per second (compared to say 50 per second with Bitcoin Core for example) on a CPU, and possibly faster with a GPU or ASIC. As long as you have a nice long passphrase, you have nothing to worry about from brute-forcing, just be aware that in order to be secure it does have to be longer than you'd need with other wallet types.Regarding privacy: MultiBit doesn't really encourage the use of multiple addresses, and this leads to some loss of privacy. I think this is fine if it doesn't matter to you (it doesn't matter much to me), as long as you're aware of it.Regarding backups: Every time you add a new receiving address in MultiBit, your wallet file changes and it must be re-synced with your backups. If you don't often add new receiving addresses, this shouldn't be much of a problem.Regarding malware: All the encryption and backups in the world won't do you any good if you have malware running on your PC. Along with running some anti-malware software, keeping your PC up-to-date, and so on, I posted some more Bitcoin-specific advice regarding how to avoid trojans over in the bottom half of this post. Most of it's basic common sense sort of stuff which you already seem to have a lot of though...Â   Maybe this is already obvious, but there's no reason to avoid using a potentially compromised entropy source assuming that you're also using a source that is likely to be good, is there?In other words, why not use a shuffled deck + CryptGenRandom() (even though it's closed source) + RDSEED/RDRAND (even though it can't be inspected) + whatever else you can come up with? Even if one or more of those methods is insecure, the result is secure as long as at least one of those methods produced enough real entropy, correct? You're right, the unencrypted seed is all hex, I completely missed that. That reduces each check from three AES block decryptions down to just one, and as you noticed makes an extract script possible which only extracts half the seed, still leaving 64 bits of unknown entropy once/if the password is found. I'll definitely be incorporating these improvements and an extract script for Electrum, thanks for discovering this! TL;DR: Please try running Memtest86+, this worked for me!About two or three weeks ago, I was having the worst problems getting past the Sync step. I spent probably about a week or two re-downloading the Bitcoin blockchain (more than once), rebuilding the Armory DB (several times), and rescanning, and it would always fail during the scanning phase with that same "Cannot get tx copy, because don't have full StoredTx!" error often at different points (at different %'s completed).I became convinced there must be a bug somewhere in Armory. On one occasion in the debug log, it mentioned an additional error message "Invalid txIndex at height # index #". This gave me a place to start looking in the LevelDB database to see if there actually was a corruption. After quite a bit of digging, I did indeed find the issue: in the DB, each transaction in a block is given an ID starting at 0 (that's not the blockchain TxID). There was a transaction in the block whose sequential ID number was greater than the total number of transactions in that block (which is recorded separately in the DB). But how did this happen??Looking at the transactions that should have been in this block, there was also one missing, so it looked like the corrupted transaction matched up with the missing transaction except for it's sequential ID. Looking closer, the ID was almost correct: it had just a single-bit error in its high nibble, flipping a 0 to a 1 and making it too large.Well that's strange... maybe my hard drive was failing? Usually HD failures doen't cause single-bit errors, but rather entirely unreadable sectors or relatively large corruptions though.... Maybe a failing RAM stick?Well, very long story short, I did indeed have some bad RAM which Memtest86+ found pretty quickly. After replacement, I had no trouble rebuilding and rescanning.A big thanks to Armory for helping to find this bad RAM! If it weren't for all of the double and triple checking in the Armory code, this could have gone undetected for months, and who knows what I could have lost!! Thanks!!! Thanks for the compliment, flattery will get you everywhere Getting what btcrecover needs from the pywallet dump is pretty easy.... if you actually manage to find the password, we can worry about the rest later.Save only the "mkey" section from the pywallet dump to a new file, e.g. it should contain only something like this:Code:{Â Â  Â "encrypted_key": "2e2c3b9b58e9b33c9799b4472e83c136e6246120c45e390daa6a57476e7fbe4f57d83f79d75f9b4c1db680fe5a846cb8", Â Â  Â "nDerivationIterations": 67908, Â Â  Â "nDerivationMethod": 0, Â Â  Â "nID": 1, Â Â  Â "otherParams": "", Â Â  Â "salt": "4593aff5639179c7"}The Python script below produces output in the same format as extract-bitcoincore-mkey.py, but it uses the file above instead of a wallet.dat file. Give it the filename from above as the first argument, and it will print out some base64-encoded stuff that btcrecover can use:Code:import sys, json, struct, base64, zlibdata = json.load(open(sys.argv[1]))encrypted_master_key = base64.b16decode(data["encrypted_key"], True)salt Â  Â  Â  Â  Â  Â  Â  Â  = base64.b16decode(data["salt"], True)iter_count Â  Â  Â  Â  Â  = data["nDerivationIterations"]bytes Â  Â  = b"bc:" + encrypted_master_key + salt + struct.pack("<I", iter_count)crc_bytes = struct.pack("<I", zlib.crc32(bytes) & 0xffffffff)print(base64.b64encode(bytes + crc_bytes))Then you can feed that into btcrecover like this:Code:btcrecover.py --extract-data --passwordlist existing-dictionary-file.txtPlease enter the data from the extract script> lV/wGO5oAUM42KTfq5s3egX3Uhk6gc5gEf1R3TppgzWNW7NGZQF5t5U3Ik0qYs5/dprb+ifLDHuGNQIA+8oRWA==...Password found: xxxxIf the dictionary file is particularly long, it might be worth trying to get the somewhat experimental GPU support working-- it can improve speed w/Bitcoin Core wallets from somewhere in the 50s to somewhere in the 1000s (tries per second), but it can take some effort to get working well.Good luck! Yeah, btcrecover has a lot of scaffolding to actually generate the passwords to test... still that's faster than I expected.Â That could be true (I doubt PyCrypto uses AES-NI). Although the oclHashcat guys have done some impressive things, including password generation and AES decryption all on a GPU, which is far more than I've managed (I only do SHA's for Bitcoin Core in GPU, everything else is in CPU).
Yup, that's exactly what I'm doing in btcrecover here. I'm only managing around 10^5 tries/s per CPU core (it's written in Python but uses libraries for SHA and AES written in C) but I'd guess it could be improved if written entirely in C, or even better in OpenCL....It turns out that you can play similar tricks with many wallet encryption schemes (but not with Armory as far as I could find - Armory really got wallet encryption right). There's a good reason you can't compile it... the source code isn't complete. Even it it were, the source code which is there is clearly just a 99% copy of CGMiner, except for removing any references to the CGMiner name and replacing some of the copyright notices (which itself is a GPL violation...) with bogus names ("Michael Bubble"? really?). In short, the binaries and the source code are not the same.Just because something claims to be open source, doesn't make it safe. I guess that depends on your definition of "subtle", but one thing is for certain: there's some new piece of malware posted on the forums every couple of weeks, and it's been getting a bit more clever each time. This is a trend that I'd guess is very likely to continue.Take this one for example. The website it points to looked surprising professional even though it had some broken links (it's currently down, so you'll just have to take my word for it). It wasn't posted by a newbie which gave it a little credibility (I'm pretty sure the forum account it was posted under was hacked). The malware itself wasn't all that clever given that it tripped a bunch of antivirus (probably some existing RATware if I had to guess), but overall it wasn't immediately obvious.Here's another one that's a little more clever. Not the nicest looking website, and it is posted by a newbie, but it claims to be open source and even has a link the the supposed source on GitHub. There's also someone who's not a newbie who is somewhat defending it. The malware itself isn't an off-the-shelf package-- it appears to have been custom written and doesn't trip antivirus unlike the first example.I'd have to guess that these kinds of examples are already fooling at least some people, otherwise why would their respective authors keep bothering (both of those examples were not the first of their kind...)? RodeoX, baitty, Acidyo, thanks for the kind words.Yes, it comes from years of trial and error ( mostly the latter...Â   ) Some of these are repeats... but they deserve being repeated!Do encrypt (passphrase protect) your wallet. Don't use a simple passphrase. Don't use a passphrase you use elsewhere. Encryption helps, but understand that it doesn't prevent all types of theft.Do backup your wallet. Different wallet software work in different ways: some wallets you only need to backup once, others you need to backup after every new receiving address is created, and others are somewhere in-between. Understand how this works for the wallet software you've chosen, and be vigilant with your backups!Don't start off owning more BTC than you can afford to lose/have stolen. If you find yourself getting close to your personal limit, search for "cold storage" and find out how to use it. Don't put this off until it's too late.Do choose one of the wallet options from the official choose-your-wallet page here: https://bitcoin.org/en/choose-your-wallet. Not all online wallets are bad, however Do heed the warnings on this page regarding some of the less-safe online wallets. Choosing an online wallet does not exempt you from backing up your wallet.Don't download programs from the Internet. This rule is difficult to follow 100%; just be aware that each new program you download and run could be the one that steals your BTC.Regarding that last rule, here are some guidelines that can help you decide how (un)safe a download is. Note that these are not hard-and-fast rules!Do research a program before downloading it. Are there a lot of websites discussing it if you search for it? Does it have a Wikipedia page that wasn't created yesterday? If either answer is No, Do be more suspicious of it.Software that is open source, especially if the answers above were No, is generally more trustworthy, but Don't assume that something is safe simply because it's authors claim it's open source!Software that is written in a popular scripting language such as Python, Ruby, Perl, JavaScript, etc. is generally more trustworthy, but Don't assume that something is safe simply because it's a script unless you can read and fully understand the entire script! Never download and run something claiming to be a script if it's actually an EXE file.Do look at the number of pages in a thread before downloading any software referenced on the first post of the thread. More pages means a smaller chance of the software being malware (but there's always still a chance it could be malware!). Do avoid software with only a few pages worth of posts - let someone else be the guinea pig!Do look at the Activity count and the Date Registered of users when trying to decide if they're trustworthy, and be more suspicious of Newbies, but Don't automatically assume that a Hero Member is 100% trustworthy.Do err on the side of caution/paranoia. It only takes one piece of malware to steal all of your BTC even if you've encrypted your wallet and even if you're using two-factor authentication.If you've decided to risk downloading something, Do take the time to find the single official download link or website.Sorry if I sound scary... most people around here are the honest type, but there absolutely are scammers around here too. Use common sense, and have fun! Btcrecover supports Multibit.Btcrecover (written in Python) doesn't use the Bitcoin RPC API. With Bitcoin Core wallets, on a single core CPU it's around 15% slower. On a machine with more than one CPU core it's faster. There's also experimental GPU support which makes it much faster, if it works at all...For Armory, it's exactly the same speed (because it uses the Armory library) except that it can use multiple CPU cores which again makes it faster.For Multibit (classic) and Electrum, it's quite a bit faster than any of the wallet types above because these two wallets unfortunately don't use any key stretching... The LTC might be a lost cause, assuming you don't remember anything about the password, but why is there a lot of manual work for your BTC? It should just be a single dumpwallet, rename the wallet.dat file, and then a single importwallet, correct? Firstly, you're hopefully aware if your wallet is unlocked, you can export all the keys at once (unencrypted) with dumpwallet (which can then be imported all at once into a new wallet with importwallet)?Regarding your password, sorry to be the bearer of bad news, but it is not stored anywhere in memory and cannot be retrieved. When the wallet is unlocked, the password is used to generate a decryption key which is then used to decrypt your Master Key, and then the password is removed from memory (it is securely overwritten). The decrypted Master Key (which is simply 32 random bytes) alone is stored in memory while the wallet is unlocked, and it is used to decrypt individual private keys on demand. When the wallet becomes locked, the decrypted Master Key is securely overwritten.So to get your LTC back, I imagine your only options would be recovering your password, restoring your LTC wallet from a backup should you have one, or brute-forcing your LTC wallet if the password is short enough and/or you remember some portion of it... Look here for Windows:https://bitcointalk.org/index.php?topic=652909.msg7362979#msg7362979TL;DR: %appdata%\Bitcoin I certainly understand that point of view, but I thought that it was generally understood that as Bitcoin continues to get more popular, there will be a diminishing percentage of full nodes compared to SPV/lite nodes. Of course it's always good to encourage the use of a full node client, but I see no reason to discourage the use of an SPV/lite client... just my 2c. I agree with the other posters here that this should work, assuming you back up anything before overwriting it. I'm concerned that in the screenshot you provided, there was a noticeable change in file sizes between the backup files. As long as you get back all of the addresses/keys you need, this seems the easiest & safest option.The private key backups (at least the ones that MultiBit creates automatically) are encrypted with the same password(s) as the wallet files...If restoring a wallet file doesn't work, you can try to look for password typos with this: btcrecover (full disclosure: I wrote that...), quick start is here.Good luck... Damaging network health...? Can you explain? The Armory folk maintain a bootstrap.dat torrent you can use. Visit here for the current link to their torrent file: https://s3.amazonaws.com/bitcoinarmory-media/announce.txt. As of today, it's only a couple of months behind.Once you have the bootstrap.dat file all downloaded, place it in the Bitcoin directory (%appdata%\Bitcoin on windows) before you start it for the first time, and that will speed things up a bit. You can also ask Bitcoin to use more RAM with the -dbcache=# command-line option (I use a value of 2048 (that's in MB) on my 8 GB machine on only the first start, YMMV). If you have an SSD, the initial indexing and the remaining block downloads can be as short as 3 hours. (Once done, the Bitcoin client renames the file to bootstrap.dat.old, and you can delete it.)The Armory client tries to automate all this, but I've had some issues with it in the past (which were probably my fault...) so I usually do it manually. Electrum does, though I don't know anything about their (Python) plugin interface.Armory is adding plugins support, but's only in the initial planning phases now, so it'll probably be a while. There are some things that sound interesting to me... you get most of the advantages of both running a full node and an SPV or web client (full blockchain validation but lightweight on your client devices).I'm not sure what you mean with regards to blockchain.info though. Keys are stored encrypted both on their server and in localStorage (but not in RAM). If you enable two factor auth, even the encrypted keys are no longer stored in localStorage by default. Not that it's perfect, in particular their default key stretching is pretty minimal.Also I wonder how long a $5/mo. DigitalOcean VPS with it's 512M of RAM would take to do the initial blockchain indexing.... you could always beef it up during the initial indexing I suppose. Justin00 had a good question, but assuming the answer is Yes, I'm thinking it's not worth the effort trying other things if you don't have much in that wallet. It'd be possible to check for single-bit or single-byte errors in the mkey for example, but someone would have to write some custom software to do that which wouldn't be that easy... Sure sounds mysterious to me...You mentioned cloning your drive. Did you need to:Â  Reinstall the OS?Â  Reinstall Bitcoin-Qt?Do you have an older backup of your wallet file?Have you made any other recent changes (other than the HD upgrade) to your PC?Does your passphrase contain any non-ASCII characters (any characters not in this table: http://en.wikipedia.org/wiki/ASCII#ASCII_printable_code_chart)?If the answer is no to all of those questions, I'd probably try dumping your wallet file with pywallet which might provide some clues.You can download it from here: https://github.com/jackjack-jj/pywallet/archive/master.zip If you're on Windows, you'll also need Python 2.7 from here: https://www.python.org/download/ (you don't need any other libraries, despite what the README for pywallet says)Next run it from the command line, something along these lines* (after you unzip the pywallet-master.zip file somewhere):Code:C:\python27\python C:\Downloads\pywallet-master\pywallet.py --dumpwallet --passphrase="the passphrase" > wallet-dumped.txtIf any of the private or public keys in your wallet file are corrupted, Bitcoin-Qt will complain about a bad password, but pywallet only checks the first key it finds. In the dump file, check for a message that says "The wallet is encrypted and the passphrase is correct" or "is incorrect". If correct, you probably have a single corrupted key which could be found and removed. If incorrect, then it could be your master key that's corrupted, or the password actually has changed, which might not be repairable....* If you're paranoid like me, the output file should be something like " > e:\wallet-dumped.txt" where e: is a disposable thumb drive which you can later destroy. One thing about SSDs is that there's usually no good way to securely delete a file from them, and the dump file will contain all your unencrypted keys... if you have a hard disk drive, you could use Microsoft's SDelete (Google for it...). Would such a plugin directory be located in an only-root-writable location by default, e.g. /usr/lib/armory/plugins or \Program Files (x86)\Armory\plugins? If so, I don't see how it could compromise security unless root was already compromised (in which case all bets are off anyways), correct?You could still allow a per-user preference to enable/disable individual plugins, but require root/Admin to initially install them. Every dictionary word? That's not the impression I got from OP's post, s/he said s/he "probably misspelled" their password and that s/he made a "reasonable dictionary" which I took to mean a bunch of likely misspellings.If he really wanted every dictionary word, that sounds more like a wallet thief than a misspelled password to me (just to be clear, that's not the impression I have).Regardless, that thread mentioned above has a lot of good info. I'll go ahead and plug my own recovery tool which can help, although I'm clearly biased... a summary is here if you're interested, as is a link to the tutorial: https://github.com/gurnec/btcrecover No... there are just too many, sorry...Even if we leave out all non-US-ASCII letters, there are about 95 characters to choose from. That comes out to 6.6 quadrillion password permutations. Let's say you bought 4 of these (assuming it's a real product, I frankly have no idea...) for about $25,000 (USD) total, hired a software engineer to write custom software to use them for password searching instead of mining (maybe another 25-50k ??), paid for electricity and cooling (another 15k or so), then it would probably take less than 6 months to try all of them. Or you could use your home PC with mostly off-the-shelf software and be done in perhaps just 200,000 years, take your pick.... Â edited to add: sorry if I came off as snarky... I should have tried actually being helpful instead, like DannyHamilton has graciously done.
