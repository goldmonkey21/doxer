A new paper called "Deanonymisation of clients in Bitcoin P2P network" by Biryukov, Khovratovich and Pustogarov from the University of Luxembourg has been published on arxiv.org.In contrast to the usual offerings, it's actually quite good. The authors explain how to deny the use of TOR to connect to the bitcoin network by sending enough short messages of a particular form to get all the TOR exit nodes banned.They analyze a method of discovering the 8 peers to which an average node maintains a connection thereby discovering the network topology.They outline a DOS attack using ADDR floodingThey outline a method of rapidly lowering the difficulty under certain circumstances by constructing an "Alternate Reality". (A bit less exciting than it sounds!)There are some other substantial chunks of experiment and analysis as well as some pretty graphs.Probably the best constructed paper I've seen on Bitcoin.ByteCoin Now fixed... I know Nicolas Courtois and had I not seen the paper linked from his web page I would have assumed that someone had just added his name to this rubbish in order to give it some gravitas.He should have given his old supervisor a red pen (with plenty of ink left ) and asked him to review the paper first. There are portions which are OK but he's certainly gone a long way down in my estimation.Bytecoin Thank you. The intention was also to provide an incentive for miners to make an effort to clear client's memory pools.I would be wary of allowing fees to change the merit of the block because it's low-risk for a miner to publish a transaction with a large fee immediately before publishing a pre-mined block which has its merit artificially inflated because of the influence of the included transaction's fee. Let's not forget that the purpose of a fee is to pay a fair amount for the time taken to verify the transaction and the space it takes in the block-chain. There are a variety of distorting effects that transactions with large fees have so I suggest that a  transaction's fee for the purpose of calculating transactionfee seconds be capped at a value which is no larger than the transaction with the largest fee that the client saw did not make it into the previous block. In other words, if a client received a transaction paying 0.01BTC in fees and then received a plausible block which did not include that transaction, then when the client receives a 10BTC fee transaction followed swiftly by a block including that transaction then the transactionfeeseconds of the 10BTC fee transaction should be calculated as if that transaction had a 0.01BTC fee. The general idea behind this is to start to remove perverse incentives that arise from transactions with large fees while still allowing fees to buy priority service.I am sensitive to hannesnaude's concerns not to encourage block-bloating but hopefully the existing schemes to calculate transaction priority will cope with that. Am I right in thinking that clients are likely to fail to relay and otherwise drop transactions with very low priority?I must remark that I am very concerned that we do not introduce further incentives for miners to spam the network with transactions carrying fees in order to increase their own profits at the expense of everyone else. One important metric for the health of the network is the number of zero-fee transactions in blocks.ByteCoin I was very pleased to read a recent paper by Eyal and Sirer which put on a rigorous footing something  I had investigated in 2010. I mentioned at the time that there were a number of different strategies which a selfish miner could follow. I found the one that appeared to appeared to become worthwhile at 34% which is the one outlined in section 4.2 of the linked paper. The fact that it pays off at 34% is mentioned in section 4.4 and apparent from Fig.3 Although their paper is substantially correct, I believe the authors neglect the fact that (if I recall correctly) the optimum strategy changes when the percentage of hashpower is between 33% and 50%.The linked forum topic shows how I was unable to convince Gavin that this mining strategy was viable. I hope that the recent paper and publicity will lead him to reconsider.My concern at the time was to show how the mining incentives in place encourage the formation of cartels. This is still a problem and I can imagine the bitcoin network reaching a steady state with two mining pools the large one verifiably "honest" and the smaller one "selfish" whereby the presence of the selfish mining pool is tolerated (and even encouraged) by the larger "honest" pool because it suppresses competing smaller "honest" pools. The selfish pool can pay "protection money" to the honest pool either directly out of the coinbase or more covertly by including in the "selfish blocks" double spent transactions which fund new transactions paying a large fee (the success of this scheme depends on the absence of forfeiture of double-spent coins).As time goes by and fees become large compared to the block reward, miners will of course feel the incentive to build on or orphan blocks based on their share of fees after any block reorganization. It is easy for a miner to appear honest and still participate in cartel activity as it is hard to prove in what order the miner received blocks.My countermeasure for "Selfish" mining relies on the fact that pre-mined transactions from a selfish miner don't contain as many transactions of non-zero age from the memory pool. So conceptually, when a miner receives a transaction it should start a timer which measures the age of that transaction. When a block arrives it stops all the timers,  sums the total age of all transactions in that block and stores this value against the block. As this is a product of transactions and seconds I propose it should be called "transactionseconds" (similar to bitcoindays) . If another block arrives then the number of transactionseconds for the new block is measured as if it had arrived at the same time as the previous block. The block with the highest number of transactionseconds is used to build the next block.If another block arrives and the existing block chain rules indicate that a block should be orphaned then the transactionseconds of the longer block chain should be calculated as if all the blocks had arrived at once and the orphaning should not be successful unless the longer chain also destroys a larger number of transactionseconds.We don't just compare the number of memorypool transactions included in the different blocks as that would give the selfish miner an incentive to stuff their selfish blocks with dummy transactions (which could pay themselves hefty fees to allow themselves to bloat the block).There's no point for non-miners really to have an opinion about which block is better but if they see blocks destroying large numbers of transactionseconds being orphaned by blocks destroying small numbers of transactionseconds then they can be pretty sure that something fishy is going on!ByteCoinPS If I am allowed, I intend to moderate this thread to remove posts which are off topic or do not contribute positively to discussion of cartels, selfish mining, incentives or Eyal and Sirer's paper. This is the first thing written about Bitcoin that's been worth reading in quite a while.ByteCoin Note that this scheme is essentially the one I posted more than a year and a half ago but without the short secure message. Untraceable transactions which can contain a secure message are inevitable.ByteCoin Now that this is well known, I have to point out the following:If some subset of clients rebroadcast transactions while flipping the sign of s then the transactions have different ids (because currently the signatures are included when hashing to find the transaction ID) and there may be some problems if the flipped version makes it into the block instead of the vanilla version as I believe the originator wouldn't recognise the flipped transaction has spent his coins.ByteCoin I've been out of the loop for a while.. Does lockTime work correctly nowadays? If not, when is it scheduled to be implemented?Well, the worst case scenario (under plausible assumptions) for the exchange signing something arbitrary with some key is to lose control of (or unwittingly commit to) everything associated with that key, so it's important that the key has not been used for anything else.Now of course if my proposal about transaction id hashes not including signatures were adopted, then the funding transaction could be sent in its unsigned form to the exchange and the exchange could verify that the refund spent the funding transaction because of course the transaction id wouldn't change on signing.ByteCoin Why would the other node have to trust you completely to initialize itself under my scheme?Can you come up with a remotely plausible scheme in which anyone would regret us excluding the signature from the hash that generates the transaction id?ByteCoin All known serious algorithms for computing what have become known as "discrete logarithms" on elliptic curve over fields of prime order have a very extensive precomputation step, which, when completed allows arbitrary solutions to be computed quickly.Please provide a citation for this "fact". There is an attempt underway to calculate discrete logs on a 130-bit elliptic curve over a prime order field. Without some massive algorithmic improvements we're not going to have any chance of attacking 256-bit curves in eight years. I seem to recall that there is some speculation that humankind will never be able to count up to 2^128 let alone perform an attack with such a work factor.ByteCoin Whoever holds the private key for P1 can easily calculate the private key for P2. I haven't been following your scheme but I presume that's the issuer. If I catch on correctly then the issuer could misrepresent some information about the bond, saying that the issuer public key was actually P2.The "modular operations" use the prime p but for the above calculation you should use the group order n which is a somewhat smaller prime.Code:p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2Fn = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 Yes that's what I meant. The block chain is still entirely self-validating if the transaction hash doesn't include the signature as long as you bother to store the signature. At the moment though you HAVE to store the signatures. Can anyone propose a remotely plausible scenario in which we would regret not hashing the signatures?ByteCoin I'm posting in part because I felt my ears burning on #bitcoin-dev.Does everything that is broadcast have to be incorporated into the block chain? I suggested a long time ago that the signatures not be part of the hash so that the signature data could be pruned out.There are two issues associated with including OP_DROP data. One is the amount of data stored in the block chain for eternity and the other is the amount of data that has to propagate through the network right now. These issues are not the same and don't suffer the same constraints. I believe the current system smooshes them together to make things 'simpler'. I don't think this is a good idea.ByteCoin  Nice to see my suggestion being implemented finally.ByteCoin Nice work! Implementing this sort of technology is the way forward.ByteCoin Ok. Deal with this scenario:1) Innocent user funds casino account with tiny number of bitcoins and provides convincing ID.2) Innocent user's laptop is stolen or otherwise hacked by Hacker - the point being that Hacker gains access to innocent user's private key and Innocent user loses access to the private key.3) Hacker steals lots of bitcoins and sends them to Innocent user's casino funding address.4) Hacker withdraws the coins from Innocent user's casino account.5) Police find out that the stolen coins went to the casino.6) Police ask the casino to tell them who the account belongs to.7) Police have good reason to accuse Innocent user of theft. Innocent user can't prove he doesn't control the stolen coins and a jury has good reason to believe he can.ByteCoin https://blockexplorer.com/address/1QLbz7JHiBTspS962RLKV8GndWFwi5j6QrByteCoin Since the adoption of Firstbits has demonstrably contributed to useless block-chain bloat and the implementers have "reserved" many of the short addresses before "going public" I suggest that it should not be supported.ByteCoin I think this is the wrong approach and will give you problems down the line even if you're dogmatic about sticking to your recommended "solution".You're essentially asking the unwilling recipient of the funds to participate in laundering them. Imagine this scenario:1 ) We have a casino using the kjj/Gavinandresen scheme.2 ) Hacker says he wishes to deposit bitcoins and supplies them with a return address A.3 ) Casino generates funding address B and gives it to hacker.4 ) Hacker steals large amount of bitcoins and sends them to B.5 ) Casino gets a bit suspicious and to avoid liability as per kjj/Gavin's scheme sends them to agreed return address "A"6 ) Police investigate theft and want to get their hands on the money (to return it). They catch the hacker but don't get the private key for A. Perhaps the hacker was supplied with A by the person paying him. Anyway, they find out somehow that the bitcoins were sent to the casino.7 ) Police go to the casino and ask for the stolen bitcoins.8 ) Casino says "Yes we did have them but we sent them to A".9 ) Police accuse the casino of helping the hacker launder the coins.You would also have to address the situation in which step 5 is "Before theft is discovered, Hacker rings up casino and asks for deposited funds to be returned due to 'urgent unforseen expenses'" - a perfectly legitimate sounding reason many legitimate clients would use when asking for funds back from their casino account.If, instead of sending them to A, the casino hangs on to the funds until the police investigate then the casino can send the bitcoins to the police but then the public might accuse the hacker and the police of working together to steal the coins. Ok the police might eventually generate a transaction which can be seen to return the coins to the rightful owner but that may be years down the line after the case has gone through the courts. Until then, the casino is under suspicion. Also, while the casino has the coins (which might be a lot more than their company is worth) they'd better be sure their internal security is good enough to stop an employee getting their private keys!The only way the casino can instantly avoid liability or suspicion from an unwanted payment is by returning the coins whence they came. Everyone can see that the situation has been returned to the status quo ante.If you wish to firefight these cases, I have plenty more awkward situations to discuss. This should be a good thread.ByteCoin There are perfectly good reasons for returning unwanted payments. With Bitcoin's lack of fungibility, the only convincing way to untaint your coins is to publish a transaction which the putative owner could use to return the coins whence they came.In the event that all transactions must have fees to be included in the block chain, there should be a way for the casino to publish some signed message to reverse the unwanted payment without paying a fee.The signed message should be publicly available from the casino as soon as possible to show that the casino rejects the payment.The putative owner would then use this signed message to create a transaction to retrieve the coins and would have to pay the fee to get the transaction in the block. They would also be responsible for contacting a bitcoin node to tender the transaction for inclusion in the block chain.Is it possible for the casino to sign some message to which someone could attach a fee payment which couldn't be stripped off and redirected to another transaction? Is it possible to attach a fee payment to someone else's transaction using the existing Bitcoin System.There are two interesting cases:1) Someone has published a transaction without a fee or with an insufficient fee. They're uncontactable or have lost the private keys so they can't issue a new transaction with a higher fee. Is it possible to take their transaction and "wrap" it with a fee payment so that it gets in a block?2) The case in the quoted article, the casino wants to publish some sort of signed pseudotransaction which can be seen to facilitate returning some bitcoins. Someone else then takes this pseudotransaction and creates a valid fee paying transaction returning the bitcoins where a relay node can't take off the fee payment and use it to pay the fees on some other transaction.The first case is likely to be more difficult as the cooperation of the sender in constructing some special signed message is not possible.Can this be done? ByteCoin
Due to the absence of effective fungibility for bitcoins, all bitcoins are traceable back to their coinbase transactions. A taint-tracing service could allow a community of bitcoin users to agree to consider coins created in "empty" blocks to be less valuable than those created in normal blocks.This would allow for retrospective punishment of the antisocial miner and those unlucky or unwise enough to accept their coins at face value.ByteCoin So how does that work then? If they let an invalid transaction into the block then that block will be rejected by the network and they have wasted their hashing effort.ByteCoin And of course wills are pointless for similar reasons. You should just tell people what you want done with your stuff now you're dead.ByteCoin This is the exact reason I came up with OP_EVAL rather than something functioning along the P2SH lines. With a script containing two nested OP_EVALs I can implement multisignature transactions of the type (BLAH... AND BLAH... OR BLAH...) OR BACKUP_KEY so that the transaction can always be identified provided you have the public backup key and always redeemed provided you have the private backup key.ByteCoin I suggested this near the end of 2010 and got into an argument with theymos. Yes it's possible. As far as I can recall, you need to use the additive homomorphic property of the Pallier scheme. It has been discussed on the forum before but I can't find the reference.ByteCoin With the current architecture, it's difficult to accept "instant" payments securely. It's unlikely that a merchant will individually have the infrastructure to check the propagation of a transaction so they can't even manage the risk of a double spend attack succeeding.Someone with good (contractual?) relationships with the major mining pools could offer insurance at a rate probably around a small fraction of a percent of the transaction value. It's much easier for merchants and customers to account for a small constant insurance cost than large double-spend losses.ByteCoin    It would really be an insurance that if the chain confirmed a block containing a transaction spending the same inputs in a different way then the miner would pay the outputs himself instead.With a sufficiently descriptive scripting language, issuance and enforcement of the insurance could be "automatic".ByteCoin My assessment is that the current state of disagreement is a rather freakish conspiracy of circumstances and would have been impossible to predict and/or avoid. Please outline how it was botched. Here's a little history as I see it:In the beginning there was casascius' proposal which virtually nobody bothered to understand. This rapidly transformed into a proposal to "reinterpret" OP_CHECKSIG with some code to recognize legacy cases to ensure back compatibility. This was rejected because the special case interpretation was seen as a hack and destroyed the "purity" of the scripting language - rather ironic in light of the current hacky solutions. Gavin then gathered fairly broad support around my OP_EVAL proposal and everything was going smoothly for a few months until roconnor finds some bugs and some low-to-zero-practical-impact disadvantages. Gavin lobotomizes the scheme in an ugly fashion to allay these concerns, probably assuming that the adoption of the more cautious scheme will be uncontroversial. With reasonable justification but with little regard for propriety or the long-term consequences, Luke-Jr objects to Gavin's scheme's violation of the script and uses his considerable technical and social capital to engineer the scheme's failure. This brings us up-to-date.To apportion the blame fairly, it should be mentioned that roconnor was threatening to spread FUD about the "dangers" of OP_EVAL if his demands were not met, regardless of the incidental damage to Bitcoin.ByteCoin The differences seem small and I'm confident that technical issues are not what is causing the controversy.Of course, I would have liked OP_EVAL to succeed as I thought it led Bitcoin in a direction I thought would be healthy in the long run.The current arguments bode ill for getting a vague consensus for more profound changes probably required in future. Imagine Satoshi trying to deploy IsStandard() if he had to deal with the current situation. Part of the problem is that the pool operators are vital to the success of upgrades and they only really care about mining and the exchange rate! ByteCoin It wasn't me. Please edit your post to credit the correct person. Thanks!ByteCoin The problem you outline very lucidly really only harms miners. Non-miners who receive an incorrectly pruned blockchain are at worst prone to relaying or generating double spend transactions and/or blocks. If the majority of miners maintain correctly pruned blockchains then double spend transactions or blocks never become confirmed.A miner who accepts an incorrectly pruned blockchain will be prone to produce blocks containing double-spend transactions and these blocks will not be built on and therefore the miner's expected block reward will not be spendable. This is a waste of the miner's hash power.Note that with the current system, it seems likely that at least a few parties will have to remember ALL the transactions forever. If we ever lost confidence in the correctness of the pruned blockchains then knowledge of certain pruned transactions could become very valuable as releasing the information could invalidate vast numbers of transactions and blocks. This problem is entirely avoided in my proposed system called "balance sheets".ByteCoin At this stage in the proceedings, with the resources out there to educate yourself, if you don't understand what's being discussed, your opinion is not relevant.ByteCoin Let's not hold Satoshi's inferred design decisions sacrosanct. There's lots he did well but also lots that's bad.I sympathise with Luke's misgivings about P2SH. As a solution it seems to fall between the two stools of having a clean scripting language and dispensing with the script language altogether.Gavin said something like "It's a hack but I like it." - a sentiment typically followed by years of regret.I suggest that we redefine OP_NOP1 as OP_DO_EVERYTHING and the scriptPubKey should be [20-byte-hash-value] OP_DO_EVERYTHING. This saves an byte which should please Gavin and is clearly not pretending to be anything it's not.I also propose we take the opportunity to remove miner support for all disabled opcodes and OP_CODESEPARATOR pending the reuse of their values.ByteCoin Glad you've stomped on this! We don't want more incentive to spam.ByteCoin Yes it was a stupid idea. I was trying to create a secure hash of the private key, the value of which you couldn't infer from the public key using little more than the code/hardware used to multiply the group generator point.Something like taking the private key adding it to the public key x-coordinate and then multiplying the group generator by that value should do the trick.I don't see why a minimalist piece of secure hardware needs to deal with address strings. All it needs to do is key generation and ECDSA signatures.I believe that this is just a feature of "brainwallets" (yuck) which has to be managed. What's the point of having a passphrase you CAN remember if you also need an impossible-to-remember "chain code" in order to be able to use your "brainwallet"? Implemented this way, you're falling between two stools.ByteCoin This would be the case for a network split where one of the parts has roughly half the hashpower. An even split cannot be expected or relied upon. Block chain reorganizations as a result of network reconnections are likely to be complex events and I think that simple rules for coping with them yield the least unpleasant surprises.A better metric for inferring an attack would be to estimate the implied aggregate hashpower. If a longer blockchain arrives that invalidates the last 10 blocks and the generation rate has been normal then one could reasonably infer that the aggregate hashpower has doubled and that there is cause for concern.A reorganization which contains double spends would certainly be suspicious.I would not recommend inferring anything from timestamps, the originating miner's identity or transaction amounts/numbers/sizes. Such rules would contain arbitrary hard-to-justify "magic numbers", be difficult to test, have complex failure modes and a large security perimiter.   What should be done if a new chain arrives which invalidates an AAA rated block at depth 4 but now the new chain has incoming AAA ratings. The added complexity of sorting out conflicting ratings will have lots of nasty edge cases and be hard to test. ByteCoin As long as the blocks contain adequate proof of work, they are all eligible to be accepted. It's not a beauty contest where the one with the highest proof of work wins. The reasoning works if we replace "block" with "blockchain" on the basis that longer blockchains are preferred.Suppose the bitcoin network divides into two roughly equal portions in terms of hashing power and trusted parties but without any attack. Life goes on for a while at roughly half the block rate and with half the trusted signatures missing. When the network reconnects what happens to the losing chain and the trusted parties' signatures of the losing chain's block hashes?ByteCoin The proposed etotheipi solution makes it quite feasible securely to operate a bitcoin node even if an attacker can see everything the node does, using only vanilla multisignature transactions.Running a determinisitic wallet means that all the different public keys can be regenerated from relatively little secret information. It's easier to store and secure small amounts of static secret information. Also, if the devices are wiped, the information which enables redemption of payments can be regenerated completely.The proposal does not involve frequent secure transfers of secret information between devices in order to operate correctly. This is desirable as such transfers are vulnerable to corruption or eavesdropping. The workflow suggested by etotheipi has the computer generating new wallets A and B. I imagine that the phone could do this if the user was of the opinion that the phone is more secure. The private key is short enough to write down with some suitable error detection scheme. For instance, the phone could tell you what to write down and then make you re-enter what it told you to write before continuing.In etotheipi's solution, the phone finally signs and broadcasts the transaction. I imagine it might be easier if the phone provides its signature for the transaction which the user then enters into their possibly compromised client to countersign and broadcast.It's clear that the standard client does not support this scheme at the moment. I propose that as a medium-term goal  we add support for this scheme (and similar schemes) to the client. This means support for:1) a deterministic wallet - importing root public keys.2) exporting unsigned, partially signed or signed transactions.3) importing signatures for partially signed or unsigned transactionsByteCoin I came up with a scheme which looks like it's functionally equivalent in the thread called Protecting privacy without generating and distributing new addresses. It wasn't popular then but I still think it's a good scheme. I imagine it's possible to come up with variants to allow untrusted third parties to recognize your transactions and send them to you if you don't want to scan all transactions.ByteCoin
The two advantages of the "2-of-3" solution over my "or C" solution are:1) It's simpler.2) It's soon to become standard.However, I'm concerned about how well the "2-of-3" solution will integrate into the existing workflow.The current client seems to use new addresses (public keys) at every possible opportunity. In the "2-of-3" solution this means that there's potentially quite a lot of data transferred from the "offline device" to the online wallet. Similarly, unless a deterministic wallet is used on the offline device, the secure storage requirements for the offline device are significant. If a deterministic wallet is used then the computation and software complexity/trustworthyness requirements are significant.With the "or C" solution, the offline device can be a small piece of paper which has no computational requirements, has perfect computation integrity and is a storage medium of long standing with well understood properties.There's also the question of key management for the WPS. Would they issue one key for all their customers, one key per customer or one key per transaction? Every different WPS key either needs to be securely stored separately or else sent to the offline device to be logged. If stored separately there's another secure storage problem and there may be a problem matching up the WPS key with the user's keys if the WPS disappears. If sent to the offline device then that's another infection vector, storage and key matching problem.I agree that the problems can be somewhat mitigated through the use of deterministic wallets but unless deterministic wallet operation is standardized before "2-of-3" solutions go online then it's going to be chaos when people try setting up and using WPSs with various behaviours. It will be difficult to ensure that the standard client can interoperate with different WPSs if they distribute keys or implement deterministic wallets in different ways.You might imagine that similar concerns operate with the "or C" solution. The situation is considerably better as the standard client can always ensure that the transactions are recoverable irrespective of the operation of the WPS. This means that the issue of recovering transactions is orthogonal to the WPS implementation whereas in the "2-of-3" solution, they are intimately bound together.ByteCoin It can't be done in the current Bitcoin system as the scripting language is insufficiently powerful and cannot introspect (i.e the script can't read the block chain). A Bitcoin-like system with these features could be used to faciliate secure poker games and other contracts. As a "decentralized betting framework", it would be vulnerable to legal attempts to disable it. As a "more powerful Bitcoin" it would have "substantial non-infringing purposes".ByteCoin  As mentioned in BIP0011, implementing multisignature transactions is expected to facilitate the development of "wallet protection services" which are meant to ensure that someone can't steal your bitcoins even if they hack your computer.To do this, you would request that people paying you send the bitcoins to an address which requires two signatures to spend. One signature is supplied by your bitcoin client and the other by the wallet protection service after appropriate checks have been completed.Unfortunately, if the wallet protection service goes out of business or equivalently, if you lose your wallet.dat then you effectively lose the associated coins. Losing your wallet.dat is a risk we have with the current system and the fact that bitcoin is used nevertheless means that it is deemed to be tolerable. It's doubtful that users will tolerate being vulnerable to the wallet protection service losing their wallet and to mitigate this risk, it is suggested that the WPS will send the user a copy of their private keys in some secure fashion to be used to recover the coins in the event that the WPS disappears.There are several problems with this:It's inconvenient and a security vulnerability to have to manipulate and mail out the secret keys.The recipients of the secret keys should ideally have a way to verify the keys are correct without revealing them to their possibly hacked computer.The wallet protection service has to maintain different keys for each of their clients.Once clients have the wallet protection service's secret keys, they can do anything the WPS can. This means that it's difficult for a WPS to maintain a good reputation against the efforts of a malicious client. Similarly, a malicious WPS can say that fraud it has facilitated is the action of a malicious client trying to ruin its reputation. Let's look at that last point more closely.There will likely be multiple wallet protection services and each one could sign up as a client with the rival WPSes. It's in each WPS's interest to use the mailed private keys to "steal coins" from themselves and claim that the rival WPS is not doing its job correctly.Alternatively, hackers who have stolen a user's wallet.dat can offer to split the bitcoins with the WPS if the WPS supplies the keys and the WPS can claim that the user must have divulged the mailed private keys or be attempting to defame the WPS.So we can see that mailing out private keys is likely to result in acrimony and fraud. Not mailing out private keys is likely to result in lost bitcoins.The solution to this is the use of an (A and B) or C transaction which is an instance of a "recovery key" transaction. It is important that the bitcoins should be spendable even if all information about keys A and/or B are lost. This post outlines how to achieve this in a practical fashion. ByteCoin There's a reason why the things you're printing out and calling X and Y are really called r and s. That's because r and s have nothing to do with elliptic curve coordinates. Read the wikipedia article for ECDSA for the details. Generating an address from a public key does not require ECDSA_do_sign or do_verify so you can get rid of that code. The coordinates are likely to be stored in the public key structure in some fashion.ByteCoin No and yes respectively.A number of mechanisms have been proposed to implement this, notably OP_BLOCKNUMBER however all parties accept that implementing it would break a number of important invariants. I think it's safe to say that no such functionality will be implemented for the foreseeable future.To address the thrust of your post - I'm confident that such a trust scheme will never be implemented in Bitcoin as it is more complex and prone to manipulation than the current system. I also believe that no Bitcoin-like scheme which "builds" trust in this fashion will ever succeed for roughly the same reasons.ByteCoin The recently explained security flaw resulting from adding public key points to derive a common public key is the one I had in mind in my original post.A number of forum members seemed to have convinced themselves of the security of the scheme and I hope that this episode encourages people to be less confident and more cautious about "novel" cryptographic constructions.I believe it's possible to recover the security of the scheme without resorting to a two-round system in which the hashes are published and then the public keys revealed. This is achieved as follows:1) The participants publish the hashes (or equivalently addresses) of public keys for which signatures have been seen in the block chain.2) The software scans the signatures in the block chain for the relevant public keys and the combined public key is formed by addition.This scheme is secure against the attack outlined (in a somewhat garbled fashion) in this post because Ekim is unable to create signatures with the key he broadcasts (P in the post's terminology). ByteCoin You have a habit of identifying these interesting and useful corner cases Theymos!One can then store 256bits in the "random" k value of this signature for every transaction spending those 0 coins back to itself! Anyone can read this information with a suitable patch to the client or some freestanding software.ByteCoin Oh really? So if I use SHA256 as one of the hashes and the other hash is just reversing the bits then the XOR of the two is stronger than SHA256?ByteCoin so in decimal x=55066263022277343669578718895168534326250603453777594175500187360389116729240y=32670510020758816978083085130507043184471273380659243275938904335757337482424p=115792089237316195423570985008687907853269984665640564039457584007908834671663y^2 = x^3 + 7 - p * 1442042049659660869506300006036683750029629333882594701370927246876626245108435 922902327776681700708714008192087431130951749952236093997894375239788520937The equation of the curve is y^2=x^3+7 mod pByteCoin If I recall correctly, the impediment to implementing (a AND b) OR c transactions is that it should be spendable if you have c, even if you have lost all knowledge of a and/or b. So the knowledge of c has to make the knowledge of a and b redundant. In standard OP_EVAL solutions, all the information identifying a,b and c have to be contained in the transaction. If a or b are changed or forgotten then recreating the hash of the script is impossible and hence the transaction will fail.So when redeeming an (a and b) transaction, the scriptPubKey is the standard DUP HASH160 <scriptHash> EQUALVERIFY EVAL. The client start off the scriptSig with 0 <sig a> <sig b> and then complete it with a stored serialized script "[2 <pub a> <pub b> 2 OP_CHECKMULTISIG]" which hashes to scriptHash.To get the (a and b) or c functionality, we keep the same scriptPubKey and when redeeming using both a and b keys, the client fills it in the normal way with 0 <sig a> <sig b>. However the stored script is "[2 <pub a> <pub b> 2 CHECKMULTISIG]<sig c>[<id> DROP <pub c> CHECKSIGVERIFY EVAL]" so in this case it's two chunks of serialized script on both sides of a signature. The scriptHash in this case is the hash of "[<id> DROP <pub c> CHECKSIGVERIFY EVAL]" and <sig c> is calculated so that CHECKSIGVERIFY will succeed when called on "0 <sig a> <sig b> [2 <pub a> <pub b> 2 OP_CHECKMULTISIG] <sig c> <pub c>"So the total script executed in normal circumstances is 0 <sig a> <sig b> [2 <pub a> <pub b> 2 CHECKMULTISIG]<sig c>[<id> DROP <pub c> CHECKSIGVERIFY EVAL] DUP HASH160 <scriptHash> EQUALVERIFY EVALIf all trace of keys a and b have been forgotten then the transaction is redeemed in a different way by using the knowledge of the private key for key c to generate a new signature <sig c'> such that CHECKSIGVERIFY succeeds when called on "[TRUE]<sig c'> <pub c>"So the total script executed in the event that keys a and b are lost is [TRUE]<sig c'> [<id> DROP <pub c> CHECKSIGVERIFY EVAL] DUP HASH160 <scriptHash> EQUALVERIFY EVALIt's unfortunate that the private key for c needs to be kept around to create the sandwiched signature <sig c> which is different for different pubkeys a or b but I doubt there is a way round that without considerably increasing the complexity of the transaction (or scripting language). Fortunately, if a range of pubkeys <pub a> and <pub b> are known in advance, the signatures <sig c> for each pair can be generated at the time and stored in the wallet. The private key for c can then be erased from the computer and kept in a safe.The DROPed parameter <id> is intended to be an easily bruteforced number which serves to make <scriptHash> different for different <pub a> or <pub b> otherwise a transaction requiring <a and b> or c would have the same address as <p and q> or c. If the wallet is lost then the stored scripts which tie the <id> to the <pub a> <pub b> pairs are lost. To redeem the transactions using the secret key for <pub c> in the safe, the value of <id> must be searched until the hash of "[<id> DROP <pub c> CHEKCSIGVERIFY EVAL]"  matches the address of the transaction to be redeemed.So, indeed, recursive EVALs have their uses.ByteCoin  At the moment, if you want to send without fees and risk getting "stuck", you can compile your own client. Since you're running non-standard software then it's clearly your fault if your transactions get stuck.If the official client can be used to send with an inadequate fee resulting in "stuck" transactions then the official client becomes "fragile software".I imagine the support overhead and bad PR associated with stuck transactions is likely to be worse than the irritation with the miniscule fees. A possible compromise might be to enable the option but to display a warning and leave the feature undocumented. I still don't see what the incentive for change is for the developers who are happy with the fees and want to keep the code simpler and smaller.ByteCoin Quite so. If the transactions were sorted in the merkle tree according to value, then a client (or miner) not interested in fiddling small change could stub off whole chunks of the tree. I agree that "There Doesn't Have To Be One Way To Do It" but one has to be careful - going too far down that route can result in TxOuts being shunned. If a majority of miners don't relay and don't accept transactions using the tiny TxOuts then such transactions take a long time to confirm - if at all.I'm in two minds as to whether this scenario is natural optimisation at work or a bad thing.On the other hand, similar pressures exist under the current system if block chain pruning were implemented. There would be a temptation to prune small unspent transactions to free up disk space.ByteCoin  How about enabling it exclusively on testnet for the moment? It is possible that badly written merged mining systems might spam BitCoin with blocks of low difficulty while happily mining on their own chains. Having the DOS prevention code enabled would mitigate this risk.ByteCoin Splendid! Would you be so kind as to rerun the calculations while discarding TxOuts with small BTC values, please? Let's say anything below 0.001 can be discarded.If you're feeling keen could you please plot a cumulative distribution of TxOut value? Possibly on a log value scale?I have a strong feeling that the vast majority of the ledger will be taken up with very small TxOuts, many of them vanity addresses.The fact that a ledger system seems to result in reclaiming 90% of the disc space is encouraging. Now that many bitcoins have been exchanged, the space saving results of a ledger system are more obvious than when I first proposed it over a year agoThe fees system could be reworked to provide incentives for keeping the ledger small rather than the blockchain. Some transactions would result in ledger size decreasing and could perhaps be encouraged by refunding some previously paid fee.As Gavin implies, all nodes would have to verify ledger integrity in the same way that block integrity is verified. If this were implemented, a couple of extra optimizations should accompany: the transaction signature shouldn't contribute to the hash and the signature should not be recorded in the block or ledger. This would result in further considerable space savings and pave the way for enabling transaction replacement and other advanced contract features.Note that if the ledger is implemented as a hash tree and incoming transactions are incorporated into the tree according to a suitable algorithm then when a new block is found, each client can recalculate the ledger independently and hence the whole ledger need only be downloaded once. ByteCoin This suffers from a security flaw that my scheme does not have. Whether it's exploitable depends on the details of the implementation.Can anyone else see a problem with the above?ByteCoinPS I think you're a bit hasty with the "unrealized" Yes that works fine except instead of point addition, use point multiplication. S1 and S2 are random numbers about the same size of the group order. Send the second party the coordinates of S1*G where G is the agreed "generator" point. The final public key is S2*(S1*G) and the private key is (S1 * S2) modulo the curve order.ByteCoin I don't believe that there's any additional security to be gained by encrypting the private keys. So long as one party does not release their private key then the resulting vanity address is equally secure. If the revealed private keys are published in plaintext then all parties can verify that the private keys match the public keys. It's probably more important that the revealed private keys are signed with the public key to stop a MITM DOS attack.The hard part will be ensuring that payment is sent for vanity keys and preventing DOS attacks.bwagner: From what you write, it appears that you understand the scheme correctly.ByteCoin In an obvious extension of the method you quoted and also the slightly more general but essentially identical method I posted, no exchanges are required (apart from a keep-alive signal if desired) until a successful match has been found. Once all but the new vanity address owner's private keys have been revealed, new public keys must be distributed to securely search for new vanity addresses.Pooled vanity address generation seems completely feasible.ByteCoin So the goal is to be able to buy a vanity address by crafting a transaction. It's easy enough to reward someone for finding a certain vanity address as explained by runeks but the act of claiming the reward should enable the person offering the reward to generate the private key associated with the vanity address.To do this, the rewarding transaction must be spendable by providing a number which, when used to multiply the generator, yields a point which when added to a specified public key point yields a new public key point which hashes to a value that gives the required vanity address. Firstly, it seems hard to have a point multiplication routine in a script without looping constructs. I can see how it's possible to do in space roughly log2 of the vanity difficulty. Secondly, implementing EC arithmetic in scripts would also be verbose. Thirdly, you'd have to that appropriate precautions to stop relayers from stripping your solution out of your transaction and claiming it for themselves.  Finally, there is a way of generating time-limited transactions without nLockTime or a third party but it requires a couple of rounds of interaction and is extremely wasteful of computer time when used over long durations.Yes that works better.ByteCoin As soon as someone stops participating, the common public key is recalculated without theirs. To detect this each participant needs to send everyone else some sort of keep-alive signal signed with their private key every minute or so. This is an obvious solution.ByteCoin
Solution: 1) Each party publishes their pattern list.2) Each party generates a keypair and publishes the public key.3) Everyone adds all the public key points together to get a common public key.4) Everone searches from that point in some suitable fashion to avoid duplicating work until one of the patterns is matched.5) The matching offset and all the other private keys are sent to the lucky "owner" of that pattern.6) Cross off that pattern and go to 2.A suitable searching strategy for n people would be as follows: Agree on a numbering x of participants from 0 to n-1 inclusive. Agree on a batch size m.Each participant calculates m affine curve points (x+i*n)G where i runs from 0 to m-1 inclusive.Each participant adds the common public key to each of the above m points, does a bulk inverse, hashes and checks for pattern matches. If no match is found then the common public key is incremented by mnG and then the last step is repeated.ByteCoin For the most efficient method that doesn't waste any coins, read about  the subliminal channel in (EC)DSA. Also my posts on the subject 1+ years ago.ByteCoin That's pretty well the definition of "spent" for the purposes of this discussion. Actually, it's more technical than that as you could have a transaction that spends coins from an address and sends them to the same address and it would (probably) still destroy some number of bitcoindays. What you're actually spending is one or more of what is commonly called a "TxOut" which is worth some number of bitcoins. An address can have zero or more spendable TxOuts. In order to spend a TxOut you need to supply an appropriate signature generated using the private key associated with that address. ByteCoin I thought I'd transplant Gavin's post to here, rather than derail the original thread.Using your link for BIP 0012, I didn't see any reference to a timeline. Found it. It could be more prominent.What's the timeline for enabling relaying of OP_EVAL transactions and for a client that can generate OP_EVAL transactions?Also, when will clients be patched to start rejecting blocks with the OP_NOP1 interpretation of OP_EVAL?I presume that, if all goes well, then on the 1st of Feb 2012, blocks containing OP_EVAL will suddenly be interpreted in the new stricter fashion than when it was OP_NOP1. We know that GetTime() seems to return widely disparate results over the bitcoin network. Are we confident that problems are not going to arise because of the pseudorandomly timed nature of the change of interpretation of the opcode?This is why I suggested a magic transaction in a block to precipitate the changeover.Majority hashpower support for OP_EVAL is required before changeover. It's conceivable that something might go wrong after OP_EVAL transactions are mainstream which might make miners revert to interpreting OP_EVAL as OP_NOP1. If OP_EVAL loses majority hashpower support then the bitcoin system keeps going but with considerable damage to reputation, prospects and some people's wallets.Has there been any consideration of this possibility?I suggest that OP_EVAL transactions be limited to "toy" amounts of bitcoins until enough of the installed base of clients would reject the OP_NOP1 interpretation of OP_EVAL. ByteCoin  I believe that "crashing when you try to HASH160 an OP_0 byte" is what your scripting code did wrong.ByteCoin Correct!The current block reward scheme and fees schedule incentivizes miners to implement schemes which arguably harm the network. Similarly, some helpful activities like transaction relaying without mining go unrewarded.  There have been forum posts on this topic before but I'm not surprised that they're difficult to find. I touch on a similar issue in the Most transaction relaying is currently pointless and wastefull thread.Indeed. Also, if the fee is large compared to the block reward then it makes sense for miners to ignore blocks from other miners which include the transaction and try to build a block chain in which they claim the large fee themselves.If the miners see a double-spent transaction in which the later version includes a very large fee then it would be in their interest to throw away the blocks containing and confirming the first version and build a new chain including the double spend and gaining the fee. Miners who had their blocks orphaned could be reimbursed from the large fees of the double spend.I'm particularly concerned that there's an incentive for the formation of a mining cartel in which the miners insure that non-cartel miners' blocks become orphaned. The mining cartel could engage in behaviour detrimental to the other users such as refusing to incorporate transactions lacking fees (or lacking inflated fees) into the blocks.This is just a quick recapitulation of some previous discussions on this topic.ByteCoin Interestingly, in order to use LockTime, you have to give at least one of your TxIns a non-standard sequence number. If I recall correctly, there is at least one transaction in the block chain with an unusual sequence number.  nLockTime affects the flow of execution is in the transaction IsFinal function, which contains the following code (tweaked by me):Code:bool IsFinal(int nBlockHeight=0, int64 nBlockTime=0) const    {        // Time based nLockTime implemented in 0.1.6        if (nLockTime == 0)            return true;...        if ((int64)nLockTime < (nLockTime < 500000000 ? (int64)nBlockHeight : nBlockTime))            return true;        BOOST_FOREACH(const CTxIn& txin, vin)            if (txin.nSequence != UINT_MAX)                return false;        return true;    }It seems that even if nLockTime is larger than some value, the transaction will still be final if all the txins have the normal sequence number. The sequence number seems to have no other effect on execution at the moment as replacement is disabled and so can be set to any other value to produce a "LockTime" transaction.ByteCoin I think this is an important point. Currently the analysis that we do is rather ad-hoc and reliant on us thinking of various exploits and how to prevent them. What we should do, as Mike implies is to look at what security guarantees the existing system provides and then systematically check that any proposed changes do not unexpectedly compromise those guarantees.From the information given, and from the implementation of OP_EVAL that I imagine, I'm having trouble thinking of the assurances that are invalidated by OP_EVAL. Could you please provide more details Mike?ByteCoin This assumption is not safe. If a person is typing in a string they are reading from a piece of paper, when they read a "L" they have it in their heads as a letter "ell" and may type it as "l"."O" and "0" could be interepreted as the valid "Q" though....ByteCoin Ok. When you see "l", how do you choose whether to change it to "L" or "1" and why?ByteCoin This is impossible in general as the checksum does not guarantee the invalidity of an address that differs by the smallest amount from a valid address. For instancehttps://blockexplorer.com/address/1ByteCoinAddressesMatch1kpCWNXmHKWhttps://blockexplorer.com/address/1ByteCoinAddressesMatch1kpCxNXmHKWare both valid addresses even though they differ by only one character.Similar collisions can be found for omitting one character.If a new address type is introduced, I suggest the adoption of a shorter error detecting code which provides some guarantees.If the correction function only results in the replacement of an invalid character with the corresponding valid character then the problem is not relevant. However, if the address contains a lowercase "L" then there's some uncertainty whether it should be converted into "1" or "L" and potentially both might result in valid addresses. I suppose the validity of both interpretations could be checked but this would complicate matters and finding a full set of test cases for the code would not be trivial.ByteCoin If such comprehensive changes are being considered then I suggest that the default option should be that the signatures for a transaction should not influence the transaction hash. This would allow transactions spending unsigned transactions to be signed, which is a crucial step in some contracts. Also, the signature data could be pruned from the block chain for transactions occurring at sufficient depth or before a checkpoint. This would effect considerable space savings as the signature data is probably the only data that doesn't compress.Another improvement would be the introduction of the Bernstein signature scheme with a similar security parameter to the existing ECDSA but a much faster verification. Transactions using the cheaper signatures could get a discount on the fees or be allowed more sigOps. To be clear, the scheme I'm thinking of is "A secure public-key signature system with extremely fast verification" from about 2000.With regards to key recovery, a 2 bit hint can be used to accellerate the process. Alternatively, a single hint value could be assumed and it would be the responsibility of the signer to redo the signing operation until the assumed hint value is correct.ByteCoin I must credit sipa as first raising this issue as far as I know.There's a bit of a problem with rolling out OP_EVAL using this idea and I believe it may create a more dangerous block chain split than casascius' alternative proposal whereby OP_CHECKSIG gets renamed and re-imagined as a slightly hacked OP_EVAL.It's true that old clients will be accepting of blocks creating and spending OP_EVAL transactions. This is the advantage you mention.However, old clients will also be accepting of blocks which contain transactions which incorrectly attempt to spend OP_EVAL transactions with a null scriptSig. As you mentioned in the IRC, the old clients see these OP_EVAL transactions as ones which anyone can redeem.Miners would be best placed to watch out for transactions in which a null scriptSig can satisfy the scriptPubKey and then include transactions spending them in their blocks. This checking could be implemented now in anticipation of OP_EVAL being introduced in the fashion you propose and the exploit could be fully automated and require no time-consuming user intervention. This means that the bitcoin developers would have little time to react before the fraudulent transactions become confirmed. Clients (and miners) using the new version would reject these blocks but they would at least initially be a minority. People may opt not to upgrade to the new client as it would be easy to portray the new client's behaviour in negative terms. The effect of the above exploit would be to have a block chain split in which the latest clients who are supposedly doing the right thing may end up on the losing side. It would be bad for the public perception of bitcoin if an upgrade voluntarily precipitated a completely optional disaster along these lines.I think it's more practical for people running old clients to bear the risk of failing to keep their software current. The policy towards incompatible changes will have to decide how much risk is acceptable and how long a time users are guaranteed to be safe running a particular version.Bitcoin is lacking an effective and reliable mechanism for safely performing block chain splits. The worst-case scenario is one in which mining pools say they have updated their software and patch their clients to look like they are updated but then their software is actually designed maliciously to exploit the incompatibility of the new clients. If a client deployment strategy can cope with this situation then it can probably cope with anything.Before introducing an incompatible client, I think it's wise to ensure that the existing clients have robust detection of block chain splits. In particular, if a client sees a succession of what it thinks is invalid blocks with a high difficulty, then instead of banning the peer for misbehaviour, the client should disallow transactions (until overridden) and advise the user that an upgrade may be required.Another way to limit the financial damage from an exploited rollout would be initially only to allow new incompatible transactions of infinitesimal value; where both the transaction and any change are both suitably small. This limit would increase in some fashion over time unless perhaps a "shutdown" transaction were broadcast which would disable the new behaviour. This shutdown switch could be removed in a subsequent version when no exploits appear and sufficient confidence has been reached. Also, there would have to be an initial prohibition against spending new style transactions into old style transactions.Also, instead of enabling a feature after a certain block number, it could be introduced after seeing a block containing a particular magic transaction. This protects against the situatuion in which the miners (or the rest of the network) fail to upgrade as quickly as expected.ByteCoin  True. The fact that it uses the existing scripting system probably makes it easier to implement and considerably reduce the number of test cases to provide code coverage. I am happy to disclaim any credit for the idea if that is desired.You are right in that OP_CHECKSIG could just be reimplemented so that it effectively does OP_EVAL and appends a OP_CHECKSIG (see postscript) to the decoded script. It would have the advantage of being instantly compatible. I finally understand what you were talking about. In my defense, when you talked about redefining OP_CHECKSIG it sounded very sketchy. I will read your posts more carefully in future. IsStandard() will probably ensure that OP_EVAL'ed scripts match known whitelisted types with at least one SigOp. So it's not open season on non-standard transaction types yet.  One disadvantage is that the IsStandard() check will now apply when you're trying to redeem the coins rather than when you're trying to send them. Unfortunately, this means that if IsStandard fails, you probably can't redeem them (short of breaking the hash) until IsStandard is changed. This could result in some distress.ByteCoinPS. Obviously the appended OP_CHECKSIG would have to be renamed something else to avoid recursion! This is merely a matter of giving your version of OP_EVAL the number of OP_CHECKSIG and having a new opcode which really just evaluates a sig against a pubkey.PPS Nope, you're right again. It's no good always having OP_EVAL append an OP_REALCHECKSIG to the decoded script. The case when the decoded script is just a pubKey needs to be recognized and an OP_REALCHECKSIG needs to be appended only in that case for back-compatibility purposes. The special behaviour and the reasons for it would take quite a bit of explaining in the code comments. I must credit jimrandomh for this quote which put me on the right track.When I first read this proposal, it sounded to me like casascius was proposing a special scripting language for use with OP_CHECKSIGEX within the existing scripting language. This sounded inelegant; much better to have one scripting language we can use for everything. However I missed the point casascius was trying to make. Here's my version of the same idea using a new opcode OP_EVAL.At the moment, most scriptPubKeys look like "OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG".It's easy to see that to satisfy this scriptPubKey you need to supply a scriptSig containing a signature and a public key.  When you send someone your address, it's taken by the current client as an instruction to build a scriptPubKey of the above type when making a payment to that address. This means that one just needs to distribute a shorter public key hash to receive payments rather than the longer public key. When blockexplorer sees a transaction with the above scriptPubKey it knows that only a public key with the specified hash can be used to satisfy it and hence it's possible to calculate the "balance" of an address.We could introduce a new address type of the same length (but with incremented version number) and the new opcode. Use of the new address would mean that the intended scriptPubKey would look like "OP_DUP OP_HASH160 <scriptHash> OP_EQUALVERIFY OP_EVAL".In order to spend the transaction, the holder of that address has to construct a scriptSig which probably looks like "<sig> <script>" where <script> can be treated as a number (OP_DUP'd and OP_HASH160'd) but when OP_EVAL'd expands into a script.So to duplicate the functionality of the current system, the new address encodes the hash of "<pubKey> OP_CHECKSIG". Someone sending to that address looks at the version number and knows to construct a scriptPubKey of "OP_DUP OP_HASH160 <scriptHash> OP_EQUALVERIFY OP_EVAL" where scriptHash is decoded from the address in the same way that the pubKeyHash is decoded from current addresses.To redeem the transaction the address holder supplies the scriptSig of "<sig> <script>" where <script> encodes "<pubKey> OP_CHECKSIG".  Following the explanation of the transaction wiki pageStack#Script#DescriptionEmpty#<sig> <script> OP_DUP OP_HASH160 <scriptHash> OP_EQUALVERIFY OP_EVAL#scriptSig and scriptPubKey are combined.<sig> <script>#OP_DUP OP_HASH160 <scriptHash> OP_EQUALVERIFY OP_EVAL#Constants are added to the stack. <sig> <script><script>#OP_HASH160 <scriptHash> OP_EQUALVERIFY OP_EVAL#Top stack item is duplicated. <sig> <script><scriptHashA>#<scriptHash> OP_EQUALVERIFY OP_EVAL#Top stack item is hashed. <sig> <script><scriptHashA><scriptHash># OP_EQUALVERIFY OP_EVAL#Constant added. <sig> <script>#OP_EVAL#Equality is checked between the top two stack items.<sig>#<pubKey> OP_CHECKSIG#Script is popped and decoded.<sig><pubKey> #OP_CHECKSIG#Constant added.true #empty#Signature is checked for top two stack items.Obviously if the new address encoded the hash of "<pubKey2> CHECKSIGVERIFY <pubKey1> CHECKSIG" then one would have to supply a scriptPubKey of "<sig1> <sig2> <script>" where <script> encodes "<pubKey2> CHECKSIGVERIFY <pubKey1> CHECKSIG" as mentioned above. This would mean that knowledge of two private keys would be needed.So the above scheme is easily extendable to all multisignature messages.In order for IsStandard() to still restrict transaction types, it would have to do whitelist template matching on the results of the OP_EVAL.BlockExplorer could easily be tweaked to show transactions to new addresses. AdvantagesAddresses for arbitraritly complex transactions are fixed forever. No more new address types need be introduced.Addresses need only be same length as the current ones, forever.Transactions sending to multisignature addresses in this scheme are the same length as normal. This addresses theymos' concern that senders shouldn't be burdened with extra fees from longer scriptPubKeys. Instead, for more complex transactions, the scriptSig is longer which means that the owner of the address bears the cost of potentially increased fees.On preview - Gavin Andresen has come up with something very similar. I think they are probably functionally identical but my proposal uses only one keyword and I think it will be easier to code than BEGIN & END_DIGEST. Also, in both our schemes the increased length of more complex transactions is in the scriptSig.I think my proposal might be superior to Gavin's in that it more easily allows both constants and opcodes to be specified whereas Gavin's proposal involves hashing things on the stack and opcodes don't go on the stack, they operate on stack items.ByteCoin Could you please outline the contracts which one would be able to construct if one just had nLockTime without transaction replacement?In particular, there seems to be a lot of general interest in the trust-free cross-chain transactions. Is it possible to do this with the proposed multisignature scripts and the "post-dated cheque" nLockTime you propose.I believe, the version on the wiki requires replacement.ByteCoin I missed this first time round. I will edit this comment on Sunday to address this proposal.ByteCoin At the moment, everyone using Bitcoin runs a full-weight network connected client when creating transactions. We hope that this will not be the case in future. In particular it is anticipated that most people will only need to run lightweight clients which don't store the block chain.I think it's worth agreeing what facilities must be made available in order to have certain functionality.Firstly, I'd like to discuss creating transactions to new addresses.At the moment transactions can be created just given the intended recipient's address and knowledge of the details of unspent TxOuts for which one is able to satisfy the scriptPubKey. Your client can create the transaction and you could potentially print it out and send it in a letter.As an example of the contrary situation, if you just have a FirstBits address as the recipient's address then you no longer have enough information to create a safe transaction. You'd need to either scan the blockchain to work out the full address or (more likely) consult the FirstBits websiteSo the client doesn't need the block chain or any access to the network. Is the lack of dependence considered vital? How acceptable would it be for the default method of creating a transaction to a new address to require a successful query of the block chain?ByteCoin Page 8 of this paper by Bernstein et al. refers to techniques to make signatures deterministic i.e. constant for a given message and key.A previous comment by khal in this thread shows that some disquiet can arise from the "randomness" of the signature. To avoid this, the random k value could safely be set to the hash of the private key concatenated with the message hash. This topic also appears here.Patentability of point compression: I believe that the idea of recovering the y coordinate by plugging x into the field equation and supplying a sign bit is too obvious to be patentable.ByteCoin Thanks for that!My first thought for timejacking is that non-miners have no business having an opinion on what time it is. They should just follow the longest chain. If they choose to start rejecting blocks because they disagree with the time, they should then notice that the apparent hashrate has fallen and freeze. This limits the damage.With miners, the decision to reject a block based on time is similar to the decision to reject a block because it doesn't clear up enough outstanding transactions, cartel enforcement etc.. ByteCoin
An attacker concocts two different sequences of blocks and/or transactions and/or other messages and injects them into the network at two points. Clients readily adopt and incorporate either one of the two sequences but, having adopted one they reject the other. Moreover,  the sequences are engineered so that the clients in possession of one sequence think that clients in possession of the other sequence are DoS attacking them. The DoS countermeasures then ensure that the two client groups ban each other. The situation is now ripe for a double-spend attack.This conceptual attack is possible on the current network if a sequence could be found which would prevent the adoption of received valid blocks. It seems difficult to prove that no such sequences can exist. The DoS countermeasures might make an attack easier because clients will not accept valid blocks from a banned peer.I therefore suggest that new block headers should always be accepted even from banned peers. If the hash is correct and of the required difficulty then the block should also be obtained from the peer. A DoS attack which requires spamming targets with hashes of high difficulty would be ridiculously costly and if a client received such a stream then it could probably take it as a hint that it was on a small network fragment which had just reconnected or that SHA256 had been broken etc... Some action would be required other than just banning the peer and carrying on as normal.Also, code which detects a substantial apparent loss of hashing power and prevents transactions from going confirmed should be developed and deployed in tandem with the DoS countermeasures code. ByteCoin You could use a long salt which is likely to be unique to yourself and hard to forget (such as your's email address) then, with a suitable algorithm which prevents quick exhaustive search, the password could be considerably shorter than an address and the entropy requirements likewise reduced. The length (and quality) of your password is determined by how much work you want your attacker to do before you don't mind them taking your coins. Saying that this is "incredibly insecure" seems to be setting a rather high bar for "incredible insecurity".ByteCoin In most practical situations I can imagine, the signature verification is likely to fail because the base-64 encoded string has become corrupted or truncated. Most instances of corruption or truncation can be quickly detected  by a strict format base-64 decoder before performing the much slower signature verification. Also with little extra effort, we can tell if the base-64 encoding is malformed and we might as well report this fact to the user rather than throw the information away and amalgamate the two error conditions under the "verification failed" umbrella.Also, I notice that the verifymessage doesn't help the user to distinguish between the signature failing because the address doesn't match the signature's public key and the ECDSA signature being invalid. I recall that one can infer the public key from a signature so we could shorten the signatures by 65 bytes or 87 base-64 characters by not bothering to encode the public key. This improvement would mean that checking the address matches the inferred public key would be the sole test of validity.ByteCoin Thanks for testing. The second issue you found is a good catch!The use of a random nonce is part of the way the ECDSA signature is formed. For signing a hash H with secret key K, it might be possible to make secure constant signatures by setting the random k value to be the x coordinate of G*H*K but this would be considered non-standard cryptography. Unless some very persuasive use-cases are shown, I believe users should not be able to set their own k values due to the risk of revealing the private key cf. Sony. The base-64 string you provide is 183 characters long. This means it encodes floor(183*3/4) = 137 bytes. 137 bytes contains 1096 bitsbut 183 base-64 characters encode 1098 bits. On converting the bytes to base-64, the value of the two extra bits has to be arbitrarily specified as 0 and on decoding the two bits are thrown away. The last base-64 value in the string is "k" which encodes 36 = 1001002. As you can see, the last two bits are zeroes. The base-64 values for "l", "m" and "n" only differ in the last two bits but "o" encodes 1010002 which changes the value of the bytes to which the base-64 string decodes and thus the signature fails.It's probably worth changing DecodeBase64 to throw a "malformed base-64 encoding" exception if "left" is not zero when exiting the while(1) loop. If this "strict format check" is adopted then one should also check that an "=" character caused the loop termination.I'd also change vchMessageMagic = ParseHex("3a4f40f998736d6f"); to something more obviously not engineered to facilitate some cunning attack. I don't see what was wrong with "Padding text - " which was in the original version.ByteCoin I edited the poll to add BRFI. I presumed the two votes which were formerly allocated to "Other (post suggestion in thread)" were votes for BRFI as there are no other proposals in the thread.ByteCoin    With reference to this discussionByteCoin You meant "increase the BTCDD to 100%". Your previous post in this thread was correct in this regard.If there are lost coins and a finite total number of coins then the BTCDD percentage cannot possibly reach 100% ever.If there are no more transactions then the BTCDD tends to 0%. In the long run, if there are any transactions then the BTCDD has a lower bound given by the proportion of the transacted coins out of the total coins.Both statements are incorrect.ByteCoin   No. Exchanges between chains require at least more scripting functionality enabled and some require nLockTime and replacement.This is misleading as K1 and K2 have to be signatures specific to the transaction and not just secrets which can be revealed.Someone, please explain how the above construction facilitates the functionality mentioned.ByteCoin I believe that your simpler version of "hidden recipient address" can be redeemed by anyone (most probably a miner) by rewriting the transaction which includes the revealed secret in order to credit themselves.In short - it's insecure.Where in the code does it prevent the addition of bignums with OP_ADD?ByteCoin  Ok so it's a 51% attack which replaces the whole block chain. You seem to be implying that the main negative effect is that the attacker gets more blocks over the period than he "deserves" from his hashing power. However, isn't the main effect that all the previous coinbase transactions are deleted and hence all transactions are declared invalid? This would effectively destroy the system and the response would be to either lock in the valid chain (preventing the attack) or start again with a new genesis block. Either solution would result in the attacker having wasted his hashing power.Is this purely a destructive attack or can it be made profitable?ByteCoin Please outline the significant inefficiencies.My protocol can be executed approximately as fast as the relevant calculations and network communication take. This means that the brute-force problems which render nLockTime unnecessary, can be small. The brute-force problems need only be solved if one of the participants fails to complete the protocol. Solving the brute-force problem is like waiting for nLockTime to run out. Giving the other party the solution to the brute-force problem is similar to broadcasting a final version of the transaction.The time that your coins could be "held at ransom" can be made quite short and, if this is still considered unacceptable, an escalating setup can be envisaged so that both parties have to do roughly comparable amounts of work to "recover" their coins if the protocol falls through.ByteCoin  Thanks for the clear explanation ArtForz!It's clear that the calculation needs to be made piecewise continuous, so for 7 we use 3 as the first.Here's where I get confused. I haven't looked at the calculation in detail but surely you can't get the same total work as the real chain without doing approximately the same amount of hashing as the real chain, no matter how many blocks is in your chain or how you've manipulated the difficulty? Please explain further...ByteCoin I believe I have a way to overcome the lack of nLockTime. Firstly let's observe that A can use the scripting language to pose B a problem to which A knows the solution, and which B can quickly verify is very likely to have a solution, and for which B cannot feasibly do any precomputation to calculate the solution faster than brute force. One example of this would be for A to challenge B to provide a number X in some random interval of size 2^N such that hash160(X) falls in some interval of size 2^(160-M).There seems to be no faster way to independently find a solution than for B to perform a number of hashes roughly equal to 2^M. If N is somewhat larger than M then anyone can verify that it's extremely likely that a solution exists. If the random interval is chosen over the range of 160 bit numbers and if N is significantly smaller than 160 it's unlikely that B will have chosen to precompute the hashes of any values in the interval.So the proposal in my last post would have worked if there was something preventing A spending the inputs crediting B.To solve this we arrange that before the start of the procedure B poses A a brute-force problem as defined above to prevent A spending the inputs crediting B without either the solution from B or alternatively exhaustively searching for the solution. B must be able to bound the amount of time A must spend to perform the exhaustive search as this will dictate how long B will wait for A to complete the next stage of the protocol. If A does not follow the protocol within a short-enough period of time then B will terminate or unwind the protocol.There now needs to be some incentive for A to promptly sign Z by revealing the secret S after B has sent the the transaction crediting A, otherwise there's nothing preventing A performing the exhaustive search to spend the inputs of the transaction crediting B.To solve this, we arrange that when A sends B the partially signed transaction A also sends an easier brute-force problem for B. When B constructs the transaction crediting A, he makes it so that it is alternatively redeemable by B if B has solved A's brute-force problem.As soon as B sends this transaction to A he starts work on A's brute-force problem.If A doesn't immediately sign Z by revealing S then B is very likely to solve A's problem before A solves B's problem. This means that B can recover the funds that were going to go to A and some time later A will solve B's problem and recover the use of the funds that were intended for B. If A does immediately sign Z by revealing S then A must also publish a transaction which spends the transaction crediting A as B will be trying to solve A's problem and if B is successful before the A spends it then B will spend it instead.So now B, knowing S can reveal the answer to the problem he posed A in order to allow the redemption of A's inputs to the transaction crediting B. B publishes A's transaction which credits him.This isn't the clearest explanation nor am I sure that it's the simplest solution but I lack the time to improve it at the moment.ByteCoin The following method comes close to trust-free crypto-currency exchange without time-conditional scripts or nLockTime.It is practical on the current Bitcoin network and needs no additional script commands or features enabled.A and B want to exchange crypto-currencies.A generates a secret S and sends H to B where  H=hash(S).Either A or B or both create two transactions Z, one on each crypto-currency for negligible or zero value which are spendable by revealing S, the value that hashes to H.At this point A who knows S can spend both Zs but there's little incentive to do so given that the gain is so small or zero.A sends B a transaction that pays B which also includes the relevant Z as one of the inputs. This transaction is incompletely signed as A does not reveal S.B checks the transaction to verify that knowledge of S would make it a valid transaction and sends A a transaction that pays A which includes the relevant Z as one of the inputs.A signs Z by revealing S on the transaction crediting him and publishes the completely signed transaction.B looks at the published transaction to discover S, signs Z on the transaction crediting him and publishes the completely signed transaction.Unfortunately, as soon as A publishes B's transaction crediting himself, A can also publish a transaction which spends the input that credits B before B can publish A's transaction crediting him.... I doubt there's a way round this without nLockTime.If the network agreed that the signed inputs from partially signed transactions could not be "double" spent until some short expiry period had elapsed then the above scheme would be secure. It would probably be a smaller and less worrisome change than implementing nLockTime and transaction replacement.ByteCoin I meant it conceptually. Hashes and public key systems are simpler and more intuitive as well as predating zero knowledge proofs.That's a theoretical result which hides the impracticality of the implementation. This video explains (at the end) how a 200Mhz Pentium needs to send about 20MB of data and do a total of about 2 hours of computation to prove you hold the preimage of a SHA-1 hash. The problem needs to be implemented in terms of a boolean circuit and the proof is in terms of bit commitments to the values of the wires and manipulation of the commitments.Jens Groth of Imperial College has recently published a succession of superb papers which bring non-interactive zero knowledge proofs of non-trivial statements into the realms of practicality. If Bitcoin were implemented in terms of operations on appropriate bilinear groups instead of straight elliptic curves and hash functions then schemes such as you describe would be more practical.ByteCoin The idea of using nLockTime is to have a transaction which can be replaced but which, if no replacement is provided, will change into a normal transaction once the time has expired.If all the TxIns can be signed by one entity then there's little point in issuing an nLockTime transaction as they can issue arbitrary revisions until the time expires. They could get equivalent functionality by not issuing the transaction or not constructing it until it's needed. Is this correct?Transactions involving nLockTime are used in forming various sorts of contracts some of which involve creating and signing transactions spending incompletely signed transactions. Transactions are identified by their hashes and in order to spend a transaction, you have to know its hash. It follows therefore that for these contracts to work, the process of signing a transaction must not change its hash. To do this, when calculating a transaction's hash, the signatures for the txins must be removed, zeroed out or otherwise rendered constant. I believe that this does not occur at the moment.Code: uint256 CTransaction::GetHash() const{return SerializeHash(*this);}Now three possibilities exist: (neglect that they are not mutually exclusive)1) I'm mistaken in my understanding or logic. 2) The contracts mentioned above which need to construct transactions spending unsigned transactions are not intended to be possible.3) The current hash calculation is incompatible with the above contracts and needs to change at some point.Which is it? ByteCoin You correctly identify that my proposal needs a way to revoke keys in the event that they are compromised. This is an implementation detail and is not cryptographically interesting. All that is required is the publication of some suitably signed message.Your proposal, etotheipi, bears scant resemblance to the scheme I outlined in the thread.Step 1 of your process involves both parties generating new keys. The rapid proliferation of unrelated keys is something that my scheme is designed to avoid.Step 2 of your process involves the recipient of funds sending the funder a new public key for them by some authenticated channel. This is analogous to the current need to pass the funder the address to receive their bitcoins, hence your scheme is no better in this regard. My scheme on the other hand does not require any direct communication between parties.Step 3 and 5 of your scheme involves dust spamming the network in order to pass information between the parties. This is not a feature of a promising scheme.Your proposal seems to be intended to facilitate repeated interaction between two parties. I suggest you instead advocate hashcoin's fine "Instant TX for established business relationships" scheme which has the advantage that most transactions don't touch the network.Also I recommend collaborating with the other developers to improve the mainstream client rather than writing a new one.If you wish to suggest improvements and alterations to my scheme then I welcome your thoughts on this thread. If your ideas are at such variance then starting a different thread would be more appropriate. On-topic discussion please!ByteCoin Thanks! I'm glad you've taken the time to understand it.Correct. If addresses are more like public keys instead of their hashes then schemes like this become possible. One can do almost no cryptographically useful operations on a hashed public key.Yes. There is an obvious implementation detail that would discourage A from sending to the "wrong" address of B which would also shave a few bytes from the size of the public key. Similar concerns would also discourage users from holding too many different active public keys as they provide essentially no additional anonymity and the computational burden increases linearly. It means that one can make one backup of one's wallet and then it's safe forever. In the existing situation you need to back up your wallet every time a new "block" of addresses are generated.The two parties can agree on some easily identified, optional OP_DROP tag for the transactions. Alternatively, the identification of transactions can be handed off to a trusted third party. Remember that full nodes have to verify all transactions anyway and it may be possible to arrange this scheme that one's own transactions can be identified with insignificant extra work as a side-effect of this verification.The "difficulty" of recognizing transactions is inevitable if you want anonymity. In the current system, to have the same anonymity, each time you want a payment, you have to distribute a new address to your payer. To do this securely you really have to have a public key of theirs already. Some interested party could observe the exchange to compromise the anonymity. They might not know what the consequence of the interaction was but they know that you and your payer were communicating securely for some reason.We'd try and avoid this by having B start with one key and by making it difficult for A to send to anything but B's intended key. I'm having trouble thinking of a good justification for having more than one key in a wallet under my scheme.ByteCoin It was precisely this issue that prompted me to devise this solution.ByteCoin Yes you're quite right. Not a good solution. I was hoping you'd respond to this thread.Your method of including the encrypted address as an OP_DROP parameter to the transaction would work but would take up quite a bit of room but that's the only particularly ugly part. It's a bit hyperbolic to say that it's like reimplementing PGP!I believe the following scheme should sort address the problems you mentioned as it is indistinguishable from a normal transaction and there is a negligible possibility of address collisions or reuse.The funder prepares a transaction crediting the redeemer and returning change to some other address.This transaction has one or more TxIns and the scriptsig for the TxIn contains an ECDSA signature and a public key pointThe funder does a Diffie-Helman key agreement using the secret key from the first TxIn and the redeemer's public key.The funder then takes the x coordinate of the agreed key added to the r value from the first TxIn's ECDSA signature and computes that multiple of the redeemer's public key to get a session key.The funder constructs the transaction as normal, sending the funds to the address formed from the hash of the session key.So the funder sends to hash160(redeemer_public_key*(TxIn0_signature_r+x_coordinate(recipient_public_key * TxIn0_privatekey)))The redeemer has to do two point multiplications to identify a transaction he can redeem. But that's comparable to verifying an average transaction anyway. There's likely to be a Shamir's trick variant to reduce the cost somewhat.It may even be possible to pass a secure message to the recipient using the subchannel using a sophistication of the above idea....ByteCoin
I'd like to direct you to a  proposal  which could be seen as implementing a type 2 deterministic wallet on funder's clients. The hash function in this case is choosing the x coordinate of an elliptic curve multiply in a similar fashion to ECDSA.I believe that this would satisfy the goals of a deterministic wallet and have a number of other fairly obvious beneficial effects.ByteCoin A privacy preserving solution could work as follows.All funders wanting to make payments to you know your public key c. People looking at the block chain wishing to determine which transactions can be redeemed by you (investigators) do not know the key.When a funder constructs a transaction to you he generates hashes h=hash160(c*x_coordinate(c*t)) for t=0,1,2,3.... and checks all transactions to find the first h which has not been used before.He then constructs the transaction with h being the address.This is effectively a deterministic wallet that resides in the funder's client software.One problem would be if two people sent a transaction at the same time with the same h. This is solvable with a high probability with an OP_DROP parameter to the transaction.I believe that if this were implemented in the default client then there would be no need for deterministic wallets, key pools or the distribution of new addresses for each transaction.ByteCoin In your original post, you're asking about the calculation which determines the valid block chain. I believe that this calculation results in a value called bnChainWork calculated in the following fashion in main.cppCode:bnChainWork = (pindexNew->pprev ? pindexNew->pprev->bnChainWork : 0) + pindexNew->GetBlockWork();It's probably worth examining and taking the time to understand the source code I've pointed you to. You can then tell us yourself whether the wiki is correct and inform us of the relationship between the difficulties and the chainwork.It's not obvious to me that satoshi's way of calculating chainwork cannot be manipulated to produce some undesirable behaviour.This would be an interesting area for some research.Also, it seems a little wasteful to do repeated bignum "reciprocal" calculation when the argument only changes every couple of thousand blocks.ByteCoin As the code I quoted in my first post shows, the client uses fixed-point bignum arithmetic to compare chains already.ByteCoin In the interests of my being critical in an unbiased fashion, I must mention that I think etotheipi and theymos' most recent posts on this thread are also offtopic. To quote Gavin againHe specifically mentions that the implementation may require a new address format which is outside the scope of this discussion.In that case, you have nothing, apart from your approval to contribute to this thread. The thread is about what you term "the first proposal", as what you term "the second proposal" was never proposed.If you look at the comments on the document Gavin linked to, you can see that there was plenty to talk about and correct regarding his proposal which you deem uncontroversial.This thread is intended to attract more critical attention to the proposal so that any problems are corrected.Your suggestions with regards to an a new address format would be welcome but probably more appropriate on another thread.ByteCoin With reference to Gavin's first post on this thread I think that casascius' recent post is offtopic for this thread and should be moved to casascius' "Modify OP_CHECKSIG" threadI will delete this message after the move.ByteCoin I presume you mean counting the leading zeroes in the binary representation.The obvious objection to your suggestion would be that it does not provide as fine granularity as the existing scheme. I think it would be difficult to determine or argue the inequivalence of its effectiveness.I believe that it's the target that's used to determine chain difficulty rather than the actual hash in order to discourage some rather impractical attacks exploiting particularly "lucky" blocks. I believe theymos has addressed the issue if you care to search through his history(!). From main.hCode:    CBigNum GetBlockWork() const    {        CBigNum bnTarget;        bnTarget.SetCompact(nBits);        if (bnTarget <= 0)            return 0;        return (CBigNum(1)<<256) / (bnTarget+1);    }ByteCoin I've only just seen this. It sounds similar in goals to this.Is there any way of turning my "Mee too!" into something that will bring this much-desired future closer to reality?ByteCoin Excuse me for mangling the quote system somewhat...The unfortunate thing about this construction is that the emergency key c, kept offline and hopefully never used is likely to be constant over a very long period of time. This results in a dramatic loss of transaction anonymity.It would be nice to have a ScriptPubKey for c from which it is computationally infeasible to determine whether another similar transaction has the same key c.Perhaps the funder knows the public key for c, encrypts a random nonce with the key and stores it in the ScriptPubKey with an OP_DROP. The rest of the ScriptPubKey for c requires that the redeemer provide a signature and public key for the concatenation of the random nonce and the redeeming transaction. Could something like this be implemented in the scripting language?ByteCoin I'm respecting Gavin's request that the linked thread not involve discussions relating to IsStandard. Firstly, let me say that I'm very grateful that we have theymos' blockexplorer to examine transaction history. I also have my own tools which even break when someone does something unusual but nonetheless "standard".However, if blockexplorer had never been made, would Gavin dispense with IsStandard? I think not. Therefore, the risk of breaking blockexplorer is not the main reason.Arbitrary non-standard transactions could be analyzed when they are redeemed in an improved blockexplorer by showing the evolution of the stack as the scriptPubKey+scriptSig concatenation are executed. The only thing that would be difficult to establish automatically is what scriptSig contents would be required to redeem a non-standard transaction.I suspect that the main reason for keeping IsStandard is a justifiable feeling of anxiety that non-standard transactions may lead to unanticipated, unwelcome behaviour. We need to look at technical solutions to allay this problem.I suggest that non-standard transactions be allowed but (for the moment) take a very, very long time to confirm. This would be easy to implement and remove the "unpleasant urgent surprise" that a quickly confirming malicious non-standard transaction might bring.Another solution requiring more engineering but minimising the potential damage still further would be for non-standard transactions not to be even incorporated into blocks until they had been manually checked out and approved in some fashion. This is just suggested to provoke discussion.ByteCoin It looks like it was necessary for me to qualify that the whole thread presupposes that a template allowing OP_CHECKMULTISIG in a transaction is added to the "standard" list for some reason in the near future.ByteCoin Got it! Thanks! Seems obvious how the code works now. I don't know what I was thinking before!This is what did it for some reason....Anyway, so that this thread isn't a complete waste of time I'd like to observe that the current way of matching signatures to public keys is very wasteful of computation. For example, if you have a 1 of 100 multisignature then the code goes through the public keys sequentially trying to verify the signature until it either succeeds or runs out of public keys. As each transaction is verified each time it is relayed, wouldn't it make sense to indicate in the scriptSig the number of public keys to skip before attempting to verify the signature. This could be an (optional?) 1 byte parameter which would save a very large number of unnecessary signature verification attempts. ByteCoin Firstly, what's the correct syntax? The comment in the code says Code:([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)but how many signatures are present in [sig ...]? Is num_of_signatures the actual number of signatures provided or is it the number of valid signatures required for OP_CHECKMULTISIG to return true?I'm reading the code for OP_CHECKMULTISIG in script.cpp. It allows for fewer signatures than public keys but seems to iterate through both the signatures and public keys without any attempt to find out which ones are missing. I don't see how this could work for even a 1 of 2 multisignature transaction in both cases where, in the first case the signature matches the first public key and in the second case the signature matches the second public key.Even if both signatures are provided but one is just invalid, the verification will fail as nSigsCount will only be 1 and if the first verification fails, the other will not even be attempted.Can anyone explain please? The issue is becoming relevant...ByteCoin Thanks for taking the time to understand my thoughts. The way to stop people hijacking your factoring proof-of-work is using the relevancy property. The work you performed was relevant to the block which includes the transaction that credits you. In the particular case of factoring we could agree on a large composite number that would be a worthwhile factoring, perhaps a number from this list.The simplest method I can think of would be to implement  MPQS where the coefficients of the polynomial are derived from the block hash. The proof of work would be one or more (depending on the difficulty) relations of sufficient quality. After sufficient relations have been found then the factorization is completed, the factors published on the bitcoin net along with the next target.ByteCoin Does it seem reasonable to everyone that there is very little distinction between enabling an existing but disabled opcode and creating a completely new opcode to facilitate some desired functionality?Many of the existing but disabled opcodes (especially the stack manipulation ones) seem rather pointless and it would be better to work towards opcodes that facilitate desired functionality such as Rivest and Shamir's  Paywords scheme as mentioned by hashcoin.Scripting is a great idea but parts of the current (but disabled) implementation seem to have been rushed out with insufficient thought.ByteCoin Reading somewhat between the lines, what you appear to be doing is providing a mechanism for tying up portions of a user's coins for a number of blocks, the reward for which is some additional coins. Presumably the "tying up" transaction would contain a hash of a number of third-party transactions which the author approves of and wishes to confirm.You say it would take c/X confirmations before the funds are untied. Are all confirmations created equal? Let's say I have 50 units of your funds. I can confirm a transaction by tying up all 50 units for c/50 blocks and that provides one confirmation. I could alternatively split it into 50 lots of 1 unit and confirm a transaction 50 times buy tying up 50 lots of 1 unit for c/1 blocks.Minor issues that need clarification are: How do you have two addresses for one private key? Do all transfers tie the funds up for c/X confirmations?A fundamental problem with the scheme is that people with a lot of funds who never spend them get more funds fastest. I don't think that this is a good way to bootstrap a currency.It would be worth you editing your post to include a link to an explanation of "proof of stake" and a bit more about your goals by contrast with the existing system. Interesting idea though...ByteCoin I have identified some necessary properties for a useful proof of work in this post.SETI, folding@home etc are not suitable.ByteCoin  This is an important point - especially when the mining reward drops to a level where fees make a more significant fraction of the miner's return.I doubt that, with the currrent protocol, we could reliably detect whether a miner is not relaying transactions as it should. Even if we could detect it, there's a question of what sort of steps could be taken to discourage it. Any sort of collaborative censure of the non-relaying miner would have the tendancy to encourage the formation of mining cartels.It's a completely rational mining behaviour however. I expect it to be the default eventually if no preventative measures are taken.Also it's interesting to note that it's a scenario in which attaching a fee to a transaction makes it slower to confirm!ByteCoin  For future reference, could you please outline the other problems it would solve?ByteCoin The original bitcoin design has transactions propagating across the network of peers essentially at random. This was a reasonable design as all peers were approximately indistinguishable. With the advent of GPU mining and especially mining pools, the network partitions clearly into mining and essentially non-mining peers.When a transaction is created, if it is relayed to non-mining peers the only effect is to force the recipient to waste time verifying it before passing it on. Only when the transaction reaches mining peers is there any chance that it might get into a block. Similarly, once all the miners know about a transaction there's little point relaying it to the remaining non-mining peers. With the current mining situation it would be more efficient to have transactions sent directly to a random node on an interconnected mining network. Also, there's little point in most non-mining clients being informed about new blocks unless they are waiting for a transaction to confirm. It would be more efficient for new blocks to be pulled from the mining network rather than being pushed out indiscriminately as in the current situation.ByteCoin
So instead of using a hash we should be using a block cipher?I presume that the difference between the two with the most practical impact is the presence of collisions in the former and the absence thereof in the latter.I'm not really calling in to question the validity of what you say but, to make your point more obvious, could you give a realistic example of a situation in which using a hash function instead of a pseudorandom function gives noticable problems?ByteCoin  Such concerns are not relevant for the security of modern cryptosystems. In particular, public key cryptography relies on the public key being published and used multiple times. Please cite any modern technical publications which claim otherwise. Codemojo's scheme is simple, viable and secure.ByteCoin Bitcoin was developed and is implemented using pre-zero-knowledge crypto technology.I think that the incorporation of an appropriate generic zero-knowledge-proving scheme which enables such digital contracts would be revolutionary. Can arbitrary functions f be proved in zero-knowledge? If not, what are the constraints?Are the proofs non-interactive? If not, how many rounds do they take?Is there a scheme for generating arbitrary zero-knowldge proofs? Can you send some references to relevant papers please?Are all the proofs necessarily probabilistic?Welcome to the forum!ByteCoin When MoonShadow says "benchmark" he means "checkpoint". From main.cpp...Code:bool CBlock::AcceptBlock(){...    // Check that the block chain matches the known block chain up to a checkpoint    if (!fTestNet)        if ((nHeight ==  11111 && hash != uint256("0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d")) ||etc...Also, the vanilla client has the checkpoints. There are other clients. I don't know whether they have checkpoints...ByteCoin  But do they accept blocks which are built off blocks mined in the very distant past when the difficulty was minimal?I think they do.As patvarilly says (and you overlook) the client can't gratuitously ignore new blocks which branch off very old blocks because that would hinder block chain reorganisation and the adoption of the "longest" chain if the network were split for a long time and then reconnected.I haven't seen the problem addressed before. If such checks existed I would expect to see them in ProcessBlock() in main.cpp and there's nothing appropriate there. As far as I can tell, patvarilly's post is completely correct. ByteCoin By specifying such a large nonce prepended to the message, if an attack on SHA256 were found then the the attacker, by engineering certain parameters into the nonce would probably find it easier to find a collision. The recipient of the signature doesn't have any way of telling one nonce from another so can tell whether the nonce has been "tampered with".Anyway, if the application decides it needs a nonce it can prepend or append it to the message anyway. Don't specify the nonce as part of the interface as it mandates using space that people can't necessarily spare.As a general rule, when you're hashing data you should hash just the data you want to hash and not any junk whose values you don't care about. It called "packing the hash"I was contributing to this thread before in a kind of academic fashion as all the solutions proposed were roughly equally good. I feel quite strongly that the above proposal with the large nonce is a retrograde step and I'm very keen that people understand the problems I outline above. If I have not explained it adequately, PM me and I will edit this post.ECDSA_SIGN(SHA256(fixed_string+message)) has the benefit of being the simplest adequate solution. Applications wanting a nonce can add it to message so that message = nonce + real_message.Edit: Let's use industry standard base64 encoding and if we're really going to use base-58 then at least fix the encoding so that it doesn't vary even if it starts with leading zero bytes. PLEASEEdit2: The paper referenced by gmaxwell concerns itself with the size of the private key and the random number k. The paper would be motive for implementing some bounds checks on dA and k (using the notation in the wikipedia article but not for any checks on e=SHA256(message).ByteCoin I think we need some controls on the quality of the wiki.One thing that stands out ishttps://en.bitcoin.it/wiki/Tonal_BitcoinThere are a number of calls for its deletion.Does anyone know the proper procedure for resolving disputes about the contents of a wiki?Can we start the process please?ByteCoin My understanding is that the bulk of the discussion occurring under this subject heading revolves around a proposal by kjj linked to above which is not the behaviour of the current system.May I suggest that you request help from a moderator to move your posts discussing this special system to a new thread (which it clearly deserves) as someone casually following the new posts to Dev & Tech (like me) gets confused because you appear at first sight to be discussing the behaviour of the current system but incorrectly.If the proposed system for discouraging block chain re-organizations was in it its own thread (and explained properly) then I believe it would attract wider interest and be more easily found in future when such proposals are discussed again.ByteCoinEdit: I gather from kjj that it already has had a thread. In this case it might be useful to mention in your posts that you are discussing the merits of a proposed change and link to a post outlining the change. I think you'll find that this idea, taken to its logical conclusion is outlined in my post about  balance sheetsSee the disussion there.ByteCoin Correct. Your analysis however assumes that the other miners will blithely accept his blocks if he wins the fee.The odds for a corrupt miner working by himself are even worse than you suggest because the other miners, seeing that they have not been "cut in" are not going to accept the lone miner's blocks. Even in 1% chance that the 10% miner gets two blocks, the other miners will not accept his blocks and will rapidly regain the longest chain.The only way in which the rewriting can succeed is if enough of the miners gain "enough" of the profits. Exactly what their negotiating strategies should be is hard to determine though....It seems plausible, given completely rational miners, that the rewrite would not be accepted unless >50% of the hashing power consents.ByteCoin Mike's concern is valid. The solution suggested in the OP_BLOCKNUMBER threads is to reduce the risk to the same level as the invalidation of coinbase transactions. Coinbase transactions take a long time to mature because reorgs that invalidate transactions spending coinbases must be thrown away after the reorg. OP_BLOCKNUMBER transactions could take a very long time to mature, proportional to their value.nLockTime, sequence numbers and scripting are powerful. There seems to be no way however using scripting, nLockTime etc to send bitcoins to an address and to have them revert back to you if they are unspent for a very long time which seems to be a keenly desirable feature. I will take this back and discard OP_BLOCKNUMBER if someone demonstrates that equivalent functionality can be gained without it.If there were an OP_DIFFICULTY as well then the futures and bonds suggested by cunicula might be possible. ByteCoin The particular issue I'm submitting for consideration in this post is the implementation of a new future-proof address type.TerminologyAn overseen transaction is one where the user requires the assent of one or more third parties to complete the transfer of bitcoin.The third party is termed the overseer. The service they provide is oversight.Bitcoins sent to the user which require an overseen transaction to spend are overseen coins. The address they are sent to is an overseen address. Note that sending coins to an overseen address does not require an overseen transaction.Oversight ServiceThe user signs up to an oversight service with a certain policy and mechanism on approving spends. The oversight service might be implemented as a USB dongle with a display or a web page accessible by a browser or by a call centre accessible by phone.Overseen AddressesThe user needs to distribute a new overseen address to receive bitcoins and/or to send his existing bitcoins to. The scriptPubKey for transactions sending to an overseen address must require the users signature (like a normal transaction) and the overseer signature.This is a non-standard transaction which potentially needs to contain two hash160s of information - one for the user's key and one for the overseer's key. It's troublesome to type in such a lot of information and to come up with a new address format for every new type of non-standard transaction. Out numbers - a new address typeWe observe however that it's very easy for the standard client to create a new transaction by copying the scriptPubKey of an existing transaction. So instead of sending to an address like 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa  which contains the hash160 of the credited public key we could send to scriptPubkey 0 as seen in the block chain. I'm going to refer to this as "out 0". Address 1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc would be out 170 as it's the coinbase transaction for block 170. The coinbase transaction for block 171 would be out 172 as block block 170 contains the first ever transaction,  sending 10BTC to 1Q2TWHE3GMdB6BZKafqwxXtWAWgFt5Jvm3 which is then out 171.The onus for creating the first non-standard transaction and getting it into the block chain can therefore be shifted onto the oversight service.When the user signs up, the oversight service creates a non-standard transaction crediting a tiny amount of bitcoin to the overseen address and gets it into the block chain. After a suitable number of confirmations the overseer works out the what position that address has in the block chain and passes that "out-number" (typo-protected, see below) to the user. The bitcoins required for the small transaction could have been transferred by the user to the oversight service on subscription as part of the fee for the service.  Paying to overseen addresses - or to generic out-numbersWe modify the standard client so that when the user types an out number into the "Pay to:" box, the client looks up the relevant scriptPubKey and fills in the fields accordingly. So if a user types "o170" the client finds out that the scriptPubKey is just a simple transaction to address 1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc and fills it in. If the user types the out number for an overseen transaction then the client looks up the scriptPubKey and recognizes the transaction type. It redraws the Send Coins window to include a box for the overseer address and it populates the "Pay to:" and "Overseen by:" with the destination address and overseer address respectively.New schemes involving non-standard transactions will be seen to be useful and will be invented and implemented in future. The above solution is completely future-proof as the client software doesn't even need to understand the scriptPubKey in order to create a transaction sending coins to it. If the standard bitcoin client software and UI is altered to allow transactions to out-numbers then users of that software can send money to overseen addresses even if the bitcoin client does not understand overseen transactions. The client should allow the user to send bitcoins to an out-number for which the client does not understand the scriptPubKey after a suitable warning such as "This version of the bitcoin software cannot inform you how coins sent to this address will be disposed".Preventing bitcoin transfers going astray with out-numbersThere is an issue with preventing the mistyping of an out-number because it's very likely that adjacent numbers will be valid out-numbers and also many transpositions of adjacent characters will also yield valid out-numbers. I suggest that the hash160 of the scriptPubKey base-52 encoded into "a-zA-Z" be appended to the displayed out-number. A typo-protected out-number would therefore look like "o170XcaYfWuomDEsiFqnaXDVxqHHTxMe". The user would not have to distribute, store or remember all the alphabetic part of the out-number as the client would look up the relevant scriptPubKey, hash it and fill it in. So for the above example "o170X" would provide approximately a 98% chance of typo detection, "o170Xc" would provide approximately a 99.9996% chance of typo detection and "o170XcaYfW" would reduce the chance of an undetected typo to about one in about twenty billion. Anyone distributing their out-number to receive payments could decide how long their protected outnumber was going to be up to a max of the number + about 28 characters.The exact format of protected out-numbers is thrown open for discussion. There must be no confusion between the current address system and protected out-numbers. Out numbers are "numbers" by analogy with bank account numbers and to avoid commerically embarassing issues whereby inappropriate words are spelled out (cf. the issues with rude words in CAPTCHAs). The alphabetical "check" portion can be engineered to be free of inappropriate words.Sending overseen coins from an untrustworthy computerUsers subscribed to an oversight service are possibly using rootkitted computers and must be running an oversight-enabled version of bitcoin to spend overseen coins. if all the coins in the users wallet are overseen then when the user presses send, the computer can't send a complete transaction as it does not have access to the overseer's key and can't generate the overseer's signature. (Except by using the "disappearing overseer recovery pack" mentioned by Gavin). One possibility is that incompletely signed transactions be allowed to propagate across the bitcoin p2p network like a normal transaction. The overseers would see all the incomplete transactions which they could sign to complete and after checking with their policies and/or phoning the users etc they sign the transactions and send the complete transactions out across the network to be included in blocks. In this instance, the behaviour of the incompletely signed transaction is similar to a transaction with a nLockTime in the future.Another possibility is that the bitcoin client has been informed of the IP address of the oversight service that they are using, so the client sends the incompletely signed transaction direct to the overseer who, after suitable checks, signs it and distributes it or sends it back etc..In the case that the overseer is a USB key, the incompletely signed transaction is sent to the USB device. It checks the transaction and displays the amount and the address to be credited to the user on its own display so that the user can check them. If the user approves then the USB key signs the transaction and sends the completed transaction back to the computer to send to the bitcoin p2p network. It seems likely that some extra USB-key-specific software needs to be installed on the computer to handle the communication between the bitcoin client and the USB key.General ConsiderationsI think the system should not prefer any particular oversight service to any other. Anyone should be able to provide oversight service if they follow the protocol and any user should be able to subscribe to any oversight service.The system should be able to be extensible to facilitate coins overseen by multiple overseers in which case the system should be able to facilitate situations in which both overseers are required to sign, and situations in which only one is required to sign.If the overseer is a USB key, care has to be taken so that the bitcoin client does not have to concern itself with the details of transacting with the USB device.In order to facilitate oversight services, bitcoind should be changed to enable the sending of transactions with explicit custom scriptPubKeys, possibly specified as a hexadecimal string encoding of the scriptPubKey contents.ByteCoin Indeed the addresses do not have a public key associated with them at the moment or indeed for the foreseeable future.Most addresses cannot be mistyped into other valid addresses with just the change of one character or one transposition.I estimate that there's about a 0.1% chance that a given address can be converted into another valid address by substituting just two of the characters, so it's not too much of a risk.However, given that the checksum ensures that the addresses are 5 or 6 characters longer than an unprotected address, the guarantees that they provide are far from optimal.  It would be better to employ an error correcting code designed to detect and correct substitutions, insertions, deletions and adjacent character transpositions. It's reasonable to imagine that equally protected addresses using the new scheme might be two characters shorter.It would be an interesting problem to determine which of the bitcoin addresses with known public keys or holding a significant balance are most vulnerable to being mistyped.ByteCoin There are a number of possible solutions to this problem. The best solution from a technical point of view would involve an implementation of the paper I referred to earlier. I gather that you are willing to make changes to the bitcoin client software to enable users to opt into some scheme whereby they are protected even if their computer is compromised.If the computer running the bitcoin client is rootkitted then strictly, it's impossible to trust anything the computer displays or limit what it sends or ensure the security of any information you input. Practically, there are limits to the complexity of software which anyone is willing to develop for a rootkit and so some use of the computer may be possible.Possible solutions are:1) Facilitating the use of an offline secure computer to hold the private key and generate transactions. In this case the engineering effort goes towards implementing an efficient secure communication probably involving copying alphanumeric strings between the two computers. The user has to have another computer and be able securely to install the client.2) Facilitating the use of a third-party website the approval of which (indicated by quoting an ECDS) would be required before transactions of the client could succeed. In this case, the unapproved transaction generated by the client is sent to the website, the website displays what the transaction would accomplish in some hard-to-spoof fashion and the user approves of the transaction via some hard-to-brute-force pre-arranged password or other such token. The website then signs and either passes the transaction back or sends the transaction onto the network itself. This is a solution which requires multisignatures to be enabled.There are other solutions, none of them easy or nice.It would be helpful if you could come up with some use-cases for the private key splitting. What ideally would you like the user experience to be? What degree of deviation and increased complexity from the normal transaction process do you imagine will be tolerable? Is this solution intended to be suitable for crypto-ignorant non technical users of bitcoin?ByteCoin The mailing list is rapidly becoming unusable for 'serious work' too.On the day after the creation of the mailing list.....13 Jul 08:55  Christian Decker "carries over a topic from the forum".13 Jul 09:35 & 10:02  Jeff Garzik posts two replies that could have been aggregated into one post13 Jul 10:03  Christian Decker top-posts to Jeff's entire first email!13 Jul 10:54  Vladimir Marchenko top-posts to Jeff's entire second email!13 Jul 11:49  Christian Decker top-posts to Vladimir's ENTIRE top-posting email!Later on on the 13th there were more posts by Jeff, Vladimir and Gavin which were fine.14 Jul 07:08  Dave Smith top-posts three lines to Mike Hearn's earlier email.15 Jul 15:47  Christian Decker replies to Jeff Garzik's earlier email by quoting it ALL including Jeff's signature(!) and interspersing his comments.16 Jul 17:13  Luke-Jr top-posts 4 lines to Gavin's earlier email.16 Jul 18:24  phantomcircuit bottom-posts 4 lines to Jeff's earlier email.17 Jul 08:12  Brendan Molloy top-posts a one-line question to John Smith's earlier email.17 Jul 14:37  Douglas Huff top posts a one-line reply to Luke-Jr's earlier email including signature.17 Jul 20:37  Luke-Jr bottom posts two lines to Gavin's earlier email.19 Jul 21:54  Doug Huff posts some sort of non-plaintext HTML email.19 Jul 22:36  Doug Huff posts an inconsequential two-line reply to Gavin's entire earlier email including signature!20 Jul 02:34  Mark Visser top-posts to Pieter Wuille's entire earlier email including signature.21 Jul 04:49  Doug Huff posts another HTML email.22 Jul 13:24  Mike Hearn top-posts to Bobby Groff's entire earlier email including sig.Fortunately later today there were some good emails by Bobby, Gavin and Mike.ByteCoin I suggest that a heavily moderated "Best of Forum" subforum be created at the top level. As "Best" precedes "Bitcoin" alphabetically this forum would be the top of the list when you visit http://forum.bitcoin.org/At the moment, certain threads start out as a succession of high quality, information rich, well formatted posts and after a while they get diluted by lots of posts of lower quality. Threads could be nominated for inclusion into the "Best of Forum" section and any replies to the threads would have to meet high standards to be approved. The "Best of Forum" would be the logical opposite of the "Newbie" forum and would serve as an example of good forum contribution and participation. If a post contained worthwhile content but was not formatted, spelt or referenced correctly then the writer would be asked to amend it before it was included. Certain contributors of good standing would have the ability to post new topics directly to the "Best of Forum" but if they abuse this privilege then they would be liable to lose it. Most of the time, contributors so entitled would only choose to do so if the topic was likely to be of significant general import.ByteCoin That's not really true. The clients have to approve of the blocks which the miners produce. If the miners start creating "bad" blocks or if the client is altered to reject certain blocks then it just looks to the client as if that portion of the hashing power has disappeared.If there were any real difference in interests there would be an uneasy truce between miners and clients.Miners need the clients to give their transactions value.Clients need the miners to give their transactions security.I think the clients have the upper hand though as in the past Bitcoin operated without dedicated miners and could do so in future (with appropriate client software changes) if the miners held the network to ransom.ByteCoin  This may be an appropriate thread to mention that the the "checksum" at the end of an address does not effectively prevent single character errors or transpositions.For instance https://blockexplorer.com/search/1ByteCoin shows thatCode:1ByteCoinAddressesMatch1kpCWNXmHKW1ByteCoinAddressesMatch1kpCxNXmHKWare both valid addresses even though they only differ by one character.Similarly, the valid addressesCode:1ByteCoinAddressesMatchcNN781jjwLY1ByteCoinAddressesMatchcNN718jjwLYonly differ by one transposition.ByteCoin Mike, thanks for the explanation. I appreciate the effort you spent to write it up. Could you please add a section to the Wiki explaining "lock time", "sequence number" and "transaction replacement" since these seem to be prerequisites for understanding the Contracts article you wrote.In particular, could you clarify exactly what is compared with the LockTime value to prevent it being replaced and a little word on how LockTime interacts with block chain reorgs in a way that makes it superior to OP_BLOCKNUMBER. You imply in your post that it could either be a time or a blocknumber. How is this distinction managed?What is the significance of the sequence number applying to each input instead of the transaction as a whole?"HashType" such as SIGHASH_NONE, SIGHASH_SINGLE and SIGHASH_ALL could do with being explained.How does CODESEPARATOR work? Doesn't the user also have to send the index of the relevant TxOut if Tx1 produced change? "Inputs" and "sequence numbers". I thought there was only one input, Tx1. ByteCoin As people have pointed out, you'd have to rewrite the block and all subsequent blocks.However, the basic idea is sound. It's true that very large fees would induce rational miners to abandon work on continuing the current block chain and start a new branch which would allow the collection of the fee.In order to encourage miners to work on the new block chain, the miner that got the huge fee would have to pay the other miners for their blocks on the "old" branch which will never mature, as well as cut them in on the remaining profit from the massive fee. As long as >50% of the hashing power feels adequately compensated then the attack should succeed. So the new block which collects the fee would also contain transactions which compensate the miners and cut them in. No special communication or negotiation with other miners is required if they are "fee aware"!The miners in the above scenario act as an ad-hoc cartel for a period of time.ByteCoin 
bji, you appear neither to understand how transactions work, nor how they propagate across the network and you make dogmatic assertions of things that just aren't true.Your "screwing a restaurant" scenario doesn't work as the transaction paying the restaurant owner has a significant lead in propagating across the network. Your "tricking a retailer" strategem doesn't work as the retailer would see the double-spend transaction to yourself and refuse to part with the goods. Your "5 minutes in advance" scenario doesn't work as the retailers "listener" is "tuned" to all transactions and hence rejects your transaction.Contrary to your assertions, accepting small transactions with no confirmations can be made fairly safe.I invite you to prove me wrong by implementing one of your attacks in a reasonable setting.ByteCoin I don't understand what motivation the existing businesses would have to take the other side of the bet.Could you please explain?You need to define what sort of transactions contribute to velocity. For instance, if I take money out of my safe and put it on the table and then put it back in the safe, even if I do this millions of times a second I'm not decreasing its value. I think you'll find that currency conversions also don't contribute.Could you also please explain what you're trying to achieve with contingent blocks? It looks like an option based on difficulty. What does it enable?ByteCoin So, given that the client instantly converts bitcoin bonds on maturity into bitcoins and given that the number of bitcoins in the economy meets a fairly strict schedule, in the run up to the maturity of one set of bonds the bitcoin client would have to know how many bonds were going to mature and adjust the difficulty of the normal block generation so that after they mature, the right number of bitcoins is in circulation. This would probably mess up the block generation rate in the time before maturity and so prevent this implementation of bonds. Block generation provides timely transaction confirmation and anything which harms this cannot be tolerated. ByteCoin The miners should take care to relay their solved blocks directly to the other miners. It's in all the miners best interests to do so. This is true of the current system too.Propagation is so slow in the current network because each node verifies all the transactions and blocks before relaying them. In reality only the miners really need to verify anything. The nodes just need to take adequate steps to ensure they're not either being attacked or being used to attack someone else. There's no evidence to back up the assertion that fragmentation and reorganizations would be inevitable.One would have to change or augment the existing bitcoin system with the new coin scheme. The network would agree to create bitcoins out of thin air in response to the new coin scheme destroying coins and vice versa in a similar fashion to creating coins when mining blocks. Hashing power would be split between both systems and the overall behaviour would be complex. A better, simpler solution would be a replacement scheme similar to bitcoin that would facilitate a higher block generation rate. ByteCoin I have found an article Two-Party Generation of DSA Signatures by Philip D. Mackenzie and Michael K. Reiter which looks very promising.At first glance, adapting the scheme to ECDSA should not be troublesome but implementing it is likely to involve a substantial amount of work. It is, however, vastly simpler than trying to do it using a generic MPC scheme.This should be exactly what you need Gavin.Everyone else should note that implementing this would not involve any changes to the Bitcoin system.It's also worth reading Secure Distributed Key Generation for Discrete-Log Based Cryptosystems by Rosario Gennaro, Stanis law Jarecki , Hugo Krawczyk and Tal RabinByteCoin I presume it's also not acceptable for device 1 to be able to figure out device 2's part of the private key after viewing the completed signature. I've looked into this already for a very similar application and initially I was hopeful too.k is a random number provided by the first signer with the intention of preventing the recovery of the private key d by simple algebra. The second signer would need to incorporate their own random number into the "k" portion of the equation in order to prevent the first signer from deducing their dB by analogous manipulation. However there doesn't seem to be a way of making a signature that behaves like ECDSA without revealing secret information.Now it's Hal's chance to shine by showing how it's done!You can probably create a multiparty signature but it would have to be verified by a different algorithm to the standard ECDSA and hence would be entering worryingly novel crypto territory. The benefit over multiparty signatures implemented in the script would be small.I don't know much about secure multiparty computation but there may be a solution down that avenue but it would be a bit like using a sledgehammer to crack a nut.ByteCoin ECOH was rejected due to a second preimage attackMichael A. Halcrow, Niels Ferguson - A Second Pre-image Attack Against Elliptic Curve Only Hash ({ECOH})I haven't read it in detail, but I believe that they tried to design it so that a birthday paradox attack would fail but the measures they took proved to be ineffective.ByteCoin If you want to use a single address for all purchases and still be able to tell who paid you and also pass secure messages then you need the method described in http://forum.bitcoin.org/index.php?topic=5965.msg87757#msg87757This can be implemented with the current network and client environment.ByteCoin I think the transaction cancelling/superseding issue is one of the most technically complex outstanding issue needing to be addressed.Are you saying that this is something that already happens in the code or is this something you are proposing to be implemented to solve the problem in future?If it is in the code, could you please indicate where?Could you please also be a little bit more explicit as to how the input cancelling would solve the problem?And why only cancel one per day if more are eligible for cancellation?Thanks,ByteCoin The addresses are essentially the base58 representation of the result of the RIPEMD160 hash of the SHA256 hash of the public key point. The derivation of the address from the public key has nothing to do with ECDSA.Your linked article and recent response to my observations make it clear that you are not fully familiar with the cryptography behind Bitcoin. You may wish to learn more so that your opinion can be taken seriously.ByteCoin Bitcoin would not survive a sufficiently serious break of sha256 (such as the ability to quickly find first pre-images) as it would become feasible to generate successive blocks which hash to zero.Your article also only considers the use of sha256 as part of the proof of work. The hashes are also used as a unique identifier for transactions and in the derivation of the address from the public key.ByteCoin Thanks theymos! That makes sense.Questions can be useful if the newbie has taken appropriate care to be clear, concise and neither the question nor the answers have appeared in the forum in any obvious places before.Just to raise the usefulness of this post: I'd like to point out that newbies are posting messages essentially void of any useful content in order to escape newbiedom. This probably decreases the usefulness of the board for the newbies who actually play by the rules making them want to escape etc...I think the current newbie confinement strategy is failing and an alternative needs to be found.How about "Newbies must request whitelisting and their posts are reviewed for usefulness before acceptance"? Similarly, non-newbies should be demoted to newbie if their posts show insufficient usefulness upon review.ByteCoin I've never thought that the number of posts was a useful metric for assigning seniority to members as it encourages people to post even when they don't really have anything to say.However, that's how it's implemented now and we might as well make sure it's working. It's not.Let's pick on Forp. I'm picking on him as he's actually OK and therefore will (probably) not suffer from my drawing attention to himIf we list his posts, at the time of this message he has six but his profile says he's posted 10 which allows him to escape the newbie-zone.Perhaps people should need to apply for "promotion" and their posts be reviewed for usefulness. I'm confident Forp would pass but others.... not so sure!ByteCoin The mainstream client is the only spec that matters at the moment. From serialize.hCode:void WriteCompactSize(Stream& os, uint64 nSize){    if (nSize < 253)    {        unsigned char chSize = nSize;        WRITEDATA(os, chSize);    }    else if (nSize <= USHRT_MAX)    {        unsigned char chSize = 253;        unsigned short xSize = nSize;        WRITEDATA(os, chSize);        WRITEDATA(os, xSize);    }etc...So yes, small numbers have multiple representations.ByteCoin I think it's fair to say that this decision was fairly arbitrary. Possibly Satoshi meant to revisit the design to eliminate other areas where more space is wasted but was already getting fed up with the project and chose to release it before he ran out of steam.ByteCoin I think if you worked the maths through carefully 12 blocks of half the difficulty would actually be somewhat more secure than 6 blocks at the current difficulty.Similarly I think that the current scheme is more secure than 3 blocks at twice the difficulty or one block at six times the difficulty.I think it works a little bit the same way that compound interest using the exponential function is more lucrative than effectively the same rate of simple interest. So 100% simple interest on x after 1 year gives you 2x. 50% interest half-yearly gives 2.25x. 25% quarterly gives 2.44x and the limit is e = 2.7183ishI don't have time to justify this at the moment. Hopefully I will either revisit this topic or someone else will pick up the torch.For the practical purposes above, the difference will be small.ByteCoin This is discussed in http://forum.bitcoin.org/index.php?topic=425.20ByteCoin You can check your solution against these exact answers:0_      738035/1209323521_      586435/100776962_      4301435/201553923_      33057475/906992644_      33616325/1209323525_      1145495/151165446_      737353/181398528I don't think it's a particularly easy problem.An exact formula for the probability of no matches is6^-12 * Sum_{k=1..6}(6-k)^6 * C(6,k) * Sum_{j=0..k} (-1)^(k-j) * C(k,j) * j^nwhere C(a,b)=a!/(b!*(a-b)!)but this is a simpler case than the other numbers of matches.Possibly proper mathematicians have more powerful tools to bring to bear on such problems.Explaining even this simple formula would take quite a lot of work but if you're willing to crack open a maths book then "Stirling numbers of the second kind" would be a good place to start.ByteCoin Essentially the latter. Do I get the money now?Is this a real world problem you're trying to solve? What is the range of the "product variations" and how much do you care (in BTC)  about an exact answer?ByteCoin I have solved the problem but the method would be tedious by hand. If it's an academic problem then there's a better way than mine.No pairs   1 pair   2 pairs   3 pairs   4 pairs   5 pairs   6 pairs0.61%   5.82%   21.34%   36.45%   27.80%   7.58%   0.41%kjj's method cannot succeed. If one party chooses 123456 then we must have at least one match whereas if one party chooses 111111 then there's about 1/3 chance of no matches.This thread should probably be moved to Bitcoin Forum > Economy > Marketplace > BuyingByteCoin
If you view the last transaction in block 110300 you can see it has a line saying "sequence":0https://blockexplorer.com/rawtx/c99c49da4c38af669dea436d3e73780dfdb6c1ecf9958baa52960e8baee30e73This is also true for the last transaction in block 112696, for two transactions near the end of 113341 and the last three in 113599 but for no more to date (block 129000ish)Does anyone know what was going on? I presume someone was testing a non-standard client.ByteCoin I agree that transactions should be able to be superseded. I imagine that calculating fees by analyzing blocks will be a hard problem.That seems unfortunate as when you make the decision to drop a transaction, you're wasting all the preceeding relayer's efforts who made the decision not to drop it. The originator is going to keep resending it as it costs them nothing and next time you may resend it and the next node might drop it which wastes your work.The basic problem is that nodes are not rewarded for relaying and can't be punished when they fail to do so.ByteCoin Your proposal is similar to one presented in http://forum.bitcoin.org/index.php?topic=505.0 which outlines a scheme for having to store as little information as possible.ByteCoin The scheme outlined in http://forum.bitcoin.org/index.php?topic=5965.0 gives much better anonymity guarantees than any solution based on mix nets. Mix nets also inflate the number of transactions needed to transfer bitcoins.There's a strong tendency to succumb to the "not invented here" syndrome when choosing what technology to implement. Fight it!ByteCoin You may be interested in this discussion http://forum.bitcoin.org/index.php?topic=2227.0 in which I show that a mining cartel with about 30% of the total hashing power can win more blocks than it deserves to by delaying their block solution announcements under certain circumstances.ByteCoin Only if you're working in base 6.ByteCoin At the moment addresses are used as fairly ephemeral things and the recommendation is to use a new receiving address for each payment. This limits the utility of vanity addresses and so I don't believe it's worth implementing. This may change in future however as new bitcoin services arise.It can be implemented securely but the method touches on some issues I should currently keep confidential. However it's an elementary problem for any half-way decent cryptographer.ByteCoin Under the current system, if you really wanted to ensure that all miners had a fair stab at any fee-containing transactions you could change the majority client software so that it did not relay a block containing fee paying transactions it had not previously seen.Miners have free reign over what they include in a block, the only censure available to everyone else is not to relay their blocks.At the moment, clients are catholic in their acceptance of block contents. This is to prevent rule-based block chain forks which would be painful to reconcile and extremely damaging to the bitcoin enterprise.ByteCoin  Note that it's cheap for a miner to rack up fees artificially (using the above terminology) by including a transaction with a large fee in the block he's trying to hash but not distributing it across the network so that other miners can't get the fee if they solve the block first.ByteCoin There have been some non-standard transactions over the past few days created by adding an OP_NOP to the script.They are functionally equivalent to normal transactions but confuse theymos' Bitcoin Block Explorer somewhat.https://blockexplorer.com/b/127630https://blockexplorer.com/b/128239Did anyone see how long it took for them to be hashed in a block?I use http://bitcoincharts.com/bitcoin/ to look at pending transactions. It might be handy if someone kept track of the amount of time a transaction has to wait to get into a block as the information will likely prove interesting and is not obtainable in retrospect.ByteCoin The problems you outline presuppose that the miner is trying to include as many transactions as possible. The miner can just shun transactions that use inputs it has forgotten. Unless these transactions contain substantial fees then the miner is not losing out significantly. The underlying problem is that the incentives for miners to include transactions are currently weak.Taking the "miners forgetting transactions" to its logical conclusion, you could probably run a miner in the current bitcoin environment that neither verifies signature nor stores the block chain. It would assume that all incoming transactions are correct as they have probably been verified by someone else. To prevent an obvious poisoning attack, it could maintain more than one separate anonymous connection to the network and only accept transactions that appear on both. ByteCoin Using my amazing elliptic curve discrete logarithm calculating ability I deduce that the private key which generates the public key points Code:FF5443FCD00B8F3844569DCAA42662D90E0C8AFB1FE35804C320E5BB08EA6DAD        C3231767AA13B9DD6ABCB45A8CD0497490D5C2A78FF85EA61711394B3B08E5C9in the above wallet isCode:44b1585492c83e83fd917783c1b74ec25e3e6b3ca8722cc41eabe05249a46288which doesn't look noteworthy.I'm not sure what all the rest of the wallet dump is but the first longer run of FFs looks like the modulus for the finite field and the second run is probably part of the group order.Nothing to see here. Move along.ByteCoin OpenSSL creating private keys with low entropy would be surprising.Could you (benjamindees and John Tobey) please post some unimportant private keys and point out the features you think are noteworthy?Thanks in advance!ByteCoin That's a very interesting claim considering that the a 512 bit factorization would come in at number 5 on the GNFS records page on http://xyyxf.at.tut.by/records.html#gnfsIf you can really factor 512 bit numbers trivially, then the project would greatly benefit from your ability.Please let me know the size and weight of an average matrix for the linear algebra step for your 512-bit factoring program.Even using the British "billion" = million million, 4 billion operations is less than a 42 bit keyspace. Please outline the attack you have in mind.ByteCoin See http://forum.bitcoin.org/index.php?topic=5965 in which I explain how to get very good anonymity using the existing infrastructure. Inter-client communication could be encrypted and, as transactions involve only small amounts of data, they could be hidden among some padding to thwart traffic analysis. ByteCoin So jontobey253 outlines a way of "rebooting" the currency. Fortunately, people supporting this move can already achieve the same effect unilaterally using transaction "shunning" as outlined in http://forum.bitcoin.org/index.php?topic=3441.msg50075#msg50075If you think that people who were mining when the difficulty was low have unfairly acquired their bitcoins and you wish to take them out of the economy for some reason you could check that any payments you and your supporters accept (and obviously make) have never used any of the coins mined during the "too easy" period. If someone tries to pay you using these old coins or any transaction which was derived from the old coins then you return them and explain why they are not acceptable.If sufficient people agree with you to shun certain coins then they are effectively unspendable and are removed from the economy even more effectively than if the associated private keys had been lost.ByteCoin You could also launch a differential power analysis attack on the site by sending a carefully crafted flood of transactions and correlating it with the fluctuations in the share price of the local electricity company.Because of the lack of reuse of keys, the number of signatures that are likely to be generated with a particular private key is small. This would make any remote timing attacks hard even when all other conditions are ideal.The key point is that cryptographers must be aware of possible side-channel attacks on a particular implementation and appropriate steps must be taken to thwart them.ByteCoin  Good work! I hope I'll get around to checking it soon. One complication - Although you can throw away the transactions, you have to keep the Merkle hash tree stubs so that's roughly 32 bytes per transaction (because the tree height is low) which you have to store.ByteCoin I perceive that the number of posts that one has to read to come across any useful content has increased dramatically over this year.I'm very suspicious of such perceptions however as a reasonable explanation would be that my perceptions have changed while the forum remains the same. Now normally "me too" responses are exactly what I wouldn't want to see in replies but in this case I'm soliciting opinions on whether it's just me or if there's a real problem.If it's a real problem then what's the best way to fix it?ByteCoin You meant the exact opposite of what you said.Correct. A suitable problem would have to have at least the properties outlined in this posthttp://forum.bitcoin.org/index.php?topic=203.msg3669#msg3669ByteCoin
I think that certain people have conclusions they like to jump to and they do so without properly reading the post they are replying to. It's also easy to infer criticism or an attack where none is meant.Nobody is seriously suggesting anymore that one can prevent using the bitcoin chain to store data. People want to store data in the block chain to implement certain functionality and if we can facilitate the functionality by some other more convenient method then they will use that instead. Alt-chains attempts to do that.[mike]'s proposal boils down to having miners who support alternative block chains incorporating a hash for one or more block chains in the coinbase transaction for the bitcoin blocks they're mining. One drawback is that the people distributing the generic bitcoin client could pull the plug on all the alternative block chains by having their client reject blocks which have a non-standard coinbase. As alt-chain-compatible blocks would not be accepted and relayed by clients, the alt-chain supporting miners would essentially drop off the network. The bitcoin network would experience a drop in hashing power as these clients left but would otherwise continue unaffected.I don't know whether the possibility of this kill-switch would be acceptable for the alt-chain users.ByteCoin I presume you actually meant the exact opposite of what you said.DER is "common" or "the same" across all implementations. Edit your post and I will delete this one.ByteCoin What stops an attacker who intends to fork your non-bitcoin block chain from sending their incorrect hashes "to Bitcoin"?What exactly does "make an RPC to BitCoin" mean? What is "BitCoin" in this context? I presume you mean a particular bitcoin miner who has implemented the "support non-bitcoin chains" option.How does the bitcoin node you're talking to know that it's getting a legitimate extra hash rather than let's say a portion of some illegal kiddie porn?Who on the non-bitcoin chain has the responsibility for and authority to talk to the bitcoin node? Everyone? - a lot of spam for the bitcoin nodeOne node? - single point of failureThe way your explanation is drafted makes it look like the non-bitcoin chain is limited to one transaction per bitcoin block. I presume you mean to expand the scheme to support rolling non-bitcoin transactions into non-bitcoin blocks and then getting hashes of those into the bitcoin block chain somehow. Could you expand on exactly how this would work?ByteCoin It's a requirement that clients support the downloading of the blockchain for new vanilla clients connecting for the first time. If you delete transactions, this breaks.You presume incorrectly that because you can identify where the information is stored, you can delete the transactions with impunity.At the cost of some storage inefficiency I could create a scheme using error correcting codes that stores a file in the block chain which would rely indistinguishably on some innocent transactions (not party to the file storage scheme) and a majority of file storage transactions. If you wished to delete some transactions to prevent the recovery of the file you would run a grave risk of deleting some innocent person's unspent transactions. I believe the odds could be made rather bad for you.Suppose the file is stored using equal amounts of innocent transactions, indistinguishable storage transactions and indistinguishable error correction transactions. You'd have to delete a third of the total transactions to render the file unreadable. The chance of deleting an innocent transaction is high.Also, deleting transactions doesn't stop people storing data in the merkle tree stubs as I mentioned earlier.You have not shown how the file storage chain can benefit from the Bitcoin chain without substantial invasive changes to Bitcoin.If I am wrong, please clarify in the relevant thread how your scheme achieves this and sent me a private message with the link and I will change this post.ByteCoin This is incorrect.Information storage transactions with a non-zero balance can only be pruned after they have been spent. Don't spend them? They stay forever. Any suggestion to prune unspent transactions is likely to be unpopular.When do you imagine is this "fairly near future" in which transactions will be pruned? The network protocol has to be changed substantially to facilitate pruning. I imagine that converting the majority of the network to pruning clients will break the old clients.If you ensure that your transaction hashes to a certain value then you can store information in the block chain (on a probablistic basis) even once the transaction has been spent and pruned. With the low height of the current merkle trees, this would be quite reliable. ByteCoin Ok. You've probably covered this elsewhere but for those new to this concept, could you please explain why your device doesn't do the following:Create a signed transaction crediting the merchant using the details supplied by the merchant. Give the merchant the signed transaction which the merchant then checks and distributes to the bitcoin network like a normal transaction.This would remove the need to trust any third party with your bitcoins.ByteCoin I'm starting to see posts which REALLY don't have any significant content where the signatures have advertisement links. Presumably this is to try to increase the rankings of the links in Google or other search engines.I propose that links in signatures or the ability to post links at all be disabled for new users.ByteCoin Under this scheme the block reward drops from       50 by 0.01 every 7 hours.After about half a year the block reward drops from 44 by 0.01 every 8 hours.Half a year after that the block reward drops from   39 by 0.01 every 9 hours.About 5 months after that the reward  drops from   35 by 0.01 every 10 hours.Four months after that the block reward drops from 32 by 0.01 every 11 hours.ByteCoin I've been reading that paper. They seem to be using a slow modular inversion routine that runs 150 times slower than multiplication and also a point multiplication routine that involves many inversions. From this, it looks like they're using affine coordinates rather than projective for the point multiplication. This is a serious shortcoming.I would hesitate to use that paper to support an argument.ByteCoin Has it been established exactly what we're trying to achieve? It seems like a reputation system has been implemented possibly in the hope that it will "improve things" but even this is not made clear. How do we establish whether having ratings is better or not?Personally I have the following problem; there are too many posts (especially "me too" or other lightweight posts) to read in order to stay informed about the good ideas. Reading the board now takes too much time.I'd like to be able to nominate (without their knowledge) certain people to recommend posts to me. The recommenders would know only how many people rely on their recommendations as an incentive to keep recommending posts. I would not want to see any posts which had not been recommended. Recommended posts would have the names of the people who recommended them so I could add/delete recommenders on that basis. I can recommend posts myself and get statistics for who recommends in a similar fashion so that I can add them to my list.I know ARS doesn't do this but could I set all posts below a certain reputation to be already read?ByteCoin Great post! Research done, code posted, graphs comparing two schemes. [ + ]It seems clear to me that your scheme is vastly superior to the current scheme. Just imagine if your scheme was the one implemented from the start. Anyone proposing a change to the current situation would be ridiculed.Your scheme is superior as it doesn't subject the bitcoin economy to a sudden shock. I believe the collective anxiety in advance of the change (to 25BTC) will be the cause of much more wasted effort than any adverse effects of the change. Your scheme avoids both the anxiety and any adverse effects.I doubt that a nicer function than the one you chose can be found. What qualities would it have to enjoy for it to be superior?I think it's a very good candidate for being included in any future breaking-change releases.If it was implemented as you have shown, could you print out how the block values would decay for a few of the immediately following blocks please?ByteCoinPS. I predict that people will complain that the areas under the graphs for the current scheme and the new scheme do not look equal. test That would be an improvement. Can it be easily implemented?Does anyone know what functionality this rating system facilitates? I haven't been able to find any documentation on what it can do.ByteCoin I surprised myself with how upset I was when I saw someone had given me a negative vote. I can't really think what I've done to deserve it. Then I saw that theymos had -2 and instantly felt a lot better!The temptation for the mods to see who's rated them negatively must be overwhelming.ByteCoin I managed to retrieve some of the posts. Can anyone get the rest?I wonder why he deleted them from the forum. Had the rating system been around somewhat sooner, I would have upvoted him.ByteCoin1     Bitcoin / Bitcoin Discussion / Re: Gavin will visit the CIA    on: April 27, 2011, 07:17:39 pmQuote from: gavinandresen on April 27, 2011, 07:00:26 pmPS: Full disclosure: I'll be paid a one-time fee of $3,000 to cover expenses and pay me for my time.  I don't want any "Gavin is on the CIA's payroll" rumors to get started, either...It would be true.  Smiley  But of course that doesn't mean it's nefarious.2     Bitcoin / Bitcoin Discussion / Re: Alternative protocols to Bitcoin    on: April 27, 2011, 07:15:26 pmQuote from: s on April 27, 2011, 04:35:47 pmThe fact of transactions couldn't remain private, and maybe I've overstated the difference between Bitcoin and what I'm describing in that regard.  I suppose one difference is just that fragmentary validation of a transaction among a private community is more explicitly supported by my model than Bitcoin, which would treat it essentially as out-of-band swapping of wallet.dat-type information.  There are a handful of other differences in what might be exposed, but those are mostly a matter of implementation detail.Actually, one advantage that's interesting, perhaps, is that you needn't publicize anything about the recipient.  Of course, you needn't in Bitcoin either because the address can be generated for a one-time use, but this alternative could accommodate simple static recipients without disclosing to the public that you've paid them.  All you'd need to do is give them possession of something they could broadcast at their will, anonymously if desired, to invalidate your copy of the coin.3     Bitcoin / Bitcoin Discussion / Re: Alternative protocols to Bitcoin    on: April 27, 2011, 04:35:47 pmQuote from: eMansipater on April 27, 2011, 02:16:10 pmYou still need an authority to do the timestamping--it's true that having one trusted authority could replace the blockchain, and thus you could definitely have a state-issued bitcoin version that gained wide adoption and was comparatively cheap to run, provided the trust could be maintained the same way a state has to maintain trust in a physical currency.  The advantage of bitcoin is essentially just that no such trust is necessary given any significant degree of adoption.But I don't see how transactions could remain private without a trusted repository.  It's true that a receiver would only have to publish their "proof of already spent" token in the event of seeing another spend of the same coins, but to transfer that right to the next owner they have to hand them the whole transaction history--keep in mind that since coins need to be split and combined this quickly means most users have most of the history.  And anyone in the history of a coin can force the publishing of the complete chain just by spending the coins to the general repository.  You also need some incentive for people to store this data, so I'm not sure how this would work economically.Thanks - Excellent thoughts. I'm not sure that timestamping is actually necessary in the model I'm describing because the verifications themselves provide a sequence.  You don't care about the cardinal times, just the ability to verify the sequence.The fact of transactions couldn't remain private, and maybe I've overstated the difference between Bitcoin and what I'm describing in that regard.  I suppose one difference is just that fragmentary validation of a transaction among a private community is more explicitly supported by my model than Bitcoin, which would treat it essentially as out-of-band swapping of wallet.dat-type information.  There are a handful of other differences in what might be exposed, but those are mostly a matter of implementation detail.The incentive-for-storage question is the most serious thing I haven't yet fully thought through.  The real general question, I suppose, is whether the fees (in economic terms, the transaction costs or friction) of this model or of Bitcoin's would be lower in the long-run.  Or perhaps incentives aren't important in this particular regard; I don't always accept on faith that they are, and even some of the very early Bitcoin discussions suggested that maintaining the integrity of the network would be a useful ("altruistic") motivator.Thanks again.4     Bitcoin / Bitcoin Discussion / Alternative protocols to Bitcoin    on: April 27, 2011, 01:43:29 pmI'm impressed with much of Bitcoin, but several features of its design, while the product of sensitive and thoughtful tradeoffs, could perhaps be problematic in the future.Just as a matter of technical exploration, it's important to recognize that most features of Bitcoin's protocol exist to address the double-spending problem.  If it weren't for that problem, the design of Bitcoin could obviously be much simpler.  Considering simpler (obviously unworkable) such designs may point the way to a solution that serves some of Bitcoin's functions but addresses some of its problems.  If the double-spending problem didn't exist, you'd simply need a way to (1) generate scarce units of the currency and (2) prove that you held those units.  To generate (or "mine"), any problem that takes processing resources to find needles in haystacks suffices; the current one is fine, and others with potentially positive externalities (e.g., research benefits) could be considered too.  To prove ownership, you'd simply demonstrate that you found the needle in the haystack.That's all that's at the core of a trivial system that doesn't address double-spending.  Bitcoin is, conceptually, one solution to that problem, but it depends on an arguably cumbersome mechanism to agree on a master sequence of authoritative blocks; the peer-to-peer network is harnessed to substitute for trusted third parties specifically by allowing the network to vote, essentially with processing power, on what that master sequence is.  But there are significant problems with this mode.  One is just its cumbersomeness; this probably can be addressed and its fatal, though in practice it will increase the transaction costs associated with using Bitcoin in the future and thus, at least potentially, undermine some of its goals.  Two probably more significant problems are, as is widely recognized, that (1) any system that needs to agree on a canonical sequence of blocks in the manner of Bitcoin's protocol subject to a trivial denial-of-service attack by those with significant processing resources, (2) a record of all transactions is public, which leaks more information about people's private affairs than, perhaps, is necessary for a system that serves Bitcoin's roles.So, start again with the trivial approach I outlined earlier that doesn't address double spending.  The appropriate question to ask of that approach is whether there's a way to graft protections against double-spending onto it without requiring a master block chain defended only with processing power.  There ought to be many answers to that question that avoid some of Bitcoin's potential problems.  Here's a sketch of one, based on the recognition that you don't need a master block chain, just a probabilistically sound portion of a distributed public-key infrastructure (PKI) with the opportunity to verify revocations.  Consider:  I find one of (say) 21 million numbers (out of whatever N is necessary to make the task appropriately difficult; "difficulty" need not be static in the system I'm describing, but let's assume it is for simplicity), and then sign this number with a private key and a timestamp, thus proving that I found it first.  Before I spend it, all that's necessary to verify that I "own" the number (coin) is to (1) verify my public key and (2) verify that nobody else has a verifiable claim to have found it earlier than I have.  Satisfying (1) is trivial and doesn't require any infrastructure; satisfying (2) can work using any distributed-storage mechanism, and it simply requires the ability to broadcast information and some level of reliability in receiving the broadcasts.  It doesn't require comprehensive agreement; just as a vendor can accept a dollar bill without being absolutely sure it's counterfeit (and can never know for certain, epistemically speaking), a seller can accept an electronic certificate of ownership after satisfying itself using whatever publicly available information (imagine a collection of Wikileaks-type sites, some in the open, some on Tor, etc., each accumulating whatever information people want to broadcast about these coins).  This will sound less reliable than Bitcoin's verficatory mechanisms because I'm emphasizing epistemic uncertainty, but it is not less reliable conceptually, and whether it is less reliable in practice is an open question.The above sketch is still incomplete for at least one particular reason, which is that it allows merely mining and initial spending, not respending. But that can be addressed securely using a similar mechanism:  to "spend" a coin, I simply give the recipient something he can use to prove that I spent it and gave it to him.  Double-spending is presented merely by adding a verification that nobody has a verifiable claim to have received the coin I'm presently attempting to spend.  The validation is through any (or many simultaneous) distributed storage systems.  None has to be perfectly reliable or canonical, but together they can be reliable enough to satisfy any realistic level of epistemic caution on the part of the borrower.  And all that's necessary is broadcast:  there's nothing to verify in any of these steps other than "has someone else spit into the public domain something that is a superior claim to spend this coin than that of the person who is communicating with me now?"I'm not saying the system I'm describing is perfect, but note some of its advantages:  (1) it is not subject to "overpowering" except in the sense that any online system can be subject to simple spam-like denials (e.g., terabytes of putative revocations), but there are probably ways around that problem; (2) it is as resilient as Wikileaks, which, importantly for the technical purposes I'm describing, is far more resilient than Bitcoin is, at least conceptually speaking; (3) transactions are private and only need to be publicized to the extent the parties wish to do so; indeed, even a miner need not immediately "claim" scarce resources of currency and can choose to take a statistical risk that someone else will mine the same currency and claim it first, depending on the miner's preferences as to finance and privacy.(My background is in cryptography, security, and economics, not specifically in peer-to-peer networks, so it's possible I've overlooked something relevant to the implementation of a distributed system.  But I don't believe there's an irremediable flaw in the system I'm describing, and I think it at least possibly presents some advantages over Bitcoin.  In practice, of course, just as with Bitcoin, partially trusted intermediates can arise on a voluntary basis, addressing many of the concerns that I suspect will seem practically most obvious to readers of this forum, though it's important to recognize that the protocol's epistemic concerns are not necessarily significant just because I'm emphasizing their possibility in theory.  If it helps, remember that we know nothing empirical for certain; when I speak of doubt I'm speaking of it in literally that sense.)I would be happy to consider developing a system based on these principles if there's interest and if nobody points out significant flaws that I haven't recognized.5     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 26, 2011, 06:01:50 pmQuote from: goatpig on April 26, 2011, 05:09:46 pmFirst of all, if an attack is easy to perform, a truly concerned party would present an isolated experiment reproducing it instead of speaking of conjecture. Second, such declarations and the weight they carry gives the right to the contributors of this post to ask about your motives, but somehow you brush those as irrelevant. And lastly, your point isn't realistic. What you are saying is akin to presenting society as fragile because a detractor of said society can walk in the streets shooting people dead for the price of a single gun.You're just not understanding me, so I don't know what else to say.  Your English is far better than my French, so I can't criticize you too pointedly.Maybe someone else here has understood.  If not, no big deal; eventually the market will work it out, more or less.  In any case, I'm on to other things and won't be reading followups.6     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 26, 2011, 04:35:38 pmQuote from: goatpig on April 26, 2011, 03:47:00 pmHave you considered the possibility that as an outsider, you are the one that is less informed, than let's say, founding and early members of this project? Have you also considered that your grasp of the technology used in this project is not at the stellar level you're fancying it? I giggled when you mentioned using a DOS attack on a p2p project...One last comment, just on the chance that there might be some progress here:Your "giggling" is immature and misinformed, because you're not actually reading what I'm saying and instead assuming that I'm saying incorrect things.  Maybe other people often say incorrect things, and backed by Bayesian probability you're jumping to the assumption that I'm one of those people, but I'm not.If you think Bitcoin is not subject to a denial-of-service attack just because it's a peer-to-peer network, reread Satoshi's paper, which explicitly points out the DOS opportunity.  Or believe Gavin, who has said "Bitcoin's p2p network is subject to various kinds of denial of service attacks. There, I said it," and "Bitcoin is still vulnerable to DOS attacks.  I'm not sure anybody knows how to prevent DOS attacks on a p2p network that allows untrusted/unverified peers to join."  That's the same point as mine, which is that the openness of Bitcoin's network is not just a strength but also a weakness.I never even claimed that I'm saying anything new, here, about a DOS attack against Bitcoin.  What I've said is that the attack is cheaper, in the present situation, than many people seem to think, and that the cost does not necessarily relate -- in the real world, rather than a hypothetical frictionless market -- to the capitalization of the Bitcoin market.Nobody's actually said that's wrong.  But immature people call that a "trolling" comment, and you in particular seem to be incapable of reading what I'm saying rather than just making incorrect assumptions about it.  I don't know if it's a bad attitude, a reading-comprehension problem in English (your syntax and style strike me as natively French, for what it's worth), or just immaturity, but it's counterproductive to real people trying to offer real analysis.  You don't have to believe me, but my contributions to open-source software go back more than 10 years, and I have designed significant cryptography-based security systems; I'm likely more experienced in these matters than Gavin, though of course not nearly as committed to the project.  And nobody here has given me any reason to be.  The social community behind a project is quite important to me; I already have more than enough money and recognition, which is why I'm contributing pseudonymously.  (I am not, like apparently many here, someone who has been marginalized by the existing economy.)Note, again, that Gavin is not disagreeing with anything I'm saying here; he's made the technical point himself before, and I'm just adding the economic observation that the (already recognized) attack is relatively inexpensive, both in real-world terms and as a matter of proportionality to the market capitalization of the Bitcoin economy.7     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 26, 2011, 03:14:10 pmQuote from: rezin777 on April 26, 2011, 02:37:02 pmQuote from: s on April 26, 2011, 03:16:13 amI can't stand the overuse of the word "troll" in these contexts; it's just extraordinarily annoying schoolyard-type bullying.  Save the bitterness for people who are actually doing something objectionable, please, and simply ignore an analytical argument if you don't find it interesting or helpful.  If you don't want to be called a troll, don't make such trollish suggestions.Quote from: s on April 26, 2011, 12:56:41 amif it's being used to trade only a bit of LSD or child pornographyThere is a wealth of intelligent people on this forum finding new and interesting ways to trade and promote bitcoin and this is what you come up with?You're clearly not interested in paying attention to the substance of what I'm saying, so I'm done here.  The tone and pseudointellectual disposition of most of the people on this forum are absurd; it's like speaking to 17-year-old libertarians who think they're geniuses or mentally ill Randists who see themselves as underappreciated innovators.  You're just not reading what I'm saying, and you're quoting isolated fragments out of context to confirm some view you have of me that's entirely incorrect and unfounded.Far more intelligent commentary about the economics and social forces that affect Bitcoin is available at external forums, for anyone interested in speaking to adult-minded people about the topic.  For example, see the following thread, which anticipated most of the discussions I've had here (including my own comments) by several months:  http://www.bogleheads.org/forum/viewtopic.php?p=959393.That's how adults talk about the topic, rather than unimaginative followers who think they're innovators or people who don't know how to read.  I was pointing out an analytical approach you could learn from; you chose to ignore it.  Bye.8     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 26, 2011, 03:16:13 amQuote from: rezin777 on April 26, 2011, 02:06:44 amI do wish you would stop pontificating about the weaknesses or flaws of the bitcoin network and either attack it directly or promote something superior. Otherwise you come across as nothing more than an educated troll.Where do your motives lie sir?I don't understand this sort of personal attack and find it extremely annoying and distracting.  I'm offering analysis.  My motives aren't relevant, but I've already expressed my view as (1) impressed, (2) practically skeptical, and (3) morally skeptical.  I don't have to commit to pay significant money to mount an attack myself in order to point out that it's easier for others to do it than it typically supposed, nor do I have anything superior I'm interested in promoting.  I can't stand the overuse of the word "troll" in these contexts; it's just extraordinarily annoying schoolyard-type bullying.  Save the bitterness for people who are actually doing something objectionable, please, and simply ignore an analytical argument if you don't find it interesting or helpful.  I suppose I should be happy that at least you consider me "educated."  Smiley9     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 26, 2011, 12:56:41 amQuote from: creighto on April 25, 2011, 11:57:20 pmThis is not so.  The function of the Bitcoin network is to be the transaction processing agents (Visa, PayPal, banks) but a central bank does not exist for this function.  The central bank exists to manage a fiat currency, and the management of Bitcoin is in the codebase.  No attack that fails to change a majority of the running codebase of the p2p network has near zero chance of long term success.  All such attacks are either local in scope (double spend, affecting the vendor who is defrauded), limited in time (blockchain fork) or both.  If you can't change the codebase, you can't "manage" the currency, and any changes that you make to the protocol are destroyed after you lose your majority cpu power status.  Which could happen in very short order, as there is an unknown amount of reserve hashing power that could be convinced to come online in defense of the honest network even at a loss.  I am one such person.  If a credible attack of the system were underway, and I was aware of it, I'd be more than willing to hash at a loss.  I'm sure that I'm not alone.It's just hard to imagine the reserve hashing power more than, say, doubling the existing "committed" hashing power.But just to be clear, nothing really depends on my calling this function one of a "central bank"; it's just semantics.  I'm trying to frame the importance of the attack.  If someone could highjack the Federal Reserve for a year, stepping into their shoes and fulfilling their powers, I'd idiomatically say that they'd acquired the powers of the central bank for the US dollar, even though those powers are not permanent.  But again, it's just a debate about terminology and I don't mean to dwell on it.Quote from: rezin777The depth of the attack doesn't seem to sink in fully for you. If it's not hard, anyone with a bit of brains should have proceeded to initiate an attack at this point. When bitcoins are trading for 1.55 USD each, someone should be motivated? Perhaps you should read the paper again.I say this as someone deeply impressed with the design of the protocol and the software, but I think the reason is just that nobody cares to mount such an attack so far.  It's only a few thousand people participating, and the Bitcoin economy doesn't really have even $9 million in it (that's just the market capitalization - the clearing price multiplied by the number of Bitcoins); even if it did, that still wouldn't be worth most governments' time.  A small-scale protest in San Francisco costs more and involves more people than Bitcoin does at this stage.And I doubt anyone's yet using Bitcoins for anything that authorities care about, really; if it's being used to trade only a bit of LSD or child pornography, law-enforcement resources likely won't divert toward that use when there's much lower-hanging fruit.  This is what I mean by saying that there's a bootstrapping challenge that Bitcoin hasn't faced yet: the challenge is how to resist populist pressure when that populist pressure can directly destroy it, for technical reasons -- not just politically or through external enforcement actions.Stillfire:  Your concerns are thoughtful and important.  Regulation does pose direct threats to Bitcoin, particularly if it concerns the conversion of Bitcoins into other currencies rather than merely access to the P2P network.  But regulation is slow and difficult against peer-to-peer networks, whereas denying service to them through technical means is actually rather straightforward, at least when they function like Bitcoin.  (It's harder with Wikileaks or other services that merely broadcast information.  It's very hard to deny service to that using technological means.)  If I'm saying anything new at all in this thread, it's that "regulation by DOS attack" is much easier than people seem to be giving it credit for; "P2P" doesn't magically invalidate the ability of regulators, and the degree to which it does needs to be evaluated sensitively on a case-by-case basis.I believe, as a side note, that some of my math earlier in this thread is off by a decimal place, as I promised it would be. Smiley  I should be saying $1,000,000 at today's statistics, not $100,000.  But that's still petty change to a regulator, and notably it's far less than the market capitalization of Bitcoin.  Again, importantly, the cost of the attack grows only proportionally to the hashing power of the network.  Also, that's just the acquisition cost; the hardware could be resold or reused after the attack achieves its purpose.10     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 11:50:43 pmQuote from: stillfire on April 25, 2011, 11:43:37 pmObviously if the majority (the 'populist will') switched their clients to do something non-standard they could change the truth of the network. That's what I described in my social attack post. I would not describe that as unrecognised though given that the whole system is founded on the idea of "one CPU, one vote".Right, I haven't meant to say that it's unrecognized, just that the implications are insufficiently recognized.  Maybe I should say it this way:  the attack is much easier, in practical economic and technical terms, than people seem to suppose.  I don't think I'm offering anything theoretically new, just a pragmatic framing of the problem and a tying of it to the threat some people perceive from governments.  A government hostile to Bitcoin doesn't need to stamp out P2P technologies generally; it just needs to deny service to Bitcoin by taking it over.The fragility hasn't seemed to sink in fully.  Surely many understand the conceptual possibility of the attack; I don't mean to suggest otherwise.  I'm just pointing out that if it's not that hard for a single relatively wealthy individual, much less an organization, to destroy an economy, the economy is probably more ephemeral than people imagine.11     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 11:44:11 pmQuote from: grondilu on April 25, 2011, 11:38:14 pmStop talking about "the central bank of the bitcoin economy".  There is simply no such thing, apart in your mind.There could be a large collusion of attackers, but since they would try to disrupt the bitcoin network, there is no way we can call them "the bitcoin central bank".    In a centralised economy, a central bank is supposed to organise and protect the economy, not to destroy it.The function of the central bank is provided by the network; controlling half the network's hashing power confers the powers of a central bank.  The rest is just semantics, I think.And many people say the function of the Federal Reserve is indeed to destroy the US economy.  Smiley12     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 11:31:45 pmQuote from: creighto on April 25, 2011, 11:21:22 pmAre you refering to the attack vector that requires over 50% of the hashing power of the network, with the intent of overwriting recent blocks?  The forced double spending attack?It isn't limited to that problem.  Satoshi noted it clearly in his original paper:  "While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network."  Nothing stops the attacker from overpowering the network except people committed to Bitcoin, making the central bank for the Bitcoin economy subject to populist will (mediated through, of course, the need to purchase and deploy mining hardware and alternative P2P participant software -- it's not "one person one vote," but it's not far from "one dollar one vote").  I'm suggesting that this is a serious and insufficiently recognized problem for a currency meant to be in some sense an alternative.QuoteI'm not sure this is a correct way to see things.  Spending money to do something is not an other way to say that you buy it.  Well, in my dialect, "for sale" is just an idiom.  If my loyalty is "for sale," it doesn't mean you buy it forever.  But I don't mean to dwell on the phraseology if it doesn't work in your dialect.  I should state it more precisely and more technically anyway:  the power of the central bank can be taken over by those willing to pay for it, and the cost of such a takeover is very low and needn't be bound to, for example, the market capitalization of the Bitcoin economy.13     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 11:17:09 pmQuote from: creighto on April 25, 2011, 10:42:06 pmQuote from: s on April 25, 2011, 10:31:09 pmQuote from: creighto on April 25, 2011, 09:54:44 pmSure it would.  The first transaction in every block is the special transaction that gives the miner his 50 bitcoin reward.  If every light client were checking that transaction to keep the miners honest, there wouldn't be any way to collude, as the lightweight clients would reject the blocks themselves and keep searching the Bitcoin network for blocks that used the proper reward amount.But the attack I'm describing isn't just "incorrect rewards for false mining"; the blocks themselves would be valid Bitcoin blocks under the attack we're now discussing, given the attacker's hashing power compared to that of the network.What am I missing then?  An incorrect mining reward invalidates the block.  Presently, full clients do check for this, and violators are ignored.  The net effect being that it doesn't matter how much power the colluding violators throw at the problem, the honest network simply ignores anything that they come up with.  The violators can, presently, either mine honestly or attempt to rewrite the recent blocks of the blockchain, but that's a different attack vector.  The claim that I saw basicly says that the collusion problem is because future clients will be dominated by lightweight clients, which presumedly wouldn't pay any attention to the actual blockchain reward; and this would permit a small cabal of well heeled miners to collude into changing the rules and segmenting the other honest miners into a minory blockchian because the majority of clients would blindly accept blocks produced that were invalid due to an overly high block reward, but reject the minority chain being produced by the honest miners that remained because they would have a shorter proof-of-work chain.Yet, if the lightweight clients even occasionally check the validity of the block reward, or even only a fraction of smartphone clients did this; the attack is undermined.How am I wrong?We might just be talking about two different things.  The article by Lee discussed at the start of this thread laid out several high-level possibilities without much technical detail, and though they could loosely be important under some future scenarios, they're not my chief concern.  What I took us to be discussing now is separate and more specific:  the relative ease and cost of an attack on the Bitcoin network by entities that simply bring higher mining/hashing power to the network than those who want to use Bitcoin for any of its potentially useful purposes.  It is effectively a denial-of-service attack that any moderately sized entity or government (or even individual) could mount easily at present to crush Bitcoin entirely, and though Satoshi's paper mentions its possibility and it's been known and discussed for several months in some other public forums, it doesn't seem to be in the mainstream knowledge of the official forums.I take it to be a serious problem and perhaps the most serious technical weakness of the protocol in the real world.  The practicality of the attack doesn't seem to have sunk in fully:  a single person, or more realistically a small interested entity, with a few days and $100,000 to spare could effectively crush Bitcoin.  And even as Bitcoin grows (as measured by "honest" hashing power -- a clearer term for these purposes would be "hashing power committed to Bitcoin's success"), that cost grows only proportionally, not even quadratically, much less exponentially.Of course, others have spoken since the beginning of a multiplicity of block chains, of the fragmentary survival of Bitcoin in various forms, and so on.  That is of course all possible; the attack I'm concerned with is not a threat against the protocol as an idea.  But it could very easily crush, essentially at will, what people perceive as the "main" block chain and whatever Bitcoin-denominated wealth is inherent in it.  To frame it differently, a debtor who owes more than $100,000 Bitcoins would never have to pay it back; it would be cheaper simply to destroy the network.  And, of course, the network needn't be destroyed for the value of Bitcoins vis-a-vis other currencies to plummet; it just needs to be credibly threatened.  I'm no expert in securities markets, but I would be very surprised if the current Mt. Gox prices, as thin as the market is overall, have fully priced in this threat.  In other words, if I were buying 1000 BTC with USD, I would explicitly be taking a $1500 or $1600 bet that this attack would not be launched -- that $100,000 or so would not be committed in a particular way.Another way of putting the attack, in more clearly economic terms, is that in Bitcoin, the central bank is for sale -- at whatever cost it takes to provide on the order of half the hashing power of the network.  The very openness of the protocol becomes its economic weakness (I know that's something people here don't like to hear) when used as a real-world currency, given external economic forces at work.  It's essentially a bootstrapping problem that Bitcoin has not yet had to face, and I'm not clear that it can face it successfully.14     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 10:31:09 pmQuote from: creighto on April 25, 2011, 09:54:44 pmSure it would.  The first transaction in every block is the special transaction that gives the miner his 50 bitcoin reward.  If every light client were checking that transaction to keep the miners honest, there wouldn't be any way to collude, as the lightweight clients would reject the blocks themselves and keep searching the Bitcoin network for blocks that used the proper reward amount.But the attack I'm describing isn't just "incorrect rewards for false mining"; the blocks themselves would be valid Bitcoin blocks under the attack we're now discussing, given the attacker's hashing power compared to that of the network.There isn't really a solution to the problem, except to hope that you have more hashing power committed to the "proper" block chain than to one that intentionally undermines the reliability of the currency.  At the moment, it would seem to cost about $100,000 to mount the attack; the cost would go up by ten if the hashing power committed to the "proper" block chain rises by the same factor.  That's still an exceedingly cheap attack, not just for a government but even for many small corporations.15     Bitcoin / Bitcoin Discussion / Re: Bitcoins Collusion Problem - by Timothy B Lee    on: April 25, 2011, 07:54:09 pmQuote from: [mike] on April 25, 2011, 07:08:45 pmThat is easily solved by having light clients demand to see the first transaction in each new block. It can be linked back to the header with a merkle branch.The protocol today does not support this, so you have to download full blocks anyway. In future it probably will and then the additional rules can be checked like that.It's not a big deal, IMHO.That's a response to one kind of attack, but not to the one we're discussing here.16     Bitcoin / Mining / Re: Bitcoin mining pointless?    on: April 25, 2011, 01:50:46 pmQuote from: allinvain on April 25, 2011, 08:17:29 amHow do we go about changing the nature of the mining work (hence the nature of the proof of work mechanism) on the fly when it is decided (by whatever mechanism) that the current mining work is no longer useful or is not bearing fruit.Oh, I think that's the easy part; you just change the main client, as has already happened a few times.  People routinely suggest that it won't be difficult to change the protocol if, say, SHA256 were compromised.  Essentially, it's some combination of open deliberation and then a decisive change to the main client by its developers, hoping that it will be adopted by users of the network.  There's theoretically competition, though little in practice (as is ordinarily true in many markets).QuoteAlso what if changing the mature of the mining work creates an added value? Whom stands to benefit the most from this added value service? Humanity as a whole or a specific group of individuals or corporation or vested interests? Let's take for pharmacological computational work? Who will benefit from any potential discoveries that come as a result of this mining work? Who own the rights (and therefore profits) to any beneficial discoveries that come about as a result of the mining process?I think those are good questions, but perhaps interestingly, as the "ultimatum game" thread points out, many in this community believe that ANY positive externality would be superior to none, just because it creates wealth.  The argument is that if you're no worse off and others are better off by virtue of the change, the change is Pareto optimal and thus wealth-producing.  It's a simplistic argument when it comes to real policymaking, for a variety of reasons, but in this context it may capture something important.QuoteAlso am I mistaken but shouldn't the ideal currency have absolutely no tangible benefits whatsoever? After all we don't use water as money do we? Gold is not the ideal currency but it very much closely approximates that ideal. Bitcoin in a sense is the perfected ideal currency. I think that bitcoins should have no "benefit" and no inherent tangible value other than that which its USERS give it.Only for portfolio theorists or those who care about the correlation in value between the currency and something else.  But it usually doesn't much matter.  For example, it it turns out that Bitcoin's hashes happen to have an incidental use (knowing the number of 0s in a string that hashes to some values happens to have, say, a scientific application), few would suggest that weakens the utility of Bitcoin.For what it's worth, though, I think these are all the right questions to be asking.17     Bitcoin / Mining / Re: Building a Mining Rig - Specs    on: April 25, 2011, 07:48:24 amQuote from: eleuthria on April 25, 2011, 06:05:01 amThe case is a bit overkill, but I like using cases that are designed for maximum airflow to keep the cards running cooler at higher clock speeds, leading to better mHash/watt ratio, both in terms of power consumption from the GPUs, and the amount of heat that will have to be offset by my air conditioner.On that last point, doesn't the heat have to go somewhere regardless of how quickly it dissipates inside the case?  In the steady state, unless I'm missing something, I'd think your air conditioner would have the same amount of work to do given the same amount of heat generated by the cards in total.Along those lines, there are probably micro-optimizations based on your climate and home construction.  For example, putting the computer on a floor rather than a table, or against a wall or window, could change the thermodynamics of the overall system that you pay for.  But I don't see how airflow through the system would do that alone, except in unpredictable ways.  (Of course, more airflow within the chassis is better for all sorts of other reasons.)18     Bitcoin / Mining / Re: Bitcoin mining pointless?    on: April 25, 2011, 07:42:43 amQuote from: allinvain on April 25, 2011, 07:25:03 amQuote from: sjb on April 25, 2011, 05:57:25 amQuote from: allinvain on April 25, 2011, 05:29:29 amHmm, I wonder if or how easy it would be to upgrade the bitcoin network to use SHA3 in the future. Is SHA256 (aka SHA2) that vulnerable to "cracking"?People say it could be done, but I think more importantly SHA256 will probably last unless there's a fundamentally new sort of compromise.  It likely won't fail because of improved hardware over the next 20 years, unless we get a kind of improvement that we'd have no reason to expect.The only thing that I can think of at this moment that would qualify as an "unexpected improvement" (well sort of unexpected) would be a quantum computer capable of making use of a surprisingly large number of qubits.Right, that seems likely, although I suppose the "singularity" people might claim there are other paths.  On the software side, it would have to be an analytical compromise of SHA256 using a novel mechanism not currently known to the public.QuoteNow on to the subject of the thread. I personally don't think bitcoin mining is pointless. I like to think of bitcoin mining as sort of what a stock exchange's transaction processing systems do. They process the necessary transactions of the exchange and in return earn a fee for their work. Miners do very much the same thing. Thus the energy expended as a result of this process is not "wasted" or "pointless" because it is used to accomplished a desirable and absolutely necessary task.If one argues that bitcoin mining is pointless, that is sort of like saying the energy used by cars is wasted or pointless because it doesn't cure world hunger. Kind of silly way of thinking.To phrase it differently; No use of energy that results in a personally or socially desirable outcome should be considered wasteful.Perhaps someone can refine my phrase a bit better. But anyways, I was quite surprised when I first saw this thread because I never quite expected that someone would question the usefulness of one of the KEY and ABSOLUTELY necessary components of the bitcoin system.I think the original poster's title for the thread has just been misleading people and diverting attention away from his point.  He wasn't saying Bitcoin mining was "pointless" in that it shouldn't be done or has no value (assuming of course that Bitcoin ought to be participated in and has value itself).  He was saying that it's not a logically necessary requirement that the mining activity not have positive spillover effects.I keep wanting to return to gold as my example.  Say you go back in time and, somewhat impolitely, pretend to be an Aztec god and have the opportunity to convince the Aztec people to use either gold or some alternative to gold.  Gold and the alternative have, for monetary purposes, similar properties:  they're equally rare, equally distributed throughout the earth, take roughly equal resources to mine, and so on.  If you were trying to help the Aztecs, wouldn't you want to look at whether the mining process for gold, versus its alternative, happened to lead to positive or negative effects unrelated to the use of the object of the mining as a currency?  For example, maybe in the process of mining gold, the Aztecs will discover valuable sources of water or other information about what lies below the earth, whereas mining for the other, they won't.  Maybe mining for the other will ultimately poison them, whereas mining for gold won't.  Why wouldn't you look at those considerations when choosing the properties of the future currency?In designing Bitcoin, which is of course an ongoing process even now, the community has that choice.  It's not a question of whether mining is "pointless"; it's a question of what to count as "mining" to make it have value beyond, perhaps, its value to the Bitcoin network alone.19     Bitcoin / Bitcoin Discussion / Re: How do we prevent money laundering and assasinations?    on: April 25, 2011, 07:16:05 amQuote from: LightRider on April 25, 2011, 06:53:23 amThere will be no significant change in criminal or aberrant activity while we perpetuate a monetary system. When people are denied the necessities of life, and can only obtain them by engaging in a dishonest, abusive, wasteful and violent monetary system, then you get dishonest, abusive, wasteful and violent activity.No offense, but isn't that magical "halo" thinking?  It's like how people see a food labeled "antioxidants" or "omega-3s" and think "this couldn't possibly hurt me; it's pure and noble."  Studies confirm this sort of bias in people, but fundamentally it's a kind of irrationality.Creating a new monetary system that allows for particular kinds of criminal activity and money laundering could well, if this community isn't careful, cause harm.  It can have good effects and bad effects at the same time, like many innovations.Money can absolutely be used for crime, too, despite some notes I've seen in these forums to the contrary.  Someone said, the other day, something like, "Guns and violence hurt people; money doesn't."  What about the money used to bribe policemen to look the other way when there are guns and violence applied against innocents?That said, exceedingly broad political questions are probably beyond the appropriate scope of this forum, but it's important to recognize that innovations you like can also have negative unintended consequences.  Libertarians recognize this well for, for example, well-meaning government legislation; just because it's private action, though, doesn't mean it doesn't have unintended negative consequences.20     Bitcoin / Bitcoin Discussion / Re: How do we prevent money laundering and assasinations?    on: April 25, 2011, 06:03:43 amQuote from: noagendamarket on April 25, 2011, 05:39:44 amThe first bitcoin exchange to be targeted by a government will cause a shitstorm of massive proportions. Unless they destroy the internet itself what can they really do but standby impotently as bitcoin eats their lunch ?Or, you know, the whole thing could silently fade away after people realize they can't use Bitcoins to deposit US dollars anywhere.  But as we're observing in another thread, it would be pretty trivial for pretty much any government, not to mention a small-cap corporation, to DOS or disintegrate the Bitcoin network.  If I saw an assassination market using Bitcoin, I think I'd contribute to that effort myself, though I know saying that won't win me any points here. SmileyEDIT:  Just to be clear, I mean I'd contribute to the DOS effort against such a thing, not to the assassination market! Thanks for the info theymos.I don't think that the sheer number of posts that someone makes is a good indicator of their contribution. There are a large number of "me too" and uninformative posts which make the forum less rewarding to follow. There was already an incentive to post indiscriminately via the "Newbie", "Junior Member", "Full Member" thing and this will just make it worse as people race to make 250 posts.Others have similar concerns. Gavin was throwing around the idea of switching to a mailing list, presumably because he too was having similar problems with the forum.I was not particularly keen on a mailing list at that point but I'm much more equivocal now.The value of ratings depends greatly on who's doing the rating. Given the fact that ratings are taken fairly seriously nowadays (seriously enough to exclude a large proportion of users from changing them), it needs to be more nuanced and transparent. It's at an unhappy half-way stage at the moment.Is it Sirius who makes these forum decisions? Sirius alone or an ad-hoc committee?ByteCoin  I watched the video, and browsed the source code, especially the mathsy stuff. Looks good!Note how it's built off bitcoinj rather than the C++ code. I wonder whether the development and the addition of new features will occur faster on this codebase and the C++ codebase will stagnate somewhat by comparison.ByteCoin Can anyone find the original post (and author) for the following quote from the forum?"with $5k, one could profit substantially on the exchanges from the "inside information" one has that the attack is going to be mounted and publicized"I can only find a post that quotes this snippet. I seem to recall that the original was a good post. Has it been deleted?ByteCoin Yes.As I have indicated in previous posts and indeed in the first post of this thread, encoding substantial messages in transactions is already possible. Gavin's mooted proposed tolerance of OP_DROP transactions simplifies the implementation considerably and reduces messaging overheads. It also allows the popularity of messaging to be measured.Additionally, Gavin's opinion is that the CPU time taken to verify signatures is a bottleneck for transaction processing. My messaging scheme would result in more signature verifications whereas OP_DROP would not.One major cause of a balooning block chain would be the use of "mixnets". My proposed solution to a giant block chain is forgetting most of it.ByteCoin  It's not necessary to bring RSA into it unless you have special needs like blinding or a lack of message expansion. If Bob and Alice use Bitcoin then they both have perfectly serviceable public/private keypairs. It also sounds like you only want to sign so ECDSA is fine.Your protocol has at least the flaw that an attacker BadBob can generate very large positive ratings for themselves by creating multiple DummyAlices who give positive ratings for large numbers of arbitrary transactions. This is because, in your scheme there's nothing making sure that the Bitcoin transaction referred to is a transaction involving either Alice or Bob at all.ByteCoin
It is somewhat more secure.Suppose an attacker called Zebedee has a fast way of generating second preimages for SHA256. Specifically, Zebedee calculatesSHA256("fixed string I owe Zebedee 00000.00000BTC")=2689918779... and his preimage attack enables him to quickly calculateSHA256("fixed string I owe Zebedee 38128.34146BTC")=3689918779...SHA256("fixed string I owe Zebedee 72413.65435BTC")=2789918779...etcwhere the changes needed to flip bits in the hash are accommodated by changing the amount.With ECDSA_SIGN(SHA256("fixed string"+message)), Zebedee "just" has to find one hash that anyone has ever signed which has the same hash as one of the above strings for which he can carry out the above preimage attack. Zebedee can then present his string, the hash and the victim's valid signature to some authority as proof that the victim owes Zebedee some money.With  ECDSA_SIGN(SHA256(HASH(public_key)+"fixed string"+message)), Zebedee generates strings like"1Cvvr8AsCfbbVQ2xoWiFD1Gb2VRbGsEf28 fixed string I owe Zebedee 12131.123121BTC" and the attack proceeds as before. The difference is that Zebedee needs to find the second preimage of a hash among the much smaller set of hashes signed by the owner of  1Cvvr8AsCfbbVQ2xoWiFD1Gb2VRbGsEf28. Zebedee just wants the money, he doesn't care whom he's defrauding. In the second scheme, Zebedee is forced to attempt to defraud each signer one at a time. In the first scheme, the work he does attempts to defraud any signer - it's much more efficient!Of course, the idea of a useful second-preimage attack on SHA256 is too ridiculous to take seriously. However, that doesn't invalidate the demonstrable technical superiority of the second scheme.Note that this is not the same attack as proposed by BlueMatt which seemed to involve a weakness in ECDSA somehow.ByteCoin Bitcoin has been running successfully for over two years. Honest miners have generated over 120000 blocks. As admitted by Satoshi, if a well funded attacker develops a hashing ASIC or otherwise buys or gains access to >50% of the hashing power (by DDOSing some pools?) then all that honest historical hashing work doesn't matter one bit, Bitcoin belongs to the attacker. This seems a shame.Wouldn't it be nice for the honest mining done in the past to hinder the immediate takeover of the network by the attacker?This can be achieved in the following scheme:Miners which have previously won a block in the distant past get a discount on the difficulty of mining the current block. The size of the discount increases with the age of the previously won block. Once a new block is mined with the help of the discount from the old block then the old block is "spent".Proof of ownership of the old block is proved by signing with the same address that the old coinbase credited.Bitcoin maintains a discount difficulty target which varies over a short timescale with the aim of maintaining a fixed ratio of discounted blocks to normal blocks.If the proportion of discounted blocks falls too far (so that the discount rises too much) then the overall difficulty is raised over a short timescale for that branch of the block chain.If an attacker arrives with >50% of the hashing power then they will be able to generate enough normal blocks themselves to make sure they have the longest chain branch. However, they don't have any historical blocks (or their recently generated blocks have a zero or negative discount) so the recent proportion of of discounted blocks falls to zero. This acutely raises their difficulty on the attacker's chain branch and the attacker's generation rate falls precipitously.Normal, honest miners recognize blocks generated by the attacker by observing the attempted double spending and chain reorgs. It's crucial that they don't contribute discounted blocks to the attacker's chain branch, so they ignore those blocks and continue building off the honest chain branch. Quickly, the attacker's chain branch is overtaken by the honest chain and the attack fails.I believe that this scheme with correct parameters would prevent sudden takeovers by attackers with 95% or more of the hashing power.Gradual attacks by an attacker who generates enough old blocks to maintain the discount proportion are not prevented but at least the attacker is supporting the honest network while generating the "old" blocks prior to the attack!There are lots of vital details to thrash out but I believe the idea is sound and useful.ByteCoin I'd like to mention that the following scheme provides perfect anonymity without extra transactions.http://bitcointalk.org/index.php?topic=5965One would also not need to generate and distribute new receiving addresses for each transaction.ByteCoin Well, your terminology is definitely incorrect as ECDSA is a signature algorithm (that's the S in ECDSA) and hence there's no concept of a ciphertext.However, your idea that one should prepend the address of the signer to the message before hashing and signing the hash, has some merit.It would prevent an attacker from developing generic tables for a second preimage attack on the hash function. Note that finding any preimage given a hash is hard. Finding an exploitable preimage is much harder. Finding collisions by comparison is a lot easier. A hash is said to be broken if collisions can be found faster than by brute force. I hope that conveys the difficulty of the attack you're hindering.ByteCoin Correct. You can add it before you sign it and check for it on verification. Whatever prepended information you choose, don't make it short or generic-looking as an attacker might take the whole lot and try and use it in a different context for nefarious purposes.This should be adequately secure."Salt" and "rainbow table" are normally used in the context of attacking password systems. Please spell out in sufficient technical detail how you think they are relevant to this thread. ByteCoin As Theymos indicates above, OP_BLOCKNUMBER pushes on the stack the block number which the transaction occupies (or is likely to occupy) in the block chain. Miners know what the block number is going to be when they are trying to mine blocks and hence they check that the OP_BLOCKNUMBER transaction is valid for that block. Given a block chain containing OP_BLOCKNUMBER transactions, if the OP_BLOCKNUMBER transaction was ever valid then it will remain valid as (apart from reorgs) transactions don't change block numbers.Please post whether you think a problem remains with OP_BLOCKNUMBER now that this point has been clarified.ByteCoin  Clients currently need to verify all transactions before they are relayed. Because clients don't know what block a OP_BLOCKNUMBER transaction will get into, they can't easily verify the transaction.Workaround: Verify the transaction with the current blocknumber. When a new block arrives, kick the verified transaction back into the just received queue. Forbid OP_BLOCKNUMBER transactions from being spent with zero confirmations. To speed up reverification, the results of checking signatures could be cached.Obviously miners know what the block number is when they try to incorporate the transaction into a block.It's not obvious to me that this is true. I presume that the forking mechanism relies on the clients disagreeing among themselves about the state and the transaction being structured so that this disagreement changes who gets the coins. If everyone is forever in agreement about what the outside state was when the transaction was included in the block chain then I don't see the problem. Please explain if a problem remains.The point of scripting is to allow primitive operations to be combined in various ways to produce a predictable overall behaviour which possibly has never been seen before. Alternatively, transaction types could be hard coded to conform to specific behaviour which is well known and understood. The current behaviour is much more like the latter than the former so I think it's true to say that scripting is disabled.ByteCoin In the event of a block chain reorganization, in the absence of a double spending attack, all the transactions on the shorter branch can expect to be incorporated into the longer chain. The only "money" that's lost is the rewards for finding blocks on the shorter branch - the coinbase transactions. There's a reason why coinbase takes such a long time to mature, it's because it's subject to being disappeared in the event of a reorg. We assume that reorgs can't take place at a depth of 120 blocks so coinbase matures after that time.The problem comes with OP_BLOCKNUMBER transactions which are involved in a reorg where they get incorporated into a block which changes the functionality of the script because of the different block number. Any transactions spending coins depending on OP_BLOCKNUMBER transactions may also get invalidated and that's bad. So to be safe there would have to be some scheme that provides as much assurance as is provided with coinbase maturing for 120 blocks. I guess that coinbase matures at a rate of 5BTC every 12 blocks so perhaps OP_BLOCKNUMBER transactions shouldn't mature until max(120,ceil(value_in_bitcoins/5*12)) blocks have passed to provide similar assurances.It's not a great solution as OP_BLOCKNUMBER transactions are treated differently to any others.ByteCoin    This is the bit where I tout the usefulness of OP_BLOCKNUMBER in spite of the modest complications a safe implementation would entail.   most recently discussed here http://bitcointalk.org/index.php?topic=6439.0Much as I think that the scripting is the best bit of Satoshi's work, I'm doubtful it will ever be revived.The fact that a bitcoin is increasingly valuable with scripting disabled means that scripting is not essential. Enabling scripting, although I'm a big fan, would break the rule that a successful product should do one thing well. ByteCoin Spotting the non-intuitive fact that fixed weight pool payouts are unfair was a good catch. Good job for working out how to price the work fairly (I haven't checked it yet!)I agree about the large variance and your analysis. Whether or not home mining makes sense depends on the motivations of the miner though. I can imagine a home miner motivated by supporting the bitcoin network, not really bothered by the reward but perhaps wanting the very occasional pleasant surprise. Admittedly, most are driven by profit and want to see an immediate return on their "investment".To clarify, in my previous article I was objecting to you saying "can't hope to generate a block solo". Lottery players can hope to win the lottery even though the odds are even more unlikely than solo mining.Only if you don't participate can you not justifiably hope to win.Agreed, and when mining pools were being developed I posted a framework which would have forbidden certain types of fraud. I almost certain nobody has adopted it or a secure alternative.  From this apparent indifference, I surmise that pool contributors will tacitly condone hostile mining (at least initially) as it doesn't harm them and indeed possibly raises their return. I hope you are right and people will object to behaviour that benefits them personally but is generally harmful. Unfortunately, I see this very rarely. Good question. I can expound (on request) in more detail what I see are the necessary preconditions to hostile mining by cartels and what might happen incidentally in future to preclude it. The recent sharp increase in the national currency value of Bitcoins is a powerful new force behind cartel formation and attendant misbehaviour and that makes me concerned.I'd like to answer your question the following way which is more general.A solution is unlikely to be found until it has already become a problem and caused some damage. The solution found, although it solves the problem, is not the best solution and causes further problems in future and so on ad infinitum.To digress:I would argue that various Bitcoin design decisions which I have noted in many of my previous posts have caused, are causing and will cause many problems because they are successful attempts to solve other problems but they solved them in the wrong way. Sometimes the best way to improve things is to undo certain bad or suboptimal decisions and redo it the right way rather than patching holes indefinitely. I'm concerned that the community seems to have an irrationally negative reaction to talking about beneficial incompatible changes.ByteCoin Except when being well established becomes a liability. It's already difficult or virtually impossible to make large changes to Bitcoin to introduce new functionality because it would jeopardize the existing functionality which is now worth a lot of money.A newcomer with better features which learned the lessons from bitcoin's problems would have a chance.Facebook was a late arrival to the social network software after Friendster and Myspace.ByteCoin The long term returns from mining solo with a GPU are equal to and often better than those of joining a pool. A pool gives a more constant payout; that is all. Mining pools concentrate the administration of a lot of mining power in a few hands - those of the people running the pool. If everyone were mining individually, to form a cartel, they would have to all unite and arrange a way of communicating which blocks they would accept and which they would shun. They would also have to distribute the profits of their collusion among the participants who did not win blocks. With a mining pool, both these problems are solved. I can't imagine a plausible mining arrangement more prone to cartel formation. I'm confident that when the reward for block generation becomes small in comparison to the fees in some blocks that we will see cartels being formed and evidence of hostile mining activity.ByteCoin This was posted when I was away from Bitcoin for a while. I've just been referred here by another thread.A miner or group of miners with >40% of the hashing power can mine more than their fair share of blocks under very reasonable expectations. Someone with 46% of the hashing power can win 51% of the blocks. I now call this strategy "hostile mining".Recent post here http://bitcointalk.org/index.php?topic=6284.msg99312#msg99312ByteCoin  Some people don't want their bid/asks to show publicly for various reasons. They could write a bot that polls mtgox to monitor the price and then post their bid/asks accordingly. This polling would be a strain on the mtgox website so mtgox implements dark pools to provide the same functionality in situ. Whether dark pool users should trust mtgox is an interesting question. I imagine there are arbitrage opportunities for mtgox based on the fact that mtgox can re-order incoming currency transactions and make his own dark pool trades which he says are other people's dark pool trades. This would be hard to detect and very lucrative. ByteCoin It's actually worse than you think. See my posts in this thread http://bitcointalk.org/index.php?topic=2227.0I did a lot of simulation and I didn't post the results because they were complex and required a lot of explanation. The basic result is that a miner or group of miners with >40% of the hashing power can mine more than their fair share of blocks under very reasonable expectations.Someone with 46% of the hashing power can win 51% of the blocks.I seem to remember that by tweaking the strategy, "hostile mining" can be profitable at 33% of the hashing power. In all these cases the overall difficulty goes down considerably as many blocks (half?) are wasted both by the hostile miners and the normal miners they are attacking.I'm unhappy with the current effectively GPU-only mining scheme and the popularity of mining pools as I believe that they provide a suitable environment for "hostile mining" to start. Fortunately, chronic hostile mining seems difficult to conceal. If there were occasional transactions with huge fees then there would be an incentive for miners to not accept a competitor's block which claimed the fees but to try and generate their own block which claims the fees for themselves and then generate a subsequent block that ensures that their chain is the longest. This is "hostile mining" in a nutshell. ByteCoin Your post got me thinking about how such a handover should be managed, hence my thread http://bitcointalk.org/index.php?topic=6753.0I don't see the need for your function F. People could just send to any agreed valid address which doesn't have a known public key associated with it such as 11111111111111111111BZbvjr. Spends to this address would generate magical crediting transaction on the "bettercoin" system. A more difficult problem is managing the handover of mining power ie what to set the difficulty to on the new network and how to ramp it up as mining pools join. Also on the old network, how to prevent attacks when most miners have left but there are some normal users wanting to leave.ByteCoin You need to search about 1.28E14 keys. Using my software (if I remember the performance correctly) that'd take me about 4 years.ByteCoin Will Bitcoin succeed forever without substantial changes?If the answer is is "Yes" then everything is fine and the rest of this post is unimportant.Bitcoin is still at a relatively early stage of development. Some desired and designed features are still to be implemented and it has not been tested by either determined attacks or a "mainstream-adoption" level of transactions per second. It's plausible to imagine therefore that the software and/or protocol will have to be changed in response to situations which will occur. Implementing these changes is a big problem for the engineers however.Whenever the software is changed, there's a small but significant chance that the new version will be worse than the old. Obviously, the intention is that the new version is superior to the old version but it's a well known reality in the software engineering world that a software update can result in disaster. As applications mature, the ratio of the incremental value of the update to the value of the current software tends to zero and the economic loss of a disaster tends to increase. Even with careful testing the probability of a shipping a new version that is broken cannot be reduced to zero and the equation implied by these facts tends to mean that updates become more infrequent, substantial and nerve-wracking.With the recent fall in the value of USD and other national currencies against the Bitcoin , one's Bitcoin holdings become a non-trivial fraction of one's liquid assets and anything that jeopardizes these holdings is a serious concern. This must weigh heavily on the minds of the developers. The current Bitcoin client is particularly problematic in that it's a piece of software that can only be properly tested when in a network with other clients with heterogeneous versions. Fortunately at the moment, the network only has one species of client.What Bitcoin needs is a realistic test network. The current test network is an excellent start but the activity on it is too capricious and unrepresentative of the main network. The current test network is more of a R&D network as shown by the fact that non-standard transactions are currently permitted.I propose that a new QA network be instigated which Bitcoin users can choose to support. QA supporting users would have two bitcoin clients installed; one running the current client and one running the current QA candidate. New transactions that the user instigates on the main network would be mapped to corresponding new transactions on the QA network. Miners would be encouraged to devote a tiny but globally fixed fraction of their current real mining power so that the QA network has the same distribution of mining power as the main network. The QA network could be operated for a number of months with one release candidate and confidence in a good candidate would grow as it could be shown to cope with the current mainstream transaction load. Bitcoin software engineers could choose to inject extra other transactions into the QA network to check how it copes with either attacks or a higher level of legitimate transactions. There would have to be a mechanism to exclude griefers from the QA network who could interfere with the testing by either inserting unwanted transactions or mining with too high a fraction of their real mining power.Normally I propose ideas with the technical details better fleshed out but in this case, it's quite a big task. I therefore submit the idea for consideration on its general principles.ByteCoin   So that's the problem with a proof-of-work suitable for PCs.And this is the problem with the current proof-of-work suitable for ASICs (and GPUs).The solution is to alternate between the two and maintain two independent difficulty targets, one for even blocks (PCs) and one for odd blocks (GPUs). Anyone wanting to take over the network would have to be able to generate both types of work. Even better would be having an altruistically useful proof of work like protein folding or finding Mersenne primes so we could even have people supporting bitcoin incidentally, even though their primary motivation was folding proteins or finding large primes.A useful proof-of-work would have to have the properties enumerated in the following post http://bitcointalk.org/index.php?topic=203.msg3669#msg3669ByteCoin Yes. How about you prepend "This signed message is not intended to form a contract:" to the message before you hash it on both generation and verification sides? I know it's English-centric but it's a lot better than nothing.You imply that a JSON error should be generated if the message does not have a valid signature. I don't know much about JSON but I imagine that JSON errors should only be generated when something goes wrong with the JSON side of things. In this case, the JSON is working just fine, it's higher level misbehaviour which  needs to be reported. I suggest that you return a message which reports that the signature verification failed and possibly return some data from the failed ECDSA verification so that users can check the maths when debugging. ByteCoin
The to address 13sUHUW8G23BLQEKFwVMf5cKUkiSuFK8XC seems to be occurring at a rate of about 2 per minute. This increases the size of the block chain at a rate of at least 256MB per year.One partial solution which would have few adverse repercussions on legitimate transactions would be for clients only to relay transactions which refer to previous transactions which have been incorporated in a block.ByteCoin   Please provide either examples or at least a plausible argument for the existence of valid addresses shorter than 27 characters or longer than 34 characters. I've corrected you on this before http://bitcointalk.org/index.php?topic=1019.msg12683#msg12683ByteCoin Surely you're mistaken about how nLockTime transactions work. I believe that they are included in the next block just like normal transactions and any transactions which supersede it would be included in the blocks following them. Why else would there be a nLockTime field in every transaction in every block? The way you have it, there'd be no point recording the lock time in the blocks because the transaction would only be in the block once it's locked.nLockTime as you explain it is an ugly solution. It creates the need for a parallel store of transactions that are neither in blocks nor eligible to be included in the next block. When a new miner starts up, how does he find out about nLockTime transactions which have been sent but haven't been locked? An extension to the network protocol would have to be made.ByteCoin I think realnowhereman's suggestions for improvement are excellent and comprehensive.The only point I disagree with is that the fundamental unit of currency being "tens of nanocoins" is fine. I find it very surprising that so many people have trouble with converting between a decimal representation of a number of bitcoin and the number of fundamental units. The mathematics is so elementary.I'd like to add a suggestion that we revamp the Hash160ToAddress via the Base58Encoding so that leading zeros are not handled in the current peculiar fashion. It's hard to approve of a function that takes a fixed length input and outputs a more human friendly "address" which can vary in length between 27 characters and 34 characters inclusive.Code:1111111111111111111114oLvT2 1ByteCosnsUNJun4KL3HSt1NfFdXpzoRTyare both valid addresses. It makes the first step of address verification on websites vastly more complex than it needs to be.There's nothing stopping you downloading the chain in reverse one by one when you get notified of a new block. Your software could also store the chain in reverse and process it with no increased difficulty. There should be support in the network protocol for clients efficiently downloading the chain in reverse. As well as "start height", "version" could return the hash of the last received block to facilitate downloading most recent blocks first.Not downloading and in fact discarding and forgetting old blocks is of course a central feature of my "balance sheets" proposal.ByteCoinPSThat's just a programming problem, you keep track of the unresolved dependencies and check them when you've worked back enough blocks.That's a reality we already live with. There's little point verifying the block chain before block 105000 due to the "checkpointing" in the current (0.3.20.2) version of bitcoin (see main.cpp). I must admit that I don't know anything significant about nLockTime. I will make a point of learning when it gets implemented or enabled.In my advocacy for OP_BLOCKNUMBER I wanted to enable the recovery of bitcoins for which the private key had been lost. Suppose for example that you've sent payment to a merchant and their hard disk dies and renders their wallet unreadable. If you had engineered your transaction using OP_BLOCKNUMBER such that, if the payment is not spent within a month then the coins revert back then you have only lost the coins for one month.  Can this be done with nLockTime while remaining secure for sender and recipient?ByteCoin I believe that transactions are verified when they are received before they are relayed. When a block is received, all the transactions in it are also checked before the block is relayed even though most of the transactions in the block have already been verified in the process of relaying them to the miner.ByteCoin  I'm willing to evaluate the feasibility of proposed schemes if they are specified in sufficient detail. Your proposal is substantially different from bitcoin and the information you provide is not sufficient to provide a clear understanding of how it would work.ByteCoin (Assuming that signmessage were to use a single SHA256 pass)When you spend coins by signing transactions, don't you sign a double SHA256 hash of the transaction? I'm looking at SignatureHash in script.cpp and Hash in util.h. So if an attacker passes to signmessage a single SHA256 hash of a valid transaction payload then the attacker can spend the signer's coins. The signer couldn't possibly work out what the effect of signing the attacker's message might be, without reversing SHA256. This is possibly the first cryptographic disadvantage of the double hashing scheme employed in bitcoin.Also, in other applications it's common to form a contract by signing a hash of a message rather than a (short) message.To avoid all these possible problems, you have to approve of the content you sign.ByteCoinPS Yes you could paper over the problem by making signmessage use a different hash function or prepend some idiosyncratic but standardized padding to the message before hashing or use >2 rounds of SHA256. They wouldn't have to break RIPEMD160. If they broke SHA256 suitably they could create blocks of arbitrarily high difficulty with very little effort which would enable them to take control of the block chain.When you send your transaction to spend the coins, you reveal your public key for which they would then solve the discrete logarithm problem to find your secret key. They would ensure that your transaction was never included in a block but their transaction spending your money could confirm very quickly.I suppose that if you never try to spend the money, they can't steal it directly but they could inflate the value away. ByteCoin It's reasonable to expect that for a specially crafted message to somehow reveal the private key upon signing, one would have to be able to find messages that hash to particular values. This would constitute the worst possible failure of the relevant hash function. Even if the hash function were completely broken as above, there is no method currently known that allows the recovery of the private key from a signed message faster than solving the discrete logarithm problem on the relevant elliptic curve. If one were to be found, it would constitute a very severe weakness in DSA and ECDSA.If an attacker can force you to sign arbitrary messages, that's certainly a security flaw. The solution is to take good care that you approve of whatever content you are thinking of signing whether it be cheques, loan agreements, wills or numbers.ByteCoin There is some extra CPU cost certainly. If the goal is to reduce the CPU cost of transaction processing then there are other low-hanging fruit to pick beforehand.Change the software so that not all clients have to check all signatures. This was raised in http://bitcointalk.org/index.php?topic=6373.msg94314#msg94314 in the context of speeding transaction propagation.Use a smaller curve - 256 bits is very conservativeUse a different group with faster operations like curve25519Remove the incentive for generating lots of transactions Not recording the public key in the scriptSig would be a breaking change and so there are many other improvements we could apply at the same time.ByteCoin Although you may hear that the 10 minute average block generation time was calculated based on propagation times and expected future transaction volumes, you should bear in mind that 10 minutes is a nice round number and that no calculations or simulations have come to light so far.The time to transmit the transactions and blocks is small compared to the time taken to verify the data. The main obstacle to faster propagation times for blocks and transactions is that the data is checked before it is relayed. From a programming point of view, this is convenient as we're always sure that our client's view of the world is consistent even if other clients are trying to deceive it. However, given that the vast majority of clients are honest, it does seem a bit of a waste that all the clients redo the same calculations.In order to speed block propagation there are several strategies which are faster but more complicated:When a client receives a new transaction or block it records from where it came and advertises that it has the new transaction straight away. If another client requests the new transaction then then it is relayed straight away. When the client has time to check the transaction, if it's found to be bad then the client deletes it and makes a note to check transactions from that sender before advertising it next time. A client would be forgiven after a certain amount of time.For blocks, the client should check successive individual transactions in the block in random order.ByteCoin Great catch! Your solution would be a very elegant way of signing a transaction and implicitly revealing the public key.ByteCoin It's true that you get occasional orphan blocks (not "all the time") but transactions in the orphan block chain are mostly just incorporated into the same block number on the longer chain.  For the purposes of discussion, I suggest that we define a blockchain reorg as one in which previously confirmed transactions become unconfirmed. This requires a longer blockchain to have replaced the current blockchain at a depth of several blocks. This has never happened (unless forced by a software change in response to a bug) nor is it likely to happen. If it did happen, as I mention in the other thread, bitcoin already has potentially bigger problems with normal transactions. The situation which Satoshi outlines, in which OP_BLOCKNUMBER transaction causes problems is very unlikely. You have to have an OP_BLOCKNUMBER transaction which is very close to expiry and a block chain reorg which occurs in the vicinity of that critical period.To completely avoid this unlikely circumstance you should be careful to spend the coins some time before expiry.I don't understand how this could be possible. Please explain.The reason why OP_BLOCKNUMBER is superior to OP_TIMESTAMP is that bitcoin functions without all the clients agreeing about exact times and engineering agreement seems hard. OP_BLOCKNUMBER is a proxy for time that everyone can agree on.ByteCoin Fees don't make anything useful significantly faster. Fees make your transaction have a higher priority for inclusion into the next block. They don't make the next block arrive any sooner and under today's circumstances they don't get into blocks sooner than transactions without a fee.ByteCoin I explain in the thread why I think Satoshi's objection to OP_BLOCKNUMBER is unjustified. Of all the features that  make Bitcoin a promising system, I think the scripting is the most powerful and OP_BLOCKNUMBER would facilitate many types of transactions which users would find very useful. Although we're grateful to Satoshi for creating Bitcoin, should the fact that Satoshi has "rejected" an idea be sufficient grounds for not implementing it?ByteCoin I'm sure I've heard this misunderstanding before from other people on this forum. It looks like the source might have been this post from Satoshi http://bitcointalk.org/index.php?topic=30.msg1169#msg1169.Although Satoshi is correct in saying that ECDSA can only be used to sign, you have to be aware that ECDSA is merely a particular method of using elliptic curve key pairs to sign messages. There are a host of other cryptographic schemes you can implement if users hold such pairs. These include other signing schemes, key agreement and encryption.It is important to note that all the common cryptographic schemes are implementable with bitcoin's keypairs.ByteCoin  It's good enough if you don't mind the message being unencrypted. Transactions aren't encrypted so the addressee can be known purely by the hash of the key. I thought you wanted the messages encrypted to the addressee, in which case you need their public key.ByteCoin It's not? If you're going to make something look like scientific notation by using "e" then 10.25e8 had better be 1025000000 BTC otherwise at least have the decency to choose a different letter like "z" or possibly a non letter.If that's true then why does the URI look like it means something rather than just being gibberish?The fact that the URI is suggestive of a meaning when viewed by a human creates an obligation that the meaning suggested should not be misleading. If the URI were really only for the consumption of the client software then you should just take the data to be conveyed in binary form and then use an efficient encoding into the supported character set.ByteCoin The day you can do your supermarket shopping with bitcoin is the day you can say bitcoin has finally arrived. Supermarket chains will not be early adopters of bitcoin and without them, the supermarkets will not come along. The early adopters will be small merchants looking for a legitimate edge or alternatively an illegitimate edge in which they defraud some customers. I take your point about smartphones having internet connections but it would be nice to have a useable bitcoin wallet on a smaller device with a similar form factor to a usb stick, an oyster card or a token generator. ByteCoin
That's a good goal but it's plain that bitcoin was not designed to support the use of mobile wallets. For instance, imagine you have your mobile wallet and you're at the merchant who has internet access and a bitcoin client. You transfer your bitcoins to the merchant. The merchant's client does its own verification of the transaction and then sends it through the network. Now the merchant can either ask some large miners whether it's on the transaction list going to be hashed into the next block or wait for the next block.Suppose you're standing there with no internet connection and the merchant says to you "Erm... The miners are not confirming recipt and your transaction wasn't hashed into the last block." What are you going to do?In one case, the merchant is lying and has taken your money and doesn't want to give you the goods.On the other hand, you think the merchant thinks that you've just arranged with an accomplice to already spend those coins and the merchant's transaction is being rejected as a double spend.Without an independent connection that is at least disinterested, even if it's not secure there's nothing you can really do.Also, standing there waiting for blocks to confirm is not ideal. A better system would facilitate more reliable prompt confirmations of transactions.ByteCoin So everyone following the message stream can see to whom messages are being sent but they can't read the messages.You should have the option to keep the addressee private. All client software attached to the messaging stream would have to speculatively decrypt "private addressee" messages and if the decryption did not yield a valid message then the result is discarded. If the message is valid then you know you were the intended recipient and you display the message.More generally, if an address has ever spent any coins to anyone then the public key is recorded in the block chain for all to see.ByteCoin Grue: I'm not seeing the relevance of the link in your post. It doesn't seem similar at all.The point rand0mmm is making is that someone hearing about bitcoin, downloading and running the software and then wanting to transfer or buy something with bitcoins has to jump through lots of hoops to get them. The way I'd get bitcoins now is by signing up for an account on mtgox or some similar site and then going through the process of transferring money etc.Presumably rand0mmm would like a little tab in the client saying "Add bitcoins" which would ask for credit card details or something similar so he could purchase some bitcoins using dollars or whatever his local currency is.It's a far cry from what the client does at the moment but, if you see it through a beginner's eyes, it's a perfectly reasonable expectation from a "proper" application.In the olden days you could just click on generate coins but with the proof of work so suitable for GPU mining, you might as well remove it.Of course, the alternative would be to have a proof of work that was more suitable for CPUs. Something more memory intensive and possibly useful see http://bitcointalk.org/index.php?topic=203.msg3669#msg3669 and the rest of the thread for details. The target could be that half the proofs of work are just hashing and half are useful computations more suited to CPUs with memory.GPU miners would shout and scream about losing their monopoly but I think the result would be a healthy re-engagement of the CPU owning community. Also, the "generate coins" button would start to do something again! ByteCoin Ok so you look at the TxIns of the transaction which contains the PrevOut of the transactions you're checking. You can therefore send a "getdata" with the hashes to get the actual transaction, but that's not sufficient. You need to be able to find out which block that (or those) transactions was hashed into so you can download it and check the merkle tree and link it to the block chain headers. I'm not sure what queries you'd have to send to find out which block a transaction was hashed into. Is it even possible at the moment?I don't think there's a way to prove that the inputs haven't already been spent without essentially downloading the entire block chain subsequent to the block that contained the inputs and verifying that the inputs aren't used in any transactions. Even if a new query was created, there's no obvious way for your lightweight client to check it's not being lied to. If I'm mistaken in any of the above, please correct my reasoning. Of course with my "balance sheets proposal" you get the assurance that your inputs haven't been spent as soon as you download the relevant branch of the balance sheet tree and verify its hash in the block chain.ByteCoin Perhaps I did it wrong but I think most of it ended up here https://blockexplorer.com/address/1NgLdBTSYqnqwqiD2JioPRfqEkm3Zvs32uByteCoin Since the prohibition on non-standard transactions, the only reason for a transaction to be overly "complex" is due to its large number of inputs and outputs. In this case the solution is for the client software to offer the option of  recasting the transaction into two or more less complex ones, possibly using staging addresses, which would no longer incur fees.ByteCoin A better global metric of transaction volume would be the number of bitcoindays destroyed.I believe that transactions are prioritized according to the value of the transaction multiplied by the amount of time since the coins were spent. A similar concept is useful in measuring the transaction volume.If someone has 100BTC that they received a week ago and they spend it then 700 bitcoin days have been destroyed. If they take those 100BTC and send them to several addresses and then spend them then although the total transaction volume could be arbitrarily large the number of bitcoindays destroyed is still 700.Currently, bitcoindays are replenished at around six million bitcoindays per day which reflects that there are about six million bitcoins in existence.If there are days when there are few transactions then the total number of bitcoindays increases dramatically. If everyone exchanged all their bitcoins at once then the total number of bitcoindays would be reduced to zero. Some bitcoins will never be spent because the private keys have been lost (or never existed) so the number of bitcoindays will never actually fall to zero.Note how transaction flooding and mix-network activity do not significantly influence the number of bitcoindays destroyed. I believe that the bitcoindays measure is a good indicator of market health and participation. ByteCoin It's probably not impossible, it's very likely to be very unlikely. So for example the address 1111111111111111111114oLvT2 has a hash160 of 0 and a balance of 0.02 bitcoins. It's likely that about 79,228 million million million million different public keys have this hash. If you were to keep generating public keys at random or by exhaustive search you just have to find just one of those 79,228 million million million million that hashes to 0 then you can claim the money.It is possible that no public key would have a hash160 of 0 in which case spending the money is impossible. It is very unlikely however.ByteCoin   I'd just like to point out that there are ways of transferring coins completely anonymously without having to trust a third party and without changing the protocol or network. The client software would have to be changed to support it though.See the technical details at http://bitcointalk.org/index.php?topic=5965If you're interested in transactions not being traceable it's best to rely on a cryptographic solution rather than a human or business.ByteCoin Using the notation in the ECDSA wikipedia article http://en.wikipedia.org/wiki/ECDSAAn ECDSA signature is (r,s). When verifying the signature, one of the first things calculated is the modular inverse of "s" and "s" is not otherwise used. Since the signature is generated once and verified thousands of times (at least once by each client) , why isn't the signature (r, inverse(s)) instead?This would save one inversion per verification.On the signing side, if you look at the way s is calculated, inverse(s) could be calculated just as quickly. Instead of inverting the random k parameter you'd invert z+rd Is there something I'm missing? Did they really just overlook this?ByteCoin There are two distinct issues being discussed here:The original article discusses a fork caused by a substantial fraction of the network suddenly adopting an incompatible set of rules.The recent observation is that a relatively small number of miners control a large fraction of the hashing power and could plausibly form a cartel.Both are worth discussing in their own right but the share little commonality.I believe that both problems would leave clear evidence on aggregate although the fault in individual instances could probably not be decided. There seems to be no evidence to suggest that either is a problem at the moment.The success or failure of a rule-change bitcoin fork will be determined by similar factors as the success/failure of an open-source software fork as similar pressures operate. The fork has to be adopted and the new code base must be maintained. A lack of adoption causes a lack of incentive to maintain and develop the code. Eventually, one or other version has fewer bugs, is easier to use, has better features or becomes a standard for some other reason unrelated to its quality.On the topic of mining cartels: I believe that as the value of bitcoin rises and the ability to quickly convert bitcoins into cash improves, the incentive to develop the programming and organizational infrastructure to enable mining cartels will become hard to resist.Much of the essential infrastructure development could be rationalized by the major miners in positive terms as an improvement to the stability and robustness of the network. A similar development has occurred in the conventional banking/financial sector over the last hundred years or so.  ByteCoin Such people would be candidates for "shunning".http://bitcointalk.org/index.php?topic=3441.msg50075#msg50075In the same way that the consensus is to reward miners with 50BTC (at the moment) per block, we could form a consensus that bitcoins used in such flooding attacks could be invalidated. Dangerous ground but the concept needs to be explored!ByteCoin When a lightweight client asks for the block containing transaction it need only be told the header and enough of the merkle tree to verify that the transaction belongs in the block. I imagine that at the moment with relatively low numbers of transactions per block the bandwidth savings of not sending all the transactions in the block will be low.Detecting payments to yourself could be done by passing a request for all transactions crediting a given address. I can't think of a way that lightweight clients could do this without essentially revealing their receiving addresses.Of course with my "balance sheet" proposal, the amount of information clients have to download to start from "cold" is minimized and a good amount of anonymity is preserved - but this would be a breaking change.ByteCoin There is a problem with bitcoin because transactions are, to a certain extent, traceable. Also, it seems to be desirable to be able to pass messages between sender and recipient. This post outlines a simple method of implementing untraceable transactions to which either party can attach messages. This type of transaction will be propagated across the network and incorporated into blocks just like a normal transaction because to all observers (except the sender and intended recipient) it is indistinguishable from a normal transaction. It's not immediately obvious that Bitcoin could easily be altered to prevent this new type of transaction if the consensus was that it was undesirable.Prerequisite: The recipient's address needs to have a publicly visible public key or alternatively the sender needs to have independent knowledge of the public key. In normal circumstances, this means that the recipient needs to have spent some of the coins sent to that address whereupon their public key is in the block chain.Step 1: The sender performs his side of a DiffieHellman key exchange by multiplying the recipient's public key by his private key.Step 2: The sender uses the hash of the resulting point as the secret key to generate another address termed the "transfer" address.Step 3: The sender sends the bitcoins to the transfer address (plus multiples of 0.01BTC if message transmission in step 4 is desired).Step 4: If a message transmission to the recipient is desired, the sender prepares one or more message bearing "k" values instead of random numbers. The messages m is encrypted (xor will do) with the hash of the concatenation of the secret key for the transfer address with a sequence number starting with zero. The resulting k values are used by the sender for the transfer of 0.01BTC from the transfer address to some  other addresses until the message is complete.Step 5: The recipient monitors the network or block chain for public key revelations ie the first spend from a new address. When a new public key is detected the recipient multiplies the public key point by their secret keys for their public receiving addresses.Step 6: The recipient uses the hashes of the resulting points as the secret keys to generate candidate transfer addresses and monitors the block chain for transactions to these addresses. Step 7: The recipient notices that the transaction crediting the "transfer" address matches the one of the addresses calculated in step 6Step 8: If there are any transactions from the transfer address, the recipient hashes the secret key with a trial sequence number and decrypts the "random" k parameter to recover the message.Step 9: As both the recipient and the sender know the secret key to the transfer address, the recipient takes ownership of the coins if they wish to by transferring them (possibly in combination with other coins) to one or more new addresses. The recipient can attach a number of messages readable by the sender to these transactions using the methods of step 4.The recipient and sender can use the transfer address indefinitely and symmetrically to transfer bitcoins and secure messages back and forth forever as they wish. The sequence numbers are incremented to ensure that k values remain distinct and remain indistinguishable to third parties from random numbers even if identical secret messages are transmitted.Advantages: The transactions are not traceable as they transfer control of bitcoins without crediting the recipient's published receiving address. They look like normal transactions. Transfer addresses facilitate message passing in the k values of transfer signatures.Disadvantage: Disputes between sender and recipient cannot be resolved by third parties using the block chain evidence. This is the price of this type of untraceability.ByteCoin  Correct. This is the implementation detail I mentioned. One would have to ensure that the public key had never been seen before so that only its hash and not the full public key would be visible.To prevent precomputation, the 192 (or whatever) bits the user is not expected to type in should not be constant but should be derived from a hash of the user specified bits. I believe the implementation  by jgarzik already handles this.The man-in-the-middle type attack Hal mentions on redeeming the voucher seems very costly and unreliable for the attacker.ByteCoin It's not immediately obvious to me that this is possible. Please go into details about how it would be done.ByteCoin As very nearly every 256bit number is a valid secp256k1 private key, there's no reason to imagine (off the top of my head) why there should be any attack faster than brute force.Note to self: I have thought of a possible implementation detail that would need to be taken care of in order to stop a birthday paradox attack. Details when I have time.ByteCoin  If this were easy then surely Satoshi would have implemented it from the start; after all the address is one step removed from the public key presumably to prevent offline attacks trying to find the private key. It seems like you're looking to be another step removed. Is there much point?ByteCoin Thanks for bearing this useful fact in mind.Another thing to consider, once any coins associated with an address have ever been spent then the public keys associated with that address are public by virtue of the signature in the transaction. If the merchant's public key is available in this fashion then the customer and merchant can generate a shared secret using Diffie-Hellman key agreement or some similar scheme. This shared secret could be used as the "authentication key" mentioned in the wikipedia article.Of course, if you're thinking of now enabling currently forbidden scripting features then a lot of options become available.ByteCoin You CAN encode a message in a currently accepted transaction using the broadband subliminal channel inherent to DSA (and ECDSA).It would require patching the code to include the message but it could be extracted by some maths on the data displayed by Bitcoin Block Explorer or by extracting it from the block chain file.ByteCoin
Can't you work out how many order and the value the merchant was getting just by looking in the block chain at the number and value of payments to the publicly posted "pay me" address? Surely there's no way around this other than the merchant using a new receiving address for every sale he makes?It would be useful if you would specify the details of what you are trying to achieve in exhaustive detail as at the moment it is unclear.It is possible to encode fairly significant amounts of information in currently permissible bitcoin transactions by specifying the random value (often termed k) in the ECDSA signing algorithm.  32 bits could be easily encoded without any significant decrease in security.  An explanation can be found on the Wikipedia page for Subliminal Channels.ByteCoin As a sophistication of jav's scheme, and with reference to http://bitcointalk.org/index.php?topic=3441.msg50075#msg50075 I propose the following.If the customer wishes to buy from the merchant without waiting for confirmation then he creates a transaction with a total value much larger than the value of the goods he wishes to buy from the merchant. Say the merchant's goods are worth 10BTC then the customer creates a transaction for 100BTC. 10BTC goes to the merchant's address and the remaining 90BTC "change" which would normally go to a new address generated by the customer actually goes to one of the customer's addresses listed as an input to the transaction. This signals to the world that the transaction is meant to be consummated immediately and that if the inputs are double spent in another "immediate transaction" elsewhere then the change is forfeit.The ratio of the amount "at stake" and the price of the goods can be mutually agreed beforehand by the merchant and customer. In the event of a double spend of the same inputs then the merchants are credited in order of decreasing ratio until the value of the inputs expires and any change is lost. Enabling the network to make financial sense of honouring the double spending of inputs in this fashion would be fraught with problems however. The idea does have merit though. Suppose the customer makes three immediate transactions using a total of 100BTC for 30BTC, 40BTC and 50BTC. The network could allow the payees of the first two transactions to be credited. The last merchant could probably be credited 30BTC out of the 50BTC owed although further analysis of strategies where the customer colludes with one or more merchants might decide it's more wise to burn the remaining 30BTC instead.Gavin's worry about "honest" double spending mistakes by buggy clients can be ameliorated by agreeing that transactions which don't route the "change" back to one of the crediting addresses should never be accepted before being confirmed and therefore the "attempt" at double spending is doomed to fail, is therefore harmless and should go unpunished.ByteCoin     Edit:I should acknowledge http://bitcointalk.org/index.php?topic=3168 where jav advocates something amounting to shunning.An effective way to discourage double spending attempts would be to propagate both attempted transactions and then "shun" the inputs."Shunning" is where the network mutually agrees that it will never accept as valid any transactions or blocks which contain a shunned address or shunned TxOut. If shunning is not unanimous then any transactions by non-participants, which transfer money from a shunned address or use a shunned TxOut as an input to a transaction, are themselves shunned. In the shunning community, the value of these shunned transactions or addresses can be redistributed among themselves as they wish or (preferably) considered forever gone in an even more irrevocable fashion than if the private key had merely been lost.If a merchant has accepted a transaction and has handed over the goods before a transaction has been incorporated into a block then it's cold comfort that the double spender's money is shunned after the double spend is detected. The merchant is still owed payment for the goods. The solution is as follows:Firstly, the merchant should require that the transaction paying him for the goods should be from a TxOut or an address that holds many more bitcoins than the value of the transaction. That is, the "change" portion of the transaction that returns the "unspent" portion of the TxOuts referenced back to the payer should be much larger than the value transferred to the payee. If the payer attempts a double spend then the payer runs the risk that all the bitcoins will be shunned even though the value of the attempted fraud is much lower. This scheme has the advantage that it requires little change to the existing infrastructure.Optionally, in the event of a double spend, the network could elect to honour the payment part of the transaction and shun the "change". This means that the merchant is not out of pocket while the fraudster is punished. In order to signal which is payment and which is "change", the payer structures the transaction such that the "change" is paid to an address that was also used to sign the crediting transaction. Care needs to be taken with such schemes to make sure that double spending remains uneconomical when the double spender acts in undetectable collusion with one or more of the double-spent merchants.A supplemental scheme would give the sender feedback about the propagation of the transaction across the network but it involves much more infrastructure change and network traffic. We observe that a minority of miners generate the majority of blocks. If the merchant can see that the transaction has been accepted by these miners then he is confident it will not be double spent. The proof of a miner's power is the number of blocks it generates in a given time. If the generated blocks always credited the same address for a particular miner then we would know who the biggest miners were (at the cost of a big loss of pseudonymity for the miner). The merchant would require that the payer construct a transaction which also requires some proportion of the largest miners to sign that they have received the transaction and will include it in their next block, in return for some fee. When the merchant sees the miner's receipts arrive across the network then he is comfortable handing over the goods.Note that the last supplemental scheme is tentatively included merely to spark off ideas as it is ugly. I would also warn against shunning as, although simple and powerful it easily results in fragmentation and I feel that the schisms it facilitates could weaken or even destroy Bitcoin.ByteCoin    When you start talking about "discouraging" blocks based on whether you think the miner is doing something dishonest you're undermining one of the central mechanisms for stopping the network fragmenting. The rule so far is that the block chain with the highest difficulty wins, full stop. If the rules for whether a block is adopted are changed to something where different bits of the network could have different opinions about the block's suitability based on the transactions they have seen then that's a recipe for network fragmentation. What you're really trying to do is to get transactions to confirm more quickly which you could do by increasing the block rate target.What are the tradeoffs that resulted in the selection of a 6 blocks per hour target rate?ByteCoin In the current Bitcoin scheme, one can't accept transactions until it has been incorporated into a block. Suppose two transactions "spending the same coins" enter the network at different points. On average, half the network will have one transaction and half the other. The only way out of this deadlock is which happens to make it into a block first. So you can see that the race across the network is unimportant but the race to get into a block is the deciding factor.Hal's attack above would yield a reliable income.ByteCoin In the interests of accuracy I would like to point out that "lost" bitcoins can be reclaimed in the long run by someone generating by brute-force (or by some as yet unknown method) a private key capable of generating valid signatures for the transactions crediting the "lost" private keys. It is uncertain whether this is possible in the lifetime of the current universe however.In http://bitcointalk.org/index.php?topic=1786.msg21998#msg21998 I proposed a new opcode OP_BLOCKNUMBER which would allow (amongst many other things) the construction of transactions where the money would revert to one or more "lost property" locations if private keys were lost. Widespread adoption of such a scheme could effectively minimize the number of lost coins. ByteCoin  Good catch to spot this pool exploit! I completely missed this in spite of thinking about pooled mining quite a lot.If you have any doubts about the reality of this exploit then consider the following thought experiment:Suppose there are ten miners hashing at equal rates. After they each submit one work-unit to the pool, if a block is then found they each get 1/10th of the total profit. If one of the miners leaves and is replaced by a new miner at that stage and each miner then submits another work-unit then, if a block is then found the new miner gets 1/20th of the profit having done the same amount of work as the miner whose place he took. It's only fair if the share of the profit is proportional to the work done.One solution to the problem is to make the payout for the block proportional to the time since the last block. The mining pool would have to have a slush fund to cover the cases where the block generation rate falls below the long-term average.ByteCoin As I have mentioned a few times before, although ECDSA cannot be easily used for encryption, the keypairs used are perfectly suitable for use in some elliptic curve public-key encryption schemes. It is misleading to try to imply that there are significant technological barriers to implementing a public key encryption scheme using bitcoin addresses.ByteCoin One plausible option for a future bitcoin-like system is to allow a selection from a numbered range of pre-selected curves. Smaller transactions or balances could use smaller keysizes if necessary.You can still embed messages into transactions see http://bitcointalk.org/index.php?topic=2393.msg32288#msg32288ByteCoin There is no effective solution to this problem until the wallet handling code can be completely separated from the networking client. See http://bitcointalk.org/index.php?topic=1691.msg20718#msg20718Attempting to improve security by having a password on the client is no improvement as noted by Nefario and has significant problems as noted by gavinandresen.ByteCoin I'm not aware of any academic cryptography papers that refer to any curves over prime fields as Koblitz curves. The standards bodies publications do not count as academic papers and I believe that their inclusion of "k" in the name is idiosyncratic. Indeed the standard states "Here ..[the term "Koblitz"] is generalized to refer also to curves over F_p which possess an efficiently computable endomorphism. [Allong the lines of the paper of Gallant, Lambert and Vanstone "Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms"] This scheme tends to be referred to in the literature as the "GLV method"When selecting appropriate cryptography you can vary the "size" parameter which has an obvious effect on security. You can also vary the "peculiarity" paramter which can substantially increase the speed at the cost of a small reduction in the effective "size". Before worrying whether the special nature of the secp256k1 curve loses a few bits of security relative to a random curve we need to examine what reasoning informed the selection of a 256bit curve. Possibly a 224 bit or 192 bit curve would have been perfectly satisfactory. That being the case, the theoretical loss of security due to the special nature of the secp256k1 curve is inconsequential while the speed increase is still useful.I forsee a general trend towards the use of more specialized curves over the vanilla random elliptic curves as the performance gains are substantial. This is comparable to the shift away from vanilla RSA towards the more specialized ECC in return for shorter keys, that happened about ten years ago.I see little justification for retiring secp256k1 without a complete redesign of Bitcoin to address existing deficiencies in scalability and implementation security. Future schemes, however, should avoid hard-coding any particular implementation of the essential cryptographic primitives.ByteCoin It couldn't possibly be that these relatively impoverished and mostly uneducated young american men, having left a situation engineered by the USA in which they were in danger of killing and being killed and now in a situation run by the Chinese in which their lives were relatively safe, with the time and encouragement to reflect rationally on their circumstances became somewhat more skeptical about the benefits of capitalism and warfare.Liberal attitudes tend to be correlated with more education and I don't think that's just due to indoctrination by "liberal educators".Back on topic: Emotional argument is a bit of an oxymoron.Gavinandresen's slogans are good. About the bankers - I think it's always a case of "I want less corruption or else a larger share of it"ByteCoin I can recast my solution in terms of ECDSA signatures, the security of which is a prerequisite for the correct operation of Bitcoin. This might reassure you.A simpler, essentially equivalent (but actually unsuitable) method is the following.When you receive a the payment transaction, you sign it with your public key. You use the signature as the result of your dart throw or random numbers or whatever. Everyone can verify that signature using your published public key to check that the calculation is correct.Puzzle: Can anyone else work out why the RSA solution is appropriate and the ECDSA solution is not?ByteCoin There are a variety of different ways of encoding information in a normal transaction in the block chain.Encoding the information as fractional amounts of bitcoin in transactions has several disadvantages.It is inefficient - the amount of information encoded per transaction is small.It is obvious - small transactions which are not round amounts of coin are not typical.It can be discouraged by fees on small untypical transactions.Another way would be to send a small amount of bitcoin to an address, were the address is the information to be encoded. This would store about 20 bytes per transaction.A superior way would be to use the broadband subchannel in ECDSA which I wrote about in http://bitcointalk.org/index.php?topic=1545.msg18364#msg18364This allows you to store 32 bytes per transaction and does not require you to waste any money.Neither of these latter two schemes is obvious, nor can they be discouraged by fees and they are vastly more efficient.ByteCoin  There are many elliptic curve encryption schemes for which the public and private keys are compatible with the ECDSA keys.One could use ElGamal or MQV or one of the newer signcryption schemes. There are no technical obstacles to implementing encryption.ByteCoin I think that the answer to that question depends very much on what exactly what it is, the primary function of which we are discussing. Bitcoin has recently proved to be a moving target. It used to have an effective scripting language but now it doesn't. There's little point discussing alternative uses if these alternative uses can be easily denied.Gold is superior to Bitcoin in this regard. Once you have your gold, nobody can decide to change its maleability so you can't make it into jewelry or it's reactivity so that it tarnishes.Is Bitcoin what the current software permits or is it what the fundamental technology could allow? ByteCoin I saw this analogy on the other thread and I thought it was a good short justification for not restricting Bitcoin use.ByteCoin Gavin, I believe my simulation is accurate. I will post a longer explanation when I have read davidonpda's pending article.I saw a post from you which was just a complete quote of my post with the numbers. I followed up to it saying "content?" and that post has disappeared too.Please try to re-do your post. I'd love to read how a cartel attack works with 50% and nothing less as my simulations and some noddy maths seem to disagree. If anyone on the forum can easily compute a steady state from a simple infinite Markov chain then we can put this discussion on a rigorous footing.I believe that either gavinandresen, btchris and davidonpda are all spectacularly wrong or I'm wrong which would be embarassing. I would like to revise my previous statistics and state that a cartel with no preferential network access can be profitable with 33% of the generating power. If it can get its blocks accepted three times more frequently in the event that two blocks are published at the same time then it's profitable at about 20% of the generating power and at lower powers only suffers a very modest degredation in its performance for it's cartel enforcement activities.ByteCoin I meant that I simulated a number (now 6) of different cartel strategies operating in the normal network to see which was most effective. I did not simulate two competing cartels operating at the same time.I recently simulated the case where the cartel is three times more likely to get the non-cartel members to accept the cartel block when a non-cartel block and a cartel block are published at the same time. In this case the cartel generates more than its fair share of the blocks when it has 34% of the generating power. ByteCoin Minimising the attack surface for exploits is vital. What is the new functionality that you wish to introduce which cannot be implemented using a suitable non-lobotomised script?ByteCoin
I did a simulation of two cartel strategies along the lines of my previous post. I have assumed that the cartel does not have any superior ability to propagate its blocks across the network. If the cartel and the non-cartel miners publish a block at the same time I have assumed that they have an equal chance of being accepted by non-cartel miners. This therefore is a lower bound on the cartel attack effectiveness.When the network generates a block, if the cartel has just one unpublished block then the best strategy seems to be to immediately publish the stored block and let the two race across the network.Neglecting the benefit to the cartel of punishing non-cartel members, the cartel starts to pay off when its fraction of the generating power exceeds about 41% of the total.ByteCoinThe raw percentages are as follows:Cartel power Cartel block fraction 0%   0.00%1%   0.46%2%   0.92%3%   1.41%4%   1.89%5%   2.50%6%   2.96%7%   3.50%8%   3.97%9%   4.56%10%   5.17%11%   5.68%12%   6.52%13%   7.10%14%   7.85%15%   8.42%16%   9.37%17%   10.02%18%   10.76%19%   11.91%20%   12.53%21%   13.51%22%   14.49%23%   15.29%24%   16.25%25%   17.42%26%   18.59%27%   19.53%28%   20.90%29%   22.01%30%   23.27%31%   24.80%32%   25.94%33%   27.28%34%   28.96%35%   30.49%36%   31.56%37%   33.86%38%   35.82%39%   37.23%40%   39.13%41%   41.19%42%   43.12%43%   44.39%44%   47.07%45%   49.41%46%   51.29%47%   53.41%48%   54.98%49%   56.91%50%   59.86% The mining cartel problem is real. The basic implementation outlined by RHorning is well understood but the more effective version outlined by mtgox is a serious problem. I have an obvious improvement to mtgox's improvement as follows:Cartel miners only communicate their new generated blocks to other cartel miners.The cartel miners then try to find new blocks based on the previously found but unpublished block.The cartel miners have a certain probability of being one or more blocks in advance of the rest of the network.When a non-cartel miner finds a block then the cartel miners attempt to punish them by publishing up to 2 of their precomputed blocks.If the cartel miners were 1 block ahead then the non-cartel miner stands a fair chance of winning. Obviously the cartel miners will be busy using their block as the base to build the next block.If the cartel miners were 2 blocks or more ahead then their chain is longer and the non-cartel miner is punished.People thinking that being a cartel member is suboptimal because honest miners supposedly make more money are neglecting the value to the cartel of punishing non-cartel miners.ByteCoin  The solution to the front running problem has been solved by Hal in http://bitcointalk.org/index.php?topic=1790.msg29919#msg29919A suitably salted hash of the required name is submitted for inclusion into the chain. After it has been confirmed then the name (and salt) are published and everyone now accepts the new registration.I agree that the theymos/nanotube "solution" to this problem is ugly. There are also serious problems outlined by RHorning which need addressing.ByteCoin Awesome, theymos! Thanks for that.It'll be handy to see during the next spam flood.ByteCoin To clarify, the block size limit is the size beyond which a received block will be rejected by a client just because it's too big.I agree with caveden that having a fixed block size limit could cause problems in future.Let's consider the scenario in which Bitcoin becomes popular and the non-spam transaction rate starts to rise. The current fees and priority scheme is fine until the size of the fees required becomes a disincentive for new users to start using Bitcoin. The miners must choose between taking a smaller fee from a given transaction or maintaining their fee schedule and effectively turning away lots of new users perhaps to other competing cryptographic currency schemes.I think it's reasonable to imagine that everyone will decide to drop fees to a level that encourages the widest possible adoption of Bitcoin until other limiting factors (such as network bandwidth) come into play.So with the reduced fees, block sizes increase until blocks get rejected by old clients with lower hard block size limits. These clients can't relay the new blocks and so new clients would have to only connect to other new clients. Miners which reject the large blocks would continue to build a block chain of "normal" sized blocks. As soon as transactions start to refer to coins in new large blocks then the old clients would reject these transactions and these coins could be double spent on the "old" client network. I don't think this would be pretty.The ostensible reason for hard block limits is to prevent spam. As ribuck mentions current spam attacks have two effects, one which you can see and one that you can't. You can see block sizes rising but this is an effect which counteracts the less visible problem of your transaction cache filling up with spam transactions. I believe that memory exhaustion due to transaction cache filling will be the main problem with spam attacks so large blocks removing lots of transactions from it will mitigate it. The real solution to spam is "shunning" which I will outline in another post. I believe having any block limits is likely to exacerbate the adverse effects of spam transactions.As FreeMoney observes, in the absence of block limits there's nothing to stop a miner from including arbitrary amounts of its own spam transactions in the block. This is true. However, it's certainly not in the non-generating client's interest to reject the block even if it only removes a few transactions from the cache. Rather the onus is on the other miners to notice that the new block does not remove enough transactions from the cache and reject it. They will then build the longer chain while ignoring that block which will be an orphan. Hence the spamming miner is punished.The moral of this story is that the non-generating clients operate on the network at the pleasure of the miners. The miners are effectively in control of the "health" of the network and the current block size limits reflect that. So for example block http://blockexplorer.com/b/92037 is about 200455 bytes long and mostly contains spam. Normal blocks max out at 50k. This shows that at least one generator has chosen to waive the current fees scheme. I think that letting miners effectively decide their own fees scheme will be seen to be the least bad option.ByteCoin I agree.It would be nice to move to an architecture where bitcoind does all the p2p, blockchain maintenance, transaction verification stuff. A gui-less wallet manager connects to some bitcoind via TCPIP to send transactions and receive new payments. This would mean that people can still handle bitcoin payments even if they are not allowed or cannot run a p2p client. The gui should just provide a pretty way of communicating information and commands from and to the wallet manager. ByteCoin I believe that it is possible to have a decentralized peer-to-peer crypto-currency solution for frequent micropayments.There are many parameters to be specified before an appropriate design can be made. Among them are:How do you seed the clients with the initial money to make transactions?Can they accumulate debts?What sort of communication exists "naturally" between the clients apart from the payments?Must offline payments be possible?Is the system "closed"? Can new arbitrary clients join?Is full anonymity desirable or is pseudonymity acceptable?Are the transactions a fixed small set of types or do you have to be able to "roll your own" like bitcoin?If you go into more detail about the application then we can probably infer most of these parameters.ByteCoin  Does every client have the same list of orphan blocks? Is everyone's blk0001.dat file identical?I'm trying to investigate the "wasted block generation" issue and it's fairly obvious that my client doesn't have all the orphan blocks. What I'd really need to generate good data is the orphan blocks extracted from the blk001.dat file of clients that have been running continuously for a long time. Better still would be orphan blocks from miners.I believe that the blocks are only relayed after checks have been carried out and after it has been written to disk. The checks are necessary to avoid relaying junk in the event of an attack but the relaying should happen before writing to disk to keep the latency down and to avoid block loss.ByteCoin Artforz data indicates that he sees 0.2% of his blocks "go missing". Our guess is that satoshi saw this happening and fixed the UI to hide the problem but overestimated the frequency of occurrence. 10% block loss implies a propagation delay of the order of tens of seconds which seems rather high. I requested that miners look for lost blocks and share their data in http://bitcointalk.org/index.php?topic=1799.msg22508#msg22508ByteCoin The .06 in 17yhRAYKJvVmBh14HMxYRHp2Z4erWgk1ne which was MrBurns old spam eventually was transferred to 1GcbuFVxrjstRoGzChn5t2xJnm2HKoDBSE 0.05 and 15JzKgaSoW5nX3qJKh6ze1uCojn9WVVnDE 0.01 in transaction c37dd025e8b7329989ab9ac378604d015895e4ec630c863620a90f3a12f73e76in block 92767 (2010-11-18 22:51:36)It got 0.05 back from 1GcbuFVxrjstRoGzChn5t2xJnm2HKoDBSE in block 92767which was transferred to 14mUbjiofYY2F6h3ZGUSoTo3kxdqtajVTp in 92875There has been a lot of spamming with 14mUbjiofYY2F6h3ZGUSoTo3kxdqtajVTp but also with1NNVFX7SiJF44fkqB27QbARXojhRSotF2o which was created from 14mUbjiofYY2F6h3ZGUSoTo3kxdqtajVTp via 1H2aPofjULC65MBeojs3eVpPvdScV8H9ouin block  92877 (2010-11-19 15:12:33)So it's the same person.ByteCoin The short answer is yes, it can be done. Unfortunately, evolving attacks to get round the countermeasures is considerably easier than developing reliable, side-effect free countermenasures so it's probably worth thinking about ways to prevent or discourage or minimise these attacks.The "pruned chain" you suggest is quite a large change to the client and probably can't really solve the problem. A torrent of the chain is just admitting defeat; that the client can't cope with the data distribution.So who are they and what did they say? I was actually worried that people might blame me!Ok just found out it's MrBurns... see http://bitcointalk.org/index.php?topic=1835.0The number of spam transactions vs time between blocks plot is fairly linear. It looks like one transaction is being included every 15 seconds. I think we're getting away lightly at the moment as there seems little obstacle to me to including 50k (or more (500k?) thanks to Artforz) of free transactions in every block.ByteCoin The above address has intermittently been flooding the real network with transfers of 0.06BTC to itself. A the time of posting there have been about 2350 such transactions in the block chain. See the following link for detailshttp://theymos.ath.cx:64150/bbe/address/17yhRAYKJvVmBh14HMxYRHp2Z4erWgk1neThe transactions must be sized somewhere in the region of 210 bytes which means that half a megabyte of useless block chain has just been generated.At the risk of belabouring the point, I'd like to point out that clients using "balance sheets" to facilitate deletion of spent transactions would not have their storage requirements increased by the recent attack. An attack differently structured however would have a negative effect on both types of client but the effects on "balance sheet" clients would be limited by the finite divisibility of the coins.Both client types would suffer from an attack which padded the script instead but again the effect on "balance sheet" clients is considerably smaller.ByteCoin In the current block chain, all the transactions (with very few exceptions) are just plain transfers from one address to another. It's therefore easy for the client to work out the current balance but this is something just synthesized from the transactions. If lots of non-standard transactions existed it might be very difficult for the client to work out whether you could spend them and hence it would not be able to determine your balance.The idea of balance sheets has changed somewhat over time as I understood more about how the scripting functioned. In order to implement a full client while throwing away the most unecessary information, the balance sheet client has to keep all the relevant details of all the unspent transactions. When spent, they are forgotten. It also has to remember a certain number of past blocks.If balance sheets were implemented then it would no longer make sense to have a fee based on transaction size. Instead the fee would be related to how much new information needed to be stored compared to how much could now be forgotten. It raises the prospect of people getting paid the fees to make the transaction!Also, for clients using balance sheets the transaction rate would be limited by network bandwidth rather than the block size limits. One might imagine that miners using balance sheets might have a competitive advantage over traditional miners.Bitcoin peers wishing to use the lower fee structure of balance-sheet based miners might neglect to forward their transactions to traditional miners. This might fracture the network somewhat but the issue is complicated and I will make a separate post about it.ByteCoin I've been thinking about your scheme appamato and as we discussed, rejecting invalid blocks and only working on the longest chain is a critical part of the security of these schemes. Therefore all hashing clients need to have the logic to tell the good from the bad. Ths could be done by distributing the appropriate logic for each app as java bytecode or .NET stuff. All clients would therefore understand all apps.There would have to be some incentive to support an app in this way. Some form of payment.... hmmmByteCoin You don't need to know the contents of every other transaction. You need to have a current list of all the unspent coins and to keep abreast of the changes when they are spent. Spent transactions can be forgotten forever. The advantage of balance sheets over lightweight clients is that lots of the block chain can be forgotten and there are not merkle tree stubs hanging around which are a non-trivial size.No. Balance sheets are script friendly as they would store the scriptPubKeys of all the unspent coins. I'll admit that when I came up with the scheme I was hazy about how scripts work. Could you please explain what the real problem is? Balance sheets was intended to enable a fully featured mining-capable client while considerably reducing storage requirements. I believe that hard disk space will become a problem for average users long before network bandwidth or cpu usage.I'm sorry I didn't notice both your continuations of this thread until today.ByteCoin I presume you got your 279 byte figure from the start of key.h. Regardless of what that says the private keys are actually a maximum of 256 bits long. This is because Bitcoin uses the secp256k1 curve. I have also done the maths and it checks out.The private key is just a number and like a number, the smaller it is, the fewer digits are required to specify it. Therefore, a scratch-off card manufacturer would choose a private key short enough to type but long enough not to be brute forced. Note that an attacker would not be able to distinguish a scratch-off card generating transaction from a normal transaction in the block chain and so they would have to brute force all suspected unspent coins.A 13 character case insensitive password of such as WTUYZFK64BOAD would imply a search space of about 2^66 curves. The last characters digits might be exhaustively searched by your client program as you typed it in by exhausting about 50k possibilities so you'd have to enter about 10 characters.ByteCoin OP_BLOCKNUMBER transactions are not understood by the current client and their use should come with the proviso that under certain rare conditions problems might occur without any malicious intent. Exactly how rare is made clear below.At the moment, if you send BTC to an address and for some reason the owner has lost the private key then your coins are lost forever. Payees can lose private keys due to hacking activity, hardware theft, hard disc crashes etc.. OP_BLOCKNUMBER transactions would allow you to recover your money and the transaction could imply a reversion time of months or years in future. In order for a segmentation to accidentally cause problems then the coins would have to go unspent until the deadline was just about to expire at which point the network would have to segment at which point the payee would have to be in the minority portion and try to spend them at which point the network would have to stay segmented until the reversion time had expired. That's a long list of coincidences for it to happen by accident.On the other hand, exploiting segmentation for double spending is not difficult. Please show me what is difficult about the method I posted. All that is required is one adequately prepared attacker waiting for the network to segment. Anyone on the minority network portion offering goods or services for sale is at risk. ByteCoin I've just looked at Artforz scheme which is simpler than yours but my scheme is simpler still and looks like a normal transaction so is less likely to be speculatively brute-forced by an attacker. You say it's horribly insecure. How so?ByteCoin OP_BLOCKNUMBER does not introduce any new vulnurabilities compared to the existing system as segmentation can be exploited to defraud people at the moment. This is accomplished as follows:An opportunistic attacker has clients running in multiple locations around the world. The attacker's clients have the same wallets and connect to different subsets of peers, probably perferring local ones and definitely keeping in touch with local mining peers. The clients communicate with each other at intervals to check whether the network has segmented and exchange the list of peers that they are talking to.If communication is lost to one or more of the attacker's clients (they go offline) then the remaining clients attempt to communicate with all the offline client's peers. If they all succeed then it's likely that that attacker's client has just crashed or lost its internet connection. If however that client goes offline and a number of the peers are uncontactable then it's possible that the network has segmented. The attacker's clients determine whether they are on the network portion with the majority of the mining power or the minority. They also guess whether the other inaccessible portion of the network has enough mining power to generate blocks over the time it is imagined to be isolated. If the conditions are favourable then the attack proceeds as follows:The attacker's clients on the majority of the network send coins from the wallet to new addresses in plausible innocent looking transactions. The attacker's clients on the minority of the network use the same coins in the same wallet to buy whatever goods they can find for sale on the subnetwork. When the network joins up again, it's highly likely that the majority part of the network has generated more blocks and all the transactions in blocks on the minority part of the chain re-enter the transaction pool. The attacker's transactions on the shorter chain are discarded as the coins have already been spent on the longer chain. Fraud complete!So you can see that OP_BLOCKNUMBER does not introduce any new risks and that the real prevention of segmentation-based fraud must rely on some sort of detection of the loss of mining power.ByteCoin Are there really so many hashes found that go to waste?The quote in the comment in ui.cpp says that by design something in the region of 10% of blocks generated won't be accepted, presumably because another block has been found slightly before and is propagating across the network but hasn't reached our computer yet. For about 10% of blocks to be wasted the propagation time for a block from one generator to another would have to be of the order of about a minute! Surely block propagation can't take that long?Could some keen miner (Artforz) please scour their logfile and find out what the ratio of accepted to rejected blocks is in real life?Also, I notice that it's in the miner's mutual best interests (jointly and severally) to ensure that they connect directly with each other and not with or via non-generating clients.  It's most important to connect to generators with the highest hash rate. In fact, there's no incentive for generators to talk to non-generators at all unless non-generators are offering a transaction with a fee!ByteCoin
I'm not advocating that the standard client attempt to prevent people from their forseeable consequences of their own decisions. The blame for the "loss" of 50BTC in this case lies squarely with the standard client/protocol as I explain below.The key point is the implied contract between the generator and the standard client. If the network accepts the new block then it should reward the miner with 50BTC that the miner can dispose of as they choose. If the miner wants to send it to an un-owned address then that's fine. In this case, the miner clearly made the effort to allocate the coins to himself and the uselessness of those coins is purely due to the fact that the network just happens to identify coins by their hash and there was a hash collision with some other coins.(Slight simplification of the real situation to save space). The assumption behind the design decision to identify transactions only by their hash was the expected uniqueness of hashes. Proper efforts are made in other areas of the code to ensure the truth of this assumption. The fact that no adequate efforts are made here is a flaw.ByteCoinPS I (and at least one more person) have sent coins to un-owned addresses. The fact that this is permitted is fine. It's a very handy tool. It would be good (for me at least) if there was a field in the "Block" view that gave the length of the block in bytes. It would be nice to have a size column which gives the transaction size in bytes and a priority column which shows the priority as calculated using the recently implemented formula.(Priority no sooo important to me at the moment though.)On the "From" and "To" columns it would be nice to see the "balance" associated with that public key before the transaction so that a coinbase transaction would say for 91812 16va6NxJrMGe5d2LP6wUzuVnzBBoKQZKom:0 +50 = 50and the other transaction would show as 777ed67c58... 0 1BFrS5LQSTY... : 1 -1 = 0 16QjxpGVX6EF... : 19 -19 = 0   1MCwBbhNGp5hR...: 411.9 +20 = 431.9You can imagine that it's handy to have this info at block level without having to drill down to transaction or address level.Also, it would be very interesting to have a list of unspent addresses and their balances. Obviously this total should add up to the currentblocknumber*50If you wanted to be a hero you could work out how much space could be recovered from the block chain by removing spent transactions and stubbing the merkle tree down as much as possible. I suspect it wouldn't be much at the moment.If you wanted a tougher task and be a real hero you could create a graph of bitcoin transactions with each address being a node and each transaction being a directed edge. You could display the thickness of the edges as being the number of transactions or the total value and see how many isolated graphs the transactions fall into. The last two are harder more long term projects but the block page changes would be very handy for me in the short term. Thanks theymosByteCoin    Yes it can. The network should demand that valid blocks have the block number hashed into the coinbase before accepting the block. The way that hashed transaction values are used in bitcoin demands that reasonable effort is made by all parties to ensure that they are unique. Clients already make a number of checks before accepting blocks and this should be one of them. Of course the onus really falls on the mining clients to check previous blocks. All the more reason why it should be easy to make your own highly optimised mining program without having to worry about keeping the network healthy by ensuring your software performs adequate checks. There should be a mining interface to the current vanilla client.ByteCoin There is an implied contract between the miners and the network that the effort that the miners exert to generate blocks is rewarded by 50BTC (at least, and at the moment) which they can spend as long as they take care not to lose their secret key for example. The network is breaking their side of the bargain by not allowing 50BTC rightfully mined to be spent.The damage to the network is to its reputation and credibility. If you had 50BTC held in some address, if the majority of generating power conspired appropriately, they could arbitraritly fail to accept any transactions using that address. Would you argue that in this case there's no harm to the network too? What about if the miners conspired to exclude all non-fee paying transactions or on some other metric?ByteCoin The implementation does not take enough care to ensure that different coinbase transactions have different hashes. That is to say that the "standard" does not mandate that something like the block number *has* to be in the coinbase transaction for the block to be valid.ByteCoin Oh no! That's really bad!Suggested fix: Include the block number in the coinbase. For discussion: The new client release should, among the other changes, allow an artificial "special" coin generation to credit that public key to compensate for the unusable coinbase credit.ByteCoin Well, let's suppose you have a cube of diamond that's 10 metres per side and a computer that can try about 10 million addresses per second. The owner of the computer touches the cube of diamond once in their life so lightly that only one atom is worn away. The owner has a child when they're 26ish who also touches the cube of diamond similarly lightly once in their life etc...The cube of diamond is completely worn away by the time the computer has exhausted the key space.ByteCoin Hmm.. If clients disagree about what the current block count is then they already disagree about whether certain transactions are valid or not and therefore the problem you mention exists already without my proposal.Please go into more detail about why this is not good for the network.ByteCoin Great. So what would you like to buy using Bitcoins and what do you have that you are willing to sell in return for Bitcoins?Solve that and I'll admit you have a useful app.ByteCoin At the moment, if you make a payment to someone but they've wiped their wallet then the coins are irretrievably lost.Similarly, if the network is flooded with 0.01 fee transactions and you make an urgent payment but forget to include a higher fee then you can't reissue that payment backed by the same coins but with a fee.If you could cause the current block number to be pushed on the stack and do some maths with it then you could implement a payment that must be spent by the recipient before a certain block number is reached or else the script would allow it to be spent again by the sender for example. I suspect that this would be a very popular transaction mechanic.ByteCoin GPU mining has had an interesting effect on Bitcoin even in the short time I have been involved.When I first heard about Bitcoin (through Slashdot or similar) I was intrigued by the idea and ran the client to see if I could generate some coins even though it's a non-trivial security risk.  Generating some coins then made me have some sort of emotional investment in the project. Similarly, I think that a lot of people who currently support the project would no longer be so interested if they lost all their coins. I think there's some hostility to people who suggest that the current scheme should be scrapped and restarted in an improved form purely on the grounds that the existing balances might be wiped out.GPU mining now means that running the client is no longer so apparently rewarding and it means that a lot of the superficial appeal of Bitcoin has gone. A lot of the forum posts have been concerned with valuing bitcoins or predicting the future value while seeming to ignore that you can't actually buy or sell very much with them. I think that the current situation where generation is not a significant factor in most people's decision to support the network is a more realistic environment in which to judge the success of the scheme.ByteCoin At the risk of provoking an economics argument, I think that economies are driven by people having supplies and demands that they wish to match up with other people's demands and supplies respectively. The money is just a means of facilitating this. The problem with Bitcoin is that the current monetary system performs this function very effectively and the reason why there's not more Bitcoin activity is that there's not a persuasive reason to engage in it. If you look at other e-currencies like egold, you can see this effect in action. The illegal money-laundering side of the economy gravitated towards egold because unlike the normal financial system, egold didn't actively discourage it.So in order to "jump start" the Bitcoin economy you need some application that it can satisfy better than the normal monetary system. Preferably you need an application that isn't arguably illegal or the "authorities" will come down on it like a tonne of bricks regardless of its actual legality - mark my words.Anyway, that application is not micropayments; Bitcoin isn't good at that. It's not full anonymity either as payments are at best pseudonymous. Nor is it instant irrevocable payments as they take time to confirm. I think Bitcoin is at the moment and implementation in search of an application. The greatest rewards for using it have so far been intelectual and to me it has the flavour of something released into the wild as an experiment.ByteCoin  In your initial post RHorning you raised a number of interesting issues and I did not give them an adequate response in my immediate reply.You think that people should be rewarded for participating in the network by providing network bandwidth for example. This is a perfectly reasonable position and I agree with you. Unfortunately there's no way that I can think of to implement this in the current Bitcoin system without being scammed or having some other negative consequences. If you were to think of a way to implement it and specify it in some detail then I'm sure the proposal would be examined in considerable detail.It's hard to imagine how network participation would be rewarded because Bitcoin is not good at micropayments. Every payment is sent to each client and gets recorded in the block chain on each client's hard disk. The number of fee free payments per block is relatively low. Let's say you can get 50k of transaction data in a block before you have to pay. Let's say the minimum size of a transaction is 100 bytes (it's actually more) so that's 500 transactions in about 10 minutes or less than one transaction per second and everyone's hard disk fills up at 2.628G bytes per year. Even if one lets the micropayments accumulate on account and you settle it relatively infrequently, it's still going to be a significant proportion of transactions.The second problem is that any reward that creates coins from thin air has to be mutually agreeable and verifiable. It would be hard to verify that all this network participation was not just falsified to get the money.The third issue is satoshi's de-facto control over all aspects of Bitcoin. I don't have an opinion about whether this is good or bad, it just is and has to be taken into account. In another thread, gavinandresen opined that it's way too early to start asking for commitments to adhere to a particular interface or functionality. Upon reflection I believe he is right. If you look at the amount of generally useful code written to further the project, essentially all of it has been written and tested by satoshi. Note that I'm not counting GPU miners as useful! Thanks to him, we all have a nice reference implementation of Bitcoin that we can examine and play with and a wonderful forum to share our thoughts. If he discontinued development for whatever reason the project would rapidly grind to a halt. People disagree on what exactly Bitcoin is and how much would have to change before it wasn't Bitcoin anymore. The real answer is that Bitcoin is whatever satoshi implements for the forseeable future. At the moment and for the forseeable future there are a lot of features of the current system that need to be discovered and addressed before an improved system can be designed intelligently. If the current scheme were substantially changed then a lot of the momentum would be lost and it would take quite a while for the new system to reach even the current low level of maturity.ByteCoin Brilliant!ByteCoin Of course, if the network is not being flooded and you're not overly concerned about the current transaction getting held up then it's probably worth preferring to use your 0 conf transactions so that you can "save" the higher priority coins for when the network is being flooded.Unless I misunderstand, it looks to me like the current logic is more likely to spend the accumulated priority of older transactions. It's a minor point however.Gaming the system  by including 1000 or so recently turned over BTC to bump the priority as described in my post above still works of course! ByteCoin If you want to know how to do it with the least effort, just make a number of normal, low value transaction to another address you control and put chunks of the data into the scriptPubKey followed by an OP_DROP.ByteCoin Bitcoin rewards user's expendature of CPU time to support the network but does not value their disk space and network bandwidth. You can't change this nor the traceable pseudonymity of transactions without the system ceasing to be Bitcoin.ByteCoin I mentioned that a while ago but I realize now that there are more effective ways of storing data in the block chain without incurring any costs. I think you can assume that at the moment an interested party can store something approaching 50k of arbitrary data per block for free. If you generate the block hash yourself, I think it's possible you could store 500k.The kiddie porn problem is real. I had phrased it in terms of Lady Gaga videos previously.As far as I can see, nothing effective can be done about it. It's a byproduct of the design.ByteCoin Fair enough. I meant that it's not necessary to issue a certificate which represents a certain number of bitcoins in a bank when you can just issue a certificate which encodes the bitcoins themselves. ByteCoin That was because the exchange of certificates was a lot more convenient than exchanging the gold. No similar incentives operate with bitcoin.ByteCoin
You're an existing bitcoin expert evaluating the possibility of becoming a sort of foreign exchange company expert - tricky and expensive.A better solution would be to form a relationship with a company that already has expertise in making money-money transactions and persuading them to enable purchasing and redeeming bitcoins. Even a cheque cashing company would do.ByteCoin You could do this by printing out your private keys.  gavinandresen may have some python code that can parse the wallet.dat and display them.ByteCoin The priority calculation you suggest would be a considerable improvement over the current system of first-come-first-served. If it were implemented then I think it's likely that the incentives outlined in my post would cease to operate and that average transaction sizes would not increase significantly.There may be some incentive to break up large change if it is believe that spending it is not likely to be required in the near future, in order to ensure that coin holdings of adequate power always exist. It's hard to do this correctly as it requires the forcasting of both priority and spending far in advance.If there were many contending transactions there would be a tendancy (all else being equal) to retard blocks with multiple ins because scriptSigs are so much larger than scriptPubKeys. I haven't an opinion whether this is bad or not.I think there may be some small distortions to the value of older transactions on the grounds that they are so powerful. People might be motivated to "exchange" the private key instead of performing a transaction in order to maintain the power of these old transactions while still "spending" them without actually spending them. This would be nothing but advantage to bitcoin as these key exchages don't show up in the block chain.Also unfortunately, there would be the incentive for the following undesirable behaviour:Suppose someone has just been paid a large sum of bitcoin (1000BTC)  and needs to make some small payments(1BTC). They also have recently been paid some smaller amouts of bitcoin(0.5BTC). If they try to pay the 1BTC debts using their 0.5BTC credits then their transactions have very low priority. This transaction can be represented as 2 * 0.5 BTC = 1BTCIf however they include the 1000BTC then the transaction has a much higher priority and it's not really wasting any significant accumulated age-derived power of the recently received 1000BTC. This transaction can be represented as 1000BTC + 2 *  0.5BTC = 1BTC + 1000BTC. This would approximately double the size of this sort of transaction.  No incentive to do so thanks!ByteCoin I have used it a little and I think it's great. Minor observation: If I enter 111111111111111111111 it doesn't come up with anything but if I enter 000000000000000000000 it does. There seems to be a problem searching for addresses.I used this link http://theymos.ath.cx:64150/bbeThe genesis block is one of the few pieces of arbitrary data that is coded into the client. Nobody controls it. It was specified when bitcoin was first generated and it can nobody can change it without throwing away the block chain and the current client.ByteCoin I agree completely.In order to enable interoperability we need to have a sufficiently detailed specification of the scripting language, how mathematically scriptSig satisfies scriptPubKey and some commitment from Satoshi that he will "play nicely" with such efforts.It would be annoying to have to reverse engineer everything and to fix it when the standard client changes the implementation. See Samba/Microsoft.ByteCoin The current proof-of-work scheme has the drawbacks of not having any beneficial side-effects and being particularly suitable for GPU calculation.It doesn't have to be this way. See http://bitcointalk.org/index.php?topic=203.msg3669#msg3669ByteCoin If you're a small company, just take the above example and pretend you're just a branch office.Also, most multinationals don't write their own finance software so they won't "do it themselves". ByteCoin If you're a multinational using Bitcoin for substantial payment and capital purposes you might have an architecture as follows:You have several branch offices overseas and dedicated secure lines and failover satellite links running between each of these and your head office . Each branch office runs a Bitcoin node that accepts and relays transactions across the network and maintains a block chain. As these computers accept arbitrary data from arbitrary peers they are hard to secure they therefore have no ability to generate new transactions and certainly no wallet. They purely act as the company's connection to the bitcoin network. They are geographically and topologically separated to mitigate network fragmentation and to shorten the maximum propagation distance for any of company's transactions. The branch offices also have a secure intranet that runs transaction generating software. This can show balances, make payments and everything a company branch wants to do with money. There are probably many terminals capable of creating new transactions. Each terminal signs any bitcoin transaction it wants to make and sends it to the gatekeeper nodes described below. They get their information from their internet-facing bitcoin node and possibly from the company's other bitcoin nodes over the secure lines. Each branch might have a separate secure computer holding some private keys but only with relatively small balances suitable for branch operation. The public key holding computer would only accept suitably signed bitcoin messages. Access to this secure computer would be through a secure gatekeeper computer which would perform various sanity checks on the messages but would have no ability to sign them so, if compromised it would not be able to create bitcoin transactions. Large transactions and most of the capital would be held at the head office secure computers. If the branch terminals wanted to generate a large transaction that the branch holdings can't satisfy then the signed transaction is sent to the secure gatekeeper node at head office.If an internet-facing bitcoin node is compromised then the harm is small as there's no ability to generate transactions and no wallet.If an attaker cracks the secure intranet or gets access to a terminal they can attempt to make transactions. Hopefully the gatekeeper sanity checking would minimise losses.If the gatekeeper node is compromised then transaction approvals grind to a halt but as it can't generate signed transactions there are no further losses.When I say "sign", "signs","signed" and "signature" above I just mean normal PKC not bitcoin signatures.ByteCoin  You must appreciate however that serious security flaws continue to be found and can be inferred to continue to exist in a wide variety of carefully written and carefully reviewed applications.  Absolutely. I therefore think it's important to separate the transaction generating code from anything network-facing. My post was more of a display of the design techniques required to implement a secure system rather than a do-this-and-everything-is-fixed-forever solution.Agreed. However, splitting the functionality across processes that communicate using a clear interface would allow wallet handling code to run on secure back-end machines without direct internet connections.ByteCoin Buffer overflow attacks against the current client could allow an unauthenticated remote attacker to steal your bitcoins.I raised this topic in http://bitcointalk.org/index.php?topic=1688.msg20574#msg20574The principal flaw of the current client in this respect is that it's a large monolithic process that accepts arbitrary data from arbitrary network connections and performs complex processing on them while having full access to small valuable private keys.An attacker who could patch the client could ensure untraceable access to all future private keys (with some caveats).The way to secure this application is by restricting the operations we allow to be performed on the private keys and by simplifying the code accessing the private keys.The only operations that ever need to be performed on the list of private keys are "read key" and "add new random key". A malicious process that can read an arbitrary private key can spend the coins associated with that key. A malicious process that can add a new random key can only waste storage space. As an aside, a malicious process that can add an arbitrary private key can spend the coins assigned to that key in future, so we must forbid this. To help the enforcement of these rules, the file holding the keys could be opened with only read and append permissions.The private key handling process would accept only two commands. "Sign message" would take a message and a public key and return the signature. "Add new key" would return the new public key. A separate process could control access to the "sign message" interface of the public key handling process. This could perhaps check that the value of the messages signed was under a certain limit before requiring user confirmation. It could check that the rate of spending was not over a certain limit or that the total sent for that day was not excessive.The private key handling process should not attempt to parse and check the messages it signs as it makes the code vastly larger and more difficult to prove secure.ByteCoin  What happens if you're also uncomfortable having a balance that is doesn't have a nice round hexadecimal representation of nanobitcoin?  ByteCoin I was arguing more along the lines of removing wallet handling code from the current client and putting it in a separate process. Suppose the bitcoin client has a buffer overflow or other similar vulnurability in the code that handles incoming network transactions or blocks. A suitably malformed transaction could result in arbitrary code execution and the malicious code could quickly steal all your bitcoins (or worse).It's hard to secure a process that accepts multiple network connections from arbitrary peers and performs complex validation processing on the arbitrary data they send. ByteCoin Prioritizing larger value transactions doesn't really solve the problem because it's perfectly possible to spam by sending large amounts of bitcoin from one of your addresses to another ad infinitum.If you prioritize older transactions, people would be incentivised to split their bitcoin holdings in such a fashion as to ensure that they do not generate significant amounts of change when they buy things with bitcoins. If you hold your bitcoins in powers of 2 * 0.01 then you can pay for anything you can aford with no change and the least fragmentation. Of course after spending the money you have to rebalance your holdings as soon as possible. The best way to do this is not immediately obvious to me. Possibly under certain circumstances it might be advantageous to generate change as long as you could specify how you wanted it split up. Possibly powers of 3 might be best for multiple purchases. Anyway, the end effect would be that transactions would have more ins and outs. Probably the average number of ins and outs would be some very small multiple (or large fraction) of the log of the number of bitcoin pennies in the transaction. I estimate that this might increase the average transactions size by over 10 times.   ByteCoin I agree that the Bitcoin coin generation should be a separate process that has a clean interface to the network.I further think that the block chain maintainance code should be a separate process from the wallet management and transaction creating process. Let's suppose that there's a buffer overflow or similar flaw in the network handling code of the current client. If an attacker sends a suitably malformed transaction onto the network then they can execute arbitrary code on all connected machines running the client. This code could empty all the attacked clients' wallets or more subtly, send the attacker all the private keys in the wallet. If the block chain maintainance code were a separate process to the wallet code then this attack would be prevented.I have mentioned this before in http://bitcointalk.org/index.php?topic=665.msg18578#msg18578Also, for those interested in some sort of collaborative or distributed mining there's this thread http://bitcointalk.org/index.php?topic=1458.msg17020#msg17020If implemented appropriately as discussed in the thread I believe it can be implemented completely securely and transparently.ByteCoin (Let's hope I get it right this time) Until the block size is 50k bytes transactions below 3k bytes are free. That's where the 50 came from in my previous post where I got it wrong. Most transactions are below 3k.In the absence of people like Artforz who hash without fees, I believe that the tiny unfeed transactions would be incorporated into the blocks 50k bytes at a time. I imagine it's first come-first served for inclusion into blocks. If it's more probablistic or even intelligent then it makes this attack more difficult.I believe so , yes. This is precisely the point I was making in one of my recent previous posts.I think the viability of various denial of service attacks is acknowledged.ByteCoin Oh my goodness! You're right! How embarassing!ByteCoin No. EVERYONE stores the block chain (at the moment). Why should a generator be able to inflict a large block on everyone just because he generates a hash?As far as I can see, the code above vindicates me and means that you were mistaken.You said I said that this only occurred if the block size was over 40k bytes (which I revised down from 50k)You seemed to disagree.ByteCoin If some behaviour is "by design" it tends to imply that the result is either good or at least ok. I was making the case that this behaviour is bad, is a flaw and should be changed. I presume you disagree. Could you explain why? ArtForz is essentially enabling the adverse behaviour I outlined.   I don't think you're right. I believe you can send a 25K byte transaction if the resulting block size is below 40k bytes for example. If I'm wrong, quote the code that forbids it.In my previous post I should have replaced 50kb with 40kb to be correct.ByteCoin This doesn't prevent the scenario whereby someone isolates a client or group of clients by fragmenting the network or running lots of clients on different IPs and relying on luck  or crashing CUDA clients with a magic transaction and then jumping in with lots of CPU power to maintain a plausible block rate. I know it's a hard attack but my scheme prevents it, possibly at the cost of some privacy. Sounds horrible to try to code and then debug/test/prove correct.Bigger problem fish to fry at the moment!ByteCoin Good catch. My mistake! I presume they sum the logs of the difficulties? Could someone point out or message me where this happens in the code please?ByteCoin
You could always make a block chain in which all the blocks are generated on an easy difficulty. After a certain time the difficulty jumps up and you don't bother creating any blocks until it jumps down again whereupon you generate loads of blocks again. It still wouldn't be easy but to generate a longer block chain I don't think you'd have to do it at the same difficulties as the current one.ByteCoin It is indeed a problem if spent coinbase transactions get "rolled back" as those coins are deemed never to have existed. An attack based on an adversary with huge computing power rehashing a decent chunk of block chain to invalidate coinbase transactions that have been spent can be prevented or at least detected as follows:When a hash of sufficient quality is found for a particular block, all the clients which have generated hashes for that block which are not quite good enough send those hashes to each other, signed by some per client key. Each client that receives this information can use it to get a good estimate of the total hashing power at a given time. If the hashing power falls abruptly to a small value then the client suspects that the network has fragmented and it's on a small fragment and new coins must not be spent. When the hash rate it sees ramps up again then it must compare the incoming near-miss client signatures with the ones it's used to seeing. If they're a lot different then an attack is in progress.Similarly, clients that seem suddenly to find lots of blocks thereby rewriting the block chain, without previously finding even more lots of near misses must be under suspicion of misleading the other peers about the aggregate hashing power and attacking the scheme.The block chain could be eligable for locking with no ill effects, a few blocks back from at any point where the current estimated hashing power is some fraction greater than half the max estimated hashing power ever seen.The astute will notice that these suggestions are dual to "balance sheet" and "regular block creation" ideas.ByteCoin I think that only happens if the current block is over 50kb already. Otherwise I think it's just accepted. I might be wrong - if I am, please point out in the source where recieved transactions are checked for the appropriate fees.I searched the source for "GetMinFee(" and it seems onlyto be called in BitcoinMiner and CreateTransaction. This would lead me to believe that a miner can attempt to hash a block with some arbitrarily large transactions in it and, if it finds a hash of sufficient quality then that block will be transmitted around the network and accepted by all clients without demur. The size of the block might be limited by any size limits of the buffer for receiving transactions and blocks from the network.Anyway, that's another possible method of attempting to store the latest Lady Gaga video in the block chain!ByteCoin You'll never believe it but I typed a big long reply and then lost the whole thing out of preview!The transaction is identified by the hash as you say below.That's what the index is for. I'm pretty sure they don't HAVE to have different scriptPubKeys. I wonder whether this corner case has been tested but it's probably fine.  They are not hashed. One is appended to the other and then parsed as a Forth-like (ie stack based) script. The link you quote actually explains it quite well. OP_DUP for example is a human readable translation of the actual opcode (158 I think). The tables in the link show suceessive stages of how operands are pushed onto the stack, popped off the top, operated on and the results pushed back. The opcodes are specified in a big enum in script.h Yes this is a known problem mentioned in a recent previous post of mine. People minting coins have an incentive to do this as it costs them nothing and the return in the long run for any of them for doing so is positive. Transaction fees discourage this but if no transaction fees are included and the transactions are individually not too large then they just hang around in everyone's memory until they close the client. Another known attack mentioned in that previous post of mine. I presume that a large single transaction requiring fees but including none will be rejected and forgotten from the current client.ByteCoin Why would you include a keypair in a transaction? Just to clarify - what private key do you use to generate the signature in the above transaction. Do you sign the transaction containing the private key with the same private key?The moment you reveal the private key, you lose the ability to stop someone from impersonating you. If you send your card creating transaction to a bad node first, what's to stop the bad node from using the private key to create a new transaction crediting him and then sending that racing across the network?Is this "private key revelation" just something you've introduced for your scratch-off card scheme or do you think that normal transactions reveal the private key?ByteCoin Ok thanks for the prompt reply. There are just a couple of points I still don't get.Please let me know exactly how the private key can be known to both card creator and redeemer.The normal meaning of keypair is "public key and private key". The private key can't be made public, that's why it's called a private key. Please explain very carefully precisely who knows about which private keys and how you propose to use them. It's the redeemer's keypair which signs the transaction which spends the scratch-off card. If it has just been generated by the redeemer then the network doesn't know the public key which should be used to check the signature hence you have to tell the network about it hence it's the redeemer's public key not the card creator's public key. I very much suspect that you have some fundamental misconceptions about how public key cryptography works. Please think carefully and be excruciatingly clear in your reply to show where I am mistaken if you still think I am wrong.ByteCoin Thanks for going into a bit more detail. Unfortunately I believe you expect readers to have a lot of shared context to understand your explanation and I for one am still unclear. I'd very much like to understand though.Please correct me if I'm wrong in any way in the following summary.What we're discussing is minimizing the amount of typing required to redeem Bitcoin scratch-off cards. I imagine that a basic card shows the public key (or address) credited with Bitcoins so that anyone can check the value and that it's unspent once they type in enough characters into their card-savvy client to uniquely identify it from the block chain. The scratch-off bit protects the private key, most of which needs to be entered but the last few digits can be bruteforced by the client program to save you typing. It does this by trying all possible values of the rest of the private key until it matches the public key. Alternatively, if you've already accepted the card or you just really hate typing, you don't bother typing in any of the public key, you just type enough of the private key until the computer brute-forces the rest of the digits to find they match some public key in the block chain.The point of your post is that a normal private key is too long to make it easy to enter, and your scheme involves less typing.In order for the Bitcoin network to accept your transactions, you have to make sure that you can satisfy the conditions stipulated by the script of the "In" transactions that you're using. The vast majority of scripts effectively check that you have knowledge of the private key for the public key which the "In" transaction was intended to credit. The script checks this by making you sign something. What exactly? The idea being that only the holder of the private key can generate such a signature.In your scheme the card references a transaction with a non-standard script. Since anyone can spend the card on recipt, the script can't require you to demonstrate knowledge of a private key. Instead you have to satisfy some other condition involving "the signature", "the code", "the real code", "the target". The scratch-off portion reveals a shortish code, the hash of which is included in the script. The hash in the script is salted with something else in the script or otherwise publicly available to discourage "rainbow tables" attacks. What is it? The length of the code must sufficient to prevent exhaustive search by attackers in the time interval between the card-creating transaction being distributed to peers for inclusion in the block chain and the time when the card recipient is able to enter the code into his card-understanding Bitcoin client application. You say the salt is "the first few bytes of the private key". Whose private key? If it's yours how does the card generator know it. If it's anyone else's how do you know it? Then the script requires you to provide a signature less than a target value and provide the public key that allows people to check that it's a real signature and not some numbers you just made up. So the person spending the card has to increment a nonce and repeatedly generate signatures until they're good enough.So, when you spend the card, your transaction provides enough information to allow the Bitcoin nodes to verify that your transaction satisfies the conditions of the script. The problem is that you can't send the transaction to all nodes at the same time and, if the first node you send it to is "bad" it could take the information in your transaction and use it as an "In" for a transaction crediting itself. It would then be a race across the network between the two transactions. The idea of forcing the client to generate a certain quality of signature is that the "bad" node can't generate a signature of sufficient quality before your transaction has reached enough honest nodes and is most likely to be hashed into the block chain first. This depends critically on exactly what is signed. The "bad" node can see the non-standard script in the block chain since the card-creating transaction was distributed. Could it generate the good quality signatures for all cards in advance? (And sell them to other "bad" but lazier nodes  ) Could you tell us what information is signed please?Note that part of the problem was that we couldn't send the transaction to all the peers at the same time. If you could send the transaction a byte at a time in round robin fashion then the problem would disappear! Another way around it is if you could make the satisfaction of the script depend on another transaction which has to be in the block chain - the details are hard to explain.What numbers are available for pushing on to the stack and what operations work a the moment? Can you specify for example that a transaction using yours as an "In" must have another "In"?    ByteCoin Thanks for that. You might feel that you're mailing this stuff into a void but I have taken note for my own project and I appreciate not having to work it out for myself.ByteCoin That sounds fascinating. So the scripting language is fully enabled at the moment? I thought it was present but lobotomized.Could you talk us through the little script you published?I presume that this requires new clients? If not, how do you do this?I disagree very strongly. I believe the computations you mention could be done in much less time than network latancies. There must be a cryptographic way of enabling secure cards or else they will fail. Your proof-of-work signature is a good start. What scripting functions would need to be added to support it?I don't understand how this links with the previous bit of your post. Please explain.ByteCoin It's only easy to detect if you bother looking for it. Without noticing the symptoms you mention there's no reason to check.One way to make this attack a lot more costly is to ensure that a certain small fraction of the nodes you connect to have found a hash at some point. You can do this by asking the node to sign something with the same key that was used to sign a coinbase transaction. If it can't, then it hasn't found any hashes ever.ByteCoin This is a nice problem! Public key cryptography to the rescue!What you need to do is generate an RSA public and private key.n=p*q where p and q are large primes.Choose e, 3 or 65537 are popular choicesCalculate d = 1/e mod (p-1)(q-1)You publish the public key (n,e) on the webside while keeping the secret key (d) private.When you recieve the payment information, you generate a number x less than n in a verifiable, previously published fashion from the transaction information that nobody can change and everyone can verify.You calculate  s = x^d mod n, send it to the dart thrower and use that to determine the result of the dart throw in a previously published fashion and then send him winnings if any.The dart thrower can verify that the dartboard has done the maths correctly by calculating x from the payment and verifying that s^e mod n =x.The dart thrower can't engineer his transaction to win the darts because he can't compute x^d mod n.The dartboard can't change any parameters to say that the thrower has not won when he has.ByteCoin   I must correct you jgarzik when you said that you stood corrected! I believe that theymos has made a mistake in his calculations.We're assuming that we can generate transactions as close as possible under 1000 bytes long.The basic charge is 0.01 for 1KB which applies after the block size exceeds 50KB. So the 200KB between the 50KB and 250KB block size would cost 0.01*200=2BTC. We agree!After 250KB if the block size is x (in KB) then the charge is approximately multiplied by 500/(500-x)This means that the charge jumps to 0.01 * 500/(500-250) = 0.02 BTC after 250KB ramping up to 0.01 * 500 /(500-300) = 0.025 BTC at 300K. For the fifty 1KB blocks between 250 and 300 the most expensive one only costs 0.025 BTC so the total can't possibly be more than 1.25 BTC so theymos is easily out by a factor of 100.More detailed calculations (neglecting the real rounding used in the code and being somewhat cavalier about other details) giveBlock SizeCumulative CostKBBTC500.002502.003003.143504.584006.6245010.1249932.535005032So the last transaction of 999 bytes to take the block size to 499999 bytes costs 5000BTC and the preceeding one costs just 5 BTC!ByteCoin You seem to be holding two mutually contradictory postions, creighto.On the one hand, in response to my observation that hashers are rewarded for using up the free transaction quota, you reply that the fee schedule could be altered to discourage it. On the other hand in your response to caveden you imagine that fees will not be charged for all transactions until we're all long dead.For this to be true one or more of the following would have to occur:Bitcoin ceases before fees are levied on all transactions.We all die rather sooner than we expect!Hashers will forever altruistically refrain from maximising their profit and nobody uses Bitcoin for data storage/distribution purposes.Please explain.Ok perhaps not all transactions would have fees but the free ones would immediately be used up by the hasher spam so effectively all transactions would need fees.The point I was making about buying something expensive urgently is the following:Suppose I have 90 BTC. My friend is in desperate need of 50 BTC so I send it to him without including a fee. All the "free" transactions in the block are taken and, as it doesn't include a fee it's not included in the block. I realize my mistake and would like to cancel the transaction and am willing to reissue it with a 10BTC fee payment to get it in the next block for sure. However, I don't think I can do that as I've already spent the 50BTC and I only have 40 left. There may be a workaround for this. What is it?More fundamentally, let's say someone for whatever reason spams the network with lots of transactions with no fee at 1MB per second. Most of the transactions don't get into blocks because they don't have the necessary fee, but they are not forgotten! They have to persist in all the clients to try to get into the next block. Are they stored on disc? If they are stored in memory then the client consumes memory at 3.6 GB every hour! If they are stored on disc then it's the same problem as if they were hashed in the block chain.Unless there is a scheme for forgetting transactions that have insufficient fee then it's still a big problem. I said that Bitcoin doesn't have effective countermeasures against spamming. I think I have shown that fees are not effective and that the current fee schedule make the problem worse, not better.ByteCoin The current fee structure is acknowledged to be tentative and I had assumed that in order for the system to work properly as the transactions ramp up, the fees would mostly be scrapped. The current fee system for example actually encourages abuse by block hash generators as follows:People trying to earn money hashing blocks have an incentive to spam the network with enough small transactions (1 in and 1 out) to fill up the 50kb "small transactions are free" limit. If any real users of Bitcoin want their transactions to go confirmed then they have to pay the 0.01 fee to get them included in the next block in preference to the spam transactions. The cumulative fees reward the block hashers for their spamming.When fees start to be effectively mandatory under the above scheme, some interesting cases need to be handled. For example, if someone tries to buy something expensive that they need urgently with bitcoin but they don't include a fee, can they then reissue the transaction with the fee, using the same coins or will the network regard the original unfeed transaction as having already spent them?ByteCoin  Bitcoin currently provides excellent security guarantees against forgery or other tampering but no effective countermeasures against spamming or other denial of service attacks. Spamming the network with valid transactions at 1MB per second results in a disc usage of at least 2TB per month.  This would cause probably all hash generation to stop after a couple of months. What would happen subsequently is less certain. Possibly if the attackers ramped their spamming up slowly then people would sell their Bitcoins just before they stopped their client and deleted the transaction data taking up all their disc space. This would drive the price of Bitcoins down and the attackers could buy them cheaply. Then a client more resistant to spamming is released (such as a client using "balance sheets"  ). Harmony is restored and the value of Bitcoins soars to its normal level!ByteCoin Thank you theymos for taking the time to criticize the scheme in some detail.After a new block is found the balance sheet is recalculated (possibly incrementally) and the hash of the balance sheet is encoded in a special transaction that serves to encode the data which is then broadcast round the network the same as a normal transaction. This is done by exploiting the broadband subchannel in ECDSA mentioned in another post of mine. There are some details to be fleshed out such as "who generates this balance sheet hash transaction" and "how do you cope with a malicious balance sheet client supplying incorrect data" but I believe there are multiple adequate ways of addressing these problems.Thanks for supplying some real numbers. I'm afraid that "balance sheet" is not really an accurate description of what is stored. See We need to store enough information about all the transactions which credit an address to allow appropriate references to those crediting transactions to be recorded in the transaction when you spend money from that address. It's like the stubbing-off-merkle-tree-branches idea in the white paper except that the stub hashes don't need to be stored and neither do the blocks. I doubt at the moment the "balance sheet" idea would save a significant amount of space but that's because Bitcoin is so thinly exchanged. As the fraction of spent transactions rises, the storage savings of the balance sheet method become more persuasive. I'm not quite sure what you mean. I think this is the same objection that gavinandresen raised earlier in the thread in response to me misunderstanding exactly how transactions worked. After he put me right I changed the scheme. After reading my reply, if you're not satisfied, please explain the problem with my scheme in more detail.Isn't it true that when you download the block chain you process it all in the current scheme? It seems to be that your criticism is more appropriately leveled at the current scheme because new "balance sheet"-using clients download the current credit list from other similar clients. The client then updates the balance sheet with all the incoming transactions to stay in sync. No processing of spent transactions ever takes place.I'm not sure what you mean by a "parallel network" or why it would be necessary. I believe it would use the current network, as a "balance sheet"-using client looks, to the network, (mostly) like the existing client. You can't however download the older portions of block chain from it as that's data it has "forgotten". You are right in thinking that the "balance sheet" scheme becomes unmoored from the root hash. You are correct in thinking that this is a problem which needs to be addressed and I believe that my scheme can offer roughly equivalent security guarantees to the current scheme but the details are complex.Implementing "balance sheets" without altering the current protocol is rather complex and that makes it unattractive. However I believe that Bitcoin will have little choice but to either change the protocol or to move to a client implementation in which nobody remembers all the transactions, such as "balance sheets". There's nothing stopping a small group of people spamming the network with transactions possibly encoding the latest Lady Gaga video or child pornography etc. As a method of storing data on the internet for free it has the benefit of designed-in complete permanence, distributed reliability and plausible deniability. Before becoming bandwidth or CPU limited I believe that the block chain+transaction data could grow at about 30TB a year with the rate only increasing. This is going to exclude the vast majority of people from running full clients. Either Bitcoin would have to give up the p2p label or it's going to have to start forgetting old transactions. Of all the ways of doing the latter, "balance sheets" is the best.ByteCoin This would be one reason for splitting the bitcoin client functionality into two orthogonal parts. One part would maintain the block chain, verify incoming transactions from the network and provide the interface for obtaining useful information from the block chain. It would neither contain nor have access to any private data. It would have large data files which need never be backed up but re-downloaded if lost. This would be the "server".The other part would run the UI and allow the user to generate transactions, maintain the user's wallet(s), show the user's balance, incoming and outgoing transactions. It would contain the minimum of information that is also encoded in the block chain and the files would be small and easily backed up. This would be the "client"Possibly hash generation could be a third independent process which is optimised for the individual CPU and other hardware. It requires no storage and just communicates with the server portion. Possibly the server portion could come with the default hash generator built in but most users with serious hardware like CUDA would run specialized hash generators using the interface on the server.ByteCoin A competitor to whom from doing what? Because this relies on the twitter infrastructure which is another point of failure. If the Bitcoin infrastructure fails then no Bitcoin payments are possible. If a messaging infrastructure is implemented within the Bitcoin protocol then (under plausible circumstances) the messaging would only fail if the payment infrastructure failed in which case there was no point sending the message anyway. Nothing lost.If you implement the messaging in twitter then you have to cope with both the additional scenarios in which exactly one of twitter and Bitcoin fail. This would complicate your implementation. I don't believe that twitter provides a guaranteed quality of service so you would be vulnurable to the human factors whereby support for your metadata is limited or terminated etc...Considering that the fundamental size of a number used by the elliptic curve cryptography in Bitcoin is 32 bytes, 512 bytes means you can transmit 16 of them in one metadata packet. If you steer clear of the patent-encumbered point compression then a public key or a signature take two slots each and encrypting a one slot message takes four slots if you're keen on security. This still leaves plenty of room for your payload. The details on how much room is left depend on exactly what sort of security guarantees you're trying to achieve.However, I suspect that a secure public key cryptography system implemented over twitter would be subject to various kinds of interference until rendered unsuitable.ByteCoin PS Thanks for the interesting twitter info. Using the same definition, "Balance sheets" is essentially done as well!  ByteCoinPSThe current Bitcoin client has the undeniable advantage of existing.Neither the lightweight whitepaper client nor a "balance sheet" based client exist but both are compatible with the current protocol.They are therefore equal on that basis.I contend that a "balance sheet" based client is superior in every other practical way to the lightweight whitepaper client or the current client. If it were implemented correctly, it would be superior to the current client. If a new Bitcoin-like protocol were correctly  designed and implemented with "balance sheet" and other improvements in mind then it would be superior to the current protocol.
Thank you for rejuvenating an old thread! I'm glad you're taking an interest and you have strong opinions but there's no rationale in your post which would cause anyone to take them seriously.Why would it not make sense for a mobile phone application to have essentially the same functionality as a full client? All the clients being the same simplifies interactions.You seem to be making a distinction between a Bitcoin 'client' and a 'server'. What's the difference?There are three resources which could possibly limit Bitcoin's performance: CPU, storage and bandwidth. Let's say 1MByte per second of uncompressible incoming transaction data which needs to be recorded in the block chain.This is a high but plausible bandwidth requirement. It might result in 10k per second ECDSA verifications which is again high but plausible in today's multi-core world. However the block chain would grow at a terabyte in under two weeks or over 30 terabytes a year which strikes me as implausibly large. This makes me think that the size of the block chain will be the first hard limit to be reached.Do you still think it's not an issue?ByteCoin  What bad effect would you anticipate?This is already sort-of possible with the current system due to the broadband subchannel in ECDSA.I was looking for ways of distributing arbitrary information in the block chain to support the implementation of a full client which did  not have to bother remembering the entire block chain. See http://bitcointalk.org/index.php?topic=505.0 - a thread about "Balance Sheets"A naive way of encoding the data would be based on sending money to a variety of addresses, the data to be decoded by examining let's say the first couple of of bytes of the receiving addresses but this is rather wasteful of bandwidth with many transactions required to transmit relatively little data.An interesting property of DSA is that if you're trying to sign a 32 byte message then each signature is 64 bytes long. This means that the signature includes 32 bytes of information just created out of thin air. If you look up the algorithm http://en.wikipedia.org/wiki/Digital_Signature_Algorithm , this information comes from the random parameter k. A signature consists of a pair of numbers g^k and another expression involving both k and g^k. If you could choose k such that g^k contained your data then you could include your plaintext data in the block chain in great big chunks. (Un)Fortunately, doing this has to be hard otherwise ECDSA is insecure. However, if you effectively release the private key then everyone can, through some simple algebra recover the k values used in all your signatures signed with that key. I was not the first to realize this. See http://en.wikipedia.org/wiki/Subliminal_channels. If you've spent all the money associated with that key then you don't care about it anymore. (Of course if someone sends more money to that key then everyone will race to spend it!) So you can encode a load of data in some normal transactions for days or months or whatever and then effectively release your private key (for which there is an elegant method) and then all the data is plain to see.Of course my "balance sheet" scheme does not suffer from this problem (if problem it is) so badly   ByteCoin You should bear in mind the fact that 1111111111111111111114oLvT2 is a valid Bitcoin address. It has 27 characters. 28,29,30... etc character addresses also exist.I have mentioned this before inByteCoin If you publish the information on a web page then if the clients want to check they can get the webpage through a proxy server. You don't know which client is really asking for the information so you can't misrepresent the state on a per-client basis. This, coupled with my signature and recipt scheme above prevents server cheating.Suppose the default situation is to send the best hash out of four thousand million.There's a big difference between  now sending the top 100 hashes out of four thousand million and sending the four thousand million hashes. I doubt you're seriously objecting to the extra bandwidth used by gavinandresen's proposal.ByteCoin Thanks to ribuck for putting me right about client cheating. I have deleted the incorrect section from my post.Magic! I've just looked at the code and it seems to agree. How did you know this esoteric fact?In this case the scheme runs as follows:The server publishes its bitcoin address. Any clients wishing to participate start work hashing a block with the coinbase partly crediting themselves and partly crediting the server - possibly half and half?. After some period of time or after a transaction is received, whichever comes first the clients send their best hash signed by the public key they want credited to the server which calculates their share of the hashing effort using the quality of their hash. The server then publishes all the signed best hashes and a new block to be hashed incorporating all the new received transactions (if any) and the coinbase split among the the clients according to their share of the work. The server possibly takes a cut. The clients verify all the published signed hashes and verify that the coinbase output credits them fairly. A winning client can distribute the winning hash block to the Bitcoin network itself.The server has to publish the signed hashes and or the new block in a fashion so that everyone can see that everyone else sees the same thing otherwise the following server fraud is possible.Suppose there are 2 normal clients A and B and one server owned client X. They all hash at the same speed so obviously the coinbase should be split into equal thirds. However the server sends signed hashes and new block targets to A, omitting B's signed hashes and similarly pretends to B that A doesn't exist. No matter who generates the winning hash, X walks off with half the coinbase instead of the third he deserves.ByteCoin  Agreed.{Deleted incorrect stuff about clients cheating. Thanks to ribuck for putting me right.}Server cheating schemes and their prevention:The server can say that a lot of of not quite good enough hashes were submitted by clients owned by the server operator. To prevent this, the server must publish all the hashes which were used in the work calculation.The server can take the proof of work hashes of one or more of the genuine clients and attribute them to a client owned by the server operator. To prevent this the clients sign their hashes with the public key of the address which they want to be credited with their portion of the pot. The hashes and signatures are all published by the server.The server can omit to publish the signed hashes of a subset of the clients which are not controlled by him and which did not find the winning hash. This enhances his share of the pot. To prevent this, the clients periodically send signed hashes to the server and the server signs a recipt and returns it to the client. The client checks the recipt is valid before continuing work. If the server omits to publish a subset of the signed hashes then the client has proof that the server recieved them and can publish this to discredit the server. If the server signature is invalid then the client stops work and the amount of computation wasted is limited.I imagine that gavinandresen's "best hash within a time limit" will be a low bandwidth and predictable method of measuring hash speed in this scheme.Finally, the server can fail to distribute the 50BTC to the clients. To prevent this I thought the cunning idea was to have as the transactions in the new bock include the distribution of the newly minted 50BTC coinbase to the participants. This would have also prevented all the above attacks in one step. The clients would stop working on hashing the block if the block transactions did not divide the proceeds in a fashion the client thought was fair.I believe standard Bitcoin software rejects blocks attempting to spend coinbase that hasn't matured. If this could be changed to allowing the spend but making those transactions 0/unconfirmed until the coinbase matures then the whole problem goes away and we're all very happy.If the server gives the clients credit transactions which don't involve the prospectively minted coinbase but instead some other source of money then the clients can just submit those transactions to the network and get the credit before doing all the work thereby defrauding the server. Otherwise the client just has to take the server's word for it that the merkle root they're using includes transactions crediting them appropriately. There's no way of proving it. This is a problem.There might be a solution involving nifty scripting.ByteCoin You seem to value the accuracy provided by your "metahash" scheme while apparently tolerating a significant amount of fraud in real-use scenarios. I believe that the probablistic schemes advocated by everyone else are sufficiently accurate, quite possibly fraud proof and result in essentially zero server load. If we can agree some plausible real world parameters beforehand and I crank through the maths I believe I can prove that the random errors produced by the probablistic rate measurement are considerably smaller than the distortions caused by inevietable fraud. Would you change your mind if I proved this? This strikes me as tricky without using lots of bandwidth. Are you saying you do this at the moment or you plan to do it? How does it work? There remain a couple of issues from your previous posts which I queried but which remain unaddressed.This was in response to a suggestion from tatcm for measuring the hash rate by counting low difficulty hashes. You seem to be suggesting that one drawback of tatcm's suggestion is that you need to compare the hash to the target. You imply that your method avoids this comparison and is superior on that basis. You furthermore imply that the comparison operation has a significant computational cost compared to the hash operation.In order for you not to be wrong you need to show1) how your method avoids comparing the hash against the target.2) that the comparison is not of an insignificant cost compared to the hash operation.I assert that you will be unable to do so and that therefore you should withdraw your "second issue" with tatcm's suggestion. You seem to be under the impression that the rate calculation can be tricked by sending a few presumably low quality hashes which are the result of an insignificant computational effort. I assert that this is not possible. You need to show why you think the client can lie about its computational effort in this fashion.Please let me know whether you will only be convinced by an explicit numerical demonstration of the superiority of the probablistic hash rate meaurement scheme and also your response to the two outstanding issues from your previous posts which remain unanswered which are outlined above. Also an explanation of how your metahash scheme can efficiently tolerate computational errors would be welcome.ByteCoin Just remind me why Bitcoin cares about the time? Is it just to change the difficulty to target a certain average block rate or something more fundamental?It seems to be quite a bit of hassle for not very much benefit. Can't the client manage just by measuring time intervals with the actual absolute time value being unused? I imagine that the effects of any systematic drift would be unimportant compared to currently accepted hash-rate related variability.ByteCoin  Your "metahash" method of measuring work, though more accurate than the probablisitic methods of gavinandresen and tcatm, is a major weakness of your method. In order to check a portion of a client's work, you have to duplicate it. This will not scale well to even tens of clients. An attacker submitting bad metahashes to earn coins without really doing the work will just shut down when found out and start a new client on a new IP.You would have to exclude new clients until a certain proportion of their results have been checked and then it becomes a probability game where the attackers only falsify perhaps an increasing proportion of their results.More seriously, you exclude clients (and servers) which are not 100% reliable. I know from Mersenne prime testing that some computers occasionally produce bad results. You can run normal software for years without noticing an error rate of one mistake in every 2^40 ops but your metahash would be very sensitive to such errors. This would result in people running genuine clients on slightly imperfect machines getting annoyed. Note that these imperfect machines are fine for normal hash generation or the probablistic hash rate calculation.You seem to think that the probablistic hash rate measurement schemes are insufficiently accurate. You might wish to do some calculations to convince yourself otherwise. There's already lots of unavoidable unfair randomness in the amount of computation required to produce a new block.Eh? This happens anyway! How else do you tell if you've got a winning hash?Nothing. But then the inferred hash rate is very low. To clarify - the hash rate is calculated from the quality and/or number of hashes and NOTHING ELSE. The client doesn't say that it's done a certain amount of work - just the hashes matter.Ah. I thought you and I were thinking along the same lines of an elegant payment method that requires no trust and cannot be scammed which is unfortunately forbidden by a fairly inessential and inelegant Bitcoin rule.You need to go into more detail about how payment works. The solutions I can think of require the client to trust the server and/or can be scammed.ByteCoin So just to clarify, you're saying that the coins created as a result of block generation can be spent in the transactions included in that same block. Won't the new block be rejected because the coinbase is not matured? See ConnectInputs. The lack of fees if fees are warranted could also be a problem as ConnectInputs checks for that too.ByteCoin The maths fundamentally does allow this under certain circumstances but a good implementation checks for it and only accepts the "normal" form. I imagine that the library does a good job and, even if it didn't, a patch would rapidly end such tricks.My method involves laboriously generating  billions of new addresses every second - but how to do that best requires some thought. There's no way of distinguishing between my novelty addresses and just being very lucky when generating a normal address. Sadly yes.If you guys want a small number of novelty addresses and are prepared to pay handsomely for them then I can generate some "manually". If there's deeper demand then I will look into automating the process but it would take a lot longer to set up. What would people pay for having the first novelty address starting with "1" and followed by the characters of their choice?ByteCoin I believe I was the first. See the following postIf there is a demand for it, I might be tempted to start a webservice like the faucet where people can buy vanity addresses for a small bitcoin fee. I have a simple handshake scheme which allows me to generate a new address for you without me finding out your private key. My method sounds like it's faster than Gavin's and mathematically it's non-trivial. It can find addresses containing a short string like "gavin" in a fraction of a second for example.ByteCoin Thanks - but no need. There are 33 characters in the above BitCoin address. This example does not contradict the statement I made.ByteCoin Show me.ByteCoin Incorrect. The smallest valid BitCoin address is 1111111111111111111114oLvT2 so the addresses can go down to 27 characters. Also, 34 character BitCoin addresses can't start with "1R" "1S" "1T" etc... I also have the ability to generate useful novelty BitCoin addresses. The best one for me  so far is1ByteCosnsUNJun4KL3HSt1NfFdXpzoRTy (pesky s)ByteCoin   I hope you have permission from the people in the converstation to post that. If not - bad form.If you edit your post to included "quoted with permission" I will delete this postByteCoin Ah, I'm sorry for not being more clear.It's true that in the existing scheme it's easy to establish whether a transaction is yours using the method you outline above. However you have to verify the signatures of all the TxIns of all the transactions you receive before you accept them as valid even if they are not credits to any of your addresses. For a transaction with multiple TxIns the computation required to verify two or more signatures is easily more than decrypting a message. This signature verification is the scaling problem to which I am referring.Please feel free not to shut up. I welcome all comments and I'm grateful for the opportunity to participate in this forum.ByteCoin Have you considered the following post which might outline an elegant solution to the problems you raise?http://bitcointalk.org/index.php?topic=425ByteCoin Useful. I have made some corrections for strict accuracy. If they are acceptable and my changes essentially stick then it's worth me spending some time expanding the list.ByteCoin http://bitcointalk.org/index.php?topic=287.msg7698#msg7698The transaction fee transaction would be designed to be a completely predictable consequence of the main transaction and hopefully any fee for processing the main transaction would also take into account the need for a fee transaction too. In other words the fee transaction would contain its own fee. This therefore seems to be a manageable aspect of the problem.ByteCoin
Possible - yes. Practical - not at the moment.The easiest way to prevent effectively permanent bitcoin loss is to backup and jealously protect the  private keys which are one roughly 78 digit decimal numbers or 64 digit hexadecimal number for all your bitcoin addresses. Everything else is recoverable.ByteCoin Actually, when you send coins to an address you can view the coins as sitting there waiting for the address "holder" to spend them even if the address doesn't exist. If that address is created in future then they can spend the coins. If you send coins to an address for which the private key has been lost then the coins can be imagined to be in limbo waiting for either the private key to be recovered or for a new key with the same address to be generated. (Not sure about the "new key with same address" bit. May depend on the details of the transaction).ByteCoin The only thing you really need to back up and keep secret are the private keys which are one roughly 78 digit decimal numbers or 64 digit hexadecimal number for all your bitcoin addresses. Everything else is recoverable.ByteCoin I believe that a Bitcoind address is just an encoded RIPEMD160 hash which can take 2^160 values which is about 1.46*10^48. The number of distinct public keys is vastly larger and hence many different public keys have the same address. This isn't as worrying as it sounds though.ByteCoin A good observation. I'm not sure exactly what fees are levied but I observe that the majority of transactions do not incur any. Would it not be possible for Bitcoin to assess the fees to be zero while witholding the amount information.I suppose if the current integer overflow bug had been an encrypted transaction buried under several thousands of blocks then recovery would have been more troublesome.They only need to bother checking them if they have reason to believe they are the beneficiary. If they don't want to bother then they don't have to and the system still works. The equivalent scaling problem you mention applies with regards to the network checking normal transactions as the useage ramps up.If encrypted transactions were made the default then then it would be much more difficult to assess at any given point who currently holds bitcoins. As they are spent, information is revealed about who used to hold them but their current holder is again obscured. The value of knowing who currently holds the bitcoins is probably vastly more valuable than the value of knowing who recently held the bitcoins and so I think the encrypted transaction proposal is helpful.The "it seems like a lot of work for hardly any gain" obsevation could be equally leveled at the current scheme of using a new bitcoin address for change transactions which has the added proven disadvantage of losing bitcoins when reverting to saved wallet files. Bitcoin seems to be reliant on the assumption that a lot of extra work is justified for any gains in anonymity and privacy.Bytecoin Agreed. Seems like a change for the better. Using a new address each time offers superior privacy for the reason you mentioned. However, some people publish a constant Bitcoin receiving address for various reasons. One example is the Bitcoin faucet https://freebitcoins.appspot.com/. Another is RHorning, theymos, sirius-m, NewLibertyStandard and Bitcoiner's signatures. One can imagine many scenarios where you can't guarantee that you can give everyone who wants to pay you a different address and my proposal helps in those instances.ByteCoin The signed TxIns are not encrypted. The network checks that they haven't been spent before and then marks them as spent. The "in" portion of the payment works exactly as normal.ByteCoin Thank you for explaining that. It seems reasonable. The precaution makes more sense nowByteCoin We can change transactions so that nobody can tell who the recipient is and how much until the recipient spends the money. At the moment the beneficiary of a transaction is a certain bitcoin address. If that address has ever received coins before then everyone knows that the money is in the same place. Alternatively, that address has been publicized as a receiving address so you know exactly where the money is going. Instead you specify that the recipient of the money is the address that can decrypt a certain message that you have signed. So your transaction would comprise a load of signed TxIns and a signed public key encrypted message saying how much of the BitCoins goes to the person able to decrypt the message. All the network nodes try to decrypt the message with each of their public keys. The one who succeeds knows that they have received the money and updates their displayed balance accordingly. When the recipient decides to spend the money their transaction includes  the decrypted message. Only when the other network nodes see this do they know who the recipient was and how much the transaction was worth. Any change is ascribed to the signing key and the decrypted message and original are cited when the change is spent in subsequent transactions. Obviously this ties up the sender's change until the recipient spends so you'd need to be a bit careful.I don't know whether this could be implemented in the current system through adroit use of the scripting language.ByteCoin The balance sheet idea is compatible with the current block list system. However as I mentioned, balance sheets enable you to throw the vast majority of the block list away. A minimal block list suitable for supporting balance sheets consists of blocks containing the balance sheet hash and a nonce. The nonce is changed until the total hash of the previous block's hash, the balance sheet hash and the nonce falls below a certain value. The transactions are ephemeral things which are passed around the network and serve to ensure that everyone updates their balance sheets identically. The transactions never need be recorded in the block list at all and, as I mentioned the block list purely becomes a method of assuring the integrity of the balance sheet. Therefore, balance sheets is actually your idea when pursued to its logical conclusion as I implied in my first post on this thread. Balance sheets do everything you plausibly propose to do in this thread with a lower storage requirement and bandwidth useage. I believe that balance sheets and the above minimalist blocklist exhibit the lowest possible storage requirements for a Bitcoin-like system.The question you asked at the start of the thread isThe answer is yes and in this post I've outlined exactly how little you need to store in the block list so long as a client can download a current(ish) balance sheet on start up and receive transaction broadcasts. Nearly full details about startup in the balance sheet thread.ByteCoin I've never seen the point of this. Ostensibly it's to stop the coins being spent until they're definitely part of the block chain.The thing is, if you allowed it to be spent immediately it could only be spent in a branch of the block chain that's includes it's own creation. If that branch is not the longest then both the transaction creating it and the transactions spending it will be rolled back anyway! There's no justification why they should be viewed any more skeptically than a normal transaction especially as they're so small. A 10000BTC transaction doesn't take any longer to mature than a 0.01BTC transaction.ByteCoin  I quoted the following portion of your postThat's exactly what a balance sheet is. As long as everyone agrees on this list then transactions work fine. Why store anything else? The block chain is merely a device for ensuring the integrity of this list. Why not just download and store the list, verify its hash in the block chain on startup along with a sufficient history of block chain to be confident it's not falsified?This provides superior bandwidth, disk space and privacy to your scheme.The public has to see the transactions to verify them, the balances can be calculated from them. I'm neglecting your embryonic scheme involving not incompletely broadcasting transactions due to unresolved obvious security problems.  If you want to provide more privacy you could always change transactions so that nobody can tell who the recipient is and how much until the recipient spends the money. At the moment the beneficiary of a transaction is a certain bitcoin address. If that address has ever received coins before then everyone knows that all the money is in the same place. Alternatively, that address has been publicized as a receiving address so you know exactly where the money is going. Instead you specify that the recipient of the money is the address that can decrypt a certain message that you have signed. So your transaction would comprise a load of signed TxIns and a signed public key encrypted message saying how much of the BitCoins goes to the person able to decrypt the message. All the network nodes try to decrypt the message with each of their public keys. The one who succeeds knows that they have received the money and updates their displayed balance accordingly. When the recipient decides to spend the money their transaction includes  the decrypted message. Only when the other network nodes see this do they know who the recipient was and how much the transaction was worth. Any change is ascribed to the signing key and the decrypted message and original are cited when the change is spent in subsequent transactions. I wonder why transactions weren't designed like this in BitCoin from the start.ByteCoin What are the desireable properties of a blinded public key which are not achievable by generating a new public key? I'm not clear on what were trying to do.Obviously this could be achieved by them all having the same keys but that's presumably unsuitable for some reason. It looks like you're trying to hide some information while trying to make it still available for other people or under certain circumstances but I'm not sure what.ByteCoin Is this is the same idea as "With "Balance sheets" most of the block chain can be forgotten"? http://bitcointalk.org/index.php?topic=505.0I think the problem with your proposal to make transactions less traceable is that the network has to be able to check that someone is not trying to spend someone else's coins before incorporating the new transaction in the block list. This, combined with the requirement to prevent double spending, seems to preclude greater opacity.You must also discourage people from forcing the inclusion of arbitrary data in the block chain.ByteCoin The transaction fee transaction would be designed to be a completely predictable consequence of the main transaction and hopefully any fee for processing the main transaction would also take into account the need for a fee transaction too. In other words the fee transaction would contain its own fee. This therefore seems to be a manageable aspect of the problem.ByteCoin Ok, I was again thinking of RSA. For this type of public key crypto it's true, you have relatively little control over the public key value. Of course if I generate a large number of public keys I could perhaps end up with about 16M =2^24 keys each with a different 3byte pattern encoded at a certain position. It would take a transaction with 11 receiving accounts to encode a 32byte hash of the balance sheet. 65536 different public keys would need 16 receiving accounts per transaction.Of course, when you do a transaction you're just sending it to a public key. Nobody checks whether anybody has the private key so if you don't mind wasting 0.01BTC per block then you could encode two hashes in one transaction if you wanted as the public key takes 64 bytes. 50BTC would last you a bit over one month. The money would of course be completely lost. I believe you could encode arbitrary data into the block chain at a cost of 0.16BTC per 1024 bytes. Or about 312k for 50BTC. This data would live forever in servers round the world under the current scheme.The benefit of the balance sheet is that you only have to receive it once when you need to sync back up if the size of the blocks you'd need to process to get back up to speed is larger than the balance sheet. Once you're up-to-date you keep the balance sheet updated in memory as the transactions go through and you just check that the hashes in the block chain agree with the hash of the balance sheet in memory. So basically the balance sheet is never sent out unless you ask for it. Similarly at the moment the entire block chain is not sent out with every new block but it is sent out if you ask it to be when you start a new client.ByteCoin I just had a bit of a brainwave as to how we could implement "balance sheets" as a non-breaking change.Presumably when you generate a new address you have, if you want to exercise it, complete control over what the public key part looks like. I take the hash of the previous block's balance sheet and split it into chunks. I make new public keys that contain these chunks of hash as parts of the public key values. I make a small transaction of 0.01BTC from a fixed address to each of these new hash-chunk-encoding public keys as soon as I have calculated the hash of the balance sheet. Each of these 0.01BTC accounts has about a month to "live" before I transfer the money back to the fixed address. If I did this earlier then in theory, the information could be at risk from the Merkle tree branch pruning.Modified, clients using the balance sheet method would of course treat the transactions as valid just like all other valid transactions but they look out for all transactions signed by the fixed address as encoding balance sheet hashes. If, as well as storing the balance sheet hash, the transactions encoded an IP address of a "balance sheet server" then new clients would know where to go to get it.As an aside, BitCoin is a great way to record arbitrary information permanently. One problem is that it thinks that the marginal value of thousands of people's disk space is zero.ByteCoin I'd just like to clarify that "balance sheets" as I outlined them were not "lightweight things" designed to augment the existing system. In order to make balance sheets reliable, the balance sheet hash needs to be included in the block chain as explained. This is a breaking change, so there's no incentive to hold back from other beneficial breaking changes.You start off with 0BTC and one person sends you 50BTC. So there's a transaction in block x which they've signed and your public key is marked as the recipient. Someone else sends you 50BTC.  So there's another transaction in let's say a different block y which they've signed and your public key is marked as the recipient.Next you want to send 50BTC to someone else. Now with a bank there's no concept of where the money has come from, it loses all it's identity when it hits your bank account. Not so with BitCoin! A new transaction (apart from coin mining) has to refer to one or more transactions in the block chain which resulted in a credit to you. So when you talk about spending the first lot of 50BTC the new transaction would refer to block x and if you wanted to spend the second it would refer to block y. I presume the choice is made for you by the current software and the user does not have any input.So to correct my balance sheet idea in one fashion, as well as the balance for each individual public key, the balance sheet would also have to keep enough information about the blocks which contain the transactions crediting the public key to enable references to those crediting transactions to be generated when spending the money. So instead of storing the public key and the balance, the balance sheet would have to store the public key, a list of crediting references and their corresponding credit amounts - the total credit being the balance. Anything more?We'd probably have to change the name from "balance sheet" to "complete current credits list".If we made a client that used the credits list method and we magically crammed the appropriate credits list hash into the block list somehow then the modified software would perform transactions which would reference credit transactions in blocks long since thrown away and the current software would be happy.There doesn't seem to be much the point of storing references to the crediting transactions in the new transaction. It's easy to see that the money is there and it's not as though we can trace coins forever even if we wanted to. In the example above, if you'd made a transaction to yourself for 100BTC before spending 50BTC then the identity of the original coins is lost. If the requirement of referring to crediting transactions is lifted then the block chain would be considerably smaller, the super light weight balance sheet method is useable and the software's a little less complex.ByteCoin The largest transaction so far is 35000BTC in block 65566.This block had about 19 transactions in, with another transaction involving 10000BTC and several others around the 1000BTC mark.This is something one is naturally curious about whenever the topic of money comes up.ByteCoin
