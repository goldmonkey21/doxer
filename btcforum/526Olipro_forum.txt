It's an interesting thought experiment and it's not entirely impossible either; say for example, if Mt Gox became sufficiently large, after they compiled statistics on their average cash withdrawals and deposits per day, they could quite feasibly loan out their hard currency on the interbank market; they may potentially already be doing this, however, it is extremely unlikely it would ever have any impact on users unless they are lending the funds out for extended periods, in which case a run becomes possible, otherwise, worst case scenario is that someone has to wait an extra 24 hours for their withdrawal.The same could potentially be applied to BitCoins, but with the current level of market activity and the nature of the system itself, there's no real feasibility to it. in regards to your IPv6 comment... IPv6 is actually very easy to restrict; only allow one freebie per /64 and also check if any requests made within a short space of each-other have come from the same /56 or /48 and if so, block accordingly. are you retarded or just a lunatic? If you care, run an API spy on the EXE - I release it as an EXE because that's what Satoshi does, and the installer is in fact identical except for including x64 headers.As a previous poster mentioned, if you give a toss, extract the binaries yourself, although I think if you're trying to imply I'm using the installer a springboard for something nefarious you're clearly off your trolley, any genuinely malicious person would put their code in the BitCoin EXE, not the installer. Yeah, my opinion on this is that the GUI should be separated from the underlying code. BUT... there's no need to throw the baby out with the bathwater and I firmly believe that the current wxWidgets interface should be maintained until such a time as something superior comes along.My personal feeling is that whilst separate daemon/GUI binaries can work, it also tends to be messy, I'd be far more in favour of having the core code and then separate source that you compile with it according to your target OS, that way everything is still a single binary and can be integrated as idealistically as possible.To put this in practice, imagine 3 SVN trunks; the first is BitCoin core, the other two are LINGUI and WINGUI - the latter two being dependant on code from the first. the Visual C++ 2010 x64 runtime is required, link provided by previous poster.And definitely delete the DLL you provided, that error means you got the 32 bit one for precisely the same reasons people run lottery syndicates.problem is, in a lottery syndicate, obviously you will know who paid into the ticket fund and who didn't.How do you plan to verify someone in the syndicate is actually trying to solve blocks?The best way I can think of is by measuring their average number of hashes per second and then have a secondary target their client must achieve which acts as a proof of work for the syndicate to know that this person is dedicating their CPU resources to generation. My usual x64 build. based on the latest SVN code.It doesn't contain tcatm's SSE2 hashing code and instead uses the Crypto++ x64 MASM (as in my previous builds) since after testing both, the x64 MASM proved to be about twice as fast.Download Bitcoin 0.3.10.3 hereif you found this useful, my BTC address is below  it doesn't, so you must be smoking something. just an idea for making it a bit better:randomize the amount the faucet gives out with the randomisation occuring once per day, per IP, you can bias it towards lower sums if you really want; either way, this would strongly disincentiveise abuse because it'd make it a real bastard to make any real profit from it. Yes, but what's so special about cash? it's just a type of asset; you're simply reaffirming that if you are using something to purchase bitcoins, the notional value of BitCoins will be increased because of your willingness to exchange it for a different asset... you could put a car up for sale with X amount of bitcoins accepted as payment, that too would have an effect on its value, however, if your price was way above or way below the current averaged value, your distortion would be short lived. Yes, because that recourse open up the possibility of either victimising people who have grudges or simple trolling (just look at 4chan) ... a host of trolls will get buyers to do escrow transactions and refuse to release them because it costs them nothing to do so.An effective automated escrow mechanism needs to disincentivise both parties from scamming/trolling. Sure, you can do it as asm instructions or you can use the SDK to make it more easy to read, it's going to result in the same code in either case.the bitcoin usage of SHA256 does not prevent you from using Padlock C style functions because they are the same standard of init, update, final. why bother? Via publish an SDK for it.I should also point out that you will need the lib files for linking. Even if the difficulty increases, you will ALWAYS have an advantage over everyone else who cannot compute hashes as fast as you. ok, posted the installer in its own topic, go ahead and grab it. For those of you who are familiar with my builds, just download itFor others: this is an x64 build which leverages x64 asm to perform the SHA256 and has some minor optimizations such as unnecessary Byteswaps being removed. if the buyer refuses to finalise the transaction and the seller refuses to permit a refund, they have 2 choices.1) be spiteful and nobody will get anything2) agree on a third party to send the money to. that third party will be an arbitrator who will weigh up both sides of the argument and come to a decision as to who should be returned the money, minus whatever fee they agreed with the two hurt parties.Subsequent to this, I also realised that my suggestion is open to trolling whereby a seller makes someone do an escrow transaction and then refuses to ship anything or arbitrate, my solution to this issue gives the following modification of the system: the buyer makes an escrow transaction which is then presented to the seller, if the seller wants to go ahead, they must agree to be debited a sum stipulated by the buyer, the seller agrees and the escrow transaction then goes into the network for inclusion into the block chain, both parties are now down on their money.if everything goes to plan, the buyer OKs the release of the funds and the seller gets the payment + his "trust deposit" returned.if the buyer wishes to cancel, the seller authorises the cancellation and both parties get their original funds back.if nobody can agree on a release, both parties now have an incentive to go to an arbitrator, when the arbitrator is authorised to receive the transaction funds, the trust deposit gets immediately returned to the seller, the arbitrator doesn't get a say over those funds. I'll grab the SVN tonight and upload it for consumption precisely, and the hashes you generate are going to be completely invalid because the target your systems are aiming for will be higher than the one the network requires.
I'm not quite sure how this attack can work because it has the following pre-requisites:1) that you can generate blocks faster than the rest of the network2) that you can do so without being subject to the same target modification rulesAs I see it, assuming you have so much processing power that you can outpace the network, when you are doing your block generation, you will still have to adjust the target using the same algorithm or when you start posting your blocks to the network, they're going to get rejected because you weren't obeying the target value rules, therefore, I don't see how you could actually permit yourself to generate blocks more cheaply by not announcing them. kind of, the point of this system is that you can leverage the network for escrow transactions so long as everything goes to plan, thereby ensuring a low cost. in instances of dispute, you will pay a third party. So, the basic escrow works by two people working through a third party to exchange (usually money) for some other form of goods or services.In a transaction where both people are honest, the escrow business can essentially be automatic since the buyer gets his goods and approves release of funds, only when there is a dispute does human interaction become necessary. Therefore, I propose the following system:1) you create an escrow transaction for the amount, authorised by your key and containing the recipient's key/data etc - this block cannot be claimed until a subsequent block is issued by the buyer to approve it, it's also impossible for the buyer to reclaim it without the seller approving it to be returned.2) it enters the network, gets verified and the seller sends the goods, once the buyer gets them, he creates a release transaction and the seller gets his bitcoins.3) if a dispute occurs and both parties are refusing to release the money one way or the other, clearly it's now necessary to get a third party to arbitrate - in this situation, a signature from both the buyer and seller authorising a third party is required which will give that third party ownership of the original escrow transaction and they can then arbitrate the matter yes, definitely fasterspecifically: the x86 build has to perform a byte reverse before hashing, the x64 build has no such requirement, this saves a fair bit of time. the x64 build also calculates the hash using 64-bit instructions. no, because Throughput will just say that someone will hack the person in possession of the key and compromise it. why? it's not the only SVN service in the world, what actually matters is the bitcoin.org domain these new builds are not Intel, they're standard VS builds because the SHA optimization is all assembler, there's nothing for the compiler to optimize so performance is identical. here's 0.3.6 offered as a full installer, includes standard GUI plus headless daemonGet 0.3.6 x64 installer here I think I went over this before but I'll do it again, albeit in harsher terms this time:just because you are too stupid to evaluate the system in both source code and binary form does not mean that everyone else isWhich means that in order for your ridiculous ideas to bear fruition it would require that EVERYONE capable of understanding the code and binaries be part of a HUGE CONSPIRACY in order to successfully defraud everyone who is unable to understand it.Let me give you an extremely simple real-world example that will utterly destroy your paranoid rants.The Linux KernelNeed I say any more? money is rarely printed relative to electronic growth, it's a number on a computer.But even then this is irrelevant, the US government could simply print extremely large notes in the form of bearer instruments. well put it this way, I just checked if there have been any new SVN commits since the announcement, and there haven't been any, I don't think satoshi would put an update out before he had it in SVN - not to mention that the SVN I have comes with the improvements he mentioned, so I'm pretty sure this is OK, even though the version number doesn't reflect it. is this in the SVN? well sod it, how did I miss that  for anyone that wants it, a headless build of BitcoinCode is identical to the GUI version except the GUI isn't linked in obviously. is the BitCoin NSIS script available anywhere? I lack the motivation to write one from scratch No point wasting a perfectly good thread I say, so, for those that want it, here's an Installer for the x64 edition of BitCoin; comes with the main EXE, localisations and a headless build.Get it here for some reason the x64 asm is only included in MASM form, if someone fancies converting it, good luck to them I say.I'll be interested to see how this goes stability wise, my bet is that it won't have the crash issues that the Intel builds did; my bet is that was a result of multi-threading being parallelized by the Intel Compiler when it really shouldn't be, race condition etc. done, grab it, everyone who sees this should redownload, I had to correct an optimization on the result hash reversal so that it correctly rotated the values after doing a 64 bit byteswap (yes, you don't have to byteswap the input but you still have to reverse the result) and with that addition, I've broken over 5000khash/s for the first time.I've updated the link above, so just redownload. Forgot to add an optimization for x64 that gets rid of the ByteReverse operations; due to the the x64 asm all the reversed bytes get unreversed when passed to the algorithm which is quite a waste so I've removed it and it's building now. so you weren't the guy who sent me 0.02 I take it?  
they'd get a payment for 0.000001 which the GUI would quite probably round to 0.00... maybe 0.01 but I doubt it OK, finally got around to doing the builds, thanks to the fact Satoshi is now using the crypto++ stuff I've been able to build it with VS without there being any performance difference between it and the Intel compiler, so with any luck we should have good stability.Please note that the x86 and x64 builds are not equal; the x64 version uses the full x64 SHA256 ASM code.I'm getting close to 5000khash/s on the x64 build and about 200k less on the x86 build (so no doubt the more cores you have the more you'll notice the difference)Link Updated, I removed the pointless ByteReverse operations and I've broken over 5000khash/sanyway, grab it here or you just grandfather the current blockchain to be accepted against their SHA256 hashes but also reject any new valid SHA256 hashes. the bug is some sort of threading issue, I'm trying to figure it out.new build based on Satoshi's latest SVN commits coming soon. talking about deflation as a "thing" is the wrong paradigm to use.deflation is simply an arbitrary term used when a group of assets prices you measure have decreased.In terms of Bitcoins being deflationary, that is very much subject to their acceptance(demand) outpacing the supply, also, given that prices tend to be sticky to the upside and that Bitcoins are not a defacto legal tender, I would be surprised if they were to have any sort of seriously detrimental impact. there are several fallacies in your beliefs:1) because you can't actually comprehend C++, you assume nobody else can.2) you assume that if satoshi suddenly goes crazy with the code, everyone's just going to let him do it.3) if we were attacked, you assume people couldn't agree to do a rollback or some other sort of response. no, it's not Crypto++ now, check the x86 thread for relevant source links. the BitCoin threads are automatically assigned low priority; as soon as any other processes want to use the CPU it will automatically lose CPU time VMware only permits even numbers of processors/cores although I believe you can expose 8 cores and then configure the OS to only see 7.if he really does have this setup, I'm going to bet that he's opted for more processors/cores than his CPU actually has (yep, you can do this but it will have a pretty negative effect on performance) Every time he posts I want to poke him in the eye, the one conveniently posted to the left of his friendly well-meaning nonsense   BitCoins are always appreciated, address in my sig the more cores your computer has, the more significant the performance boost, you should also use the EXE from the intel folder, the VS one is inferior but included for completeness. Crypto++ 5.6.0: http://www.cryptopp.com/Cached SHA256: http://pastebin.com/rJAYZJ32 (although I'm pretty sure this is publically submitted elsewhere, I was linked to it on IRC) If you don't trust my builds, don't use them, if you want to set up your own build environment, do the work yourself, all the source code in the app is publically available. if your OS is 64-bit then this has far superior performance, you need this runtime: http://www.microsoft.com/downloads/details.aspx?FamilyID=bd512d9e-43c8-4655-81bf-9350143d5867&displaylang=en yes, as I said, the Intel compiler produces far better code than the VS compiler does. Figured I'd make a new topic since anyone on x86 Windows probably won't even bother to read the x64 thread, however, since you're here, I suggest you read page 5 of that thread after reading this.OK, so essentially I've compiled 2 builds of Bitcoin with the new SHA caching optimisation, one build has full optimisation for the SSE instruction sets and will require a modern CPU, and the other is compiled without any SSE optimisation at all and should therefore run on pretty much any CPU capable of running XP or higher. The SSE version is a bit faster than the non-SSE version and both are inferior to the x64 builds, if you have a 64-bit OS, don't bother with these.Beware however that the libeay32.dll that I included may have SSE and therefore, if you can't get either to run on your machine, replace that DLL with the one bundled with the stock BitcoinYou can grab the builds here OK, now for some absolutely incredible performance.Credit to tcatm for the caching part of the SHA context - this offers absolutely brilliant performance. Additionally, the Intel compiler really comes into its own here as its parallelisation abilities give a massive performance boost over Visual Studio.Performance: 4700khash/s on 4 cores, I think that speaks for itself.I've included both the VS and Intel build, but there's really no comparison, the Intel build craps all over VS.Grab SHA state caching Bitcoin here is this the x86 asm? I dumped out the x64 asm and integrated it and performance has proved to be nothing short of blistering. OK, so given that the SHA256 is now 100% assembler code, I figured I might as well just build it entirely using Visual Studio, so I did just that and performance was exactly the same.So, for those of you who have found the VS builds to be more stable, click here to get it
If you want the code, get Crypto++ OK, I've made a new build now; this version uses the 64bit SHA256 Assembler code from Crypto++ which means the Byteswap function is now only used for re-ordering the resulting hash - and of course it's using 64-bit ASM to create the hash in the first place.Performance? I've gone from an average of 2900k hashes on my previous builds up to a pretty stellar 3300k hashes (an improvement of about 100k per core) - I would be very surprised if the Linux builds outperform this.Grab x64 Asm Optimised Bitcoin here Here is several builds based on the latest SVN code (0.3.3), it contains the following:Visual Studio Builds in x86 and x64 flavour.Intel Builds in x64 only, one with stock code and the other with the 64bit byte reversal/state init tweak since it seems to squeeze a few more drops of speed out of it.grab it here that's not an indicator of performance mind, block generation is pure luck, it's the hashes per second that mean something. given that it's based on stock code and I doubt there's an issue with the compiler, it's more likely there's a bug in the SVN source, I'll make a build from the last stable production version just as soon as I've finished this CUDA code off. the missing DLL is in my first release (libeay32.dll) bit of a shame you linked it against BerkeleyDB5, that will break everyone's database if they should wish to go back to the stock build. then either it got re-broken or he also modified something in wxWidgets itself which I don't have.on an unrelated note: I have CUDA working for SHA256 hashing... currently the host has to iterate the nonce so performance is terrible, working on moving the whole kit and kaboodle into the card and then performance should be pretty damn sexy. my builds are from the latest SVN source code, of course, had you checked the about page, you would notice it clearly states itself as 0.3.2 OK, I've made a new EXE, this one seems to get me an extra 100-200k (or about 25-50k per core).Difference? I modified the ByteSwap function to operate on 64-bit integers; it does this by using the bswap intrinsic on a 64 bit register followed by rotate right through 32 bits to put the result in the correct order. it also initializes the SHA256 vectors using unsigned 64 bit values (however, the actual hashing still uses 32-bit so I doubt this is making much of a difference) and yes, I did convert the 32 bit numbers to 64 bit correctly (i.e. 0x12345678UL 0xabcdef0UL -> 0xabcdef012345678ULL) if that appears wrong to you, think about how little endian machines store 32 bit integers in memory.anyway, grab it here a 4 core processor with hyperthreading... and two of them? a pretty significant performance increase. legal tender is a term strictly used in reference to payment of a debt, absolutely anything can be accepted as payment.If there is no "debt" and you are simply offering something as payment for something you desire, the seller is entitled to refuse whatever you are offering even if it is legal tender.on the other hand, if you are indebted to someone, if they refuse to accept legal tender then the court will not enforce the debt. which Xeon, there's quite a few.I don't think I need to point this out but here goes anyway: the significance of the performance benefit from using any of my builds will depend entirely on how many cores your computer has.Also, in case anyone missed it: the PolarSSL algo is *not* faster.next step... CUDA. I gave it a try using the x64 Intel compiler with full optimization, performance is practically identical to the stock algorithm, in fact the new algo seems marginally worse. OK, I've made a new build of Bitcoin, this one is compiled using the Intel compiler which is considerably more advanced than the standard MS compiler.Please note this build is 64-bit only since I see no reason to compile a build for 32-bit when most 32-bit processors lack the newer SSE instructions anyway.Performance? my MSVC build averages about 2400K for me, this averages 2900K so you're looking at an improvement of about 125k per core or thereabouts although this does come at the cost of a larger EXE, improved performance is worth it in my opinion My next goal is to see if this PolarSSL SHA256 algo really is faster. for now however, download Bitcoin x64 ICC optimised build here yeah, because dividing a number by 300 instead of 1000 makes it look a lot bigger, doesn't *actually* improve performance. It shouldn't be dirty, the SHA256 is untouched and I don't think the compiler has introduced any errors. no, that's definitely correct.there is another possibility however... what processor is in your XP machine? if it doesn't support SSE2, it'll crash. ]do you have the Visual C++ 2010 runtime installed? if not, that's why. that's very interesting, what processor/frequency are you on? x86 or x64?
