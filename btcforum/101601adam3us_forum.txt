we also have a single-sig option coming soon.note it's considered (eg by coin-center) that blockstream.com/green is non-custodial because you can spend by yourself after a time lock (with the default 2of2+timelock config).there is also a 2of3 config (create sub-wallet, pick 2of3) which allows you to spend immediately.The function of the server key is to have multisig enforced 2fa to protect your funds. see reddit AMA earlier today, has some more hardware and feature Q & A https://www.reddit.com/r/Bitcoin/comments/kqgehd/were_the_blockstream_team_and_we_just_announced/ this podcast has more detail https://letstalkbitcoin.com/blog/post/the-bitcoin-game-60-dr-adam-back-part-2-liquid that is because the paper was written 5 years after hashcash was released.  see first sentence of abstract or citation [1] in the paper "Hashcashwas originally proposed as a mechanism to throttle systematic abuse of un-metered internet resources such as email,  and anonymous remailers in May 1997"[1] http://hashcash.org/papers/announce.txt Actually you can soft-fork CT.  https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012194.htmlThe main challenge is size.  I believe I have a way to reduce the range proof from 2.5kB per proof to 2kB per proof but it is still large.Mimble Wimble is interesting also in making an aggregatable CT which allows the bloat to be more than reclaimed at least as far as catchup goes. (More total bandwidth used, but less bandwidth to catchup as catchup becomes proportional to UTXO size + a smaller overhead per historic transaction).  Maybe the historic transaction overhead can be removed. We might need to think about moving forum because some of the people proposing the ideas apparently being "moderator incompatible". Technically I dont think it is accurate to say the clarity has been hurt by deletions directly, as far as I saw & remember contents of now deleted post no technical comments were deleted.  What has hurt clarity possibly is the refusal of people to participate because of the potential of moderation or clash of egos and moderators.I do sympathize and dislike moderation myself, though there is a little irony in Peter R's deleted comment containing a proud link to his own heavy trolling of /r/bitcoin which is not exactly the way to encourage people to divert their time to review your proposal (moderator or not!)I started a thread on /r/btc https://www.reddit.com/r/btc/comments/3zc6qg/review_of_shelling_point_protocol_selection_ideas/and typed up a summary of ideas explained so far (including the below one that I already read before starting this thread we're in).I had read that one before starting the thread. It seems to be a different idea again not mentioned on this thread.  Maybe we should be analysing a set of features that BU proposes to combine.Immediate observation with empty block ratios is that this appears not to work in the face of 4 existing network behaviours SPV mining, relay network, big pools and selfish-mining.Dont recall if I read that one yet.Ha after thought I figured /r/btc is the next best option given the egos and the moderators clashing, yes, see above.Adam The idea of enabling nodes & miners to set a market block-size is quite reasonable so there is no criticism of the idea.  Dont take review of the mechanism as a critique of the idea: for ideas to be deployed we need game-theory reviewed protocols and rigorously tested implementations.  Dynamic block-size is actually on the core roadmap and the best proposal I've seen for it is flexcap by GMaxwell & Maaku, with some ideas from Jeff.  You can watch a video about flexcap presented at scaling bitcoin HK.  Maaku has code for the core parts of it, I believe he was going to publish it, probably online by now.The precursor idea was BIP "100" which Jeff retracted.  The BIP "100" proposal is similar but only miners vote.  In flexcap both users and miners vote.I would suggest people interested in the idea of dynamic blocks, learn about BIP "100" and flex-cap and see if they can improve them.  There are design considerations that have been refined between 100 and the improvement on it flex-cap.The bitcoin unlimited project has presented some ideas which do try to automate things.  Unfortunately all of the ones so far seem to be defective suffering sybil attack, constant centralisation pressure, dont take account of SPV mining, shared pools, relay network existing practice nor selfish-mining, attacks.I have not really analysed the idea of validating two chains, but it seems likely to have problems based on intuition, particularly in the area of race-conditions, chain sharding and divergence risk, and in an adversarial environment.Bear in mind that the consensus mechanism is extremely fragile, it only just works in that there are many design close things that completely fail.  Most variants I tried I self-broke fairly immediately.  But some of these things take a long time to realise, or require review from GMaxwell or others to disprove.  For example selfish mining was not noticed for years.  I did spend about 3 - 4 months cooking up analysing mining variants to improve bitcoin mining centralisation (eg I invented ghost, but rejected it as over complex for what it achieved, before the academic paper proposed it and a bunch of other variants), before getting into side-chains.The idea for users to vote by delaying block relay wont work because most miners are already using the relay network or SPV mining.  Over 50% of the network was SPV mining during the 4th july fork.  A large portion of miners use the relay network.Users voting by advertisement wont work because of sybil as others have explained.You can read flex-cap to see how they combine miner and user voting in a secure, game-theory stable way that defends against all these attacks.In summary:1. The use case: dynamic market set block-sizes are interesting.2. bitcoin unlimited proposals so far seems broken as discussed by multiple people for a whole range of reasons.  We didnt have a crisp definition and it seems that some things maybe undecided.  That's ok - just keep working on it and make a concrete proposal later and people can analyse it from that.3. BIP "100" seemed plausible, but was only miner meta-incentive secure. Meaning we would be trusting miners to do the right thing, limited only by their commitment to not do anything too selfish for fear of hurting bitcoin's long term value.4. flex-cap adds user voting (in transactions) and an economic quadratic feed-back mechanism to create an incentive to right-size blocks (to deter miner zero sum attacks against other miners and curtail the continuous centralisation pressure). Flex-cap also ensures miner fee profit in conditions where otherwise mining fees can be driven to zero by excess capacity in a non-dynamic block-size growth proposals like BIP-103.[EDIT: I suppose the other thing is it might be better to run experiments on testnet rather than bitcoin or putting clear warnings for users if you have not.  People could lose bitcoin running partial implementations of incomplete ideas.  Encouraging users arent understanding it is a research project to run experimental code with real Bitcoin under it's control or even on the same machine, would be inadvisable.]Adam Here are two posts from testing1567 on reddit (says he doesnt have a bitcointalk account):and another one:Mod note: fixed quote links So what happens if I left my node at 1MB +10% user threshold and a 1.2MB block comes - does my node reject it?How will the network not split into a myriad little shards which diverge following accidental and/or intentional double-spends without manual human coordination?Adam If you can stay on topic as I suggested: "To make progress on review it would be helpful to separate technical from political opinions." I dont see a problem. People have been discussing bitcoin NG ideas on here for years.Are you able to explain what BU is and how you think it works?  I gave some reviewer questions in the OP.Adam Here are some links from kanzure on IRC (Aquentys started a discussion but wanted to continue on a forum for persistence):Adam Agree I was kind of hoping Aquentys would be able to explain what it is and how they think it works.  It saves time reviewing when people take the time to explain their assumptions.Adam The idea was to have some technical focussed constructive discourse and this is a more neutral forum and also where more Bitcoin experts hang out.Adam The proposers of bitcoin unlimited said they would like to get some review which seems reasonable, if others would like to help.The proposal seems at first skim to be a copy of a few existing technologies from Bitcoin's roadmap and were first proposed by Greg Maxwell and others*: weak-blocks & network-compression/IBLT to reduce orphan risk, and flexcap (or a variant of it perhaps).Perhaps they could start by explaining what it is & how it works.  This might include unimplemented ideas, and a summary of what the code currently for download on the manifesto page does.To review it will be clearer if you state your assumptions, and claimed benefits, and why you think those benefits hold.  (Bear in mind if input assumptions are theoretical and known to not hold in practice, while that can be fine for theoretical results, it will be difficult to use the resulting conclusions in a real system).  Particularly claimed compatibilities with Bitcoin and how the dynamic block-size game-theory is expected to work and remain secure with SPV mining, selfish-mining, block-withholding and fair (progress-free) mining could also use explaining.I suggest the sensible thing is if there is something new or insightful, that Bitcoin consider adopting the technology and the BU proponents get behind that.Maintaining a new coin is a rather complex undertaking and screwing up, as something like 40% of projects that have tried it have done, is very expensive of other peoples money.To make progress on review it would be helpful to separate technical from political opinions.Adam* some citations seem to be notably missing, I trust this is unintentional. It looks like Joseph Liu, Victor Wei and Duncan Wong made the same observation in "Linkable Spontaneous Anonymous GroupSignature for Ad Hoc Groups" 2004 https://eprint.iacr.org/2004/027.pdfThe proposed scheme is basically the same as what I propose above, and the Liu, Wei & Wong 2004 publication seems to predate the 2007 Fujisaki & Suzuki "Traceable ring signature" https://eprint.iacr.org/2006/389.pdf cited by cryptonote.Adam The traceable ring signature used in cryptonote https://cryptonote.org/whitepaper.pdf looks like:KEYGEN: P_i=x_i*G, I_i=x_i*H(P_i) SIGN: as signer j; random s_i, w_i (I relabeled q_i as s_i to be more standard, and relabeled the signer s as signer j)IF i=j THEN L_i=s_i*G ELSE L_i=s_i*G+w_i*P_iIF i=j THEN R_i=s_i*H(P_i) ELSE R_i=s_i*H(P_i)+w_i*I_jc=h(m,L_1,...,L_n,R_1,...,R_n)IF i=j THEN c_i=c-sum_{i!=j}(c_i) ELSE c_i=w_iIF i=j THEN r_i=w_i-c_i*x_i ELSE r_i=w_i\sigma = (m,I_j,c_1,...,c_n,r_1,...,r_n)VERIFY:L_i'=r_i*G+c_i*P_iR_i'=r_i*H(P_i)+c_i*I_jsum_{1..n}( c_j ) =? h(m,L_1',...,L_n',R_1',...,R_n')LINK: reject duplicate I_j values.where H(.) is a hash2curve function (taking a value in Zn and deterministically mapping it to a curve point), and h(.) is a hash function with a hash output size very close to n the order of the curve, ie h(.)=SHA256(.) mod n.Towards finding a more compact ring signature I'd been trying to find a way to make c_i into a CPRNG generated sequence as they are basically arbitrary, though they must be bound to the rest of the signature (non-malleable) so that you can compute at most n-1 existential signature forgeries without knowing any private keys.  I found this paper "1-out-of-n Signatures from a Variety of Keys" by Abe, Ohkubo and Suzuki http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.363.3431&rep=rep1&type=pdf section 5.1 shows a way to do it.  I show here how to add traceability to it in a way that makes it compatible with crypto note:KEYGEN: P_i=x_i*G, I_i=x_i*H(P_i)SIGN: as signer j; \alpha = random, \forall_{i!=j} s_i = randomc_{j+1} = h(P_1,...,P_n,\alpha*G,\alpha*H(P_j))c_{j+2} = h(P_1,...,P_n,s_{j+1}*G+c_{j+1}*P_{j+1},s_{j+1}*H(P_{j+1})+c_{j+1}*I_j)...c_j = h(P_1,...,P_n,s_{j-1}*G+c_{j-1}*P_{j-1},s_{j-1}*H(P_{j-1})+c_{j-1}*I_j)so that defines c_1,...,c_n with j values taken mod l some number of signers.  Next find the s_j value:Now \alpha*G = s_j*G+c_j*P_j so \alpha = s_j+c_j*x_j so s_j = \alpha - c_j*x_j mod n.Similarly \alpha*H(P_j) = s_j*H(P_j)+c_j*I_j so \alpha works there too.\sigma = (m,I_j,c_1,s_1,...,s_n)VERIFY:\forall_{i=1..n} compute e_i=s_i*G+c_i*P_i and E_i=s_i*H(P_i)+c_i*I_j and c_{i+1}=h(P_1,...,P_n,e_i,E_i) check c_{n+1}=c_1LINK: reject duplicate I_j values.This alternate linkable ring signature tends to 1/2 the size of the crypto note ring signature as the signature is 3+n values vs 2+2n values.Adam And this is important because if you reuse k with different messages you reveal a simultaneous equation allowing the private key to be computed.  private key is d, public key is Q=dG, address is a=H(Q),  signature is (s,r) where s=(h(m)+rd)/k, r=[kG].x, n is the order of the curve.s=(h(m)+rd)/k mod ns2=(h(m2)+rd)/k mod n=> sk = h(m)+rd, s2k = h(m2)+rd => (s-s2)k = h(m)-h(m2)=> k=(h(m)-h(m2))/(s-s2).now we know k and substituting:sk=h(m)+rd => d=(sk-h(m))/rThere are worse attacks where even knowing a bias of a few bits eg http://www.irisa.fr/celtique/zapalowicz/papers/asiacrypt2014.pdf can result in d being recovered over a modest number of signatures, or that the NIST original DSA standard was partly broken due to a small bias in k generation algorithm by Bleichenbacher, see section 2.2 http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.122.3190&rep=rep1&type=pdfAvoiding reuse of k is also tricky because that implies log transactional storage in the RNG state.  What if the RNG is in a VM, and the VM snapshotted and rolled back?  What if the RNG is poorly seeded (eg in a server environment).The lesson for bitcoin is dont reuse addresses but as there are usability difficulties with that also dont have biases in k, and dont rely on transactional, non-rollbackable storage: hence deterministic DSA.Adam No thats not how it works.  Deterministic DSA is to use k=H(d,m) as the nonce.  In that way if you sign the same message m=H(transaction), you'll get the same signature.Adam Sometimes people want the ability to tell which k of n signed (for accountability purposes, if k < n) and there a multisig has additional functionality that schnorr (or other) mulitparty sigs dont.I did also mention on twitter another idea to use schnorr to make a compact multisg.  The idea is  to have enough different keys per signer to make it unambiguous which k signed, and commit the public key sums for the needed permutations in a merkle tree.  Then to sign reveal the path to the public key sum used and a multiparty sig with that (via the usual schnorr method).It seems that Micali et al thought of this idea before see http://www.cs.bu.edu/~reyzin/multisig.html though the numbers sound better for them as they're assuming prime fields not EC where a hash of a public key is a smaller ratio than in EC.I expect it wouldnt be too useful to use the bootstap method I mentioned earlier because the subset doing the bootstrapping know everyone elses keys and so could impersonate them for accountability purposes.  So you do need an enrollment process which does not involve third parties knowing parties private keys!Adam Did someone tune up the spondoolies hosted miners?http://eligius.st/~wizkid057/newstats/userstats.php/1Adam3usQMbQWScA5AXnnDsRMeZeCh6ovumy 4x sp10 hashrate jumped from ~6TH to ~ 7.5TH?  (Which'd be a very nice hashrate at 1.85 TH/sp10 vs 1.4-1.5TH advertised).Maybe someone accidentally configured another one for my payout address during a reshuffle or config change?Adam
As there was discussion on this topic on twitter I thought I'd update this with how to bootstrap from 2 of 2 to 2 of 3: introduce new signer C to recap the combined public key Q=A+B combined private key d=a+bwe will re-split d twice, once by A and once by b:first A: 1. A choses random r and sets a'=a-r2. A sends r to B3. B sets b'=b+r4. A sends a' to C(as d=a'+b'=a-r+b+r=a+b, so a',b' is a re-split of d)similarly B:5. B choses random r' and sets b"=b-r'6. B sends r' to A7. A sets a"=a+r'8. B sends b" to C(as d=a"+b"=a-r'+b+r'=a+b, so a",b" is a second re-split of d)Now any 2 of A,B or C can sign consider the three cases:A & B: sign with a,bA & C sign with a",b" (as B sent b" to C, this prevents A signing by itself)B & C sign with a',b' (as A sent a' to C, this prevents B signing by itself).This setup pattern scales to other k of n thresholds.Adam I think its fair to say its fundamentally hard (in a computer science formal sense) to make two implementations that are consensus identical in an adversarial setting.Consensus is a new and tougher version of the host security challenges.  You dont even have to make an implementation buffer overflow in a steerable way, nor perform something it shouldnt have; just most divergences become sufficient to adversarially steer to the advantage of whoever finds the divergence first and is inclined to exploit it.About the former simpler problem, Meredith Patterson gave an interesting research summary presentation on the limits of (computer) language security: https://archive.org/details/The_Science_of_Insecurity_I encourage people, even those who think they know a decent amount about host security, to have a listen.  Its quite interesting.  You can see that any network protocol with messages interpreted by software forms a computer language, as well as bitcoin incorporating explicit languages like script as part of its operation.Adam There are existing "APIs" that exchanges, OpenTransactions, payment channels use, op-codes!: op-sig and opmultisig and op-timelock  sidechains proposes a fourth one op-spvmultisig.  Thats it people can code whatever they want with those opcodes as now but just with one more...constraining what you can use in languages is generally hard.  bitcoin script does have some constraints, and some of those constraints are a good thing(tm) for security and grey goo avoidance.as its a p2p network with a security model, the API is going to be smart-contracts.  (A local API without smart-contract enforcement is meaningless to the network)Adam I agree, and have had that discussion with a number of people on this, with me doing the pointing out.  We have some advisors/investors who know a thing or two about finance & economics.  We plan hire an economist and/or finance wizard (who can be trusted!) in due course.The thread is kind of long, but it was explained at some point that the problem is it is hard to change code with $ billions of irrescindable ecash sitting on it so core changes have focussed on maintenance, cleanup refactoring, security as well as the odd new feature.  There are many features people would like to have, even including basic needed features, that can not realistically be included into bitcoin-main, or not any time soon, some examples being zerocash, snark-contracts, high volume micropayments, native issued assets at least without some environment to gain an understanding of their behavior.  Similarly its difficult to do hard-forks (major upgrade) because there is no live-beta mechanism.  The sidechain was proposed to solve this set of problems.Adam Yeah  you know now you point it out, that is not super clear in the appendix A (that the thing being protocol adapted is a full side-chain), it justs says "The key observation is that any enhancement to Bitcoin Script can be implemented externally byhaving a trusted federation of mutually distrusting functionaries13 evaluate the script and accept bysigning for an ordinary multisignature script. That is, the functionaries act as a protocol adaptor byevaluating the same rules we would have wanted Bitcoin to evaluate, but cannot for lack of scriptenhancements. Using this we can achieve a federated peg."I did say earlier protocol adaptor but I see in hindsight "insufficient information"!Adam You probably didnt read what I said about pettycoin, nor the 1hr video where Rusty Russel explains it at a conference.It is the particular approach to sharding that makes it less secure, to reduce bandwidth.  He proposes to shard it 100 ways and have each node only validate two shards, but mine all 100 via (the other 98 blind assuming the other miners are not cheating, they have a way to prove fraud, so long as no one succeeds to jam them)Not directly less secure, but indirectly Bitcoin security also relies on decentralisation and that'd be a 15 GB block, and not many people have enough bandwidth to do that.  (And sharding it is also less secure).Snarks could do something but we cant rely on this yet IMO and I am not sure if they're fast enough to keep up computationally.That if your home computer had to do 2.25TB/day down to be a full node you might not be able to do it, which is a centralising factor.Adam I said what on the thread that you trimmed   security...I am talking about the specific sharding approach.  Its not easy sharding a block chain, and he made security tradeoffs to do it.Nothing against someone doing it if they can do it securely (ie without impacting the security of the rest of the coins on the chain) or without making the centralisation very bad.Adam Right no changes needed.Yes failure modes kick in if the threshold of federated servers is compromised or untrustworthy, and could be worse as there is more flexibility on coding smart-contract enforced limits with the spv-peg (or for now hypothetical snark-peg).Nothing changes for hw miners.  Any changes are in the pool (local or remote) the miners are connected to - which fullnodes its getting merkle information from.I'd say outside of side-chains, and just in general, a soft-fork (or even 99% of conceivable hard-forks) the mining algorithm would not change.  The miners just need some basic formatting about headers to continue to work and they're fine as is.I think the unlikely because of self-preservation, but main way hypothetically you'd see mining change is if miners got far too centralised and it became an disruptive day to day problem for bitcoin security, and mining operators rejected or ignored complaints, the economic majority could eventually fell forced to defensively break the current deployed ASICs with a minor software change.  The so-called 'big-red-button'.  Its not fun in any direction because it leads to erratic hashrate risks from the hash-rate shake up as GPUs & FPGAs are reshuffled and revised ASICs fast-tracked.Adam about why consensus is hard, and more so for two different implementations, here are two presentations first on language security as it applies to host security and software compatibility and second on bitcoin consensus.  The first is quite eye opening even for security researchers (ie people who are experts in host security).language security https://archive.org/details/The_Science_of_Insecurity_bitcoin consensus programming https://www.youtube.com/watch?v=on5ySFK0aoY#t=39m50sHave a listen, particularly to the first one and then we can discuss further (here or PM or bitcoin-dev or #bitcoin-wizards or whereever).  I am genuinely interested to help resolve the discrepancy of opinion around this, as its actually to my mind significantly misunderstood, and dangerous for bitcoin.Adam I think it was more JorgeStolfi with the internal ledger (the sofa/couch in bitstamps office?),  I would not call an internal ledger a chain - a chain has to be real-time publicly audited  I think, to be called a chain.With federated peg there is a real side-chain, including mining, consensus rules etc and then the federated peg servers act as a protocol adaptor - the peg servers are full nodes on the side-chain, and pegged coins are paid to their multisig address (eg 10 of 15) and the side-chain fullnodes and miners watch the multisig address on the bitcoin network, and coins arriving there count as a peg to put coins into the side-chain; and when the side-chain hashrate majority approves a return peg to reanimate a coin, the federated pegs are watching the side-chain as they are full nodes there too, so they release the funds to the address the return peg tells them to.Now obviously the limitation is if >= 10 of the federated peg servers are hostile or compromised, they could take the coin without approval of the side-chain.  But short of that it is the side-chain consensus and miners etc that arbitrate what coins move across the peg.Adam No because USD and EUR are fiat and cost a fraction of face value to produce.That is perhaps not impossible, but the chances of it happening are far higher if people ignore cost fundamentals in their pricing.   I'd say its a definitionally bad thing if an alt overtook bitcoin because then what assurance do people have that it wont happen again: that seems like a recipe for cryptocurrency to lose store of value potential.  As it already doesnt have unit of account property that may make cryptocurrencies fail.It depends on what you think came first gold or network effect.  Do you think gold should be valued significantly differently if its stamped with F instead of B?  The fact that it can be melted down and recast puts a clear limitation on how far that to happen.The universal AI in they hypothetical bitcoinium makes it behave like gold for recasting purposes between all altcoins, as they are made of bitcoinium.  While todays bitcoin does not know about work costs in other chains, the humans speculating on them do and can do this calculation.Adam I guess I didnt understand what you meant then (I was thinking privacy).  Still not getting it.Adam I think tvbcof is talking about privacy so eg if the sidechain is an implementation of zerocash its an opaque blob and all you know is the total balance and the number of tx/day.You can hide locks on bitcoin with a simple change (thats what committed-tx does) so you dont know which bitcoin addresses are locked vs just idle.  I think what tvbcof is saying as a requirement is it'd be nice if you didnt know how much was in the sidechain (cant distinguish locked from parked on mainchain).But for the sidechain to accept that it has to know how much and have it proven.  That implies a pretty large snark proof of bitcoin blockchain.Adam Indeed the scammers are out in force in bitcoin land, as I said on the other chain:its caveat emptor, you shouldnt put money into a chain unless there is some assurance that security & bitcoin protocol knowledgeable people have audited it.  People could certify chains (like sign them - "my name is blah and I'm a security researcher with reputation and I and my buddies audited this code and its good") or wallets could etc.  Its good and a feature that people can opt to use uncertified chains.  You want a situation where there is real open possibility for technical innovation & competition in chain features.You also want no central control so no chains can get black listed.Adam There's another feature missing from current day bitcoin that the universal AI provides: PoW convertibility and non-local communication: ie the ability to recast F coin bitcoinium into bitcoin.  Without that unlike gold you cant do the analog of melting down a Spanish Doubloon coin and recast it as an American Gold Eagle coin.While we can estimate it as I described its still a bit subjective.  Also and partly because of that, there is lower network effect, less liquidity, plus the risk that it would end as a floating exchange rate due to human factors (alt-coins are not currently valued in this way, and even if that became de rigueur it might slip in event of a system shock eg like people getting out of F coin).So in the meantime the reason to bother with sidechains is they give a way to opt-in to the recastability without needing universal AI, and thereby avoid getting trapped in an alt that is losing favor.Adam So the spv peg transactions (which anyone can create at any time) includes a list of addresses and amounts to emerge on the sidechain, so that could be one user, or a group of users each contributing inputs a bit like CoinJoin.  However its going to be more efficient to use an arbitrageur or cross-chain atomic swap for all but large liquidity calls if the trade gets imbalanced.Adam Seems to me you got the last word in there   Nicely put.The time-locks is a great example because that actually exists already: micropayment channels, which provide micropayments with normal security, but the incremental payments are offchain.  There is another concept called a micropayment channel hub, which extends that idea.  Its also very simple Peter Todd explains it here:http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg06576.htmlone reason I think its an interesting example is it also has a time-preference in normal operation (though in that case any party can cash-in the balance at any time on the chain, though they have to start again for future tx, and setup a new time-lock).Adam The point of moving transactions on-chain is that the user can then own their own coins, rather than delegating ownership to a third party like mtgox.Adam Well indeed.  Hence sidechains, if they are trying to improve bitcoin, they can do that: improve it (on a sidechain, or timelock, multisig etc).Well I think its maybe like gold, the extrinsic properties grew out of the intrinsic properties and network effect of people using it as a commodity money.(I assuming you're talking about knowing the historic difficulty so you can compare it to the right epoch of bitcoin as a benchmark).I think maybe comparing the current difficulties and prices would be enough.  (Plus discounting for a steeper supply inflation and known premine % or other parameters that are worse).Setting things up to detect that, it appears limited enforcebility and requires cooperation of the alt?You could look at the blockchain of an alt and see how much work there was total, and look at its parameters, however that doesnt prove they didnt fake the whole thing to one side over the course of a month or something and give it years of fake history, some parts of which look good relative to bitcoin.  Of course unless its merge mined its total hashrate is going to typically be quite small, so that if someone had a good incentive they could've recreated it later.  That tends to suggest that minimally you would need the blocks to be periodically timestamped in bitcoin otherwise if no one was paying attention the entire thing could've been forged more recently as hashrate is faster now than in the past. (There's a graph somewhere I cant find right now that shows the number of days it would take to recreate bitcoin.  During the hashrate spike last year, it got as low as 50days, but in the bitcoin context its stilly really hard for that to be an attack, because bitcoin security is from there only existing one distributed supercomputer than can run at that pace, nothing else can catchup.)Adam No but it could afford to have one or two eg pettycoin connected over a 2wp, freeing up bitcoin main from sub $10 transactions.It has sharded validation, its not an alt its a micropayment network bitcoin auxiliary chain.  He thinks he can get to 100k TPS.  I really dont think you want that on the main chain because its weaker, and he cut down a lot of bitcoin features to get it.  But its useful.He has a video up about pettycoin chain sharding https://www.youtube.com/watch?v=yzst_gChOr8.Adam
One way in which a side-chain would not be identical to bitcoin is it has different features.  Unless we have provable security the added complexity would tend to make a side-chain less secure.  (And thats a reason for side-chains .. so that people can get access to more features without exposing other people to the risks relating to their feature).For now there are also security tradeoffs in the 2wp mechanism, so that is another source of difference.But in the future, if for example snarks or some other innovation becomes a proven secure cryptographic construct, then we can have security-equal sidechains (and security-equal smart-phones).  And then it may be possible to have a more secure side-chain: make a simplified side-chain that doesnt include bitcoin-script, p2sh, etc ie strips a bunch of stuff for pure cold storage.  Of course you also have the incentive compatibility issue, however over time the difference erodes as volume & hence fees increase and reward decreases as we get through more halvings.Adam This is why it is dangerous for the mining company: they are sitting on $100m worth of equipment, on-demand renting it is dangerous to the network and to the hope of making a profit on their $100m investment.Again a reason they should not do it.Whichever way you look at it renting out cloud mining is a bad idea because the reason to care about the meta-incentives (of bitcoins security, reputation, functionality etc) is lost - the $100m investment.The solution is to sell mining contracts so that the user actually owns the equipment, and often has also prepaid for the electricity as well.  Its flash on-demand renting that is bad as then there is no investment incentive.This is actually part of the meta-incentive: a cloud miner should be able to forsee the problems of flash renting and realise as the equipment owner his capital is at risk.No its possible today.  Luke-jr is working on it.  Thats for the reverse problem that when you do buy a (long term) mining contract, you should control the vote.  Otherwise we get articificial centralisation where the location of the physical mining data center artificially controls other peoples votes.Adam Because the federated peg is a protocol adaptor - it translates the hash majority decision of the sidechain into something bitcoin can understand.  It's not obvious, but it is the case that issued assets on the sidechain will already have full node security (up to the MM hashrate, and immune from any take-all coins attacks).  For the purposes of issued asset trading, the sidechain works fine in this model, if we assume trade is issued - issued crosses; for that use pegged bitcoin is just transaction fees.Adam If readers want to look at that thread its https://bitcointalk.org/index.php?topic=911339.0(and reply to outahere is https://bitcointalk.org/index.php?topic=911339.msg10033502#msg10033502)Adam The sci-fi version tracks proof of work in alt-coins using any algorithm (via non-local communication and a cryptographic AI etc) but even the current bitcoin the only reason people are mining alts is because they hope to sell above par, humans can evaluate the factors, as I said "The universal AI is called common sense:"I'm finding the analogy holding up surprisingly well, though it does depend on where you focus on the value lying, like gold: people discovered gold, it had useful properties, so then they invested in it and a network effect built up around it, and because of that they developed a keen interest in assaying gold, being 100% sure they have the real thing.You could argue bitcoinium (aka bitcoin) is the real thing, and imitations composed of proof of work, that are being sold above par (far above proof of work production cost) are the equivalent of gold plated lead.Adam People already are speculating with BTC on cryptsy, havelock (BTC denominated shares), just they are doing it in a less safe way because its not on-chain.  Lets imagine gold or USD it was legally forbidden to use it for share trading, but share trading is very much legal.  Do you think share trading would happen or not?  Do you think that would be good for gold or the USD?If share trading creates more BTC (or scBTC) transactions buying/selling with BTC, or paying transaction with BTC that increases utility and hence price of BTC.Adam Well there are three answers to that: a) cloud mining at scale on short contract is a bad idea; b) the cloud miner shouldnt rent out mining power to attack the chain any more than a country would rent out nukes to mentally unstable or psychopathic individuals; c) mining can be separated from voting, and some of the artificial centralisation reduced.checkpoints are a bad idea, they are a form of centralisation.  Bitcoin is working to remove the limited very slow anti-DoS check pointing that it has.Adam I am not sure how "money. digital cash.  digital gold." != "virtual commodity which can be used as sound money"Adam His arguments are not backed up by his own citations and the rhetoric got ahead of the facts.He is a capable symmetric key cipher cryptographer, but he's been known to go on fact disconnected rants.  bitcoiners seem to  conclude he maybe thinks he'll get bitcoin consulting work if he claims the sky is falling in a loud voice.  Either that or he just enjoys ranting.Apparently even academics can troll.  (Present company excepted of course Adam I said a few things about that and so did Greg on reddit (how we expect to make money).and andBefore we closed the seed funding round there were people who wrote asking how to buy in (I think some of them were confused and thought it was a "hot" new alt-coin ICO they could get it on the "ground-level" of).  But also there were people who understood what a sidechain is.  We do have one bitcoiner (non VC, tho qualified investor) who is an investor, and a number of the investors own BTC also.  What I said to people on twitter was "you dont need to buy into side-chains, you're already in, its called bitcoin"; well really we're invested in bitcoin & the value of stock representing a stake in our ability to profit as described above, but you get the point.So for now I would buy more bitcoin   Also in the (mining) incentive section of the white paper there was a concept of a time-shifted fee.Adam If its useful like sellable as a service, then that acts just like Adam Chirilluc cup of tea:an oversupply of the service will cause its price to fall also, and we'll still have the exact same Joules spent on bitcoin mining (minus the revenue from providing the service).  Bitcoin price is set by people investing in it and utility demand.  Production cost follows that, not the reverse, otherwise we wouldnt have difficulty falls as we saw last month.There's an economic principle that if a commodity is producible at below par, people will expend more effort (ie the difficulty will go up).  Paul Sztorc explains the economic theory better in this blog article: http://www.truthcoin.info/blog/pow-and-mining/Adam Well that those things are producible for a tiny fraction of par is the very problem bitcoin solves, in electronic form that gold solves in physical form.Yes you are.  In small parts via inflation.I dont think branding of digital artefacts that can be cheaply copied matters.  Bitcoin is FOSS software, if someone comes up with something useful, it can and will be copied.  That was what the pacman game analogy was about.I argue it does exist, and bitcoinium is bitcoinium.  You're just missing a property of bitcoinium which is the electricity that went into it must have no other use, and that the use must be cryptographically verifiable in a decentralised way, and behave like a statistical poisson process (people around the world trying to do it and on average one mining a block of coins every 10mins). Heating your cup of tea with a resistive heating element satisfies none of those properties.  (Yes you could heat your tea on top of a stack of ASICs, and maybe someday people will do that; but the extent to which you extract use from the waste heat causes the average cost of production to fall and hence difficulty to rise to compensate).Its a bit more than a Joule though.  Its a time-adjusted Joule that you can cryptographically prove and that has no side-uses.  That really is bitcoinium and that has amazing implications.Adam It can be that different security and assurances are required for different uses.  You could probably afford to lose the price of a cup of coffee.  Eg imagine pettycoin on a sidechain.  It has sharded validation.  He thinks he can get to 100k TPS.  I really dont think you want that on the main chain because its weaker, and he cut down a lot of bitcoin features to get it.  But its useful.You probably for now dont want any of those things on the main chain if and until someone can firewall them in the chain or prove very robustly that they work.If bitcoin rejects such things, it maybe that innovation moves to alts.  That would be a sad day to me because I think it could be the end of bitcoin and even cryptocurrency period as a store of value anyway.Adam No Jorge Timon.  The section on demurrage as I recall was just an "it would be possible" in the section on possible incentives there were multiple others.You could it turns out implement opt-in bitcoin denominated demurrage on a sidechain (or interest, or other things - ie the argument that you cant do economic model feature coins on a side-chain is also false; its just that the cost is entirely bourne by those who opted into it, so whatever interest or demurrage or additional inflation there is, is bourne by the people who opted-in), so that creates a disincentive to opt in.  Btw a number of bitcoin exchanges have turned fractional (inflation) without disclosing it, and then gone under when it was discovered.  Same for some big poker companies - they were using customer stake to operate the company when market moved against them.  Moving more things on chain is a way to avoid those, and side-chains gives the developer part of the community the flexibility to move things on chain.   At least you can say a hypothetical side-chain with some unattractive economics wont be a surprise as it is with the normal way these failures happen, so you can avoid opting-in in the first place.  The most obvious unattractive economics is - the operator takes your bitcoin.If you're interested in demurrage there's an economic theory by Gesell, the arguments for opting-in are actually complex.  Perhaps a topic for a freicoin thread.Adam True someone could make a hostile sidechain.  But so can people make hostile multisigs (eg freeze your coins and extort you a % of them to get them back), obviously IOU offchain we've seen no-end of offchain things be scams, thefts, or incompetence failures.  Or they could make defective wallets (thats happened a number of times also).The solution as with everything else with bitcoin is understand what you're doing and/or use software that is signed, on machines without malware, and from people who are competent.  If you cant tell ask someone more competent (not you, but the general novice user).  I wrote about that here:Adam Its not clear why you think adding an spv-multisig is worse than multisig or IOUs with offchain holdings (as most exchanges are doing).  That seems reversed to me.  What does it put at risk?Adam Right.Well its interesting you should say that - there were discussions that the script language could have been extended during the p2sh discussion at the time.  eg there was no reason the script inside p2sh couldnt have been a different script language.  Lets say that script had been done, then sidechains might've been possible without a separate change.Also as I mentioned a few times its already very close to possible to implement a compact SPV verify in bitcoin script.  Anyone of dozens of minor changes to slightly improve expressiveness of bitcoin script would allow it.  It seems close to inevitable that sooner or later an expressiveness or refactor or clean up of bitcoin script will happen, for its own sake and reason: to make it easier or safer to write smart-contracts etc.About cypherdoc particularly he said this:So that seems a little inconsistent to me.  ie if this is really a bad idea why would cypherdoc not have a problem with it regardless of whether it required changes or not.  I mean if its a principle you'd be arguing to please not do it even though its possible.  Or to remove something from the language to prevent it, or put a technical defense preventing it if such a thing existed (seems unlikely but I havent explored it much).  Not saying "I have no problem with that."While its possible, its very much harder, and when changes are made its very much riskier and less secure.  If you care about the security of your coins you should be for having a firewalled live beta and firewalled extension mechanism (if you support improvements "i'm all for that." you said).CP = CounterParty.  That doesnt bring anything to the chain, other than bloat, its a layered consensus system with its own alt-coin.  If you valued the price of bitcoin, probably you'd be better pushing for sidechains than CP because its bitcoin denominated and increases demand and features for bitcoin.(Not sure whats up with bitcoin price - maybe its time for reverse psychology: big negative news, generates lots of free press, and there's no such thing as bad press?)No they spent more time on core than before, because they quit their full time jobs/occupation and Mark said somewhere else on reddit he figured they'd spent 50% of their time at blockstream on core.  (Unrelated to sidechains most of it .. eg in Pieter's case the headers-first speed up you were mentioning, though he's been working on that for a long time).  You could check by looking at bitcoin github, there's a stats page.I fail to see the connection between sound money and an ability to freeze coins with an spv-multisig instead of a multisig.Bitcoin is protected with a firewall from features on the sidechain.  The bitcoins never leave the chain, they're just frozen in an spv-multisig instead of a multisig.  Lots of people are using multisigs, daily, to effectively do the same thing, its more secure to do it with an spv-multisig.  Lots of people are not even doing that, they're using pure offchain in a shared wallet, for reasons that in time could be fixed on sidechains and then with a year of live testing with $1b on it kind of assurance, ported back into bitcoin main.Yes, it is that hard.  Maybe I dont know do you follow bitcoin-dev, look at github, follow wizards and dev irc?  Making changes to a $4b system is very risky.  op-spv can avoid and reduce that risk, once it is done.Adam Satoshi invented a new element called bitcoinium, and all alt-coins are made of it too; if you pay above par for bitcoinium you're getting ripped off.Adam Very cool, fully agree.  Anyway I was applauding and telling everyone about Aethereum at the time you released it.  Hilarious.Yeah I dont know.  Maybe there's a way to have it reactively grow - if you talk to GMaxwell he has another idea involving rolling mean as a cap or something fancy like that (to avoid gaming to drive up the blocksize to lock out people with less bandwidth).A problem with Gavin's proposal is the fixed schedule - what happens if bandwidth doesnt make the growth curve, then we get bandwidth driven centralisation.  Soft-fork reduction ... maybe thats another answer yes.  GMaxwell may have the winning idea.  (He has a habit of doing that).Its also not clear every transaction needs to go on the mainchain - with or without sidechains.  Eg you can do things with time-locks like payment channels and payment channel hubs without third party risk also for micro-payments.   There ought to be a way to cryptogaphically back coins that can scale for different uses, or with sharding.  Eg take a look at Rusty Russell's pettycoin (its not an alt its a micropayment network bitcoin auxiliary chain aiming at scaling to 100k tx/sec.)He has a video up about pettycoin chain sharding https://www.youtube.com/watch?v=yzst_gChOr8.Peter Todd is also trying to figure out tree-chains which is a sort of hierarchical sharding idea.Snarks can solve the problem too but are novel bleeding edge crypto, and so far have a key gen trapdoor also.Maybe chain pressure does something else: drive scaling innovation.  You just dont want it to become disruptive short term as its hard to react bitcoin code fast, nor push people into weak offchain systems.  There maybe an aspect of doing something simple and fast enough to get confidence of to take the pressure off while people figure out these more complex approaches.Adam I dont know much about it (so these are just questions):So what is it?  Whats the TLDR; version.  Is it an alt-coin market + plug-in framework?Is it decentralised?  Or central-checkpointed PoS?Does it include a floating alt-coin?  Does it incentivise developers to make example apps by paying them from a pre-mine?Adam
Hey you let the cat out of the bag   Yes thats how.  I use the first one in committed tx (a variant of it).  The second one is time-lock crypto.Adam Something else to say about pegging is you should be able to peg a contract from one chain to another, not just bitcoin or issue assets as a combining mechanism.  eg so if someone compiles up a bitcoin denominated ethereum sidechain you could peg the contract out of it into a snark contract sidechain it with more privacy and a different contracting language between something issued there and pegged bitcoin or something else pegged there from somewhere else.So sidechains give you composability of contracts in different languages and chains.  Its like the decentralised and secure ABI of blockchain coding.Adam Relax, just a joke   I dont think you're a troll, though I see I am not alone in enjoying flame fests sometimes.I guess I missed some of those, it was a long thread!Personally I would not see anything that didnt protect all ownership, being accepted by anyone sane.  What I mean is eg in the same way you keep your bitcoins as we go from 0.09 to 0.10; you'd keep your bitcoins if we went from 0.99 to 1.0 if that was a hard fork implemented and switched over to using a sidechain as the live-beta process.Personally I guess I see it as a kind of virtual commodity which can be used as sound money.  But bitcoin is programable and as I wrote somewhere on the thread I think the programability, smart-contracts are also a big deal as well as the sound-money which is by itself awesome if thats all bitcoin could ever do.I also wrote a kind of parable/scifi story about bitcoin as sound-money which is some kind of argument of bitcoin is special as it came first, universal equivalence of proof of electricity as the unit of bitcoin.https://bitcointalk.org/index.php?topic=911339.msg10012730Matter of debate.  I guess while its true as you said they are improving at governance, its also true the scammers our out in force, so its risky relying on governance alone, and merkle audits are after-the-fact.  Mtgox could've had merkle audits and still lost $500m the next day.Either way I think it is important to simplify, modularise and freeze the basic bitcoin as sound money to protect it from failure.  You realise bitcoin has been lucky or the devs have been epically proficient in coding and testing the code and fixing bugs carefully for nothing to have blown up at a level that wiped out long stored coins.  We want bitcoin to be here in 50 and 100 years.Then you want people who are using bitcoin for fancier things to do it somewhere else, with a guaranteed firewall between your savings and their more complex code bases.  IMO.  Sidechains is one way to do that.  Another one is provably secure consistency enforcing bytecode VM.Well as I wrote here:so a DMMS signature is not so different from a mutlisig, and it is just a new type of multisig, and the bitcoins never actually leave the bitcoin block chain, so I dont think its that ridiculously complex from bitcoins side, and so we can have robust confidence in the security firewall.  Certainly once the sample implementation & BIP are up for discussion, we'll be interested in expert opinion on that and any suggestions to simplify or improve it.Its also not that alien - the DMMS is just a reuse of bitcoins PoW blockchain as an opcode.  Basically the only new thing is a way to compact it.  As I mentioned it is nearly possible to implement it (or maybe would be with some ugly chained script) already.Yeah I like people who innovate, and some altcoin devs have innovated eg freicoin, cryptonote/bytecoin etc.  I dont like pump & dumps nor false advertising of features that are technobabble and insecure, though along with a lot of other people.I gave examples of how the MM rate can be reactively handled in the peg script above.The code on sidechains is caveat emptor, I wrote this somewhere too:audit and certify and firewalled risk and dont use dodgy stuff as in quote above, plus train more devs as GMaxwell wrote about here http://www.coindesk.com/gregory-maxwell-went-bitcoin-skeptic-core-developer/I contend that widespread use of on-chain security, user controlled private keys, air-gapped hw wallets, and smart-contract business logic executed by the chain (not scam chains, but certified or written by people with competence and good intent) will reduce thefts relative to the governance model that has seen 50% failure rate and loss of perhaps $1bil to date.About supply decreasing via mishap, another source of loss of coins is user backup failure.  Happens all the time.  I think there's possibility to use trustless bank/custodian where ownership reverts to you (or someone designated like your heirs or an offline key or a banking ombudsan or another bank) if they go bankrupt/freeze your assets.My opinion is we dont need too many chains, as more asset types can be available on the same chain (its easier to write a smart-contract between assets natively on or pegged to the same chain).  So I think a separate chain should be for something that cant co-exist with because its mutually exclusive or a different risk profile (say like zerocash or snark smart-contracts (very private and safe/efficient to verify arbitrarily complex contract!) with its dependence on novel crypto).  I would therefore imagine it would more be to help people issue assets, or integrate an existing sidechain than to make someone there very own sidechain.  I mean a chain should be a blockchain which implies decentralisation and neutrality from undue code influence etc.  A company or government "owning" a chain seems like a bad idea, and probably doesnt make sense.  But I do think it would be interesting to have a government issue its electronic M0 directly onto a chain, which it would do with a secure hw signing key.  The interesting part is that they could make a smart-monetary-policy eg committing to cap QE at 2%/year.  Something like that might greatly improve the stability and exchange rate of a currency that is currently poorly run, because they'd be intentionally giving up control of moral hazard.  Its not an alien concept to monetary policy because they often set eg mandates and limits, its just that in times of stress they break their own rules to their own currencies detriment.Whether we'd want to consult for someone would depend on whether we think what they're proposing to do is non-evil for humans and for bitcoin.what does?  modularising bitcoin and making a securely firewalled extension mechanism?Sure I said something about profit here:andProbably predisposed to side with the underdog (no pun intended:), problems with authority, libertarian you know how it goes.  Nah its not for his views but cause you were trying to be rude/belittling.  But chortle at the Chihuahua humping someones ankle video.  Well you did kind of ask for it by saying "you're still that little dog who nips at my trouser bottoms" though, so its hard to complain Adam (Summary of what JorgeSolfi is saying: if one alt-coin overtakes bitcoin, people will lose confidence in cryptocurrency because it will probably happen again, and a series of popping bubbles is not a good store of value).Yeah thats one of the reasons I am not keen on alt-coins.  If an alt-coin took over bitcoin it might be the end of artificial scarcity (aka cryptocurrencies) in general, is my assertion too.  You might enjoy this post:https://bitcointalk.org/index.php?topic=911339.msg10012730or the short tldr; twitter version:https://twitter.com/adam3us/status/550841397927235584I think its quite hard to prevent merge mining automatically because people can steganographically watermark bitcoin tx.  eg they could make a multisig where the second sig is not a pub key but a hash of their chain.However miners could try to find them and block them via whack-a-mole as all users on that network need to know the decoding trick for the stego.  As chains dont tend to be secret society things, that could actually work somewhat.  You saw some miners and pools blocking unnecessarily bloated clumsy MasterCoin & CounterParty transaction encodings using that kind of approach.  (I guess it worked as I think I saw someone say MC & CP now use less clumsy encodings).Its a little risky to play steganography arms race though because they could bypass that (at the limit steganography wins)  by replacing broadcast by sending one hash encoded for each coin public key in the network and bloat the chain even more, and that couldnt be blocked.  (Because it would take the respective private key to decode and distinguish from real transaction and thats known only to the affected user).There is a cleverer to get public steganography through the miner-filter, I wont elaborate as I dont want to give the "meta-coin" and "censor resistant IM" spammers ideas.  If you see how too ssshh! (Censor resistant IM like http://www.reddit.com/r/Bitcoin/comments/2q1gnn/tweetbitorg_censorship_free_content/).  Adam There's a difference between decentralisation and fragmentation.  You can have a system that is decentralised, but if you have many mini-systems they wont be very decentralised, nor secure by definition; and much utility value comes from the network-effect of the larger system also.It depends what you view bitcoin is, but I've come to view it as a generalised unit of proof of work measured in normalised electricity x time.  And from that point of view it doesnt seem possible to make a new unit, only to improve the unit (if its still an electronic proof of use of electricity at a given time, its always a bitcoin definitionally as it is the word to describe that thing).  As in the parable marking a bitcoin (a standardised electricity-time unit by definition) with a logo or brand and trying to sell it for above par with branding isnt creating decentralisation nor value.Btw its really hard to improve bitcoin algorithmically or protocol.  The implementation has some known things left to improve, and they have a pretty comprehensive wishlist.  If people  want to work on improving bitcoin there is a github, developer mailing list, etc.  They're always looking for quality assurance, code security review, documentation writers, and protocol & code review.Adam Undoubtedly.  The "what is hashcash?" % would be way higher.  Not sure you'd quite need a "what is bitcoin?"The poll was generally aimed at technical people who can think about algorithms or code, related to the what skills and insight would be needed to invent bitcoin line of Satoshi could be reasoning.Adam Hey Zerg - no fair - too much signal density (signal/byte!)  This is bitcointalk - where's the trolling, name-calling, ad-hominem or claim of bad faith bias?cypherdoc - can you do us a favour and redress the karmic balance before the signal gets too high in here?  Gotta rev up the flame war, it was fun!Adam Thats valid but if something is pegged against an external value (USD, shares, property) held as a custodian or owned by the issuer its not really a bitcoin, its an issued asset with ownership tracked by the blockchain.  The limitation is the user has to trust the issuer, and the blockchain narrow AI cant value the asset (Bob in his garage may go nuts one day and issue a bazillion shares in Bob's F coin stamping scam).Those are valid things but they are not bitcoins (cryptocurrency units).Adam You know Peter Todd self-admits freely that he hasnt figured out if tree chains work at incentive level yet, its the kernel of an idea that may or may not work - not an implementable spec.  Its based on full node only model, somewhat like the respendable version of my commited tx idea https://bitcointalk.org/index.php?topic=206303.15.  So tree-chains wont have the same scaling properties if they do work, but its an interesting line of exploration.   I'm interested to see if he can make it work, or to add ideas if I can.  I didnt see anything further yet beyond the common inputs (from a 4hr late night IRC chat between Peter & myself) that went into both respendable committed tx and tree-chains.  And as far as that goes committed-tx dont quite work either due to an issue Peter Todd describes as the proof-of-publication issue.Adam I dont want any death threats (you know Jeff Garzik tweeted about getting some after saying something derogatory about NXT and technobabble) but for a long while NXT was closed source, and since it became open, I never took the trouble to try to decipher whether what it claims to do is actually achieved in a decentralised way.  Actually beyond that I dont even know what it claims to do beyond "bitcoin 2.0" like bitshares, and the rest.If someone works up the energy, be sure to explain what they're talking about to us.Adam Lets conduct a scifi thought experiment, and talk about Bitcoin at a requirement level assuming some magical quantum scifi tech that can make it real sometime during the next 100 years: using the really high level definition that Bitcoin is a global process of converting electricity into some physical coin via transmogrification/energy to physical object or sufficiently advanced scifi to look like magic today, and its called a bitcoin and it can be easily inspected to see how many Joules it took to make (and the time at which it was made); and where all of these bitcoins are produced globally such that the process somehow magically knows (via non-local quantum communication?) the number of bitcoins created globally and the Joules/bitcoin consumed and which then adjusts the Joules/proof required to produce bitcoins over time to hold production interval on target at 10mins every 2016 blocks, starting with 50 bitcoins from its earlier incarnation before a few upgrades, origination back in 2009, and then halving every 4 years and currently running ag 11.921bits/per block.  Its all a bit scifi but maybe the coin contains a globally unique proof of work, its somehow magically turing universal and cryptographic AI and it doesnt matter what algorithm is used for the proof and any will be accepted, just the mining is an optimally efficient process, and what counts is the amount of electricity used, and the verifier can understand and easily verify any proof (and obviously the AI is going to see through any short-cuts).When you look at it like that, the 2015 bitcoin cant quite do that global non-local communication, universal cryptographic AI nor electricity to matter transmogrification, but thats really just an implementation limitation, that maybe we can fix with quantum sci-fi in the next 100 years future, and the current bitcoin is a pretty close facsimile.One day a fellow named Bob had an idea, he could stamp an F on the bitcoins and call them foocoins and persuade people they were better!  He choose some different interval of parameters and split the bitcoins into different sizes and stamped F on top them and talked up a good spiel so that others started playing too.However they were still fractions of actual bitcoins because the proof is universal due to the cryptographic AI, there was nothing Bob could do that could change that fact, no supply parameter changes, hash function used, software feature, not even a retro pacman game (loaded into the FHE processor in the coins), branding etc would change that because the universal cryptographic AI was measuring Joules expended, and unlike humans was not easily swayed by marketing and logos: a proof of joules mined is a proof joules mined, whatever letter or logo you stamp on the coin!  Because it started at difficulty 1 and ideal quantum processors are fast, foocoin difficulty adapted really fast (2016 blocks were over in a femtosecond), but as few found Bobs ruse plausible difficulty stabilised and by some creative marketing Bob found he could sell smaller and smaller fragments of bitcoins with F stamped on them and exchange them for whole bitcoin.  As this was profitable Bob and his friends ramped up production and used the proceeds to go on a marketing drive!One day some people started complaining that these coins were F crazy because they were the same material as bitcoin, in fact they were bitcoin, but Bob was selling them above par and they started demanding their money back.  Naturally Bob had spent a lot of the money on marketing and flashy objects.  The price crashed to true value, which unfortunately for the holders was really close to zero.  Bob made some money, but unfortunately he didnt hide his identity very well and he was convicted and given some community service and had to make reparations (it seems pyramid scams and stock pump & dump scams and currency skimming/debasement are still illegal in the 22nd century.)We have that same problem in current times.  The universal AI is called common sense: changing hash functions does not change the joules expended per coin, a hash with half the gate count results in a difficulty twice as high but the same Joules/coin.  A hash with a lower power density (say because it uses more RAM) can be run at a higher clock rate within thermal limits, and still use the same Joules/coin.  Changing the supply function to 2x as many coins doesnt change the value it halves the price expressed in 1/2 bitcoins.  Having a shorter halving schedule just makes the price change to 4x as many coins at price expressed in 1/4 bitcoin after the earlier halving etc.  The pacman game doesnt change things either because if it was useful to play pacman on bitcoin, someone would fork the code and add it; an arms race of cutting and pasting each others code doesnt create value.  Chances are the reason bitcoin doesnt have a pacman game is it isnt that useful or you dont need bitcoin to play pacman.  The 2015 Bitcoin doesnt yet know about users mining coins stamped with creative logos is because it lacks quantum non-local communication, we'll fix that one day, but in the mean time humans can convert one supply function to another with simple math and measure average electrical efficiency and when measured this way people are paying way over par, no rational entity would put money into marked coins, never mind a cryptographic universal AI.A bitcoin is a proof of Joules spent, no matter what branding or features you market with a bitcoin its still a bitcoin, and can no more change than a clump of gold atoms will cease to be gold atoms and start a floating price against gold if stamped with a letter F (assuming free instant assay like bitcoin has).Adam I wouldnt work to prevent it I'd evaluate whether it was a good idea or not.  Same as anyone else involved with bitcoin development, so it depends on the value & risks.  Wanna get specific?  op_snark or op_weil-pair support so someone can implement zerocash right in bitcoin?  What do you think?  In or too risky?  (I have a detailed rationale as ecash crypto is my thing, but I'll let you go first:)There is scarce development and QA bandwidth though, and risk from complexity.One advantage of sidechains is its a sort of meta-opcode - when you have it you can do nearly anything else, eg you can do op_snark without #including however many kloc of code for a snark library into bitcoind.As GMaxwell said when I expressed on #bitcoin-wizards right after he connected the dots between his previous snark based covenant idea/discussion and my one-way peg idea to explain two-way pegs, I said "but would that be practical to put into bitcoin given the whole point of pegs is to avoid needing to make changes" and his reply as "well maybe, because its the one change to rule them all".  So I think meta-op_codes have any an extra argument going for them.(I didnt originally consider two-way pegs because I assumed that you need to find a way that doesnt involve changes, as the rate of pace of change due to risk is the problem I was trying to fix, one-way pegs can do somethings including live-betas but with higher risk of brown-out).  one-way pegs explained here: https://www.mail-archive.com/bitcoin-development%40lists.sourceforge.net/msg02944.htmlAdam We're working on it.  Some test stuff running internally.  Watch this space.Adam We havent actually proposed anything concrete yet, but we expect to with code and a BIP for a op code to do something that is nearly or maybe actually possible already just less efficiently.The alternative is offchain transactions which are impossible to stop, constitute probably 90% of bitcoin transactions, and remove fees from bitcoin network, and result in an ongoing economic impact when exchanges and other startups with custody of other peoples bitcoins get hacked, get "hacked" or steal them, get them frozen, deleted by accident etc.That seems like a step forward to me.  Its an op_code.  We dont "own" the op code.  Anyone can use it to write any scripts they can cook up, to do with audit of sidechains or other users they may find.Adam There we go, thats the cypherpdoc we know   But seriously I wrote several hundred lines on this topic, so it'd be helpful if you have something specific you can point about what i've said that you dont find convincing, it'll make it easier for me to comment.I wrote a bit about why the op_spv is not proprietary or specific to blockstream and that idea existed before blockstream the company existed.  Feel free to pick it apart or disagree with something specific, here are some quotes and links from this thread:(and the rest of that post follow the link).and andand and andAdam Ayup the one and same.  He has a video up about pettycoin chain sharding https://www.youtube.com/watch?v=yzst_gChOr8.btw that is a kind of (non-pegged) sidechain and you hear him talking about a gateway or federated gateway.  That is like a federated peg.  (Yeah he knows its related, he's hanging out on #bitcoin-wizards and discussing pettycoin design with GMaxwell and others).(Pettycoin is a micropayment network bitcoin auxiliary chain aiming at scaling to 100k tx/sec.)Adam Doesnt bitcoin's SOV get helped by more demand for bitcoin arising from more types of transactions (eg share trades, zerocash transactions, snark contracts, micropayments, richer contract language etc)?  Most people seem pretty ecstatic about sidechains for that kind of reason, bringing innovation back to bitcoin rather than in altcoins or featurecoins or altshares.  Maybe one analogy would be say with gold if there was some law mandating you cant use it below some value, and you cant do more than so much trade, and you cant use it for property transactions only cash trades - that might have dented golds 6000 rule as a world currency no?Btw random question, I was meaning to ask with aethereum?  Would a sidechain be a better way to make the point to ethereum that their value isnt in the feature that can be forked, but in cryptocurrencies network effect.  ps I thought aethereum was awesome  except that if I recall it would float from bitcoin so not by quite bitcoin denominated.  Bitcoin users had a perpetual right to claim their share of the coins right?Yeah I'm not disagreeing other than to suggest you maybe want to take it easy increasing it, eg do it a little and then do more later and monitor the situation.Its probably fair to say you want to support both because a sidechain is also a different security formula.  However I think you acknowledge there are centralisation risks so that'd have to be balanced.  If both were done we could see where users were willing to put transactions.Adam Yup what fellowtraveller said.  I personally am happy to donate time or code to OpenTransactions and may get time to do it sometime, its sort of on my todo list.  (They have some fun possibility to use things like Chaum ecash and Brands attribute certs and ecash and I have a library that does that).Yeah I've talked to Justus in person a little if he recalls, and also watched his presentation at one of the conferences as well as a video of a OpenTransactions security model presentation he did etc.  I know he thinks in terms of bitcoin ethos so thats logic I grok.sounds good to me, and you shouldnt interpret our intent to be anything otherwise, the thread is pretty long but I said eg Thanks for the kind words.  You're doing cool stuff also and thanks for the demo a while back I as pleased I managed to find you at the massive San Jose conference.Dont worry about Justus we get along just fine - its all in good humor, like I said when someone flamed him on this thread:Yeah actually I said to Justus I wasnt really asking about Monetas funding for that exact reason, just replaying his questions to him to illustrate for him so he could think go through the analogous mental exercise of answering his own questions from with a Monetas hat on.trust me the discussion hasnt even started... wait until there's a proof of concept code and draft BIP for people to suggest redesigns of.  This'll be an interesting and very open public discussion and community discussion.Adam Well the term sidechain is sort of fuzzy pre-existing term that means something like a related chain that watches or interacts with a parent or sibling chain.I suppose I should say pegged sidechain because then that implies (compact) spv-proofs etc and then a chain is doing whatever it wants but its peg return requests must be signed by the DMMS signature composed of the majority of its miners view of the correct status of that from the sidechains point of view.Adam I think of it as a bad thing that blocksizes grow too fast if it leads to centralisation.  And also a bad thing if people are blocked from getting access to full bitcoin features (eg because of the effects you mention).  Being offchain generally degrades your features sometimes to no better than legacy "trust us" banking.I think there's a middle ground which can grow the blocksize a bit for now if it has to.  And some technical hope that the problem can be solved so that we have decentralisation and more scale.  Sidechains have a security trade off but do give you full (and potentially more) bitcoin ethos functions - eg someone can do zerocash, or network enforced limits etc.  Other things also snarks can do magical things (full node validation and low bandwidth), sharding like Rusty Russel is exploring with pettycoin (its not an alt, its an approach to sharding bitcoin).  Federated pegs.  And Open Transactions offers some interesting protection via its trust but verify approach though maybe not quite full bitcoin features, it can offer many features and maybe some different ones also (eg blinding though that as I understand it hampers audit, and I didnt see a way to repair that either yet).One problem we face is it seems blockchains are inherently more expensive (bandwidth, latency, convergence time) at the limit that server clusters like Voting Pools for OpenTransactions and other related ideas.  That might encourage people to not take up full bitcoin features if those systems turn out not to be able to match the features quite due to less decentralisation.sounds good to me.  I think there is sort of assumed to be some price discovery via user preference and miner policy but as the blocks havent filled up so far we've never seen much supply shortage other than at 0 fees.Adam
Just terminology I mean where you find a way to express the security critical parts of the business logic so that it runs in a smart-contract, and then the blockchain enforces it for you.  For example lets say daily spend limits, if bitcion scripts had access to value as well as block height (without getting into address reuse for now) you could write a script to protect yourself from being coerced to spend your savings when you're trying to spend < $1000/day or whatever as a basic precaution from that wallet.  Its more secure if the blockchain enforces that than if a server does via a multisig where the server is the policy decision point because the server could be compromised.Well block size is an interesting debate.  Lots of people on both sides of that decentralisation vs scalability.  I made my comment on it earlier in the thread here in reply to Peter R comment about it.  https://bitcointalk.org/index.php?topic=68655.msg9997995#msg9997995 on this thread.  Peter Todd for example is pretty against increasing blocksize - but believes in full nodes only, and things like tree chains, Gavin mildly exploring it as a possibility and people who rely on bitcoin scalability due to a focus on user transactions and merchant integration getting nervous about being 3-4x from seeming limit (though we've yet to see spam get squeezed out).  Greg seems cautious due to centralisation risk like Peter.  I think go slowly and carefully as I said.You do realize that all the blockstream people are cofounders and founded the company and are philosophically inclined to defend bitcoin to the death and would quit if the rest of their co-founders went nuts and tried to coerce them or convince them to do something they considered bad for bitcoin.  We have like 8 Justuses (and I'm one of them:) not even kidding (and 3 people who would bow out for technical depth).Yes actually that outcome also sucks and is the flip side of the debate where some people (eg Peter Todd with his keep bitcoin safe video on blocksize) small blocksizes are good for decentralisation but bad for access, if bitcoin becomes a settlement network.  As I was mentioning sidechains for those who like the security tradeoffs that can be constructed with them may provide a safety valve that doesnt involve switching to an alt, or going offchain.If you're going to go offchain obviously its better to do it with split trust (voting trust, federated peg, multi-sig vaults etc) than pure governance IOUs.  But I think by being offchain you often miss out on user ethos focussed features like:- unfreezability (exchange/vault refuses to give your coins back)- unseizability (exchange/vault gives your coins to someone else)- smart-contracts (if your ownership can be undone then so can a contract sort of, so it devolves from smart to dumb conventional electronic contract)There's not a super nice answer thats in Adam well seemingly you, for articulated reasons that we're exploring, would like to restrict people from sending their coins to a sidechain.I agree people should be able to do what they want with their bitcoin and send them where they want.Another way to look at sidechains btw is that a federated peg is a multi-sig (with modest parameters eg 5 of 10 and some trustworthy security competent bitcoin interested businesses) and a SPV peg is a bigger federated peg with a 5000 of 10000 multisig with dynamic membership (ie whoever is mining the chain right now).  The spv peg op_code is an opcode to understand those dynamic membership multisigs.  The dynamic membership multi sigs (DMMS for short) are written about in the sidechain white paper http://www.blockstream.com/sidechains.pdf and are a different way to look at bitcoin mining, though its actually the same thing.You can also combine DMMS sigs with regular multisigs, its just an op code so you can program with it.  eg IF ( 0.5*DMMS + 0.5*multisig(5,10) ) THEN spend coin.  Or IF ( hashrate > 75% AND DMMS ) OR ( hashrate <= 75% AND multisig(5,10) ) THEN spend coin can react to hashrate drops.  Different people could even use different peg rules on the same chain depending on their security tradoff preferences.I dont see that as some how evil or dangerous relating to offchain transactions (we've seen them cause system shocks mtgox etc) or federated pegs or voting pools (then you are depending on the 5 of 10 of their security etc its better but its still non-zero risk) ... its just the next evolution in that direction - more decentralised, more things enforced by the network.  For example read Nick Szabo's recent blog post about fiduciary code http://unenumerated.blogspot.com/2014/12/the-dawn-of-trustworthy-computing.html what do you think he's talking about?You complain about incentive, but I talked about the details of that and there are multiple secure and workable parameter choices with usable tradeoffs , and off-chain transactions and voting pools have incentive too - the holder just steals them for free with no effort!!  Thats pure human trust.Incentive discussion was here Also for the non-voting pool version the statistics are horrible it used to be that 50% of exchanges that ever existed went down with loss of user funds.  Yes its improving but lets ask you a question: do you store investment amounts of bitcoins on an exchange?  Or a web wallet?  Or an offline/paper wallet with backups?  I imagine you do the latter.Its also (I said this before on this thread) basically embarrassing that bitcoin is repeating the banking governance failures of the last century and of 2008 etc when the entire point of smart-contracts and programable trust is that users can have direct control of their funds and not have to trust third parties.One of the interesting motivations for wanting the extensibility that sidechains provides is to be able to make that zero trust a reality for more bitcoin transaction types.Adam btw (I know you were predicting JustusRanvier) but I dont think one can characterise the op_spv is to the disadvantage of blockstream competitors.  Its an op code, anyone can use it to make sidechains or other things.  Other things: you can also use the op_spv opcode to enhance security and efficiency for SPV clients like smartphone wallets completely separately from sidechains.  And to fast catchup headers also, the compact SPV proof is work-preserving.If for example OpenTransactions sees a use for it, or ethereum wants to switch out ethers for bitcoin (i imagine the developers are attached to their premine for now) but perhaps Mastercoin or something thats market cap is falling, seeing less use and the ICO people probably mostly dumped by now (if thats a fair characterisation, dont follow it closely) maybe they might want to migrate to a sidechain, thats all expected and good.  Permisionless innovation is the point of sidechains.  You could even one-way peg the remaining mastercoins into a sidechain to allow their residual tradability.If you mean it allows bitcoin to more easily incorporate features, well most alts dont really have features, or not meaningful or useful/non-broken ones, but there are some feature coins and bitcoin 2.0ish coins that do.  I dont see how extending bitcoin is unfair - they're all leeching off and copying bitcoin, which was the actual innovation - why cant bitcoin take little bits of innovation back too?Also alt-coins or feature coins can have sidechains off them also for beta versions, or secondary functionality if they were actively developed.Adam Well there is the federated peg that doesnt need miner support.  There is the one way peg that also doesnt (but is more limited than 2wp).  And also most of the miners we've talked to informally seemed pretty keen on the idea.I mean for example namecoin gets a pretty high Merge Mine rate and thats not really actively used even.  Mining profits are quite thin right now with difficulty reaching equilibrium for the price range so another percent or two makes all the difference.  I got the idea they were also interested in future potential for more transactions and more types of transactions as they considered this a source of bitcoin price upside, and they are mining bitcoins and living off the margin.Plus a price uptick is a big deal to current miners, its a kind of derivative on bitcoin price.  They get to cash in for 3months at a higher price with too low difficulty until the manufacturers can ramp new manufacturing pipelines and get lots of new equipment to market.I think the bigger picture though is its premature - we have not yet released code, nor BIP draft for community discussion and picking apart and redesigning etc before there is something to merge mine.  Its also useful (maybe you said it yourself also I think) for a federated peg to operate for a while in parallel with that open design discussion for people to see how it works.  You can view the federated peg as a protocol adaptor - there can still be mining occuring on the sidechain with the federated peg, just the return peg is translated into a multisig for bitcoin by the federation servers.After that if the community can settle on a op-code for extensibility everyone is happy with people including us can try to stand up a few sidechains.  If no one likes them then they wont get mined.  So as you can see sidechains and the op_spv really depend on community and economic majority approval, and thats a good thing.Adam Agreed.  But you're also not completely off the hook.  There are also economic implications from offchain and voting-pools version of offchain.  People also have a right to ask about that similarly.  There are actually economic implications.  If OpenTransactions sucks a bunch of transactions off-chain that deprives bitcoin of transaction fees, and so it lowers bitcoin security.  I am not saying this is a bad tradeoff, just point out that nothing is free of implications.You did see this reply?  https://bitcointalk.org/index.php?topic=68655.msg9997546#msg9997546Was that really called for?  I am trying to be responsive here...I said its a very valid question.  I tried several times to answer.  Feel free to pick apart the answer but dont just say I didnt answer, or I cant really reply short of reiterating as I wont know what it is you found unclear or unconvincing about the argument.Adam Hmm so it took me a while to see this, but actually most economic differences can be mathematically modelled and opted into on a sidechain.  For example demurrage could be implemented.  Or different block intervals.  Or different tapering of block reward, or ongoing block reward.  Those define a deterministic calculable difference.Sidechain pegs do not have to be 1:1 nor silly things like 1:1000 just mean sidecoins are milli bitcoins, but also the rate can be deterministically time-changing.Now the even more interesting realisation once you see this, is it provides a formula to value altcoins.  If you wouldnt opt into the sidechain with that behaviour, if you had to pay above par, you probably are just seeing more clearly that you similarly shouldnt buy that altcoin.  An alt-coin is a watermarked bitcoin sold above par with a marketing story.Using the really high level definition that bitcoin is an abstract model for converting electricity into proofs of work, where in all of these proofs globally define the total electrical expenditure, which then adjusts the J/proof to hold block interval on target at 10mins.  When you look at it like that, and if bitcoin cant quite do that its an implementation limitation, that maybe we can fix with quantum sci-fi in the future, then you can see that mining an alt-coin is sort of like watermarking a bitcoin and calling it a foo and expecting people to be suckered into paying above-par for it.Or like gold bars but making them into triangular shapes or stamping them with a doge and expecting people to pay more.  A gold atom is a gold atom.  A proof of electrical consumption is a proof of electrical consumption.  That not many people are stamping doges on their gold bars doesnt mean doge stamped bars are more valuable, once the fad wears off, someone will realise they are being ripped off for gold or buy their own doge stamping machine and buy basic gold.Adam I think thats wrong, lets say bytecoin with its ringsigs.  That provides some interesting privacy properties, not quite zerocoin, but safer crypto and more compact.  I could imagine a number of people would be interested to use that as a sidechain.Adamps checkout cryptonote https://cryptonote.org/whitepaper.pdf and http://cryptonote.org for explanations (seems they've been busy making a nice web site with explanations). Nah Justus is the good guy.  He just flames a little, so what.Adam Oh boy, thats another can of worms.  You dont happen to work for conformal do you btw?So (it a long story) but a) no one knows who's funding them; b) most of them seem to have ex-defence contractor profiles; c) no one knows why they are coding it; d) if there is one off by even a single bit interpretation bug in it it breaks consensus and forks bitcoin, which can likely be systematically abused, to create a massive accounting/double-spend mess that will be too expensive to repair as last time - that could create a mega fork worse than the leveldb bug, and kill bitcoin or force some really harsh choices to best effort cleanup where there are innocent losers; e) it apparently took a lot of effort by the core devs to persuade them that this was a problem; f) it still has that problem.I think that about covers it.Adam I could persist, and I think you are glossing over questions that could and should be asked of monetas (it is also some kind of offchain thing and brings its own risks - if people wanted to get concerned about economic models, sucking fees out of bitcoin, encouraging lower security transactions - they could call OpenTransactions a kind of sidechain and with full justification make all the same observations that you just saw on this thread), but I think I made my point - there are hard questions that could and should be asked to companies and individuals proposing changes or architectures/trust-models for handling bitcoin.And its better to be open, clear and non-confrontational in your responses - people have a right to ask.  I think I handled it more openly and gracefully than you did.  So there Adamps the correct response is touche not deflection. I am not sure its a blockstream position as there are multiple independent minded bitcoin-protocol aware people that compose blockstream who dont always agree on everything.But my view is increasing blocksize increases centralisation so you'd want to be careful about that.I guess the current tx throughput is about 3-4x away from the 1MB limit with current average tx sizes?It may also not be as close to the limit as it looks because once there was actual block space scarcity, maybe the economics will push out some stuff that is currently basically spam.  But you dont want that to go too far or actual transactions will back up.Maybe the interim solution is to increase it a little bit or be prepared to, as it takes time to be ready.If sidechains were ready, for people who like the security tradeoff, it offers another degree of freedom, because you can have different blockchains with different blocksizes.  eg you could have a lower value transaction blockchain where people can better tolerate the small extra centralisation risk (centralisation being if the bandwidth is 10x or 100x fewer nodes have the bandwidth to validate all tx.)   You might even make the argument bitcoin main blocksize could be reduced to improve its decentralisation.  It decouples from the one-size fits all aspect of bitcoin, which I think is a good thing - we can have more decentralisation where it matters, and more and faster transactions where it doesnt as much.ps As its not always obvious to people a sidechain could also have a shorter block interval for faster clearing of lower valued transactions.  I'm sure you know that, but not everyone does.Adam Hmm I'm not sure if actual VCs invested in any alt-coins - other than ripple & stellar, right?Actually I did watch an hour video of you presenting technical details about the trust model & I thought you did a good job of articulating it and being fair about the security assumptions.  I also read some other stuff and Chris showed me a code walk through and demo a while back.But I do find it pretty funny that you jump on me as trolling when I replay your own questions to you   Chortle.  Thats actually what I said about what I was doing and you still bit?Your (and others) questions about our investors were far more pointy and detailed than I asked you also.  You didnt name them.  You didnt say what their motive was.  You didnt say why we should trust you.  You didnt give your backup plan for what'd happen if Monetas went evil.Anyway really - you dont have to answer, I'm not actually asking, you're not proposing changes to bitcoin core.  But once you have users, they may have a legitimate reason to demand answers to those questions so you maybe want to think about company structure and board voting control and such things also and ask yourselves a bunch of red-team what-if questions.Not giving you a hard time really.  I kind of like OT's model its slightly similar to a model I had for a 2001 censor resistant name space http://www.cypherspace.org/p2p/auditable-namespace.html in its trust but verify model, and I spent a while talking with Chris and he seems to have good intentions and be technically smart.I like his articles, and if you contributed ideas to them great, nice job.Yeah I saw some of the bct exchanges between you and him about project status.  Not my business to pry into really I dont know.Adam Yes.  I argue altcoins and appcoins are fooling themselves as they imagine that the feature they are selling creates value.  It is the network effect and liquidity that creates value.  And their feature if it were really really killer awesome, would actually get copied and patched into bitcoin core (ignoring sidechains for the moment).  Fact is as far as I know, no one created a feature useful enough to qualify (for the rather high bar of patching bitcoin) because bitcoin is awesome already and its really hard to improve strongly enough to overcome the risk cost.What sidechains do is make it easier, trivial even to fork the altcoins with perhaps useful features and put them in a sidechain.Also many of the altcoins are making mistakes that cause the technical failure of the network in ways cataloged by Andrew Poelstra, https://download.wpsoftware.net/bitcoin/alts.pdf so they also arent typically safe to use.  Adam I quit a job paying plenty more than I am paid now.  I think everyone took a pay cut relative to US listed company rates of pay.  I wouldnt say we are poorly paid for a seed startup, but software development is expensive, and there are limits to how far below market rates you can expect people with living costs to go.What you are saying is sort of analogous to me suggesting you donate your bitcoins to charity so no one can accuse you of bias?I dont think a kickstarter or donations would've raised enough money to do it.  Mark Friendenbach has first hand experience of trying to work for a year on bitcoin donations, that didnt work out very well.  We could probably have implemented the core part in our spare time, but we figured that isnt enough for people to actually use it.  You need mining software, wallets that understand sidechains, you need a sample sidechain or two, a sidechain explorer, tools to issue assets (if thats in the sidechain feature set), etc etc.  Thats a ton of work and in our estimation if you drop a library or patch over the wall it lands with a thunk and sits there unused.  You have to minimally demonstrate a useable system.You should view blockstream as a sort of hybrid.  We are developing FOSS open IP much as a not-for-profit would.  But we are also aiming to make a profit by selling services, doing partnerships, advising integrators etc this is all complicated stuff and people need help to make it work.  Like was said its kind of like Mozilla.We also had opinions about the correct uses, and maintaining bitcoin ethos.  If you drop a patch you dont have any strategic input into maintaining bitcoin ethos in the deployment.We're also individuals with a community voice independent from the company.  I dont think you see most companies nor individuals working for companies in the bitcoin space giving the kind of detailed rationale or insight into plans.Not to OpenTransactions, not conformal/btcd, not bitfury, not 21e6 etc.  I understand we're the only company to propose actually extending the core so there's a higher standard - but really btcd is kind of opaque which to my mind is a bit of a concern given that its proposed as a full node and creates risk of network fork as it has a reimplementation of consensus critical code.Adam The primary safe guard is what I said Everything is FOSS, open IP.   Thats just like bitcoin right.  If the company changes management later down the road after investment rounds or whatever, and it tries to do something bad (which would sabotage its investment as the ecosytem would reject it), we could all leave (which would cripple its ability to maintain code nor execute its plan).  Or if it was us under blackmail or some legal threat, the same logic as applies to bitcoin applies: if the core does bad things, a new core can fork it and undo the bad things.Clear enough?We also did a bunch of stuff in terms of GMaxwell and Pieter Wuille's contract that was mentioned (can walk and continue to get paid if company does bad stuff) as was mentioned, and chose investors with similar and compatible ethos (understanding of FOSS, need for decentralisation, need for open IP, etc. they get it and get bitcoins value hinging on its decentralisation. )  Reid Hoffman is you might notice Chairman of the Mozilla foundation and you can find videos online where you can see he's enthused about bitcoin potential himself pre-blockstream.Well kind of what we said is "dont trust us"   ie if we succeeded in the cant be evil you dont have to trust us, and we cant be coerced because we have no control or power.  And if you think about it, its in our interests individually to not have a position of power or control as potentially even governments or organised criminals (there's a difference) might get interested in abusing control.You know not to troll you, but Justus you also work for a for profit company - Monetas/Open Transactions - right? Nothing is known about the funding of that company.  We dont know what your motives are.  The OT network voting trusts escrow everyones bitcoins so are a form of trust.  Should we trust you.  You dont have to answer.. just illustrating the sorts of questions you're asking so you can think about them and see the perspective on the receiving end.I am quite happy for people to ask tough questions.  Indeed it would be kind of surprising and disappointing if they did not given how important it is for bitcoin to remain decentralised, neutral and free from proprietary control.I am also quite happy to voice my opinion if I see bad stuff (take a look at the coinvalidation redlist thread for example).  You might notice Greg doing the same.I suppose the cipherdoc version of such questions is that he's biased to the value of his bitcoin hoard.  Personally I think thats a pretty healthy bias.  And as maybe Greg said or maybe implied (or not) everyone at blockstream has some bitcoins.  Anyway Daniel Krawisz view is that the investors are driving bitcoin so the extent he's right and certain things about bitcoin must not change or it isnt bitcoin.Adam Yeah that figure comes from memory if you google around there was someone offering Jackson Palmer $500 or $600k to develop and market dogecoin.  He told them to go away as it was a joke.  Unfortunately the dogecoiners havent realised the joke yet   I believe I heard others were offered similar amounts to develop an alt-coin.  (I dont think that would be no-strings - they'd own a defined share of the premine, and there would be multiple developers to run the project for a period of time in the budget).However its very likely the case that people working at blockstream, including myself, could've made more pay going to the dark side and starting their own alts, or taking money from unscrupulous people to start pyramid pump & dump scams.  However they have ethical problems with that.  It also probably helps them avoid sharing a jail cell with the pump & dumpers We also want to be constructive and think bitcoin is where the future is.  Good things dont magically happen someone has to design and code them.  Thats why we co-founded blockstream to go do those things.So that was partly why I mentioned it because people were saying, but they'll be beholden to the company for pay so they can eat etc.  Screw that they walked away from more money doing alt-coin crap - ie they already demonstrated willingness to walk away from things they think are unethical.Adam The quote didnt say not to make a profit it said to have a dual objective and compared the approach to Mozilla.  Mozilla made plenty of profit (and is a hybrid incorporating both a for profit and a not-for-profit) and also did a good job of making the firefox browser a leading source of user ethos focussed innovation and features.Greg Maxwell (nullc on reddit) wrote some about how blockstream plans to make profit.  https://www.reddit.com/r/IAmA/comments/2k3u97/we_are_bitcoin_sidechain_paper_authors_adam_back/clhoo7dI dont think making a profit is a bad thing - to hire developers & QA and UX designers and maintain software and design protocols and figure out how to use smart-contracts and find business partnerships to make those available to users all takes money.  As those are good outcomes, and require more money, you have to have a profit to fuel it, you cant rely on investors to keep putting in more rounds!Its quite feasible to make money without being controlling, proprietary, centralising or evil.  We certainly aim to try.Adam Patent trolls dont feel the need to be concrete - there are patents on how to run a CPU on top of homomorphic encryption before there is usable performance FHE.The world badly needs patent reform.  Ban patents, copyright cant be too soon IMO.Adam (Summary being from the reddit attack described at the above link that a miner with > 50% DoS's transactions on bitcoin chain (ie does not accept any transactions just mines empty blocks on the main chain people are trying to use) until people either abandon bitcoin or capitulate and adopt the rules the DoS miner is threatening.)  Yeah that is kind of logical, there are some caveats.  The miner has a lot of capital invested maybe > $300m to do that now.  (You can be sure most pool miners would abandon a pool that did that.)  This is going to be disruptive to bitcoin confidence and price and that affects the value of bitcoins they are mining, or the equipment itself which is worthless if bitcoin fails or crashes badly as a result.  Dangerous game to play with a $300m good behaviour bond.  Secondly while they are DoSing bitcoin, they are not mining coins nor on their proposed alternative chain at any kind of usable speed as they have almost no hashpower left (if they have 55% and they're using 53% to DoS bitcoin that gives them 500min blocks if the new chain has the same difficulty.  If the new chain has reset difficulty the honest miners might DoS it in retaliation (block transactions there).  Now if the attacker had maybe 70% they could dominate both chains reliably.This is beyond mining a new hard-fork protocol version (which honest users and full nodes would ignore) and more DoS warfare to kill the main chain to give users a choice of no transactions or to fold and use the new chain.  I would imagine users would be annoyed enough about that so as to be a scenario where the bit red button might get pushed - destroying the $300m capital of the attacker (and the $245m of the rest of the miners who probably are going to sue the attacker, and its not easy to hide the delivery and location of $300m worth of mining equipment drawing perhaps a GW of power.)Yep its a unfortunate.  This is why decentralisation of mining is important.I dont think you cant really technically enforce freedom from security issues or freedom from bad economic parameter choices kind of stuff, thats probably AI / halting-problem type difficulty which we dont know how to do.  You could certainly make some best practices statement about how security should be achieved, and acceptable parameters and configurations for user safety, and have someone competent audit that and certify their audit.Well bitstamp isnt trying to algorithmically peg - they're saying trust our host security, cold wallet physical security, audit, governance / separation of duty etc.  Ie you are trusting humans to manage an IOU.  (Not saying bitstamp is a bad exchange).Adam You know my experience of flame fests and trolling is the effective way to deal with it is to create signal, let the ad-hominems slide and circle back to the interesting tech/policy discussion.Anyway its your thread so if you two enjoying saying fuck-you too to each other all-day long, knock yourself out.Nopes dont know him personally and i was presuming he was in the thread for a long time.You know a lot of people think sidechains are the coolest thing since bitcoin itself.  He might be one of those people?Adam
They can only force soft-forks, hard-forks are ignored by full-nodes and clients.  An attempted forced-hard fork results in hostile miners forming an alt-coin with no users.  The limiting factor is soft-forks are quite flexible and can do a lot, some of which could be undesirable.the nuclear big-red-button option of tweaking the PoW hash is a meta threat to miners that they dont quite have the upper hand - if they abuse it, or get too crazily centralised - people would worst case be willing to push it.Probably thats a MAD argument that keeps miners somewhat sensible as if that button is pushed they are sitting on $500m of scrap electronics with a low scrap parts salvage value.Outside of spam limits which could be protocol enforced, its caveat emptor, you shouldnt put money into a chain unless there is some assurance that security & bitcoin protocol knowledgeable people have audited it.  People could certify chains (like sign them - "my name is blah and I'm a security researcher with reputation and I and my buddies audited this code and its good") or wallets could etc.  Its good and a feature that people can opt to use uncertified chains.  You want a situation where there is real open possibility for technical innovation & competition in chain features.You also want no central control so no chains can get black listed.Adam I thought you said you didnt do ad-hominems to troll and fan reaction?  Just a few posts back too.  Decorum!Stuff like that is why bitcointroll.org is redirecting here.  Also it pushes out more tech focussed people who want some civility and dont have the USENET flame war developed rhinoceros hide and egos to say "fuck you too" and keep talking.What the tvbcof said seemed pretty reasoned to me, and if you read it neutrally, not to be calling Gavin names, just talking about hypothetical conflicts of interest, independence etc.   I share his view about balance of power helping also, eg you can see that Microsoft & Apple are both pretty world domination evil corporations.  And yet the growth of apple's market penetration of OSX has weakened eithers ability to execute on their rent-seeking actions.  Thats a pretty conventional understanding of the real-world.Adam For conflict freedom to occur (and I think its an interesting and useful objective) bitcoin perhaps needs to be simplified and frozen, maybe moved to a formally provable specification rather than code as definition.  Soft-forks could be prevented by consensus rule if we were convinced of perfect correctness.  Hard-forks are harder to foist on people because they require a near absolute majority whereas soft-forks are a bit more miner influenceable.If we had an extension mechanism that doesnt touch core once setup, the core becomes that bit closer to freezable & formal specifiable refactor becoming possible.  If we have the possibility for live-betas we are more likely to be able to get to formal specification as definition.  (Thats a hard-fork for sure).Another aspect of conflict freedom (other than freezing and forcing change to be hard-fork) is to enable permissionless innovation - then there's no conflict, people who want to try things can go try them without lobbying for changes to bitcoin.  Also good.Adam Sure hoping 2015 is the year (and earlier in better than later!) they get the bitcoin ETF operational.  I know lots of semi-technical or even technical people who'd really like to invest in bitcoin that cant handle or dont want the risk of the technical management of coins and so have held off buying for purely that reason.Adam I'm not sure if you know but people who can code in bitcoin core receive frequent lucrative offers (eg like $500k) to code altcoins.  Devs all received them, and rejected them.  The only people who took such money was Peter Todd (I think busy at $250/hr), however as I understand it he only takes that work with the caveat that he can work on decentralising bitcoin or other tech that is mutually useful to bitcoin.   A few of these guys have almost no bitcoins or spent them trying to do startups or such things.  I think thats a pretty clear evidence of intent to do the right thing.  They have more fealty to bitcoin as a concept and doing the right thing than putting food on their table.  And also disdain for ethics of pump & dump business models that have victims at the bottom of the pyramid.You can view that while in theory some one could fork bitcoin if Gavin went nutso on something really bad (or was blackmailed into doing something dodgy) or something, that the community could fork the code.  However in practice there is also realistically a shortage of people with the skill set to maintain and create security patches for a fork, so while the desire to do it would be real, the number of devs is a problem.As Greg mentions here thats something we thought was important to improve - train more core devs - so there is more decentralisation.  http://www.coindesk.com/gregory-maxwell-went-bitcoin-skeptic-core-developer/Secondly basically there isnt anything thats going to happen in the core that a consensus of this group of people dont agree to.  And they listen to feedback and want to keep the social contract and understand that contract.  In fact their view is ideally its impossible for them to not keep the social contract (for their own personal safety as well as desired outcome) because the bitcoin network is really controlled by the economic majority.  Thats kind of what cant be evil is about, an attempt to replicate that type of thinking into a corporate structure to fail-safe it.  Not even miners can fork the protocol if no full nodes nor users like the change.  That effect holds companies honest to bitcoin ethos - companies are dead in the water without developers.  As I said our company was founded by core developers.  And we actually view it as a feature that if we all disagreed vehemently with a strategy the company would have a problem - like a technical inability to do the thing we disagreed with.Its actually in the companies interest to do the right thing as a company also, in terms of fiduciary responsibility because something bad for bitcoin ethos will likely be rejected by the bitcoin user & business community.You might imagine given the shortage any core developer could walk out and get  job the next day.  Even outside of bitcoin its a pretty uber-geek architect level crowd in terms of employability.  But right now the only hope of doing something might be Peter Todd (however he's pretty rabidly pro-decentralisation, pro-anonymity (eg stealth addresses etc), anti-censorship (work on proof of publication and end-to-end policy full node only exploration with tree-chains idea) etc so I doubt he'd be interested to do something bad for users), or perhaps Mike Hearn (who sort of floated the idea of red-lists though I'm not sure how serious he was).  However I dont think Mike did a lot of core development in years, more working on java wallet library and apps.Sidechains may also be good for that - an escape valve - people who want to do crazy stuff, can go do it in a sidechain, that no one (who cares about bitcoin ethos features) would use.  Vs try to coerce legally or otherwise developers into subverting bitcoin itself at its core where there's no choice left, and bitcoin risks destruction.In summary yes we thought about this stuff, and outside of some disagreement that sidechains create more risk than they remove (I say they remove risk, because bitcoin is exposed to offchain risk & monetary shocks from eg mtgoxings, such that sidechains are a clear improvement over offchain economically), I'd imagine we're in violent agreement on the ethos of bitcoin and whats are the important aspects of idealised bitcoin features & ethos.Feel free to suggest protocol improvements.  Eg other ways to firewall features (eg hardened vm per feature inside core) or whatever.Adam Yep.  Bitcoin has a lot to offer, and some of those things are not possible for the legacy systems to mimic.  Particularly sound money, no counter-party risk, irreversable transactions (seizing and freezing basically prevent that outside of paper cash, though even that is partly relying on fungibility laws or it could have reversibility problems).  Smart-contracts that are strengthened by no counter-party risk and irreversibility are one of the most interesting advantages I think.  Without irreversibility and no freezability a "smart-contract" isnt smart, its just an electronic contract and we already have those.  Ultimately if you combine it all you could rearchitect the financial system to largely remove systemic risk, add competition legacy systems cant react to (they intrinsically need their governance costs).  This is why people gave us $21mil.  Bitcoin all-in is a big deal.  Sound-money is cool, but its only part of the picture.Even if bitcoin transactions ended up costing more than headline fees for some transaction types, but it would still be worth it because of those features, the legacy system has higher costs, its just those are appearing in other places or disguised in the price.  The dispute resolution cost and auditors and governance and separate of duties and systemic risk and strong relevance of credit rating create an environment that must charge higher fees, and can charge much higher fees on top because of the barrier to entry to obtaining a corporate credit rating and reputation.  With bitcoin technology the product has the credit-rating, and is subject to real-time audit like bitcoins real-time assay.A good day to buy more bitcoins.  Its cheap at the price and most do not understand this potential.  Its like 1990s internet tech stocks.Adam I guess you mean:I guess the response from myself and GMaxwell kind of drifted off the topic of your question.Sidechains are not a proprietary technology.  Everything is FOSS, open IP.  And we invested a fair bit of mental energy and legal review already into making sure it stays that way, even if blockstream management were someone replaced or blackmailed; to imagine yourself or a company a perpetual lifetime role is naive, and we've seen it before eg digicash patents got sold by the investors when they went bankrupt to some company that sat on them, preventing people who wanted to innovate using ecash.  We're all anti-patent and want to avoid that kind of crap creeping into bitcoin.  I have some first hand knowledge that some companies are patenting things related to bitcoin, and probably much more I dont know about.  I suppose someone could search patent db though filing is a long slow process.  At ZKS where I was working on our ToR-precursor and ecash, back in 1999-2001, Austin tried to buy digicash patent and making it available in the public domain, we failed to buy it sadly.  John Gilmore was our advisor and he'd helped cook up an open patent license GNU like scheme.Its not our softfork - its a softfork to enable a generic extension mechanism.  We have no monopoly (and wouldnt want one) on use of the op code.  Our only defence is meritocracy - if we build better, more secure sidechains and people prefer to use them.  We wont be getting the fees off the sidechain either because those go to miners.  If we have the technical edge and people use our stuff that seems sort of fair enough to me.Personally I guarantee I trust each and everyone of our team more than J Random web2.0 startup CEO.  What do those guys want?  To make a profit.  Would they stop at sabotaging bitcoin to get there?  I doubt it.  Some of the bitcoin web2.0 startup guys are cool and bitcoin enthused.  But they're getting patents some of them, and not all of them will survive.  Crappy things the less cool startup CEOs might try eg the red-ilist or other things so sucky I wouldnt even describe them for fear it'd give people ideas that they lack the technical competence to design.I do get where you're coming from, in the past I was the guy holding people to account eg PGP incorporated when they were busy trying to include key escrow into PGP ostensibly for corporate data access.  (I imagine people selling stingrays tell themselves something also).  Partly due to my efforts that was never included in the open-pgp IETF spec.Sidechains are just a mechanism to extend bitcoin.  The interesting thing is the extension not the chain.  If a better way to do it materialises great.  If some sidechain innovations are so cool and well validated from $1b resting on them for a year that it allows bitcoin core to merge them fantastic.  Actually Pieter Wuille views that as the best way to view the utility of sidechains, to enable longer and live validation of things that could then go into bitcoin where that'd be difficult to impossible to gain that confidence on directly.There can also however be one-size fits-all limits.  Some extensions are mutually incompatible, or too risky though interesting (eg snark contracts, zerocash) unless a way to contain the risk in chain is found.  Also you can get some new scaling possibilities by having chains with different blocksizes.  Its more decentralised and safer to have a small bitcoin main block and a medium sized sidechain block, than introduce a large main bitcoin block as there is an escape route and choice.  You can within limits get your cake and eat it.Adam Actually not even.  The podcast is on a completely different topic: a response to Vitalik Buterin's bitcoin maximalism assertion (its pretty funny everyone is too polite to accuse Vitalik of ether maximalism given the percentage of the premine he owns).  I encourage you (or others) to read David Krawisz article http://bitcoinist.net/the-two-ideologies-in-bitcoin/ he is quite knowledgeable about economics and able to reason.  He draws a conclusion that is a little different to what most are assuming: that it is investors that drive bitcoins price & network effect, and transactional usage follows; rather than the assumption many make that it is the usage that drives intrinsic value & network effect.  I am not sure about that - maybe its a bit of both, but its an interesting and well reasoned argument, that is somewhat reassuring - we're not fully beholden to the success of people like bitpay trying to integrate merchants and the success of those merchants in having people pay in bitcoin etc. if Krawisz is to some extent right.Adam I can see the argument.  But wouldnt that have effects on main chain also?  Wouldnt it be more prone to technical and policy / moral hazard failure?You can view all the off-chain transactions (must be > 90% offchain) that are based on trust, governance and audit as also part of the economic system.  Prime example Mtgox.  Dont get much bigger than that $500m loss.I think the economic system is at greater risk the longer this offchain model persists.  One of the motivations of some of the people interested in sidechains is to increase transaction volume, smart-contract capabilities to have the tools to migrate the security critical parts of the trust & governance aspects onto the chain - ie replace that trust and governance (which is prone to human failure) with smart-contracts (which are less so).Its also kind of embarrassing and stupid given that the point of bitcoin smart-contracts is to avoid that risk!  Sort of because of tx volume, missing a few features and largely transaction volume limits, reinventing the mistakes of the past centuries early banking governance failures, with young people with no banking experience running $500m exchanges with basically no separation of duty and probably dumb security also.  Thats also a bad idea for inviting regulation - regulators are trying to protect users from losing money.You can directly see that people are running scared of losing their money in anything that they are trusting with bitcoin.  Eg delays for wire transfers to clear because they dont want to leave money on exchanges with uncertain governance and security competence.  Thats not good for bitcoin either.I think sidechains are a net win if its a choice between offchain or on sidechain.  Even if some people are focussed on slow velocity investment, the people that do want them, those transactions will go somewhere and offchain will be it until someone works to solve it.Feel free to help also.  We're doing plumbing at this stage.  Early adopters could see uptake as people move to on(side)chain offerings in preference to offchain.Adam Well yes I have, to save time, you talk too much   Now if you focussed on constructively and impassively analysing the technology and implications, maybe it'd progress faster?That is not realistically practical, that is exactly what motivated sidechains as an extension mechanism.So you wont be against the idea of an extension mechanism per se, just the next bit:You know, not that I am concretely proposing it, but one could shift the reward as a consensus rule into a singleton sidechain.  Or some proportion of it.  (Simple enough to do: use a peg transaction in the coinbase, and make it a sidechain consensus rule that this be the case).  That might address your incentive concern.Secondly bitcoin transaction fees will need to surpass subsidy soon enough.  At that point there is little difference.Bitcoin main needs to plan for that day anyway.The incentive protection for bitcoin is not absolute: it just raises the cost.  If someone can commit a bigger theft (via double-spending etc) they can pay for the lost mining during their failed double-spends before success.  Bitcoin is already vulnerable to the same pattern of attack, and at times we've had the bad situation of near 50% miners, and certainly 2-3 miners that are overwhelming, and yet it doesnt happen.  Clearly there is meta-incentive at work.  It works because the honest majority want it to work, and miners particularly collectively have $500m+ of equipment at risk.Another possibility to think about is some people talk about litecoin or whatever as backup plan to bitcoin in case of centralisation or catastrophic bug.  Well a sidechain can fulfil that kind of role also.Yep.I posted the article http://bitcoinist.net/the-two-ideologies-in-bitcoin/ which came before the podcast and covers more topics & is clearer IMO.Adam There was also https://bitcointalk.org/index.php?topic=831527.0This one is arguably in the wrong thread (speculation between gold & bitcoin?) but whatever.Adam actually I wasnt assuming you had an agenda, or at least I couldnt figure out what it might be.My agenda is simple: bitcoin is awesome, and I want to defend and improve it.I presume by philosophy you mean stasis vs change?  I read your view to be stasis.  Nothing about bitcoin must change ever (other than bug fixes).  Maybe thats over simplifying.  Or maybe your arguments are shifting or dancing around to prod people into extending the argument (sorry thats the impression you give at times).The sequence I saw was people trying to pressure bitcoin core to make changes to support their various ideas and pet projects.  And bitcoin core not being able to accommodate them due to resources, and significantly risk.My pet project that caused me to notice the risk of change clearly, was homomorphic encrypted values, which I thought were pretty cool as they completely hide transaction values and are still validatable.     https://bitcointalk.org/index.php?topic=305791.0  (They do nothing about hiding which address is paying which, thats harder and takes zerocash which has to much novel crypto to deploy on main IMO).And actually the earlier one was committed transactions which try to prevent transaction censorship even in the face of miners with dangerously high hashrate.  https://bitcointalk.org/index.php?topic=206303.15 (there's a so far unresolved problem with that, but if it could be made to work, thats pretty cool in my book also).So I suppose one example for your philosophy question is would you be against the above two changes being in bitcoin?  One improves privacy and the other improves decentralisation properties.  I presume most people on bitcointalk like those properties.  How about cypherdoc?Next realise there's basically zero chance of those going in, and I approve of that.  Its too risky, and what we need even more than cool features to improve bitcoin, is to not lose everyones bitcoins (including cypherdocs hoard, which I am very happy he has, good for him).  i dont but thats my fault for not installing the alpha client when Satoshi emailed me about it in Jan 2009.  I bought a few but I guess my buy in price average is close to current.  I still think bitcoin is the coolest thing and has awesome potential.And another example is how do we do bitcoin protocol upgrades.  There are limitations to live upgrades, some things are not soft-forkable also.  We'd have lower risk if we could have a live beta.  That was the first proposed use for one-way pegs (precursor to GMaxwell et al two-way peg).  Presumably you'd think a one-way peg for the purposes of software upgrade could be good - lower risk of failure during bug fixes and software modularisation.An example is its hard to fully fix malleability which causes problems in some scenarios.Maybe also zerocash itself.  Kind of risky bleeding edge crypto, but really good privacy.  I would be against that going into main due to the novel crypto risk unless it was somehow constrained to those opting in to it.But that kind of sucks, people who want it cant use it.  You and I and everyone is censoring their desired feature.  Thats not permissionless innovation.  But we are justified because of the risks in fact.  A securely firewallable extension mechanism enables permissionless innovation.  Otherwise you just see more feature coins.I am not sure if you are aware sidechains are nearly possible with zero changes to bitcoin.  Its already programable via the script language.  It may even be doable with zero changes with some chained contorted big script to validate compact SPV proofs.Anyway its not like blockstream even existed when a bunch of core devs got excited about the possibility of improving on the above situations with a generic extension mechanism so I encourage you to separate out arguments about risk or imagined intent of blockstream from concerns about the change.  eg pretend the change is just that group of developers, same people who've been coding bitcoin for years.  (Blockstream basically is that group of developers, but thats a separate discussion!)Note also the 51% takes all coins risk depends on the peg script.  Its possible to limit that problem and place the risk on the people doing the arbitrage or transfers by forcing the person returning coins to put up a bounty in main-chain bitcoins equal to the exchange which they forfeit if their transfer is proven fraudulent by a chosen % of the sidechain.  There can also be caps and time-adaptive delays (longer for more bitcoin).  Its a programming language, the op_spv is just an opcode to simplify the coding of one part of it, validating the compact-proofs.Hopefully we got past the misinterpretation of Konrad Graf's article, to see that the discount is for time-preference only, and the security firewall will work fine against a malicious or dud sidechain; caveat emptor, and look at the credibility of people writing wallets, chains and cryptocurrency.If you dont put your coins into a chain they are not at risk.  Why would you want to censor someones ability to have zerocash, homomorphic value, faster transactions, more TPS, native share/color support, snark contracts?  Wouldnt those be good things for bitcoin?  I personally thought it'd be pretty cool to see a new wave of bitcoin centric innovation.Also I dont think even statis vs change captures the situation.  If you like stasis, keep your coins on bitcoin main; if others like cool features they can use them on chains that support them.  Why is this a conflict?Adam Yeah no axe to grind, or hidden motive, I just mean a better gold because its electronically transferable, instantly assayable, harder to seize.  There was a famous economist who commented that bitcoin in his view ought to longer term start to track gold price because they fulfil potentially similar functions, and bitcoin is better in multiple areas.I was inferring from cypherdocs earlier rejection of change (to eg support more tx/sec or other features that an extension mechanism would allow) that he prefers even the hoarding/large investor with few transactions type of bitcoin use over actual trade.Thats also why I forwarded the link to David Krawisz's article as he argues that it is investors that drive network effect, and trade is following; rather than value driven by trade.Another alternative future is where an altcoin grows due to offering easier extensibility than bitcoin.  That maybe moderately unlikely given bitcoins network effect and huge lead, but its perhaps a risk.  I think those are the main things to consider in a tradeoff analysis.Adamps I edited the subject field.  Actually I am not sure why this is in the "gold up" thread. I read a few dozen pages some weeks back, so I think I got a fair flavour of the substantive arguments mixed in now and then.  Others seemed to be doing an excellent job of injecting logic and signal so I left it at that.But I am not convinced you are trying to be persuaded, maybe more enjoying the protracted heated discussion Adamps it only takes a second to trim quotes - the thread'd easier to read if you also would trim! Uh I see I spoke too soon.  Seemingly the cypherdoc vs world sub-thread is still raging   (Wasnt reading thread for some weeks).I think cypherdoc's skill is to be the right balance of adhominem, unexplained dismissive & occasional logic to cultivate a continuous flame war.  Otherwise called trolling I guess, easily recognisable form of entertainment for anyone who enjoyed USENET news flame wars of yore!  Flame wars are fun and all but I prefer constructive discussion.  Cypherdocs a clever fellow, I'm sure he has the smarts to hold a pure logic conversation if he chose.  Just the inner-troll is having too much fun trolling.Anyway thats my view of whats going on.Adamps and for the love of Mike trim quotes! Thought cypherdoc might like this article by Daniel Krawiszhttp://bitcoinist.net/the-two-ideologies-in-bitcoin/I am sort of imagining it as what underlies his arguments that he doesnt like sidechains.I think cypherdoc likely still mistaken (and Krawisz as ever makes interesting informed economic arguments).If nothing else for those who view bitcoin as gold2.0 (and I do myself) then its in our interest actually that there not be code churn on bitcoin-core to add micro-payments, fancy contracts etc etc it's better to fix all the bugs, refactor and freeze the code.  Put the code churn onto other chains.  But having the other chains be non-bitcoin denominated detracts from bitcoin.  Hence... sidechains.Further if extra features can go into sidechains, perhaps along the way bitcoin could do things to reduce centralisation reduce blocksize, and get rid of extraneous existing code complexity by refactoring some things off into a more featureful sidechain.btw I read Krawisz as more saying investment utility is the predominant driver of bitcoin adoption, transactional uses secondary.Anyway just some thoughts, not trying to reanimate the sub-thread.Adam Yes.  And the second part (sybil resistant BGP solution) is maybe not as critical - ie if we imagine that Satoshi didnt find that solution, or it were broken unexpectedly, could we repair bitcoin and have it still work, just not as elegantly/securely whatever?I think the answer is probably yes: use a conventional identity based BGP solution (of which there are existing eg Lamport himself in the original paper up to 1/3 malicious players) and work-around the identity problem by copying what i2p did for its identities from 1998 or  the nymservers  (pseudonymous mixmaster related mail service) did - require hashcash to create identities.  You might need to tune some stuff - eg the identities must be timestamped, time-limited use etc but probably you could make that work.  Doesnt seem so removed from how bitcoin sybil resistant BGP works even so maybe thats how Satoshi arrived at it.The former question though decentralised secure inflation control, people who were trying to figure this out in 1997/1998 were mostly aiming for $-adjusted zero inflation which isnt possible without exeternal price feeds which are not decenralised/machine-measurable.Adam Yes thats true.  The hypothetical what-if/question is - is the positive (stabalising) feedback loop between price and gold production useful to mimic also.  I argue that dual difficulty retargetting may go towards achieving that (see the other thread)https://bitcointalk.org/index.php?topic=907157.msg9973992#msg9973992Adam Its a pair of long-term hypothetical what-ifs, as I disclaimed not proposing anything, though its interesting to observe that if there was enough motivation and self-interest, there are things the bitcoin super-majority could hypothetically do.  Some people find confidence from long-term possibilities that bitcoin can technically and even economically adapt without violating its social contract.  (Otherwise these people reject bitcoin because of projected hypothetical end-game problems).A) could volatility be damped by dual-retargetting (difficulty & reward/block) and B) could electrical cost be reduced if security subsidy overshot or reached scaling limits (shortage of reasonable power).  Massive electrical demands can create economies of scale, where politically connected people can get power.We might see government wealth funds holding bitcoin (if thats not already the case) and/or governments taking strategic mining positions (possibly small loss making with subsidised power) within a few years - who knows!  If your country (or company, bank etc) depends on the secure operation and decentralisation you may want to participate to counter-act centralisation power-grabs from other countries.Bitcoin is a better gold, and gold served as the predominant world currency for 6000 years.  The current debt based fractional fiat currency has its own seemingly inherent limitations.  Who knows, maybe it'll happen that bitcoin continues to grow in this kind of role.Adam Bitcoin already includes some damping measures: eg difficulty retarget is capped at 4x up or 4x down.This is another hypothetical damping measure, depending on the parameters.  You could eg split the retargetting 50:50 (geometrically) between reward and difficulty.  As such that doesnt affect miners as the net-effect is the same: lets say difficulty was about to go up by the maximum 4x, then geometric mean is 2x difficulty and 1/2 supply.  To a miner its net neutral if they get 6.25 coins at difficult 1 trillion vs vs 12.5 coins at difficulty 2 trillion.  However it adjusts the supply reactive to rapid difficulty adjustments which damps price swings (volatility).  And that is good for miners if miners like predictability.As it is bitcoin mining is a kind of derivative on bitcoin price: its sort of slim-to-mildly profitable for the various efficiency operators, so there is a sort of keep the mine operating maintenance mode, and then if bitcoin price spikes by 2x and sustains, then it takes a three months for new equipment to be produced.  Old equipment could be turned back on if the price change makes it break-even again, and longer term that could be a good thing for stability, but currently moore's law catchup is too fast so that old equipment becomes quite obsolete within a year perhaps.(And bitcoin-mining with a few asics has so far is looking like a small loss making for me and probably many other hobby miners due to electrical cost and my lack of economies of scale).Adam
No what I am saying is Satoshi did know about and use hashcash, because he cited it (and wrote to me in aug 2008 to ask for the correct citation).  But seemingly he didnt know about B-money from what he told me & Wei Dai, and seemingly didnt know about bit-gold either from what he told Wei.  I put links to those things above in the OP, which were collected by Gwern on his blog.My point is lots of smart internet protocol aware / programmer type people knew about hashcash for 11 years before bitcoin was announced.  If hashcash was the only novel required building block (other than very widely known things like digital signatures and hash functions) then the number of people who can code, are interested in internet technology and knew about hashcash is hard to enumerate but must be in the 10,000s if not 100,000s range.To be clear Satoshi solved some difficult problems that others had tried and failed to find answers for (how to build a distributed ecash system with hashcash mining without creating a centralised mining inflation rate control, ie how to control inflation (bitcoin solves a different problem supply side inflation which is mathematically controlled - others tried to design around price inflation, which seems impossible).  But there were others who tried, and independently thought of the problem that needed to be solved.  The sybil resistant consensus system reusing the proof-of-work is a neat innovation too.Adam the lack of that supply fedback could be engineered into bitcoin somewhat (though bitcoin cant measure price as thats external, it can measure other indicators, like rate of difficulty increase/decrease, and also more slowly and manually adapt supply to community super-majority consensus), see: https://bitcointalk.org/index.php?topic=907157.msg9969697#msg9969697(I had been meaning to post those two topics and your comment reminded me but I started it in a separate thread).Adam Some hypothetical thoughts about price stability, (lack of) price/supply feedback and long run electrical cost.Not a call to change anything just some thoughts.One observation people often make about the difference between bitcoin & gold is that gold reacts to price changes, by rate of supply increasing when price is high, and rate of supply decreasing when price is low.  This effect has some positive feedback loop in the direction of stabilising gold price.  Products with an inelastic supply function (like bitcoin or farming with long production lead times) result in gluts and shortages which take longer to self-correct than something with an elastic supply function.While bitcoin cant directly know its price as that is an externality, one related thing it does know is the rate of difficulty change.  An indication that supply is too high would be that difficulty is slowing, or similarly an indication that supply is too high difficulty increasing too fast.  So we could (hypothetically) change bitcoin to decrease subsidy per block if difficulty increase is above 10% per 2016 block period (2 week retarget).  What could we do with the unclaimed subsidy?  We could defer it so that bitcoin subsidy lasts for longer, and/or we could bring it forward again if difficulty slowed, eg for example increase the subsidy per block if difficulty increase falls below 0%.If subsidy is not deferred, just deleted, that saves electricity and reduces the supply.One might even speculate that the absence of price or rate of difficulty change feedback is currently causing price drops as mining difficulty is falling for the first time while the production cost (mining) is efficient (close to market price of coins) even for the most efficient operators.  Or put it another way miners in todays market would be happy to get another 5% at 13.125 btc/block over 12.5 btc/block.A second question is if bitcoin is $10,000/btc or $100k or $1mil which would be supported by various real-life uses eg see page 5 of report comparing to different aspects of gold ownership https://cdn.panteracapital.com/wp-content/uploads/Bitcoin-vs-Gold.pdf then at those prices, what happens to electrical use and mining investment.  Is the result sustainable.Now one argument is more security is needed for higher market cap $21 tril?  And another argument is you cant have mining cost artificially pulled below market price or people will expend that amount of money anyway to bypass, bribe, hack etc the artificial factor.  (eg Paul Sztorc makes that argument in his blog post http://www.truthcoin.info/blog/pow-and-mining/)  I notice Nick Szabo made a similar point in an old blog post also.  The cynic may like to think of the lack of mining for USD (or other fiat) leading to huge expended effort for people to lobby, bribe etc to get access to government funds, where those funds partly come from inflation (which is a form of taxation) and also quantitative easing and bailouts.  The resources arent actually saved, they they just go into lobbying efforts and create cost via inefficient allocation of capital that arises as a cost of moral hazard.Maybe at these prices subsidy ends up being too high for the needed security and transaction fees cant go negative!  Anyway it would also be possible to voluntarily shrink subsidy per block (phased in over time to respect mining investments).Adam More early bitcoin-like what-ifs:http://cypherpunks.venona.com/date/1997/07/msg01268.htmlAdam I mean did it occur to you that it might be possible to have digital scarcity (and perhaps that this was interesting towards having a deployed ecash system).  The closest physical analog in terms of usage being gold.Adam Here's some apr 2007 stuff on decentralised ecash requirements and using hashcash (pre b-money).http://cypherpunks.venona.com/date/1997/04/msg00822.html(there's more read the link).  Sounds like b-money/bit-gold line of thinking.Adam See also (continuing from) https://bitcointalk.org/index.php?topic=906865.msg9965116#msg9965116 first poll question #1 did you learn about hashcash before bitcoin?There is an implied secondary assumption about oh but who would think of using hashcash for electronic cash.  Well actually hashcash was proposed as a form of electronic cash and the announce itself compares features with Chaum's ecash http://hashcash.org/papers/announce.txt.  Also at the time of hashcash initial announce multiple people independently commented immediately that hashcash was like digital gold (and punned about bits) and then a number of people explored (unsuccessfully) how to control inflation which would run at moore's law etc.  The idea of trying to control inflation wasnt new either (but succeeding is!)  I discussed some hierarchical variant to  control inflation (eg a group of people could benchmark equipment and push out a new difficulty level via DNS), however that was unsatisfying as that would make them the central-bank.  In the end I opted to leave that to recipient policy (recipients would gradually increase their minimum stamp size over time so there was a decentralised consensus on what is appropriate to curtail spam).  This was possible because hashcash was mainly used to increase the non-spam score - lower required was fuzzy so you'd still receive the email with a lower than required (if it was relatively non-spammy).  Wei's b-money relates to that in proposing to make hashcash respendable and one of the inflation control proposals and Nick Szabo's bit-gold has a different inflation control proposal. Anyway I claim the hard part about bitcoin is the decentralised secure inflation control (and sybil resistant byzantine generals solution.)  But the idea that PoW is some kind of virtual gold and it would be useful to figure out how to control inflation to make it respendable seem to have been ideas that immediately reached out and grabbed many people.  Or thats my claim!What do you think, what do you recall your thought process being if you heard about hashcash before bitcoin.Adam see also second question of poll https://bitcointalk.org/index.php?topic=906867.0 #2 did it occur to you hashcash was like virtual goldA recurring sub-topic in the who could Satoshi be debate is what knowledge would have been required and what communities discussed and were exposed to the required building blocks before bitcoin.The assumption about the need to have known about b-money (because it is cited in the bitcoin paper), is seemingly invalid as from various Satoshi emails it seems he wasnt aware of b-money until after the paper was written and added the citation after it was pointed out to him (by me).  See eg https://www.gwern.net/docs/2008-nakamoto   Similarly bit-gold isnt cited, and the same Gwern post quotes Wei Dai saying Satoshi didnt seem to know about bit-gold either.  See also footnote 34 of gwern's blog article http://www.gwern.net/Bitcoin%20is%20Worse%20is%20Better  Similarly Hal Finney's RPOW wasnt cited either.  (b-money was announced originally in 1998 on the cypherpunks list.)One of my contentions with people who asked me what I thought about that line of thinking (must have been on this or that mailing list) has been that well lots of people knew about hashcash before bitcoin, going back to 1997.  In the context of anti-spam (much tech news and tech magazines online and offline, discussion forum coverage existed at that time, probably suffered some bitrot since) and blog-spam (wp-hashcash) and namespace protection (in i2c tor-like FOSS competitor) and anti-DoS protection (in tangler, in interactive protocols etc) but I suspect that many 10,000s of internet programmers & technically minded people knew about it.  Eg. It was a fairly common experience for me to recognised by name at security conferences "hey you're the guy who did hashcash".There is an implied secondary assumption about oh but who would think of using hashcash for electronic cash.  Well actually hashcash was proposed as a form of electronic cash and the announce itself compares features with Chaum's ecash http://hashcash.org/papers/announce.txt.  Also at the time of hashcash initial announce multiple people independently commented immediately that hashcash was like digital gold (and punned about bits) and then a number of people explored (unsuccessfully) how to control inflation which would run at moore's law etc.  The idea of trying to control inflation wasnt new either (but succeeding is!)  I discussed some hierarchical variant to  control inflation (eg a group of people could benchmark equipment and push out a new difficulty level via DNS), however that was unsatisfying as that would make them the central-bank.  In the end I opted to leave that to recipient policy (recipients would gradually increase their minimum stamp size over time so there was a decentralised consensus on what is appropriate to curtail spam).  This was possible because hashcash was mainly used to increase the non-spam score - lower required was fuzzy so you'd still receive the email with a lower than required (if it was relatively non-spammy).  Wei's b-money relates to that in proposing to make hashcash respendable and one of the inflation control proposals and Nick Szabo's bit-gold has a different inflation control proposal. Anyway I claim the hard part about bitcoin is the decentralised secure inflation control (and sybil resistant byzantine generals solution.)  But the idea that PoW is some kind of virtual gold and it would be useful to figure out how to control inflation to make it respendable seem to have been ideas that immediately reached out and grabbed many people.  Or thats my claim!  That is topic of following poll.It would be interesting to see if the assumption that many people heard about hashcash before bitcoin is valid.  The few people I asked informally said yes they'd heard of hashcash long before bitcoin.Adamps the answer to what's hashcash http://en.wikipedia.org/wiki/Hashcash and https://en.bitcoin.it/wiki/Hashcash and http://hashcash.org OK never mind I think it must be this:3.2 t=random(0,n)3.3 user sends z=H(m), P=tG3.4 signer sets u=random(0,n),r=[uP].x3.5 signer sends s'=(z+rd)/u,r3.6 user sets s=s'/t (so that k=ut and s=(H(m)+rd)/k)3.7 user verifies sR=?zG+rQthat seems pretty good, two moves only, nice hhanh00.Adam eh what happened to the message from hhanh00 that this was quote from?  Seems to have been deleted from the thread?Someone want to reinstate that or retype the missing protocol steps from it?Adam Well presuming we're talking compressed points, thats 256-bits per point or value, then I think doing what I said should be 1x 256-bit point homomorphic value, 2x 256-bit elgamal encryption, a proof of discrete log equivalence signature (2x 256-bit) so 4 values.  4 vs 6, net saving?  Maybe I missed a point not sure without writing out the protcool.  And the CRT scheme while interesting is kind of shiny and new and slowish to decrypt.  It looks ok to me, in terms of crypto-conservatism; but I think this elgamal equivalence proof etc is even more conservative.  (And so is the schoenmaker's range proof IMO). Adam There are variants of schnorr proof of knowledge (DSA is a variant of schnorr) where you can prove that encrypted values are the same by combining with Elgamal.  So I think you should be able to prove that the sender sent the recipient in a way decryptable by their advertised public key, an encrypted value which matches the (non-decryptable) second encryption.  eg if you look at Brands is a more complicate version but there are a few survey papers showing all the common things you can easily prove using schnorr variants.ie so prove that the plaintext under the encryption would result in the recipient knowing a value that would allow it to spend the coin.  in your labelling make a schnorr-related proof that y=y' and r=r'.I did think of this going back a few weeks in my comments on your original scheme but maybe neglected to say it.Adam The EDH idea seems not bad.  Have to check the math but that sounds like it should be possible to make work.Yeah imagine armory usb, and other limited comms mechanisms: at hardware or human interactive level these can be basically untenable with a 4-move protocol.  Worth working hard to make that a 2-move protocol.State is a bit risky, hard to make cheap devices storage database transactional, where each nonce is used 0 or 1 times maximum.Adam [The url is b0rken for the additively homomorphic Elgamal variant you mentioned.  Should be http://ecewp.ece.wpi.edu/wordpress/crypto/files/2012/10/main.pdf]Their additive Elgamal variant seems interesting, but I am not sure why you need it to be simultaneously decryptable and additive: instead you can have additive simply with vG+xH for two EC bases G and G, value v, and random value x, and presuming the owner knows his own decryption, he can do the addition, and communicate the value & new x value to the recipient using ECIES or normal Elgamal?Adam You're referring to another scheme committed transactions http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg02184.html and detail on https://bitcointalk.org/index.php?topic=206303.msg2157994#msg2157994, your description is correct.  There is an unsolved problem with it though - how to prevent hostile miners censoring the keys instead (by pretending they never saw them)... there needs to be a second stage validation to say ok, this is the disclosed key and the signatures are good & values add up.  You cant directly impose consensus on not disclosing that because it creates a DoS risk - that someone really doesnt reveal the key at all, or keeps it to themselves, like a selfish-mining type of attack.The homomorphic encrypted transaction values is different, just encrypting the value.  So the payments are still as traceable as without them, just the values are hidden from the miners and from the ledger.  Miners and anyone else can still verify that the amounts add up, just they cant tell how much they actually are.Adam public key encryption can do that fine, and the user has key(s) to control coins or balances.As far as I can see this is all (including the matrix proofs) modulo n the order of the curve (or p the field).  Consider if I prove balance a == a'+b+t where t is the transaction fee, a is alice's initial balance, a' alice's revised balance and b bob's additional balance.  Alice and Bob can collude to create instead a' > a eg say n = 13 then the honest version is t=1, a=6, a'=3, b=2 (6=3+2+1)but a dishonest version is t=1, a=6, a'=11,b=7 and 6=11+7+1 mod 13 = 19 mod 13 = 6.  So Alice and Bob can add n to their balance and the ZKP still passes.Adam I agree, the values seem to wrap rendering the scheme insecure unless I'm missing something about the ZK matrix additions - those are also modulo one of the fields right?What Greg said re Elgamal is how I did it in this homomorphic value scheme https://bitcointalk.org/index.php?topic=305791.msg3294618#msg3294618 note use of Berry Schoemakers ZK range proof to prove the values dont wrap.  It ends up being basically a pedersen commitment because you dont need to be able to encrypt, just verify.  The sender can send the Pedersen nonce to the recipient so the recipient can see how much he received and be in a position to respend it.I would personally prefer to avoid adding the Paillier security assumptions, while they seem fairly conservative and reasonable, unless it was necessary.The hard part is the ZK range proof (aka ZK less than) - that is where the largest part of the verification cost and worse, the coin size comes from.  As you see on the above link it comes to 1KB per value.  I am not sure that would actually be worse than this scheme because for 128-bit security with Paillier you need 3kbit keys and 6kbit ciphertexts.Adam Not sure if there is maybe a literature survey paper but the people who came up with using PoW http://hashcash.org/papers/comp-chal.pdf have a number of references which you'd hope would be the best results if they were then going to claim to go further in comparison (by shifting the problem statement partly).Probably you can find copies of those online.Adam Greg is right I retract above.  Depending on the attack model 33% of the hashrate is the threshold above which the colluding miners start to gets an advantage arising from block withholding relative to non colluding miners.That doesnt mean 33% can attack, it means eg something like they could 50% attack with 40% hashrate - or however the advantage works out (assuming the rest of the network does not collude in other groups).I agree the 25% variant doesnt seem very convincing as that depends on racing the other miners to relay, and you have to imagine other miners also have an incentive to use low latency connectivity too.Adam Note while its not clear if Satoshi was aware of it or not, because its not cited, but this 2005 academic paper proposes the same PoW based symbil resistant BGP solution that bitcoin uses (this paper also cites hashcash):http://www.cs.yale.edu/homes/aspnes/papers/tr1332.pdfits seems quite plausible to me that Satoshi reinvented the proof-of-work based BGP solution though.Adam
Well there were other known algorithms for BGP and the best of those required minimum 1/3 honest participants.  The issue is that hidden in that is the assumption that participants can only participate once, and that assumes identity (or is-a-person credentials and a central trusted issuer).Identity is problematic on the internet, back when I published hashcash (1997) people were proposing identity centric ways to limit spam, and of course they were failing.  Some people still are proposing such things.  They start by assuming that the sender is reliably identifiable, and then design a protocol assuming that identifiable people would not spam, and/or plan to blacklist identified people who do spam.   This does two things: firstly it erodes privacy, and secondly it doesnt even work because the spammers just create lots of identities or borrow or steal them or whatever.  I view it as garbage in, garbage out: if you start with a false premise (that identity is a solved problem on the internet) you get garbage out: a protocol that doesnt work.  Furthermore it is bad for privacy, so as well as not working it has very undesirable side-effects affecting everyones privacy.Hashcash was a rejection of identity, and tried to address the root-cause of the problem by adding sender cost in an anonymous/identityless, scalable way.I'd say bitcoin appears to make a similar rejection of identity approach.  The bitcoin solution is one BGP vote per hashrate.  ie rather than try to fight sybil, just go with it, and give people one vote per hash.  That imposes maybe a lower inflation of votes than pure network/identity sybil, or at least its approximately fair in electrical cost and equipment investment.Its kind of curious that according to the selfish-mining paper, if that remains the conclusion, hashrate BGP is also assuming 1/3 honest hashrate (same ratio as previous BGP solutions, but just with "vote per hashrate" rather than "vote per participant".Secure the bitcoins, dont secure an identity.  Security identity is hard, and if you try it anyway, then people can steal assets by identity theft, impersonation etc.  Where is identity rooted?  Its a human concept.  So then you have TTPs and CAs, and those have never proven to be particularly secure; the RA processes are a source of identity theft.Adam I think there are two things:online chaum ecash, has central double spending protection.  that works very reliably right up until the central server goes offline (which it did when digicash went out of business).offline chaum ecash, the double spending protection is weak because its just a deterrent.  all it does is identify who double spent (up to the limits of identification, which can be subject to identity fraud etc), following which presumably some sanction happens - person gets sued? conventional account frozen if assets in it to recoup losses or something.not really compatible with an identityless model.right so hashcash stamps are more like on-use stamps (for email postage, prevent server resource abuse etc).people pretty much immediately after hashcash was released started observing that hashcash was like digital gold, and trying to work out how to control inflation.  No one really figured it out until Satoshi.  I think the difference is he didnt try to fix price inflation to zero (which seems to fail as it seems to require an outside data feed which becomes a point of centralisation or central rate setting policy) but rather controlled the supply inflation instead which is internally achievable without external reference.right.  b-money was an idea only.   probably other non-trivial things to work out to make it practical.they proposed it in the context of audit of a bank.  but because its keyless it is compatible with p2p use and people noticed that at the time as I recall.  so if you figure out a way to do p2p ecash (which satoshi did) then you can combine it with Sander & Ta-Shma to get cryptographic privacy via ZK set-membership proof, and this is what zerocoin did - use (and optimize) sander & ta-shma with bitcoin.  not fully implemented, but fully specified and practical if a bit inefficient.its pretty easy to implement hashcash - I am not sure if he used the reference library (it is quite optimised in assembler so he may have) probably the RPOW code is online.  Hashcash is an algorithm (mathematical description) and there is a library/implementation focused at telnet protocols.  Easy to use the algorithm for non-telnet encoding.Yes bit-gold proposed to use hashcash (I was unsure, but a while back found a clear reference on one of Nick Szabo's pages about it from a decade plus ago).no not really.  There is a footnote in the thesis but I was unable to find the manuscript as its a masters thesis.  I could write it up a bit better some time, but for someone familiar with the protocol details they could probably make it work from what was said in OP.  The brands protocol itself is implemented eg http://cypherspace.org/credlib/ and links to papers there, and microsoft (who released the patents under a very open license) has an implementation also.Adam I moved the question and my comments on it into another thread in dev/tech section https://bitcointalk.org/index.php?topic=856069.msg9526439#msg9526439 as its not really to do with speculation nor gold, though an interesting question!Adam Moving this question into a new thread:not solved at that time, it was only online double spend protection that was robust with Chaums scheme, and that was with respect to a central server that was the authority on which coins were spent.  Good privacy, but weak survivability as very centralised.The offline double spending protection of Chaum was kind of weak because what it boils down to is you could actually double spend, but if you did that eventually someone would learn your identity, which they hoped would be sufficient deterrent.  (Eventually the double spent coins would get deposited at the bank and a simultaneous equation in the double-spenders identity revealed).  How it works is the coin has embedded in it your identity in a way the bank can verify, but which is kept private so long as you do not double spend.  Chaums offline double spend is a bit space inefficient as it involves cut-and-choose a generic proof mechanism, also used by zerocoin and which is the primary cause of the zerocoin bloat.Hal Finney did a write up on this Chaum cut-and-choose scheme for more detail: https://w2.eff.org/Privacy/Digital_money/?f=double_spending.articles.txtStefan Brands ecash system has more space efficient offline double spend protection because the coins support (without cut-and-choose) multiple attributes directly.  However the default scheme is just delayed deposit (not offline respendable).  Actually I guess Chaums offline scheme has that property also.I reinvented an offline respendable variant of Brands around 2000/2001 but when I asked him about it he pointed me at a footnote in his thesis / book referring to someone's masters thesis.  How that works is people have multiple spare 0-denomination coins, so when you accept a coin you use this 0-denomination coin as the initial witness (random value chosen by recipient as part of the ZKP).  In this way if someone downstream offline respends and does a double spend, its their 0-denomination coin with their identity in it that gets identified as the first double-spend.  A downside of this is the coins grow on each respend.  Its a bit like bitcoin as the respends are also pseudonymous but linked in their spend history (which I viewed as a not ideal limitation of the approach) where as the online coins are anonymous but more vulnerable to traffic analysis as you had to race to deposit to be guaranteed to receive.The other paper from 1999 was Sander & Ta-Shma's auditable anonymous electronic cash which is extended by zerocoin (its zero knowledge proof of set membership based - the list of unspent coins is public but to spend you prove in zero knowledge that your coin is one of the unspent ones, but not which one).  Its kind of interesting as the "bank" doesnt have a private key, so its clearly p2p compatible.  So kind of a zerocoin precursor existed before bitcoin, zerocoin refers to this paper.I think the main missing bits from Chaum/Brands/Sander & Ta-Shma/b-money/bitgold were how to do inflation control without reference to any central party or network external information and sybil resistant solution to byzantine generals problem (double spend problem - which spend of many comes first).  Plus a bunch of implementation level detail.  You can see that Wei Dai's b-money & Nick Szabo's bitgold both 1998 offered some directions on ideas to vote on or have a market effect setting inflation, and both included hashcash mining as bitcoin does, but they did not connect a p2p (no enrolment/no identity) solution to sybil attack on byzantine generals problem (double spending, which spend comes first) with mining, nor arrive at the elegant solution of having an engineered supply function that can be measured internal to the network that bitcoin introduces.Adam There isnt BTC denominated volatility because you're comparing BTC to BTC, unless the arbitrageur is not anyway a long term BTC holder, and so looking at BTCUSD volatility, in which case you would be right; however BTCUSD volatility is sufficiently high that holders of BTC could undercut non-holders taking BTCUSD exposure solely to gain the arbitrage profit.  As I said the best candidate for sidechain liquidity provider is someone who is anyway holding their own or other peoples BTC for long term storage.Note also re your CoD rate comparison, you can buy forex forward contracts for below the interest cost of borrowing the money to exchange now.  This is because the market maker can discount by using interest to move in the other direction.  The same thing would take place in a mature arbitrage environment between sidechain and bitcoin, the arbitrageur can do it below the amortised 2wp fee cost, because he can hold positions in both chains and cancel out the flows in opposite directions, just as the forex forward contracts.  If you're willing to wait for p2p trade you may even do it at bitcoin tx fee cost only using cross-chain atomic swaps (faster than 2wp but slower than via arbitrage agent).Or do the 2wp yourself direct if you're willing to wait.  The interesting thing is the arbitrage can be both faster and cheaper than the 2wp, and trustless via smart-contracts.  And because its a p2p blockchain on a technical* level anyone can do arbitrage without permission from anyone.  (*Technical because there is also regulation: regulations may apply to arbitrage service; though I do think an interesting future potential is that regulators in more forward-looking jurisdictions will exempt zero-trust operations from regulation.)Adam There seems to be some confusion about floating rates, sidechains are algorithmically pegged not floating.Lets try a thought experiment.  Say you can directly move a bitcoin to a sidechain or move it back to the mainchain with either direction taking 10minutes and normal bitcoin fees.Clearly given that this is the best case confirmation time for bitcoins, and the peg protocol is algorithmic there will be effectively ZERO spread, because the algorithmic peg is an unlimited standing offer at parity (plus per KB fees) and is in direct competition to any market offer, and rational actors take the lowest offer. Now we introduce the concept of time-preference.  For security reasons (rather similar to coinbase maturity which sees you unable to spend freshly mined coins for 100 blocks) the algorithmic peg has a time-delay.Now if you planned to hold anyway for that period or longer, then you dont care and the situation is unchanged.But if you want to do a sidechain BTC transaction faster, you swap it for a small premium with someone who already has BTC on the sidechain and is planning to long term hold, or swap with someone trying to go the other direction.  What you pay them will be small due to the mechanics of arbitrage.  They'll just look for some small fee because to them if they're already long term BTC holders its basically free money, like interest on BTC to move funds back and forth and provide liquidity service for sidechains.  The $ exchange rate is immaterial, the best candidate for sidechain liquidity provider is someone who is anyway holding their own or other peoples BTC for long term storage.Anyone who tried to sell  BTC on one chain for a lower than time-preference cost on another chain would just lose money.I think the above logic and economic concept & precedent is extremely simple.  It seems like some people misunderstood Konrad Graf's comments, he's just talking about the mechanics of the low arbitrage spread.One can look to other bitcoin arbitrage scenarios for a hint at how it works.  Look at the spread between btc-e & bitstamp now that multiple people are systematically arbitraging it.  That is a far riskier arbitrage because you are relying on governance and security management of bitstamp & btc-e in the face of 50% failure rate of bitcoin exchanges.  Ok these ones are survivors and better than full history average no doubt but still there is non zero risk there and yet the spread is basically 0, this is because of competition amongst arbitrators.  Compare to a 2wp, where there is an algorithmic arbitrage.  A bot can take that all-day long at zero risk (using smart-contracts).The remaining non-imaginary risk is side-chain implementation defect, but the point of side-chains is to allow experimentation on new features to occur outside of bitcoin core.  This is actually a good thing for bitcoin core's risk because it doesnt have to take as much new development risk itself.  Sidechain development will also be rigorous like bitcoin, and you should look at the reputation of the authors of the sidechain you are considering using and have others review it or certify it before you dump your lifesavings into it.  You can still do long term holding on bitcoin if you prefer, and benefit from the even lower than current mainchain risk.The current pattern in bitcoin infrastructure is most transactions are offchain (in exchanges and other offchain accounting).  Much of that code is not open, or inexpertly written or relying on firewalls and host security and hot wallet ratios plus you're vulnerable to governance failures, operator theft and or blackmail.  Most bitcoin lost to date has been for these reasons.  If, using sidechains, we get more innovation and more onchain transactions, its better to be onchain in a sidechain than offchain from bitcoin.  You dont even own bitcoins offchain, you have an IOU for a bitcoin from a human who typically has no banking governance nor operational security experience, though with better capitalization and management things are improving.I would think more transactions, more transaction types and more uses for bitcoin, and faster innovation on bitcoin and more onchain transactions and zerotrust/smart-contract based infrastructure are all positive things for bitcoin, and it seems to be that most people with a technical understanding hold the same view.Its not that a sidechain displaces bitcoin hypothetically and that this is bad; a sidechain is bitcoin, its the mechanism to internetwork bitcoin, to build on it.  Sidechains no more displace bitcoin than HTTP displaces the TCP and IP protocol it is transported on.  Alt-coins and alt-shares are in nominal competition with bitcoin, though it seems highly unlikely they would catchup with bitcoin's network effect nor reach an appreciable real-life usage; but sidechains are not in competition.Bitcoin has one advantage over sidechains - it has the subsidy, and full node security, so I'm sure it'll be able to defend itself against abandonment or insecurity, and sidechains depend on bitcoin anyway so all bitcoin users on which ever chains have a meta-incentive to see bitcoin main remain secure.   We have decades of subsidy ahead to deal with fee-only security for bitcoin, and sidechains may move forward the ways to do that because the sidechain by default has only fee security from the start. Anyway one potential use for a sidechain is to host a beta for a major new bitcoin version.  If that version after say $1b value running in it for a year, gets upgraded into bitcoin, that hasnt displaced bitcoin, its facilitated its feature and performance upgrade, which is a good thing for everyone.The exciting thing about the internet wasnt just the ability to send IP packets, but all the applications and permissionless innovation that could be built using that transport.  Same for bitcoin.Adam Correct.  I think its worth clarifying that the peg is algorithmic, because its seems from the thread that some people may not understand that.  You, personally, can ask the network automatically to swap unlimited quantities of BTC on the sidechain for BTC on the main bitcoin chain.The only reason to swap with users using atomic swaps or trades is to do that faster.  No one is going to take anything other than a negligible price difference because they can click a button and move the coins between chains themselves.Further because that 2wp backstop is there, and anyone and his dog can do arbitrage, with full confidence that they'll be able to exercise the 2wp and capitalise on the small time-preference, the will be small.  It seems just as likely that the sidechain coins sell at a small premium for the time-preference access to side-chain features.  (Time-preference means someones preference to gain access to something sooner rather than waiting eg 24hrs, and they'll sometimes be willing to pay a small fee to get it earlier, eg check advances or such things).I dont think it realistic that we would see anyone willing to sell sidechain BTC at anything significantly below par in either direction, to do so is to burn money needlessly.  People will arbitrage it and its open to anyone to arbitrage.  So unless someone wants to burn money (and bitcoin already supports proof of burn or pay to miners if you're into burning money or donating to miners), no one will be offering to swap sidechain BTC for BTC at anything far below or above $350 (assuming current market price of $350).  eg $349.50 to $350.50 might be an example which is 15 basis points, that'd give someone a 15% return on an annual basis with steady arbitrage for a 2 day clearance time on the peg.  They can maybe get a higher return (and hence be willing to offer even lower margins) by holding a float on both sides and cancelling some trades against others as those happen faster so they get more than one arbitrage fee per exercise of the 2wp.Obviously no one is encouraging anyone to put real money into untested or buggy sidechains.  I dont think there will be lots of sidechains and the main sidechains will be extremely well tested and coded to the same rigor as bitcoin itself.Adam I am not sure they will continue to mine.  It is more profitable to switch off older equipment and buy bitcoin than spend electricity at loss making J/BTC cost basis.Its normal at any given time that people will be switching off previous gen equipment as newer more electrically efficient equipment pushes old hardware below electrical breakeven with sunk cost economics (ie even losing money based on electrical cost, ignoring purchase cost).Same thing happened to CPUs, GPUs, FPGAs... now its the turn of old gen ASICs.Once they adapt difficulty will flatten or even fall, sell pressure will relieve and price will rise.  Flatter difficulty will help also because it extends equipment life-time which makes planning easier.Thats what I think anyway.Adam Isnt hydro power heat neutral?  The potential energy has to go somewhere whether they open the bypass sluice gate full or feed to the turbines/generator full, and as we know the miners output is also all heat.Adam As someone who used to live in the UK and did the odd bit of ebay buying internationally: I dont think there's duty on UK import.  You do get charged VAT by DHL.  I have found some of the shipping companies charge you a fiver on top for the "service" of collecting the VAT fee off you.Right.  I have some SP10 I bought and they are hosted I think in Israel.  I think they have multiple hosting locations in different countries.I think also if you pick out your own 3rd party hosting they presumably will ship it direct to your hosting co.  For US and some other places there is no import nor sales tax/VAT hit on import of computer equipment, so it can be worth it just for that if you live in europe with the dreaded VAT.Or maybe in UK you can voluntarily register for VAT, claim the VAT back, and sell the bitcoins without charging VAT (because they are now VAT exempt).  You'd have to research that one a bit Adam There are both cgminer & bfgminer co-exist and are feature for feature with relative strengths.  No particular claim as to which is better or what the relative strengths, just to point out there are two maintained asic & gpu mining code-bases and apparently have been since close to the beginning of gpu & fpga mining where those code bases forked.Adam Wanted to clarify: the point in my view is the snark proof proves that the validation program was run on the sidechain and the rules were followed.  Then the bitcoin chain can validate the proof without needing to understand the validation program.  Other than the risks coming from bleeding edge crypto, it thereby allows the sidechain to offer the same security properties as the main bitcoin blockchain.gmaxwell wrote about this concept first here https://bitcointalk.org/index.php?topic=277389.0alt-coins as usually defined have floating market prices, pegged coins do not.  Sidechains give a way to extend the parent chain (eg a bitcoin sidechain allows you to experiment with and deploy new features like scripting, issued assets, different block intervals etc).that sounds rather centralised?  Dont forget MtGox also operated like that - they exchanged your bitcoins for gox iou entries in their database.  Then some stuff happened (you trade etc) and finally you ask for repayment of the iou.  If its central there is a central point of failure that can lose or steal the backing funds.You can think of a sidechain as a decentralised escrow agent where the sidechain economic majority (hashrate etc) controls and fairly administers the backing.Adam It did not occur to me but someone told me they suspected this happened with mastercoin: they may buy their own alt coins for their own bitcoin.Consider: if they own bitcoin they can buy their own ethers/foocoins/whatevers and to them its not a loss because they get their own bitcoins back.So if it helps prime a pump & give the illusion of demand, yes they really could be doing that.  Maybe they are, I'd say thats unethical but then so is the whole thing IMO; and if it was happening it might not be widely known even amongst the ethereum "team" of paid advisors etc.  Presumably that might even be illegal in terms of stock or asset price manipulation, IPO manipulation etc.Clearly its being heavily marketed by 2nd or 3rd generation repeat pump & dumpers and quite a bit of effort went into marketing.  (Ex bitshares guy Charles Hoskinson is the ethereum CEO, some ex mastercoin people etc).The maidsafe thing and its relationship to mastercoin dump was pretty dodgy also IMO.Adam Maybe it depends which part of europe but trust me I have put a voltmeter on the supply and it is 240v not 220v.You can also get three phase with 415V which relates to sqrt(3)*240=415.Adam Speaking for myself:I dunno.  5.4TH was the stated target.  The 6TH figure was a burst objective the way I read it - something like it might even go as fast as, but no promises.  Obviously there is some margin that cant be 100% simulated with the overclock to the limit and then step back model.thats a canard, if you were paying attention on the thread, it was long discussed and advertised that you do not get full performance on 110v.Now I live in europe where 240v is standard, but apparently even in the US/Canada you do actually have 220v just split in two parts and its a matter of getting a little y-cable and you can do it in a home also.  So buy the cable already, sure it cant cost more than $5 on ebay.If I read it right you are not actually a customer right?  I presume people who are customers are asking privately.I am not sure if they are open to compensating more than the hashrate, but you'd have to realise that people dont negotiate bulk discounts, comp plans related to their location etc on public list.  Guy hinted at this multiple times in the past.I think its fair to say they've been more open than any other mining manufacturer, throughout the process and more responsive to technical issues, bug fixes in firmware etc.Feel free to buy S3 if thats what you want.Without reference to any particular mining outfit, SP have pledged to not self-mine / compete with their customers and decentralise the hash rate.  That means they have to make a profit by selling hardware to grow.  If you want to support that ethical stance, it means you want to support spondoolies if you care about bitcoin decentralisation.  Maybe go complain to the competitors who are mining like fury in huge data centers and selling used equipment "without preorder" after they've mined 90% of the profit out of it.I have some SP10s and am personally considering buying some SP30.  I would be happy to do that at break-even to support decentralisation and thereby financially support a company that is trying to do the right thing with hashrate decentralisation.  It'd be nice to make a small profit on top, but I am not focussed on it.Adam[Disclaimer I do some crypto consulting for SP, speaking for myself with no inside info above] continuing the do the math thread $5.5m < $20m and they already spent money they said:$5.5m - burnrate x 9 months - SP10,SP30 pre-payments to TSMC < $20mBut Spondoolies-Tech already explained to that these $20m order pipelines that they have to pay up-front are like 3months deep.  Not just TSMC, the other parts.  If they do what you say, their pipeline will be very low capacity.  (You need lots, like > $10m up front cash to build a high capacity pipeline).So either they raise $20m (or some large amount of cash) or if they follow your advice and fund with sales, there is  a 3month delay in pipeline capacity increases, they produce a trickle of hardware and ramp up really slowly.At least thats what I took from reading what was said here - I'm a crypto guy, no manufacturing pipeline experience at all!Adam(Disclaimer I'm a crypto consultant to Spondoolies) You did see Spondoolies-Tech account specifically say 5000s of SP30s and "do the math".  You also saw they publicly disclosed they had $5.5m in venture capital.  BUT they have been running for 9months (employees, equipment, travel, rent etc), they funded the NRE dev costs for SP10 and SP30.  They pre-paid fabrication costs for SP10 (and maybe some SP30 also?)  When they say do the math... DO THE MATH.. its gotta be like $20m or something.  Have $20m to lend them?  Maybe get some bitcoin bazillionaire could front it?You cant just materalize $20m to give to TSMC.Even with huge funds like that its work and time to ramp up production pipeline.  Minimum order time.The other thing is like Spondoolies-Tech said: however many they make, they'll probably SELL OUT immediately they get any stock, if they delayed sale and stock-piled.  At any production rate there is a rate of fabrication/assembly per day.  Suggest you make suggestions.  What would you do: run a daily auction for those assembled on the day?Disclaimer I am a crypto consultant to Spondoolies, BUT I do not have knowledge of the finance specifics, the above is from public information they intentionally posted to this list to enable readers to do the math, I just got impatient and did the math for you.Adam Aha I get it.  Guy at bottom, photo & username matches someone on this thread Personally I am out about $5k to butterfly for the monarch, which started as an order for 2x 25GH asics, and upgraded when they blew past that delivery date.Adam(disclaimer I am a crypto consultant to spondoolies) http://www.coindesk.com/bankrupt-bitcoin-mining-company-alydian-sell-218ths-mining-power/bankrupt cloud mining company Alydian attempting to offload 218TH of mining equipment.Alydian's equipment efficiency and pricing is significantly worse than spondoolies for comparison.Watch: $5k/TH vs $5k for 1.4TH.  Secondly 6kW per 1TH unit vs 1.25kW for 1.4TH (6.7x worse W/GH).  And 42U (whole rack??) vs 1.25U (47x worse density TH/rack?).  Me thinks alydian will have to reduce their price or no one will buy them.   6kW at $0.15/kWh is $650/mo plus 6kW worth of heat to disipate via cooling vs $97/mo (power per TH).   They would have to sell them at a significant discount for that to make sense in a mining calculator. (Less bad if your power is cheaper).(Of course its easy to show poor results for several generations old equipment, but if Alydian actually want to sell them...)Adam(disclaimer I am a crypto consultant to spondoolies). I can confirm they are legit - have been to their office (my first trip toIsrael).  Its definitely not a scam if thats what pdawg means.(Caution is understood as there have been a few outright scams from othersin the past, plus aggressive/loose preorder promises which have left the customers to fund the "can this team ship anything at all or in a useful timeframe" risk). As others have noted spondoolies have running/shipping hardware, andunlike other mining companies did not fund their company by preorders.(They are VC funded by Genesis Partners, you can see in one of the videos in OP).Their team has a lot of years of combined chip experience (take a lookat the team page on spminer.io).   Contrast with the level of detail, andputting their reputation on the line vs other companies.  If you look on their CEO Guy Corem's linkedin page you can see they havebeen in business 8months.  8months from start to selling hardware is fast.Adam(disclaimer I am a crypto consultant to spondoolies).
The offline double-spend of Chaum reveals identity.  Brands also has a mechanism to do that (reveal private key and all attributes, one of which could be identity).Other than these advanced ecash protocols, the one-show signature idea is quite simple and somewhat general (eg can be applied to an ECDSA signature) and can reveal the private key if the user double spends.  That would be an alternative mechanism to deter double spending (rather than one coin coming first as voted by miners), you can go ahead and double spend, and the miner will take your coin (because anyone can compute your private key if you double spend, they can create a third spend where the miner pays himself, and mine that.All you have to do is with ECDSA there is Q the public key and r,s the signature; to leak the private key on double spend if you define the public key as Q,r and the signature as s, the signer is forced to reuse k (as R=kG, r=R.x) and if you reuse k with different messages you reveal a simultaneous equation allowing the private key to be computed.s=k^-1(h(m)+rd)s2=k^-1(h(m2)+rd)=> sk = h(m)+rd, s2k = h(m2)+rd => (s-s2)k = h(m)-h(m2), k=(h(m)-h(m2))/(s-s2).then sk=h(m)+rd => d=(sk-h(m))/rAn address would then be addr=H(Q,r) signature would be Q,r,s and signature is not valid unless addr=?H(Q,r) and sR =? h(m)G+rQ  The main problem with doing that in bitcoin is if you accidentally send twice (because your client crashes) you lose money.  And people keep reusing addresses.  These extended addresses would "discourage" address reuse (which some would say is a good thing:)But there is a concept of a limited-show signature where you can spend n times but not more, just define r1,r2, ... rn and you are allowed to use any of those; but if you use one twice your private key leaks.For bitcoin also you could put the recipients r choice in the transaction (allowing Q to be reused, across different tx, but a single r to be used once for the tx).  Unfortunately that inconvenient as the recipient must choose r.Adam Well starting with n-of-n Schnorr, the difference is no k^-1 value complicating the math.  DSA is a complexification of Schnorr, probably as an attempt to avoid Schnorr's now expired patent.  Schnorr is simpler, has better security proofs (possible because its simpler) and makes weaker assumptions about the hash function (ie tolerates a weaker hash, or more slips in hash function properties without breaking the signature, aka DSA stresses the hash function more).The simplicity makes it easier to do blind signatures, and n of n, k of n etc.Comparing ECDSA and ECSchnorr (with relabeling to highlight similarities):ECDSA: R=kG, [r=R.x, s=(H(m)+rd)/k], Q=dG verify: sR=?H(m)G+rQECS:     R=kG, [r=R.x, s=k+H(r,m)d],    Q=dG verify: sG=?R+H(r,m)QECS-alternate: R=kG, [c=H(R,m), s=k+cd], Q=dG, verify: c=?H(sG-cQ,m)(because kG=sG-cQ)(And both ECDSA and ECS can use deterministic variant where k=H(m,d)).so with ECS if you have users with pub keys A=aG and B=bG (priv keys a,b) they can make a sig with  their combined key Q=A+B simply as R1=k1G, r1=R1.x    ->r1                               <= r2,s2       R2=k2G, r2=R2.x, s2=k2+H(r1+r2,m)bs1=k1+H(r1+r2,m)a, r=r1+r2, s=s1+s2as r1+r2=k1G+k2G=(k1+k2)G, s1+s2=(k1+k2)+H(r1+r2,m)(a+b)QED.  (That was just figured out from scratch, maybe there are some other nuances).  k of n would have to look up or think harder.So then unlike with the blind ECDSA method you proposed by choosing a public key relating to k, (and I was thinking ok with that you can 2 of 2 most likely, and sure enough https://bitcointalk.org/index.php?topic=511074.0 the OP put that together), with ECS you can do it more simply and with normally chosen pre-existing keys (and without having to do one-use signatures.)  A risk with R=kG being fixed that is a one-show signature, meaning if you accidentally (eg due to non transactional storage on the client) sign two different messages, you leak the private key, and allow miners to take your coin.  (Considering one-show signatures, where Q'=(R=kG,Q=dG) so k is pre-committed as a double-spend model ie then you cant double spend without giving both spends to the miners has the same problem with accidental double-spend and transactional client storage requirement to avoid).Adam I moved this question about risks with turing complete scripting to this thread on turing complete / ethereum and added some comments.https://bitcointalk.org/index.php?topic=431513.new#newAdam From another thread:They address halting by fee paying for interpreter cycles.  When the fee runs out the contract is stopped.But there are obviously interpreter escape dangers, which are harder to contain for a stateful, looping, low level (byte code like) language.  Look at the history of java sandbox escapes.  People say that was mostly due to call outs to complex native library have to look through the (large!) CVE database on JVM to figure out the stats.  Also the pressure may have been lower.  If you get real money under it all kinds of resources and unrevealed 0-days can leak out of the woodwork and create the new target for grey and black hats some of whom are world class at this stuff.  Or even from national security network intrusion insiders with Snowden-level access or the people developing and selling grey market 0-day to the intelligence community etc.  Those people are fallible humans too - they may succum to the financial motive, or the people who developed and sold them the 0-days may find a new monetization model, or second use for them (they cant "forget" them after sale).There have also been VM escapes from full hw abstraction vms (i mean not just API sandbox light linux-in-linux virtuozzo but actual whole OS in the container).And finally bitcoin scripting is functional, stateless and non-looping (non TC in fact also) for a reason.  Bitcoin doesnt (and I think its intentional) have even extrospection.  There are grey-goo outcomes if you are not careful with even something as constrained as an extrospection op code to existing language.   There will be whole classes of not yet imagined grey goo opportunities lurking in a full TC language.  You cant easily systematically defend against whole classes of such issues without intentional constrained language.Here's a thread started by Greg to explore grey-goo outcomes from extended scripting:https://bitcointalk.org/index.php?topic=278122.0Greg Maxwell also noted the elevated risk of forks developing.  If there is any deviation in script outcome and being more complex there is more risk there also.  eg tracking how many cycles through a JIT executed/CSE optimized etc version as super-majority of nodes MUST interpret the script to the same byte code instruction, or one version can return true, another false etc.I discussed these risks with Vitalik and he is a very smart guy, so obviously they'll try to do what they can to contain them, but you know bitcoin is the highest assurance sw dev and QA risk on the planet by orders of magnitude.  So it maybe a time for risk containment rather than risk LoC and API size expansion, I am already worried on bitcoin about base band-processors hacks, 0-day OS and CPU hacks, and thinking a more zero-trust more air-gap model needs to be the objective.If hypothetically ethereum grew to large adoption (litecoin level say) and then there was enough motivation and something failed hard, there are potential whole system value loss, hard fork and other failure modes.  It seems to have by design, ongoing higher surface area security & value safety riskAlso btw Dan Kaminsky said he spent 4 months trying to hack bitcoin (network stack, overflow on messages, the usual host-security 0-day discovery process) and he failed.  He's one of the best host security guys and the experience impressed him.  Its not a simple thing to make a network stack that bullet proof, most even hard core programmers cant do it.  You probably have to practice 0-day development to some depth to even understand fully the risks and defense landscape.  Bitcoin got there with a really solid start from Satoshi and a bootstrap period where other bugs were fixed before the pressure built up to $10b.I am not going to comment for now on the funding model   They are somewhere between the others and I am sure Vitalik has his eye on actual innovation as well, because knowing him he lives for tech challenge.I think anything that needs to be done, can be done in a bitcoin centric backwards compatible evolutionary way using eg 1-way peg and other related features while maintaining value firewalls between long term holders and people using newer features.But clearly other than the security containment, zero-defect in flight once live, and grey-goo risks, Ethereum can create some fun self-extensibility with a loose analog of like introspection, late binding, eval and dynamically loadable code languages.  We do have to be clear that the cost is the towards opposite end of the spectrum, though lower than activeX and executing native code delivered over the network.  Fun possibilities but a big security job.Adam I see I dont think I realized that aspect of how bloom query works.  So you then with IBE-based filtering could send multiple keys, one for each block; but you are implicitly linked by being in one query, so you'd just as well mark your key with your preferred epoch size and sender uses epoch number in the query.I think Greg is pointing out on IRC that by having a fairly small epoch you can choose later to go down to that epoch size or scale up by sending multiple epoch keys in a batch, a privacy/network round-trip trade off.Re my other problem with epochs ("In practice you might need an epoch not block or overlapping test because the user does not have full assurance of their tx ending up in the pending block") I think that maybe fixable, if the blocknumber is chosen by the sender, and communicated in enough bits to be mostly unambiguous in the message.  Then the node can index them by sen block num and no ambiguity.It could be that another way to partly obscure ownership of queries would be to relay queries and responses and mix other peoples queries with your own in a batch, however as we are considering the SPV client case relaying other peoples queries seems hard to gather query traffic on demand and to use more bandwidth than it saves relative just issuing smaller batches.You could have relaying in the network eg using the embedded Tor but waiting for queries to mix with adds latency, and suffers flood attacks on mix-nets (send fake encrypted query traffic to flush out a tx, that has no-anon set vs the person doing the flooding who can distinguish their own queries).Adam So have been talking with Greg Maxwell, Peter Todd, Jeremy Spillman, Mike Hearn, Bytecoin and others about reusable addresses.There is a summary of the situation here http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03792.html and I had posed th question of whether it was possible to do better at all with Peter Todd:and Peter proposed also the related problem of proving something about that existence or not of a solution to that problem.  I think I have a proof-of-concept solution that proves by example we can do better in space efficiency, linkability defense and non-interactivity than my bloom bait, Peter Todds related prefix; and Greg Maxwell's extended bloom bait described http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg03705.html.So the idea is to use an IBE scheme as a building block in analogous way to my 1996 problem statement for NIFS and 1998 observation that a novel use for an IBE scheme can provide a generic solution to NIFS, and the arrival in 2001 of the first efficient / sensible trapdoor steepness (*) IBE with the introduction of the Weil Pairing problem by Dan Boneh and Matt Franklin described here http://en.wikipedia.org/wiki/Boneh%E2%80%93Franklin_scheme.Greg summarized IBE as follows on IRC:Basically as Greg said your public key is your address (an email address, a block hash, whatever is convenient and unique) and from that and the master public key of the IBE server, the server can compute a private key corresponding to that.  The master public is usually considered to be a system-wide domain parameter.   Naturally enough because a side effect of this is that the IBE server can decrypt everyones email people were never too excited about the prospect.However my 1998 NIFS observation is by acting as your own IBE server (each user creates their own master public server key) they can create a sequence (NIFS) or set (bitcoin reusable address) of public keys with interesting and publicly derivable properties!It is my conclusion from 1996 that to solve this with DL directly at least in the NIFS case appears to be not possible. So basically the reusable address becomes an IBE public key, the existing public derivation via DH or EC Elgamal/ECIES or whatever variant (bytecoins, mine, Peter Todd/Amir Taaki's) arrives at a factor that can be recovered.  So with my variant (random sender generated multiplication factor encrypted with ECIES) you could encrypt the factor with a pub=IBE-extract(master pub, id=previous block hash) using the previous block hash as the "identity" and the users own self-owned IBE "server".  For Bytecoin & Peter Todd/Amir Taaki EC DH version using input or auxilliary addresses to save space its not even necessary to send the factor, its already sent.  So then you send a separate message to do with secure delegatable filtering, a more secure/more space efficient bloom filter/prefix replacement, and this is a more flexible structure.So the secure delegatable filter is you separately add an encrypted bloom bait Greg suggested (eg 1byte prefix communicated with public address.)  And you can even combine that with Greg's extended bloom bait above to add anonymity set within the block.Consequently you can now securely and very network/space efficiently securely delegate searching a block by computing the private key for the IBE pub key that any sender would use for that block, and sending it as a query to a random (or node-capture defended random selected node).  The node can decrypt the encrypted bloom baits with it, but remains powerless to correlate with bloom baits to other payments received by the same user in bother blocks.(In practice you might need an epoch not block or overlapping test because the user does not have full assurance of their tx ending up in the pending block).About weil pairing, and new hardness crypto risk, this is also the hardness assumption under some ZK-SNARKs as I think used in zerocash, and while ZK-SNARK introduces its own complexity/crypto system risk on top; in my view weil pairing is slightly lower assurance/review not so widely used relative to EC DL problem.  Anyway the interesting thing to say about that is in the event this scheme got broken in the future it falls back to the scheme that is being proposed using prefix.  Ie its no worse than that from linkability and likely would retain some cost even if broken-- asymmetric crypto breaks are usually somewhat gradual.This looks more expensive and non-indexable though I didnt look to see if there is any ciphertext only or batch precomputation that could be squeezed out of it.Obviously its more CPU intensive and some eg fee mechanism to prevent node DoS could be nice, but it seems to demonstrate a proof by existence that it is possible to do better.Finally I think it maybe within possibility to do further than this because it is not technically necessary to delegate decryption, only to delegate filtering, which can be a simpler requirement.Adam(*) There was an earlier scheme by Maurer et al if I recall, but to get a 1024-bit security margin you had to perform a discrete log attack on a 512-bit prime, so the key generation cost was immense, hence "sensible trapdoor steepness" thats very shallow in tems of work difference between setup cost and crypto system strength. Forgot to link that topic.  You can see the comments yourself below threads (positive).  1-way peg doesnt need any bitcoin main protocol changes we could do it now.A new even better but bitcoin-main change-requiring variant figured out since.  And someone who can comment if they wish said on #bitcoin-wizards IRC (about the hard fork of this variant) that a) maybe it can be done without a hard fork, and b) anyway its the "one change to rule them all".  Ie after you've done it, other changes can happen on a pegged merge-mined side chain with no bitcoin main security risk.Bitcoin-dev threads see comments for yourself (thread comments are at visible at the bottom of the pages):Dont think there is a forum thread on the specific subject of the long list of EdDSA (EC Schnorr) security/flexibility/compactness advantages, though Greg Maxwell has been exploring it for those and performance reasons.  There were some open questions for Dan Bernstein which he hasnt replied to yet.and as I said EC Schnorr (EdDSA) also supports blind signatures, which are not so far known to be possible with ECDSA.  CoinJoin uses blind signatures based on RSA I think, so it'd be nicer, faster, more compact, to use the native EC Schnorr blind sig.EC Schnorr also makes possible wallet with observer (Stefan Brands concept) which allows a hardware wallet to be made subliminal channel free (wallet prevents offline double spend up to tamper resistance but cant mark coins nor leak private key).  But I spoke about a more advanced wallet observer, what I described (on the podcast) is actually a use of Brands issuing protocol to extend wallet observer so the wallet can sign a transaction and has a ZKP that the subliminal channel free signature it is making is bound to the message it can then display on the bigger hw wallet screen.Subliminal channel free means the wallet has no way to leak the private key even if it is malicious (short of having a radio emitter inside it)Adam A podcast from letstalkbitcoin where I am talking with Andreas Antonopulous: maybe a better summary of the committed tx & homomorphic value, the threads here were full of crypto-math and perhaps hard to decipher, also fungibility/red-list & tx-cost and how that relates to indentity and privacy; also hashcash, decentralization, coinjoin/payment protocol, zerocoin/zerocash, some history.  1h45 of "light" listening http://letstalkbitcoin.com/e77-the-adam-back-interview/Some bitcoin talk links to the topics discussed:Committed transactions (that really needs a summary top post, too much design evolution through it):homomorphic values:fungibility, identity & privacyhashcashcoinjoinzerocoinMentioned some 1998/1999 cypherpunks posts by Wei Dai, Hal Finney & anonymous (Satoshi or not unclear).  The links are at the bottom of this:Enjoy Adam Apparently forum user bytecode proposed something related to this in the past.Some update on this.  I had discussed on IRC the idea of using a 'bloom-bait' to make this a little more SPV friendly, eg by including the last byte of the public key, but it does erode the anonymity set though.Alternatively one could make a separate pairing message with no inputs (other then anonymous unlinkable fee for anti-DoS) to send E.  In this way the pairing message sends E(Q,c') (actually deterministic c' for idempotency/crash recovery reasons).  And c' becomes the shared chaincode for a normal BIP 32 HD sub-wallet specific to sender-recipient pair and secret to them.  There is some risk of time correlation of pairing and first payment are made immediately, and some risk of failure due to non-communication of the pairing message, meaning the recipient does not know c'.  This part is not ideal, sending a single combined message is preferable but incurs trial-decryption and a full node, or a delegation to a full-node that learns the chain-code and does the trial decryption.  Probably one could delegate trial decryption to a full node, and the payload is a super-encrypted chain-code.I am not sure if its analogous to bytecode's idea or not (didnt find the original), but retep also proposed on idea another variant of this same idea: to use static DH for the encoding instead of EC Elgamal (aka ECIES), which is basically centered on the artefact that the paired users dont care to choose a chaincode, a random, negotiated one would do.  For that eg the sender has a public key from an input say P=eG, and the recipient has public key Q=dG, then they use ECDH to arrive at shared code c'=H(eQ)=H(dP).  retep called this a stealth-address, so using BIP 32 it creates a sequence of HD addesses as Si=M(c',i), and the recipient compressed address is S'i=H(Si) so the recipient with a full node can scan for these.  Or delegate scanning to a full node.Again an explicit bloom-bait tag could be used to reduce scanning at the cost of anonymity set.  To make it backwards compatible retep suggested to grind the address to give it a prefix with the added bonus that many tools already keep address prefix indexes.  (Address grinding might modify BIP32 to add a grinding counter: Si=M(c',i,ctr)).  That does imply some grinding cost which slows things down, but its somewhat backwards compatible and arguably indistinguishble to some extent.  Ground address prefixes, or explicit bloom-bait tags, may have adverse effects on CoinJoin as the tag/mark is visible and anonymity set reducing.To my way of thinking therefore there are still gaps in the viability of this approach.  While it is quite attractive to have a safe way to have static base addresses with sender derived addresses or chain codes, it is not so far scalable to light nodes.  But if a way can be found to make this scale to light nodes without introducing an anonymity set problem it could be a big step forward as seemingly users on a recurring and on going basis dont understand and dont like single-use addresses on the receiving end.  Clearly single use addresses are problematic.This approach above could work for recurring business things like exchanges, payment processors etc as those entities are typically running full nodes anyway.  You could say those entities anyway have the infrastructure and communication pattern to support HD sub-wallet addresses.There is one additional advantage of sender derived addresses: the recipient has a global shared static address so it can act as a trust anchor to ward off diversion attacks in a simple and space efficient way without signatures.  It can act like an SSH TOFU (trust on first use) fingerprint.  Users can compare fingerprints, call up the company, expect the fingerprint advertised on all official emails, SSL static content web site, business cards, trust directories, PGP signed by key employees etc.  (Diversion attack meaning where someone hacks a server and replaces the addresses with their own).   Furthermore people can check that fingerprint in their offline wallet for investment level amounts.Adam[edit: NB for this general scheme to work, the recipient needs to advertis an uncompressed address, ie the x-coord of Q, rather than H(Q).  That might even be compatible with older uncompressed BTC addresses, I am not sure] I mentioned a few times that there were 1997 (hashcash) and 1998/1999 (b-money) posts and discussion about how to build digital scarcity and control inflation on the cypherpunks list.I was just reading some of them, hadnt notice this one last time I looked and it is quite nice (anonymous):http://marc.info/?l=cypherpunks&m=95279521221935&w=2(Anon seems to take as a given that b-money would be able to technically solve inflation - the way Wei Dai described it the servers would vote on how much money to create and the cost of creating it per time-interval.  Personally I found that prone to human gaming & abuse, eg might people with limited money at stake vote for "lots" and "cheaply" for the two parameters)So he is referring to the b-money property of supply being increasable by vote amongst servers, but assumes that will remain low and benign.  I am not sure this confidence is justifiable - it depends on the motives and interests of the server operators.  Maybe he is assuming server operators would be unlikely to agree on > 1% supply side inflation or greater than human population growth %, in a mature deployment.This one also appears bullish that b-money can be improved:http://marc.info/?l=cypherpunks&m=95280154630156&w=2(Again as stated b-money would have allowed on-going supply side inflation according to an average of server voter-for rate at a creation cost based on average vote-for difficulty).(Found those with search term b-money from http://marc.info/?l=cypherpunks which finds several threads).Adam I didnt so far find a way to do it with ECDSA, but that is not a proof.  Also there exist other crypto schemes that are self-reblindable (without knowing the private key).But it seemed to be rather than relying on this additional and perhaps not designed for property of signatures non-malleability (of the anti-malleability-canonicalized serialization) that maybe longer term bitcoin could include the public key in the hashed data rather than the signature.  By definition the signed data must also be unique as txins are spent in full.We were also talking at the physical meetup about possibility to fix the malleability before forwarding and Greg had mentioned this as a work-around used by blockchain.info as they were unable to modify their wallet due to apple's regressive policies.Adam I am not sure.  One thing you could say is if amounts are encrypted maybe you dont so much need lots of addresses.  However I think encrypted amounts isnt quite enough, you probably need like to hide who is paying as well as hide the amount before that becomes convincing enough to say you only need one address.  Then it could save some UTXO space as you only need one unspent address per user for privacy.Adam I think eg if you read the original zercoin paper and I said similar things on bitcointalk that anonymity is the ideal building block.  What you can build with it is many permutations of desired and useful privacy levels.  It doesnt have to be full payee & payer anonymous just because the building block supports that.  And there are many reasons in the real world that you dont get that privacy in practice.  IP logging, IP geolocation, physical shipping address, knowledge of you by the person you are paying/receiving from, privacy mistakes etc.Kind of odd if you are sitting on the holygrail crypto and not publishing for some kind of ethical considerations?  Really?  Technology is neutral and this technology can add many useful permutations of privacy to bitcoin.  I'd sure publish it immediately if I had figured it out and feel I did a good thing for society.Maybe you want also to read this post by Greg Maxwell explaining why privacy is important for society and commerce.https://bitcointalk.org/index.php?topic=334316.msg3588908#msg3588908I think you get that also because as I understood it you explored anonymity because of your interest in card gaming to prevent collusion being used to cheat.ps Personally I think gambling has far more ethical worries than users being able to transact privately with something approaching the analogous already existing levels of privacy in other systems.  For some people gambling becomes a near ruining addiction.Adam Yes you are right.  It was written in great haste as I was leaving, figured this out shortly afterwards.The problem is the network can be expected to cache your correct password result after KDF.Therefore the only thing this could be good for is a one use signature (eg a big stash that you dont touch except once to sell it).Or if you have a seed encrypted 1000 times with each different salt and the same password, and you securely delete the respective encrypted seed after each use.50 choose 100 doesnt seem to help that picture.I think the Rivest & Wagner time-lock puzzle (which I extended with blinding) might be somewhat memory hardenable if one used bigger RSA key than necessary for security.  Not really tried to analyse it from that perspective so far, there may also be some parallelization opportunities or TMTOs.The basic RSA blind signature is rather simple, eg used in the coinjoin protocol right.  The blinding variant I use for blinding the time-lock puzzle is quite similar.  Maybe it wouldnt be so bad if a simple reference implementation in OpenSSL were provided.Adam But I think you can do it by making 100 KDFs, and add 50 of them together mod n.  Then you shuffle them send all 100 to the network, it does the KDF stretching which is expensive, sends the 100 back to you.  You pull out the 50 that are correct combine and decrypt.https://bitcointalk.org/index.php?topic=330819.msg3548144#msg3548144what makes it hard is the network doesnt know which 50 of 100 which is work ~2^128.  There is no closeness metric so you have to brute force.Adam You do have the key.  My point is you can do it fast before you delete the salt.  After you delete the salt it becomes hard as you have to search for the salt.You do not need to do work when you create the key.  Only when you decrypt it.Replying to gmaxwell now I have another idea.  Secure offload with symmetric crypto no blinding.Adam Ilja Gerhardt & Timo Hanke's Pay-to-Contract Protocol http://arxiv.org/abs/1212.3257 is something else that could be done which is somewhere in between signed addresses and payment protocol.  I think signed addresses could be used in both protcols.  The point is the signed address can be more offline and control that the payment at least goes to the right entity with offline security.Adam Bitcoin irrevocability & fungibility is cool and one of the main benefits of bitcoin.  However the cost is stealing them constitutes the perfect virtual crime, and so the level of APT attacks will surely rise to new proportions against both user machines, and bitcoin processors.Now one step towards making bitcoins hard to steal is offline wallets (armory & trezor) where the remaining remote threat is almost removed (subject to very few lines of code in usb drivers and the attack vector of the protocoin sent to the offline device for verification and signing).  Given the stake the lines of critical code can be minimized and audited.  This is  robust starting point.However the remaining issue is, while you can receive bitcoins securely over an air-gap, and pay from an offline wallet using usb or QR code, your ability to securely communicate addresses for receipt via the users online computer is questionable.  Targeted bitcoin malware can win this race (show you what you want to see, but send a different address to the sender via local SSL backdoor, app patches, OS patches etc).Similarly security of the online payment processor's environment is in question.  They can use host security experts, best practices etc.  But still there is the 0-day and the APT attack, but surely it will escalate to a new level.  And the payment processor despite hot-wallet / cold-wallet trade-offs is an increasingly valuable target.  Malware on the payment processor can send users the attackers address for "deposit".  It can steal the hot-wallet.  It can replace users "withdraw" addresses.  They'll notice but it maybe too late.The payment protocol https://en.bitcoin.it/wiki/BIP_0070 helps, however that has to be part of the online merchant app because its not just signing the merchant invoice address, its signing the transaction details also.  Likely it will be signed by the SSL web site, though it could be signed with a separate sub-domain.  Lack of a hard requirement for this to be the case makes that assurance weak - an attacker who gains control of the merchant site can sign with the SSL cert key and users wont consider anything amiss.Also even without breaking into the merchant, SSL certs can and have been hacked, and absent cert pinning, the entire system is as weak as the weakest CA.So what could we do about this.  We need to rearchitect for the bitcoin offline wallet security model.  Its fine for the web app layer to best-effort sign the transaction, if one values it for what it is - an assertion by an at risk web app with at risk keys.  (Hardware security modules dont help that much, the app layer still obtains no-restriction signatures from the HSM).So one more thing that could be done is to use hierarchical deterministic wallets to make a sub-wallet with a shared chain code between the user and the merchant.  For repeat custom or a bitcoin exchange this could make sense.  Then if both the merchant and user keep the chain code off the online machine they can at least be assured that the address is unique to them.  Use out of band security to set this up.  Or use TOFU (trust on first use) so that both sides abort of something changes about the security context.Secondly it seems to me we could do with something end to end authenticated between the sender and the receiver.  Signed addresses?Then the sender and the receiver dont need a secret (shared chain code of sub-wallet), they only need an authenticated signing address from the respective online wallet.Maybe you derive identity assertion keys deterministically from the offline wallet, derived from the receiving parties identity (domain name, email address etc).  And send those to the receiving party during setup, or use out of band for one off.Privacy, fungibility?  The signatures are not part of the bitcoin transaction, they are just to convince the relying party.  They are not receipts like payment request ack messages, they just show you that the person you expect is the owner of the address with offline hardware assurance.Because the addresses are not user specific the merchant can upload batches of them from the offline computer.Could you use abuse the payment request protocol to encapsulate a second signature on an address?  Probably but that seems like a protocol layering violation to me.  Payment protocol is an app level protocol, authenticated addresses are simple, have no external references and gives a stable public handle to authorize.  The hash of chain code of a sub-wallet could do something similar.In terms of concepts and terminology you could consider the signing address (that signs the one-use addresses) to be an account number.  And the one-use addresses as transaction or invoice numbers that are signed to prove they are owned by the account number.  You can use a different signing address for each recipient to add privacy.  Or a different signing address for each time if its not an identified ongoing relationship.You can wrap these signing addresses with X509, PGP, SSL, phone call to check, offline address signing key fingerprint on company business cards etc.Adam You rely on the custodian who holds the asset as backing for the colored coin (xcc)/mastercoin (msc).  However if the asset represents a bearer share in a company you dont trust anyone.You know that share buy backs and fresh share issues are not the normal way that you redeem company stock - you redeem it by selling it to someone else.You are not thinking for enough ahead.  The company transacts entirely in bitcoin, its shares are represented in color coin.  The dividend payment subject to shareholder approval (holding colore shares gives you the right to vote proportionally) and measured against the share prospectus shareholder vote threshold, defines the dividend.  Ownership of the shares definitionally grants you authority over the dividend amount.  The company is powerless to renege.Same for the entire banking & finance ecosystem and governmental policy.  Its in the constitution (a countries prospectus) they cant change it without a super-majority vote defined as part of the constitution.This is why smart-contracts are the future.Obviously second and third generation of scripting is required for such things, but thats the direction IMO.  So you have to architect to that assumption.Adam Yifu also responded via tweet.  Now Waters via reddit.  I responded to them on reddit and tweeted also.https://twitter.com/adam3us/status/402370818232958976http://www.reddit.com/r/Bitcoin/comments/1qmude/yifu_guo_is_conspiring_to_make_his_own_coins/cdgn3fuHere is what I put on reddit.Adam
You know that is a good idea, practical, can be done now, no experimental crypto risk.  Greatly reduces fungibility risks and might buy a few years.  Lets do it!Zerocoin or equivalent can catchup when it does.Adam Yes thats pretty much it.  Technically the coin is c=g^s*h^r and c is seen by everyone when it is added to the accumulator (though s and r are not seen by anyone).  But when it is spent s the coin serial number becomes disclosed and is stored in the doble spend db, c is hidden because of the ZKP and r is still not revealed).Adam I guess we have to see it first.  I hope they are going to publish the crypto before the alt, presumably because the zerocoin v1 paper came out long before the library.I think fungibility guarantee via coin anonymity is the right thing to do, as the strongest form of fungibility is cryptographically enforced fungibility.   But I think user privacy is orthogonal to coin fungibility.  I can prove my identity while sending an anonymous fungible coin or not as I choose, if the coin is cryptographically fungible I have a choice.  As is with bitcoin I have limited choice because the coin leaks linkages.Usually if you have anonymity as a building block users can opt to disclose and prove because the anonymity will also have keys and the user can publish their keys.  So I think it likely that opt-in public association of an identity with specific coins, or maybe with unlinkable but validatable amount of coins would be technically available, and I can see its a useful feature, so should be made an option for users.  (Eg to prove they have the bitcoins they claim to be holding for users, or disclose the amount of donations received).About privacy in my view bitcoin is a bit too open which I think is not so much by design, but because its difficult to have privacy and the auditability SPV operation needs, because miners need to validate, and to validate they need to see amounts and transfer histories.   (Hence the interest in zerocoin and zerocoin2.)  Without needing to support SPV clients one could do committed-tx and it would be a step forward.I think Ideally transacting parties should be able to choose the level of privacy from each other and from the public.  eg pseudonymous to each other but private to the public.  Or identified seller (because its a regulated business) and identified business (because the user need to validate the reputation of the seller), but private from the public.  In event of need to reveal more detail to selected other parties, or to the public to prove good faith, they should also be able to do that eg by publishing some keys.In this way policing can be done by asking for information from transacting parties.  And demonstrating openness (eg for donations, charities, public companies) can be done by publishing keys.  And financial auditing can be done by a charity or company giving their accountant or auditor keys to view their transactions (but not necessarily the sender identity).There are also privacy preserving forms of auditing.  Eg homomorphic values can still allow auditing that values add up by anyone and yet hide amounts and/or payer psueodnym is unknown (close to single use addresses but slightly stronger privacy).So I think if we can get a cryptographic private, efficient, distributed coin with conservative security for the coin anonymity/fungibility layer then we are golden.  We can engineer/architect the selective disclosure, selective identity and different privacy concepts to dove tail with transacting party wishes.  I would say bitcoin should not make any global rule about maximum allowed privacy, because rules are different in different countries.  Rather payments should be private between the transacting parties, and it is up to the transacting parties to keep records and answer requests for information disclosure, and to provide identity to regulated businesses in their respective jurisdictions, But its hard to do get the efficient, distributed and private ecash, thats so far proving to be another triangle thing like pick 2: efficient, distributed, private.  So lets have a look at what we have:- bitcoin (efficient, distributed, but taintable privacy)- chaum or brands ecash are (efficient, cryptographic privacy, but centralized)- coinjoin (efficient, distributed, smudged taint privacy)- opentransactions (efficient, cryptographic private, limited redundancy)- committed-tx (efficient, private except parties see payment history, decentralized but no SPV)- zerocoin v1 (private, decentralized, but inefficient)- holygrail (efficient, distributed, cryptographic privacy)we have to see how zerocoin v2 stacks up.  Another risk point can be bleeding edge crypto that hasnt seen 10yrs of review.  Things with security proofs have been broken before.  Hardness assumptions for new things sometimes erode or slip.Adam well rather than the get rich quick, get in early motivation for the me-too alts, the idea is that you get into it because you want the features it provides.  eg if zerocoin used the model.Now thats not as strong an incentive as make-money-fast pyramid speculation on frankly long-term hopeless me-too alts.  But if the idea is that it is going to become the new bitcoin in say 1 year, once the features are well validated.  Then it would help reduce concern of being stuck.The reverse swap depends on demand.  If people dont care about the new features they wont use it.I would think something like maaku & jtimon's freimarkets would be a good candidate for doing this way.  Freimarket is not related to frecoin - its a native coloring and smart contract proposal.technically it could be done, (bitcoin could accept coin moving in the other direction) however it imports risk into bitcoin main as a security defect in betacoin that allowed theft or forgery of coins, could then be transferred into bitcoin. Once the beta is over, the remaining coins would be bulk oved in a hard fork and beta wold become main, and a new beta started.  eg on a yearly cycle.  like fedora and redhat enterprise linux or linux kernel stable and latest etc.see earlier in tis thread:https://bitcointalk.org/index.php?topic=175156.msg2378622#msg2378622and another few posts after it where I tried to explain it a bit.Adam btw see also "bitcoin staging" aka betaCoin.  http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg02944.htmlIts a way to one-way peg an alt-coin to bitcoin, so there is no native mining, the way you create coins in the alt-coin is my moving bitcoins into it.  And the way to trade them back to bitcoin is to swap them with someone who would otherwise move one.  If a security problem develops in the betaCoin, people stop swapping betaCoin at par for bitcoin, or market freezes until the issue is fixed.  This is the minimum necessary feature to firewall bitcoin from betaCoin security issues while allowing bitcoins to move between betacoin and bitcoin in the normal case.This is how I would go about doing an alt (otherwise the usual me-too coin is contingent on the hope of getting in early, or early mining and selling to next stage speculators before the pyramid collapses when it becomes obvious it has no chance of competing with bitcoin for acceptance.  As this coins have no acceptance, they have no transactional value, their own value is speculative, which I think must implode at some point.)  Also even in the hypothetical that a given coin did overtake bitcoin it could be a dangerous outcome as then what happens to the value of bitcoins?  Such an untidy unravelling of bitcoin value would hurt the overall concept of digital scarcity.  Say it was litecoin.  Then if litecoin got to like 90% to bitcoins 10% BTC/LTC exchange would fall.  But then people will be looking nervously at the next runner up, and hedging in the main runner ups.  This is a net disservice to digital scarcity.  Digital scarcity is a new virtual asset class, and I think is the future of money and financial networks.  So we dont want to weaken the concept with me-too alts, even relatively well thought out ones because they define a new digital scarcity race.  I think there should only be one credible digital scarcity race or we may have a problem.  Digital scarcity becomes digital tulip, then who wants to invest in the next one.betaCoin is also a way to do an alt that preserves the 21 million coin cap.  Fees would be paid in betacoins (or bitcoins).  Miners would mine both networks for profit maximization reasons.Adam I pointed this out in another thread, and to Mike Caldwell in relation to BIP 38, but I think people are not aware.You do not need to do work when you create the key.  Only when you decrypt it.Instead of k=scrypt(salt=0,iter=65536,mem=1GB,passphrase) you can use random 16-bit salt k=scrypt(salt=16,iter=0,mem=1GB,passphrase) with a salt you securely delete after key generation.  The work is the same and the setup cost trivial for a smart phone.  Obviously its easy to create key stretches you cant undo even with a super computer or the entire bitcoin network, so you have to apply strict sanity checking to the parameter choices.(As an curiosity aside, to create asymmetric work decryption with symmetric crypto, is an extremely old design, due to Martin Hellman which led to the discover of public key cryptography, practically cryptographic archeology You can also adjust the difficulty over time, by deleting another bit to adjust for moore's law once a year or so without changing keys and addresses.  You can after the fact harden your KDF.  eg if the bitcoin become worth more, or if you start simple and end up with more holdings relying on it.I have another KDF approach also based on a blind version of Rivest et al's time-lock puzzle which allows third parties to do the KDF work for you, in zero-knowledge for a fee.  At litecoin prices it allows you to add 44bits to your KDF for a fee of 50c.  (or 40bits for a fee of 3c).  Lower than the bitcoin fee.  That can make grinding even  relatively weak password economically infeasible and litecoin-like networks are probably the most efficient rentable computer on the planet.It gives GPU miners something to do and allows a smartphone to directly provide massive KDF security.  Your private key, if encrypted, once in the hands of your attacker - be that physical laptop theft, cyber criminals from an online or USB bios attack, law enforcement investigation - *becomes* a brain-wallet.I encourage people to consider the offloadable KDF approach.  It provides a combined cryptographic/economic defense and level of assurance to brainwallets and stored-wallets that is not feasible otherwise.Have you looked at what bitcoin armory does?  They are using scrypt's romix which is has a memory hard security proof, but tweaked slightly for cpu/memory.Btw I presume people know that scrypt has TMTO tradeoffs and is was actually not designed to prevent that.Adam This thread has focused on technical reasons why coin-level privacy is necessary for fungibility and bitcoins value (and that CoinValidations proposals seem likely to sabotage both).   User level identity privacy was mentioned in passing above.  Privacy does not prevent legal investigation.  The system of courts and subpoenas for information, is societies way of balancing and asking unrelated people to disclose information that may hep track a crime.  A better background explanation of the motivation and reason society includes privacy as a fundamental human right, and why financial privacy is actually important and necessary for individuals, businesses and finance to function is given by gmaxwell on this thread.  Adam He probably is spinning PR or focusing on short-term implementation plans to avoid discussing the longer term plans discussed in the article.  If you read it with the PR-interpretation mindset its not so good.  Whatever his intentions, he is not thinking through the implications or just selfishly doesnt care for quick buck reasons,  I dont know him so I cant tell.  Either way I think this will not end well.  I've been in the privacy tech / crypto business for 15 years, its quite common to encounter and have to navigate around people of all stripes: well meaning, neutral, dont care, and anti-privacy.  Even the ones that are neutral or well meaning often dont think about the long or even mid-term implications of what they are doing.  Thinking about implications is complex, requires concentration, deep understanding across many fields, and may conflict with short term objectives (ie rush something ill-thought-out but  "pragmatic" to get something out the door).  Sometimes making a buck even conflicts with user interests, or even the survival of the system.  Some of these people might even show concern and genuine remorse afterwards when it predictably blows up (to their genuine surprise because they didnt think more than the first chess move.)  Most probably though they'll be onto their next venture and pretend it never happened or more likely not even make the connection between their actions and the outcome.The technology space is littered with implications from ill considered decisions.  Eg web pages are not signed, and jscript is not signed; a single server key is used for combined tunnel auth/encryption but no transferable signature on the content.  So people can hack servers and modify and replace code and steal eg jscript bitcoin wallets.These things matter because architecture defines the internet.So first they want to identify clean addresses (from the forbes article).And then they want to distance themselves from clean addresses (from reddit).So whats a clean address?  Its one that according to them has not got taint on it according to some threshold they decide against some blacklist.  Seems squarely what we are talking about.Thats my interpretation.  Waters or the other people at CoinValidation are welcome to clarify.The KYC part yes, the clean coins I am not so sure - they really do seem to think longer term that tracing coins is somehow a useful thing to do, which can only harm fungibility.  We may need a priority deployment of CoinJoin option into multiple clients before they get far with that.DarkWallet could probably do with some funding help also.Adam Its a subtle point but there should ideally be two layers.  A. Coin layer, the coin is anonymous and fungible (like zerocoin if they can get the CPU & storage efficiency and another issue fixed).  B. User layer: the users send each other encrypted transactions for commercial sensitivity and user privacy, within the encryption the users identify to the degree they choose, if any.   If the recipient is a regulated, it asks for AML/KYC level identification.Bitcoin is not so far able to meet this normal ecash design.Bitcoin is cutting edge, the blockchain design is an elegant all-new design to handle double-spend protection for distributed ecash.   But it lost some crypto ecash features of fungibility via cryptographic blinding (Chaum) because they are harder to do in a distributed system.  As close as we have so far is the ZeroCoin proposal of Matthew Green & Ian Miers which improves on a 1999 paper by Sanders & Ta-Shma.It is very complex to improve bitcoin features, to do it with practical efficiently, and to get them implemented securely, tested as rigorously as a jumbo jet autopilot, and deployed.  There are hard cryptography problems.  People are working on it as hard and as fast as they can, most of them volunteers but enthralled by the new possibilities bitcoin enables for society, with smart-contracts, user self-determination etc.I think you have been reading too much David Brin    While corruption is bad, as Assange says, there should be transparency for the powerful, and privacy for the weak.  Current financial systems have the reverse.In fact a further future, smart-contracts (that bitcoin includes an early version of) should allow rules to be apriori enforced.  This is because smart-contracts act like a scrupulously honest virtual AI that always follows the rules and cant be influenced.  Technically its just that all recipients of proceeds of contracts, and he network itself validate the transactions before they rely on the money.  But its a very powerful effect.  Mike Hearn made a presentation on smart contracts www.youtube.com/watch?v=mD4L7xDNCmAI do think in principle we could build a future with less systemic risk, less scope for fraud with more sophisticated smart-contracts apriori enforcing rules.  It is better to prevent a crime than occasionally catch these people, and mostly they are smart-enough and connected-enough to avoid sanctions anyway.Or strong legal protections and government funded support for whistle-blowers.  Whistle-blowers of corporate and government crimes should be lauded as heroes.  Take Snowden: should be nominated for Nobel prize, not grounded in Russia.I think investigation should work as at present.  Subpoena people and businesses the criminal interacted with to track down.Typically the user can keep receipts and present them afterwards in event of dispute or to prove what happened.Adam This is not about crime, nor identifying perpetrators, its about fungibility, they are (perhaps surprisingly) orthogonal payment system properties.An electronic cash system, must have irrevocability, which as we discussed here is how bitcoin can achieve low cost and efficiency relative to credit cards & paypal.   Coin anonymity is necessary for fungibility, but that is strictly about fungibility, identity level privacy is separate. Bitcoin makes attempts to achieve irrevocability via blockchain hardening (so it is expensive to undo or change the transaction) and also via using fresh addresses to add coin-level anonymity.  CoinJoin and mixes are technical solutions to improve on just using fresh addresses. However that does not mean the user is anonymous.  The user is identified  because they have an identity, they interact with multiple coins and identify themselves to businesses.  Police investigators can ask normal businesses they interact with to identify them.  And users identify themselves via street address for delivery, IP address (unless using Tor), username/password on web site, and email address for receipt, bank account for exchange, AML/KYC identities at the exchanges, geo-location of their smart phone, IP address log of their DSL connection, and (without CoinJoin) because their payments link different addresses when a transaction is made using multiple coins, and change is given.The bitcoin user is far from anonymous.  The full transaction log is public.  (Bitcoin really is not that private nor anonymous: if someone offered to make your bank account or credit card statement as public as bitcoin does we would be angry about it.)As I said in the original post:Now in an ideal world how it is supposed to work is the fungibility/anonymity is secure like zerocoin.   And identity is managed between people sending and receiving bitcoin.  Many variants are possible:1. public (everyone can see amount, and sender/recipient addresses - current bitcoin)2. private (encrypted so only recipients see value and address information) 3. private but identified (encrypted between recipients, but recipient and/or sender is identified)I prefer user choice of 2 or 3. We use SSL for web commerce for a reason, confidentiality of the transaction, and bitcoin does not encrypt transactions.  It means only parties to the communication see the value and decide what level of identification they want if any.  This supports buying ebooks without a dossier of what books you read.  Its no ones business.  And it supports AML/KYC for large for regulated businesses.  And identifying the customer account so the business can account eg with repeat customers.   And it supports criminal investigation also.  The police go subpoena information from businesses the criminal interacted with to track him down.  Same as in real life.(This is what committed transactions try to do, though it so far has inefficiencies for SPV, and has imperfect privacy as people on the transaction see previous transactions; however it is much more efficient than zerocoin.) The problem with Coin Validation arises because bitcoins coin-level fungibility/anonymity is imperfect, so it is somewhat possible to correlate users via coins.  It depends if the user follows technical advice, what wallet they use, and if they use coin privcacy enhancing tools like coinjoin.There are two approaches: cryptography like zerocoin/committed tx; and stirring coins together like coinjoin and mixes - so their whitelist attempts see a jumble of spagetti and reject all transactions and so are ignored.  CoinJoin works now the others are future projects.Bitcoin identification is also adhoc.  However any regulated bitcoin processor asks for AML.  Most business sites will have an address for delivery, an email for a receipt, an IP address from the web, cookies linking to other sites.  Hence my suggestion to them: issue AML certs in their jurisdiction that the user can show when requested its the sane way to do it within the architecture of an ecash system without destroying its fungibility and hence destroying the currency itself.(btw fungibility to the other reader, has a second standard meaning: that each coin should be considered equal value).I hope contrarily that to quote John Gilmore the internet views Coin Validation as censorship and routes around it.  Meaning the coin graph is stirred to a blur via coinjoin integration in all major clients, or Matthew Green & Ian Miers figure out a faster zerocoin or something else figures something else out.Please do not feed the "oh but the criminals" meme.  We're not encouraging or facilitating crime.  Before it was shutdown silk road accounted for < 1% of transaction volume/month and falling.  Paper cash has worse statistics and is less traceable.   HSBC laundered $880m of dirty money for drug cartels and worse, and walked away with a fine, no sanctions.  http://www.reuters.com/article/2012/12/11/us-hsbc-probe-idUSBRE8BA05M20121211  We just want an efficient fungible payment system that works without the reputation (equifax etc) costs and revocability (credit card charge backs, paypal freezes etc) that come with credit cards and paypal.   Do NOT invite currency destruction via fungibility attacks it WILL pull the costs up to credit cards and paypal levels.Adam Well towards getting some kind of reasoned response from Coin Validation I tweeted a link to Alex Waters & Yifu Guo for the above thread.  Couldnt find their email, but their twitter handle are easy to find, and they appear to be very current.https://twitter.com/adam3us/status/401104148558397440Adam All previous addresses that received the coin are listed on the public blockchain ledger.  From what was said I believe Coin Validation plans to look at the history of the addresses associated with coins.  If your coin was used 10 transactions ago by a silk road user, (eg seen entering the silk road address) then likely implications are you will not be able to spend your coin on any site using their system.They hope it will be viral, ie because you dont want to hold coins you cant spend, you may also refuse to accept coins they do not white list.  Having them validate your coins will not be free and the uncertainty arising from not knowing if your coins will suddenly become less spendable will create fungibility problems.There are costs associated with the fraud tracing validation, blacklisting and payment revocation.  eg its bad for merchants too, they cant rely on receiving money they can spend themselves.  This is why credit cards are expensive for merchants (3-5% + 30c).  This is one thing that makes bitcoin attractive for merchants and users - the fees are close to zero in comparison.  Coin blacklist/whitelistng (just different names for the same trend) damage the underlying  irrevocability which enables low cost transactions, and pulls bitcoins transaction cost up towards credit cards and paypal. The problem is when fungibility degrades because everyone is mutually scared of accepting blacklisted coins the utility of the coin goes down, the cost of using the currency goes up and so its price falls.  It might literally collapse if the feedback loop picks up momentum as people sell non-white listed coins at steeper discounts in a race to the door.This makes as much sense as a $100 note in your pocket disabling itself because 10 previous holders ago, someone stole it from a convenience store.Someone posted on reddit about a 17th centur scottish court case (cant find the link now), where a bank was able to prevent legislation that would've had that implication - if you're left holding a stolen note, you lose it.  The court rejected the case based on the argument that doing so would be unfair and also destroy the fungibility and value of the currency.  Coin Validation want to reopen that 17th century mistaken (but defeated) court case.Adam I disagree with that as the main assmption and use case.  Most share trading is done via buying and selling, not via redemption (share buy-backs).  I made some more elaborated comments on this thread you pointed to now about the additional value PoW provides for shares:https://bitcointalk.org/index.php?topic=220155.new;topicseen#newI encourage re-examining requirements, its a habit of mine also, and that is often how improvements are made.  However I think you maybe missed some use cases for PoW/block chain security in share trading.Adam Trusting the issuer is a plausible trade off and others have worked with that assumption.But there remain advantages for mining/blockchain validation based security.  Consider:- if you want the issuer to be offline (it could be dangerous to have a key online that can create value on whim if it is hacked the system may break down).- more advanced/2nd gen types of features where the bearer shares are the shares, not a representation for shares in some external authoritative ledger or issuer escrow broker account: there may be a digital prospectus where the issuer is issuing 10,000 shares for their A-round of financing.  The prospectus says they need approval from 25% of share holders to issue a second round or to do a share buy-back.  So the network validates shares, and all peers reject any shares created in violation of the company prospectus apriori.- mostly when one is talking about shares, there is no redemption (outside of a company voted share buy-back) - there are just buys and sells on a market setting the price.  If you want to redeem the value of your share you sell it.- smart contracts depend on final settlement.  If the settlement is not final, then undo requests will be made by users in dispute.  If your system is based on consensus the court will hit your transaction server/issuer with a demand to undo consensus.  Once this happens people will realize the contracts are not smart, and incur the same posthoc dispute costs at the transaction layer as credit cards etc.- I am not saying disputes cant or shouldnt be resolved: the point is the parties go to an arbitrator or court and allocation of blame is made, and the parties settle financially.  Not by undoing a transaction..  You no more want transactoins to be undone than a $100 us bill in your pocket fail one day because 20 transactions ago someone stole it from a convenience store.  Bearer assets based on smart contracts flow onwards into dependent transactions eg as part of a structured product, a swap etc.  They must not be undoable or the utility of smart-contracts is damaged.Adam http://www.forbes.com/sites/kashmirhill/2013/11/13/sanitizing-bitcoin-coin-validation/Its based on significant misunderstanding about bitcoins value proposition - destroy its fungibility and the costs float up to meet credit cards and paypal.It is also a ridiculous approach.  If they want to certify users, they should do that as optional KYC, AML certificates that regulated merchants in respective jurisdictions can request, which could be attached to wallets/identities, not to fully fungible coins.  The certificates should be non-transitive they attest to the identity of the user, not the coins.  They should be optionally sent - if the recipient does not request it, it is privacy destructive and a security risk to send identifying information to unregulated businesses and individuals.Their technical representatives of Coin Validation should be ashamed.  How can someone who doesnt understand a concept as basic as fungibility and its relation to transaction costs, and the difference between identity and coins hope to exist in this ecosystem.  What they are proposing so far at least as explained by the Forbes article is stupid, dangerous and just wrong.  I am also incensed frankly that someone would step into the market with such a muddle-headed thinking, and attempt to sabotage or destroy the core bitcoin feature that gives its value, where the value has been created by Satoshi and a cast of millions of man-hours of contributions of the community and technical wizards developing it mostly on volunteer time.  I am not someone prone to swearing, but this is astonishingly stupid and dangerous.   Please stop now.  In the article it is claimed they sought advice from the Winklevoss twins, if the twins value their estimated $30million bitcoin holding they should advise them to stop: if fungibility is destroyed bitcoins value as a transaction currency is impacted.  I encourage anyone with technical skills to put their thinking caps on to find ways to increase fungibility in the short term like CoinJoin, coin control in wallets, helping less technical people migrate to better wallets, educating people about privacy practices that defend fungibility.  And longer term privacy technologies like zero coin, homomorphic encrypted value and committed (hidden) transactions.I encourage all bitcoin businesses to shun Coin Validation unless we see some major U-turn or corrections.  If your business depends on the success bitcoin, it depends on the fungibility of bitcoin, and Coin Validation seem to be set on destroying both.You can quote me on that.I welcome Coin Validations corrections of the claims in the Forbes article.  Tell me you were misquoted.Adamps For people who have no idea who http://cypherspace.org/adam/ I am https://bitcointalk.org/index.php?topic=225463.msg237167 , my small part in bitcoin is I invented distributed mining in 1997 https://en.bitcoin.it/wiki/Hashcash (you can find the reference in Satoshi's paper) and worked on opensource ecash & crypto currency research & implementation for about a decade alongside Wei Dai & Hal Finney & others. Other than the committed tx defense, if they try to centralize it, and introduce dispute resolution, taint tracing as an analog of credit scoring, they will damage fungibility, increase transaction costs via the credit scoring management tax they extract, and the payment repudiation they may seek to introduce.  Eg take a look at this http://www.forbes.com/sites/kashmirhill/2013/11/13/sanitizing-bitcoin-coin-validation/Its based on significant misunderstands about bitcoins value proposition - destroy its fungibility and the costs float up to meet credit cards and paypal.If they want to certify users, they should do that as optional KYC, AML certificates that regulated merchants in respective jurisdictions can request, which are attached to wallets/identities, not to fully fungible coins.  The certificates should be non-transistive they attest to the identity of the funds.  They should be optionally sent - if the recipient does not request it, it is privacy destructive and a security risk to send identifying information to unregulated businesses and individuals.I put some comments about confidence chains idea on the thread about it:https://bitcointalk.org/index.php?topic=317114.msg3581752#msg3581752I think it has the same problems as other consensus systems like ripple, and the existing banking infrastructure in terms of sybil attack (identity theft), reputation management (equivfax etc) and fraud (when people prove unworthy of their default reputation, succeed in committing identity theft, or commit fraud).These are issues bitcoin mining is intended to defend against.  Most attempts to save the cost of mining reinvent ripple and come to the realization that mining is performing a critical security function.  Mixed PoW/PoS of PPCoin maybe an exception.Adam Doesnt this have the same problem as ripple?  How do you assign confidence.  I believe pragmatically ripple is assigning confidence based on external business relationships with gateways.Plus some manual trust links by individuals.In either case this is either vulnerable to systematic sybil attacks, or legal attacks to the gateways, where because consensus has no mining security, they can be ordered to undo history.When that happens it damages fungibility, and introduces dispute cost and defensive reputation management cost into the transaction layer, and fraud cost when those best-effort mechanisms fail, and then you are back to the status quo.  ie there is a reason businesses go to equifax, and that credit cards are expensive, beyond banks having regulation costs and high margins due to barriers to entry: paying for the above reputation evaluation counter-measures and fraud costs.Adam You could consider a merge mined side-chain (for security), or an existing altcoin.  If interested in alt-coin route perhaps protoshares/bitshare have some synergy in being a bearer asset related alt.But if you're going to do it an an alt you dont need to coloring, just directly represent the color.  No need to encode your messages on top of a network that doesnt understand your semantics, if you can extend the protocol.  You can technologically win an arms race with hypothetical anti-color rules, via steganographic arguments, but it doesnt change the network cost, so its zero sum for the anti-coloring and the pro-coloring.About native color representation freimarkets have done an excellent job of thinking through the minimum new script features necessary for smart-contracts.  I proposed a couple of extensions, and I saw they had the exact same, plus more as they have explored the full set of required features with the minimal, simple and elegant protocol bitcoin script extensions.  (Freimarkets is completely unrelated to freicoin other than name).  Bitshare itself has its own (unpublished?) direct encoded from scratch implementation in the works.Well this is another solution.  Make bitcoin so scalable that it doesnt matter.  However that is really hard.  Zero-trust offchain is one avenue, but its not clear how or if it can work; there maybe some 'crypto/computation physics' limits.  Unknown so far, but lots of people are interested to see if it could be done.  The existence of satoshi-dice didnt help as a catalyst - the scalability problem is known recognized and very hard, it didnt progress because we're at a technology limit unless and until someone can overcome it.The problem as I see it is bitcoin has a scaling limit, like transactions per second, which it can support in full p2p bearer form.  It can be scaled but only at the cost of reducing its decentralization.  eg if block sizes go to 1GB, that counts me out of running a full node.  Its an issue because if you can only be a full node, with an OC3 line, most people will be pool mining without validating what they're mining, and then defacto control remains unavoidably central.  These will grow into large companies, be acquired etc.  And then become defacto policy points and they'd just as well sign contracts and stop mining.  OK so committed transactions can till prevent policy by making transactions opaque to miners, but it is not quite ideal itelf.The other direction is that the minimum transaction value (implied by minimum fee) goes up, and the minimum bandwidth to be a full node stays p2p compatible.  But that implies bitcoin turns into a clearing network.  If its for large transactions its less interesting to users and will either disappear from lack of interest (remain as a whale speculator network?) or be co-opted and shaped by companies with a use for end-of-day clearing transactions - large exchanges, big payment processors.  All user traffic anyway would end up off-chain.  As the off-chain technology does not exist (and we dont know how to do it not for lack of trying), that means the off-chain technology will offer weak semantics: it will have need for central trust in offchain transaction servers, it will have risks of value seizure/account freezes, risks of the transaction server going out of business.  Probably 1 of 3 properties could be fixed, or maybe 2 of 3 (pick any two features conundrum style) if the business even care to try.  Many are "pragmatic" which is an ugly word.And then where is bitcoin?  In this environment a smart contract is not smart.  Smartness requires final settlement which means strong fungibility (cryptographic blinding/hiding, or defacto).  Without those guarantees, disputes will arise, transactions will be undone by court order, and the usual costs will creep back in and we're back to the status quo of credit card transactions, and not transacting without reputation research, reputation rating of the business world, which is where their high costs of existing revocable payment systems come from.  I dont think most people understand this unfortunately. As close as I got was committed tx (aka hidden tx), where you can transact with peer level policy decisions even if 99% of the miners were hostile to your transaction completing.  https://bitcointalk.org/index.php?topic=206303.0  A new idea even triggered by your question is that I think you can reveal without miner censorship of the reveal, which was previously a UTXO compaction limitation.  The reason is peers can broadcast old keys for revealing without fees because they are validatable against previously published data which was already paid for. (The reason to reveal at all, and not re-spend in hidden form, which is supported is that it increases the UTXO set size because only people receiving the payment know what the transactions mean, it is in fact fully private and anonymous against anyone except people in the transaction path.  The limitation is the velocity of money means that there will over time be many people in the path and they all need to see the full history.  The actual payment is very compact as it is just a key allowing the recipient to identify and decrypt/validate the input transactions.)Adam Well a system that aims for security can not rely on self-asserted time, and there is no distributed secure time.  If you start from a false assumption people will systematically abuse your assumption.This is why for optimistic parallel discrete event simulation Lamport clocks were invented (some kind of vector of local clocks based on observed messages, to partially order transactions, and detect out of order relayed messages, without relying on clock sync, the only assumption is the clocks monotonically increase, they dont even have to be remotely accurate to wall-clock) - you want to progress the simulation with optimistically and roll-back when you later discover causality violations.  But rollback is not such a hot idea in bitcoin, then your n-confirmed coins disappear at uncontrollable wall-clock delays.  You do not ideally want to rely on clock accuracy or secure clock convergence protocol in a network with symbil attacks.  Bitcoin may already depend slightly too much on clock convergence.Also in crypto protocols for freshness proofs (anti-replay) people use a relying party generated nonce rather than time.Heh maybe you can find a new 8th use for mining - a loose (+/- 10mins)  sybil resistant clock convergence (same mining argument against byzantine generals).  Maybe thats already happening I never did read how bitcoins internal clock sanity rules work.Adam So people are aware of physical coins with user chosen password security (against the manufacturer and people with unattended access to the stored coins).The simplified explanation basically the user generates password x, proto-coin P=xG, the manufacturer generates pub key Q=yP so the full coin private key is z=x*y mod n.  And manufacturer generates check value B=yG.  Now the user can see xB==Q so he knows his password was used.I gave a summary of the BIP 38 protocol here:https://bitcointalk.org/index.php?topic=311000.msg3342217#msg3342217(basically they have to move some stuff around to incorporate scrypt password stretching, and store a salt on the card for you to prevent scrypt rainbow tables).The BIP itself is confusingly hard to read https://en.bitcoin.it/wiki/BIP_0038 but says the same thing as the above.Now if you dont trust the manufacturer, and really you shouldnt, there remains a problem: they can grind your password becaue they know P = x*G.  (And the fulls scheme includes a modest amount of scrypt KDF stretching to frustrate that).   So that is easy to fix, use a computer generated random password, and print it out, put it in a safety deposit box with your bank.But there is another risk: extortion risk, (or bad batch due to software or other screw up) the manufacturer follows the protocol but prints something else on the card eg y'=E_m(y) where m is a master key he owns.To explain the motivation to protect against extortion: despite reputation risk for manufacturer on discovery: the manufacturer knows your street address and maybe has an idea you're thinking of the long term holding, and somehow knows you are Satoshi (or Winkelvoss or other big bitcoin holder) who is about to stash $100m of bitcoins physically for his grand children.  The investor is distrusting so he doesnt just give them unprotected form to his lawyer, nor due to business continuity risk and doubts about operational security to exante, bitcoin trust etc.   So if he wants to use physical coins  there is a low redemption and reputation risk for the printer to attack the investor because its long term storage.  Maybe they risk their business reputation for this once only low risk of discovery opportunity to attack $100m of bitcoins.Or maybe you're just paranoid and dont trust casascius or bit-card to not screw up their processes, because its a lot of bitcoin, and yet you like the physical coins they produce and their tamper evidence against people with unattended access to the coin storage area.(Obviously the investor can monitor the block chain for his address, the extortion attack comes into play much later, once the coin/card holder tries to redeem and finds the code is invalid and contacts the manufacturer.  Maybe a rogue employee, long fired did it, or the manufacturer can plausibly claim so.  In any case the news gets out, and the coin/card holder receives anonymous email demanding 10% of funds.)Your protection so far is once in a while people get curious or decide to redeem a physical coin, peel off the hologram etc.  If they cant redeem it they're going to be complaining loudly in the forums, so you're fairly sure it hasnt happened.  (The casacius ones cost a bit so redemption is probably less common than the nominal cost bit-card ones).But history of non-complaint is not a direct, personal proof that your physical coin is not from a bad batch, and actually has the private key printed on it.  Maybe they should send you the sticker and you put it on yourself.  However that has other problems - now you can peel stickers off high value coins, and empty them and have a new sticker.  (Of course realistically anyone can print stickers, or do as in the demo of using a hypodermic needle and the right kind of solvent to get the sticker to slide off without damaging it Anyway so using Chaum's cut-and-choose crypto protocol (but done manually with paper (or plastic/metal) wallets) you can fix the extort/bad-batch risk.  Order 128 bit-card.de password protected bit-cards (or cascius coins).  Shuffle them, pull out 64 of them.  Peel the stickers off, check they are valid, throw them away.  Or put 0.01btc on each of the 64 and give them to your children to validate & redeem with smartphone as a fun exercise.Now take the remaining 64 cards scan the addresses, Q1,...Q64 and create a new address Q=Q1+...+Q64 the sum of them.   Because of the permutations even with  copy of Q (which is public on the block chain) if the manufacturer guessed your password (or just the bare private key if you didnt use the BIP38 password extension), he still cant compute your private key because there are C(128,64) > 2^128 permutations.You also have assurance there is a 1/C(128,64) < 2^-128 that none of the cards you used is defective or bad because of the cut-and-choose argument and you verified the other 64.Of course you could use smaller numbers eg C(80,40) > 2^76 but do remember that security of O(2^n) password plus O(2^k) has security O(2^n)+O(2^k) which is much less than O(2^(k+n)) so you cant rely much on the password, even if its really really good, it only adds 1-bit to security.Its a bit complex so you'd have to practice there were no operational screw ups.  Like scratching the QR code off too vigorously when scraping of the sticker glue so you can read the qr.Or much simpler from operational mistakes, just use armory's upcoming k of n (optionally printer secure) paper wallets with no passwords.The bit-card approach has the arguable advantage that an internal threat the bank with your safety deposit  box cant as easily see your private key without creating evidence with the tamper evident sticker.  Its like being able to use the fancy printing technology they have and tamper evidence, but without trusting them due to Chaum's cut and choose, and it might be more durable than paper.  Probably inkjets are not a good plan due to damp bleed.  And you want color fast ink pen for the handwritten printed secure code.Adam
I posted some comments to the bitcoin-dev list (cc the authors).  http://sourceforge.net/mailarchive/message.php?msg_id=31612133Adamps Presumably you sent the authors an email with a link to this bitcointalk topic thread? Need to update this - found a problem a week back, but lost part edited tab:There is a flaw in the logic in the last para.  If Bob is coerced into revealing c" and hence d is recovered (or he is coerced to reveal d directly), then anyone can do n^2 analysis of the n signatures (one real and n-1 forged) pairwise and see that all the forgeries derive from Alice's deterministically with the private key, but Alice's key cant be derived from any, and hence Alice's is correct.  Also Bob's only deterence to doing that at any time without coercion is revealing his private key.  The root cause of the failure is there is no new randomness in the process of forging chameleon hashes by Bob.To the extent its still interesting if we change this much more, I think that might be repairable by having Alice not publish s (send it out of band to Bob, dont commit to it in the spend).  Then the chameleon hash becomes (r,c).  Alice cant find a different s that signs commits to a different message because she doesnt know d.  And Bob can recover k as sR=H(m)G+rcQ => sk=H(m)+rd so k = s^-1(H(m)+rd), and armed with k Bob can create s' for any signature.  Whats more this time those are all symmetric.  With d he can as plausibly recover k from (r,c),s' so Alice's message is indistinguishable as desired.Not sure that overall is ECDSA like enough to be interesting and the schnorr method in https://bitcointalk.org/index.php?topic=318279.msg3417729#msg3417729 seems a lot simpler!Adam Yes I was aware of that one, the original poster had a 2 of 2 sig which might a bit more like what discussed above (partly non-transferable) though it was hard to understand what he meant, and Sergio simplified it to literally non-respendable period - sacrifice a bitcoin to a non-spendable address being hash of bank note serial number.  I had posted something earlier about fixing a coin public key while still being able to prove ownership also https://bitcointalk.org/index.php?topic=232787.5.  That idea was to hold the public key constant and change the base (which is not bitcoin format compatible).  There was also an idea to do something similar in a bitcoin standard way that could be a stable coin serial number (an auxiliary signed message, that the recipient would demand to be present).  The purpose of which is to allow the user to check the coins current ownership status, with respect to a static identifier that is engraved around its rim say.I more like to think about a mostly online world where you want to ideally be able to check the status of a coin.  So the ability to do that without the ability to transfer it back to the blockchain (or with a clear long lock-time) means one issue is taken out of the picture - that if you are not online for a while after receiving the coin, that a previous owner cant spend the bitcoin underneath you on the blockchain.Adam I suppose there are two ways to view that:a) transaction fees should not be implicit (and outputs summing to inputs, including fee should be validated downstream); or b) the signer should state what he is spending (and the downstream should verify it) as you proposed in the above link.Either solution could be fine.  Kind of frustrating the pace of progress on bitcoin main though one can fully appreciate the risks and resource constraints, but mostly the risks.  It is why I proposed the bitcoin-staging idea.  Now all we have to do is coax Warren Togami (formerly fedora distro founder) into taking the mantle.  He already ventured from litecoin into spinning a bitcoin-OMG release (litecoin latest fork with bitcoin parameters reinstated, to give bitcoin users the advantages of litecoin validated fixes).Though something like that is less use to armory as armory is itself on the high value end of the bitcoin scale, and people may not use the fedora like variant on high value.Streamline and practice a system for hard forks?Stall and dont progress and get undertaken by faster progressing alt-coins?Move too fast and make a security mistake.Rock and hard-place.  Hmmm.Adam drazan's visualBTC android offline wallet uses "animated QR codes" which is consistent with what you said about the practical bandwidth requirements.  https://bitcointalk.org/index.php?topic=210371.0The other thing is there's a sanity size cap on a transaction: the bitcoin block size is limited to 1MB for now, and I think its probably the bitcoin developers might have to take countermeasures or non-linear size related fees if people got in the habit of creating individual transactions that use a whole block - that would limits bitcoin to one transaction per 10 minutes.Maybe there's a market to include a PGP code signing key. and a pre-installed armory client in an armory labeled cheap android tablet with the speaker, microphone, bluetooth, wifi, and USB cables cut.  (Or one that could be made cheaper by not even including that hardware).Then you could send it via QR video, armory signed software upgrades;)I think a risk with USB is someone can infect the online wallet via remote internet compromise, infect a USB that gets plugged into it, and from there into the offline wallet.Adam Well there is also the air-gapped optical interface: scanning QR codes. drazvan made an offline QR code scanning wallet using network disabled cheap android wallet (can buy for $50 - $100) including camera.  Then you can make payments.You do need no buffer overflows in the QR code scanner, but other than that...And at least thats code we get to look at, not USB firmware on a motherboard.Adam One work-around is to use scripts directly serialised into the transaction rather than script hash, however that impacts UTXO size, P2SH is good because only the script hash goes on the blockchain which is typically smaller than the script itself.  Note script addresses are intentionally incompatible (different version) with regular addresses, so its not possible to find AH(Q)==AH(script) where Q is a public key and script is a script.Probably the most generic approach is to increase the script hash address to 256-bit hash eg define new AH'(z) = SHA256( SHA256( z ) ).Alternatively work-arounds or security can be achieved by considering the size of the attack O(2^80) + TMTO is large even relating to a bitcoin hashrate.  Users of hashlock as a protocol sub-step should avoid creating pre-computation attacks.  Eg accept hashlocks only on strings they had input in shortly-before (few hours/days which might be needed for confirmation) or during the protocol.Adamps thanks to sipa and gmaxwell for discussion on IRC about this topic, clarifying assumptions for me. Towards reducing the manufacturer and hardware trust of physical coins it occurred to me that you can easily and voluntarily create a non-block-chain-transferable bitcoin.  Its a bit like partially destroying a coin (by spending it to an invalid address) where you create a coin that is not blockchain spendable (by bitcoins rules), but where you can still prove you half-own it, and can hence half-transfer it.  Because you can half-transfer it, it can still be transferred outside of blockchain rules (eg offline or by a group of clients respecting these alternate rules).To summarize existing methods that coins can be sacrificed or made permanently non-transferable: spend the bitcoin to an invalid address, eg to the address 0, or H(digits of pi) or to an address formed from a public key of form H(random).Now back on topic, to create a coin that is partly spendable is analogous:  a 2 of 2 signature with one invalid address.  Or requiring hash preimage of 0, or digits of pi.(I mentioned the idea of having a multisig with one invalid address in the thread about fixed public key coins, also about physical coins, but I did not see this use case at that time.)The partially-transferable coin means you have intentionally created a coin that can not be transferred on the blockchain but the physical ownership can still be demonstrated if you have an electronic coin like firmcoin ( https://bitcointalk.org/index.php?topic=232898.0 ).How does that help physical bitcoin security?  Well it ensures that someone cannot empty a coin of its value undetectably by removing the SD card under the tamper evident sticker, or spending the private key where its hidden under a tamper evident sticker, or trusting the coin manufacturer that the coin is even in there in the first place.  And relative to firmcoin (which allows coins to be unloaded and reloaded, but deletes the private key on unload, you no longer have to trust the manufacturer to do that as much, because even if they have the private key in unloaded state on their computer, they still cant spend it on the block chain).To double spend a coin the attacker would need an extra empty physical coin, or the manufacturer could put the same private key in multiple coins (or the user if the user loaded the private key).  And whats more if multiple people think they own the same coin it can be somewhat obvious in that the coin is spent at locations too far apart to physically move in the time frame.  (And this is a topic of another post, tracking that).If its permanently non-block-chain transferable that creates two non-intercheangeable bitcoins a physical coin that can not be unloaded, and an online bitcoin, and the only way to trade them is to swap them 1 for 1.You might also consider variants where the 2nd element is not invalid but heavily time-locked eg 1 year.   To time-lock the person loading the coin would create a 1 year time-lock and put the time-lock private key in the physical coin.  In this way anyone can validate the address and see it wouldnt have been possible to spend it yet.Or where the 2nd signature allowing online redemption can be spent but only in cooperation with a somewhat-trusted entity, or a quorum of entities or users (k of n of them.)Adam Unless I am misunderstanding something about the seralization, with pay to script hash, you create an address which is the hash of the script, and to claim you have to provide the script and the inputs to make it execute to true.A recurring pattern in cross-chain atomic swaps (litecoin for bitcoin) and atomic colored coin swaps, or fair-coin-toss / fair-roulette, CoinSwap etc like is use of "SIG(A) and SIG(B) and y=H(x)" where one party with-holds x and the other party builds a related transaction that he can see will become payable as a consequence of the counter-party spending the first transaction because both transactions rely on knowing x.One example is (to see what I mean about the two stage, this protocol was by iddo and optimized by myself, I think the y=H(x) idiom is used in multiple earlier protocols also):https://bitcointalk.org/index.php?topic=277048.msg3220019#msg3220019 The problem is hash output approach is only secure up to the birthday attack which is a generic brute-force O(2^80) attack, not bitcoins O(2^128) design target.Lets call the bitcoin address-hash AH(z) = RIPEMD160(SHA256(Q)) where Q is a public key or more generally a bitcoin script.This is because I can use the birthday attack to search for strings s="SIG(A) and y=H(x)" and s'="SIG(B)" such that AH(s)==AH(s').  That can be done in work O(2^80) (and massive storage), or various time memory tradeoffs with lower storage and more work.Sounds expensive but bitcoin right now is doing O(2^62) every 10 minutes or about O(2^78) per year.  Maybe in a few years bitcoin will be doing O(2^80) every 10 minutes and 14nm ultra-dense energy efficient ASIC miners will fill racks of data-centers.Also worth thinking about that there are O(2^64) birthday attacks on SHA1, and no one has probably tried to find analogous attacks on RIPEMD160 but that is not proof that RIPEMD160 is immune.   But note the SHA1 birthday attacks need multi-hash-block inputs, and the inner SHA256 output fits in one SHA1 input block; and SHA1 birthday attacks work by choosing and steering bits; SHA256 output is one-block and random and frustrates that.   Realistically given the constraints therefore even SHA1(SHA256(z)) for this purpose probably retains O(2^80) birthday strength.  Designing hashes immune to that class of multi-block steering attacks is what the SHA3 NIST competition is about...Adam Well so long as we are relying on trusted things, one could have a virgin mined coin and a time-stamp authority using TPM hardware also, which would define just that coin is valid if its virgin (its address is in the coinbase/block that the card can present) and the public key is signed by a certified-as hardware contained key, and the difficulty of the mine is >= difficulty at that time-stamp (to prevent cheaper mining at historic difficulty rates.Thats a looser definition of time-stamping as its not directly blockchain auditable, though it can easily be made indirectly blockchain auditable by including the time-stamping authorities signed master-hash into a bitcoin message in the block chain.  It is looser because doesnt quite adhere to the 21mil limit - its follows bitcoin difficulty but doesnt contribute to it.  To track it strictly you'd need to what gmaxwell said with SPV.Btw I presume people also know about or recall firmcoin https://bitcointalk.org/index.php?topic=232898.0 by Sergio_Demian_Lerner, it also contains a private key, only in that case uses the hardware to sign transactions, and does do things with SPV information.  I presume he made at least a prototype from the initial post photo.About the private key, and addative homomorphism, its not explicitly stated that I saw in the article or thread, but I think what is going on is that the smartphone app has the second half of the coin, to compose the address (as with BIP 38) except thats using ECDH (curve multiply) vs addative homomorphism (analogous effect).  Then the smart phone transfers one half of the key to the other smartphone, and the hardware key container transfers the other half (via hw certified RSA as described in this thread).  The key-half held by the phone cant be changed between transfers, without going via the block chain, so all previous parties who held the coin have enough to spend the coin online, once the coin private key is taken from a card.[EDIT: and the purpose of this is like a poor-mans observer protocol like in Brands and other offline ecash systems: the card cant tell much because what it knows is not correlateable with the public key].What about instead at each transfer the private key (composed of x+y where the public key is Q=xG+yG, x held on card, y held on smart-phone) is resplit as in proactive security at each transfer?So far the design is smartphone and the card never know the full private key z=x+y mod n in one place, unless and until the coin is spent online (by removing it from the card).  To preserve that security assurance, the card can instead create r=random, send RSA(z'=x-r) to the other card, and r to the other phone.  Then the other phone learns y'=y+r and hte other card learns x'=x-r, and the private key and public key remain the same: z=x+y=x'+y' mod n.  But yet the previous smartphone owner does not retain power to spend the coin, even if he physically stole it back from you as he is missing y'.  The recipient smartphone will not consider the payment offline validated unless it can check that x'G+y'G=Q and that x'G is certified by the card.(I used this mechanism in my still not yet posted, really must get around to editing last bit and hitting send, non-TPM model for this).Adam btw I its not so clear in the book, and I reinvented it in my 1995-2005 pre-bitcoin attempts to find a way to deploy a decentalized anonymous ecash, as specified what he is saying is actually not offline respendable, only offline spendable; ie after you've done your spend, before you can respend, you have to deposit the funds in an issuer bank.  (And in bitcoin or zerocoin or the 1999 Ta-Shma & Sander "auditable anonymous electronic cash" paper there is no central bank, but you have to send it to the blockchain/zerocoin mix/shared blackboard respectively, but the dependency is still present).What I figured out is you can offline respend without deposit (without going online) using 0-value coin collection as the initial witness.  Very excited when I figured out that in 2000, and I asked Stefan about it, but it turns out there was a masters thesis on this topic and its mentioned in a footnote somewhere in Brands PhD thesis/book referenced above.Anyway it seems to me you're more interested in offline re-spendability so you need to use that follow-on invention/re-invention.Why I did nothing with this protocol (eg like rush off and implement it with B-money) is I was thinking it was not good enough - its necessarily, like bitcoin, pseudonymous, and publicly linkable, which I considered, and still do consider to be a privacy problem (and in bitcoin whether you believe in privacy or not, a fungibility problem in addition, hence all the debate about zerocoin, coinjoin, mixers and taint, whether you actually even want anonymity or not, those security concerns of fungibility and anonymity are actually orthogonal - you can have fungibility (via coin anonymity) with pseudonymity, or escrowed identity and other variants just fine).  Btw there is a difference between payment confidentiality and pseudonymity/anonymity also, you can have payment confidentiality with or without pseudonymity/escrowed identity pseudonymity/anonymity.  Bitcoin has limited payment confidentiality (you have to work hard with wallet control, which is not implemented, and disciplined fund separation, and mixes/coinjoining is of apparently statistically weak value according to the data analysts who have looked at the network flow statistics.  And thats a problem.  If nothing else we need to make bitcoin payment amounts confidential (eg homomorphic value encryption).  And even payees is extremely invasive if you think about it.  Oh the public can see you bought an ebook from this publisher.  Or you bought a condom pack from this supplier.  etc  Its ridiculously invasive as is, and if your credit card issue or bank account put your statements online like the block chain there would be a public outcry.Also I have to say I am not someone convinced by the offline respendability security argument.  Even if there is a fidelity bond, the problem is offline respendable card is a license to print money, and people will just spend a multiple of the fidelity bond or try to.  One somewhat defense is that if multiple people have offline respenable money flowing around, some of them are going to convert it to online ("deposit" it) and as soon as that happens the double-spend hw hack is blown.  You want to pass a "this key and card series hacked" protocol revocation cert through the network, and switch to the ciphersuite/keyset B while working on deploying card C or firmware upgrade C.Adam I was also thinking of something similar (draft post sitting in another tab), not skimmed your paper yet though.  I think I can get it to work, pseudonymously, somewhat online verification, but with untrusted open spec hardware, that anyone would be invited to produce and load bitcoins onto.  So the design parameters are a bit different.  But I share your excitement for physical electronic non-clonable coins (though I did not try to increase bitcoins privacy model in my idea) and encourage you if you're an operational guy who actually builds things go go for it Specifically about your proposal and question the perf requirements of your card, I think you are not taking advantage of existing known technology.  Read about Stefan Brands observer protocol, chapter 6 (whole book online as pdf in chapters):http://www.credentica.com/the_mit_pressbook.html[EDIT: its long and full of crypto, but read 6.5.1 last para or two; and 6.5.4 shows you what he's thinking this is good for "bearer certificates" = offline transferable pseudonymous ecash.]In short it gives you a way to have a smart card that does something very cheap (like one 256-bit mod mul and 256-bit mod add to compute cx+w mod n (a contribution to the signature)  Because of the inflow/outflow security arguments the card has no visibility into your privacy, its tamper resistance only protects double spending.  Furthermore its offline spend compatible using limited-show protocol, which allows things like retep's comments about good behavior bonds.  You can put the private key for a high value coin (eg $10,000) in the private key certificates in such a way that if a single double spend occurs (which can only happen as a result of hacking a card) a simultaneous equation is released that allows recovery of the $10,000 private key (that is the basis of the limited-show protocol).Brands protocols are defined on Schnorr signatures (or ECSchnorr) and of course bitcoin uses ECDSA.  It might be within the realms of possibility that you could achieve something analogous though DSA is a complexification of Schnorr that does nothing for security and just limits flexibility.  Brands also has an RSA group variant but that doesnt help the compatibility.Adam Catching up the thread from #bitcoin-wizards (plus some fixes and new observations) gmaxwell posed the question if you could make a chameleon hash that is also a valid ECDSA signature (with the added benefit being its a bit more bitcoin integratable).  Curiously it seems that you can and here's how:ECDSA: R=kG, r=R.x, s=k^-1(H(m)+rd) where d is private key Q is public key Q=dG, G is base point, k is random; signature is (r,s).  A verification relation is: sR =? H(m)*G+rQAlice is using the hash, Bob is the owner of the private key able to forge hashed values.Work backwards, choose r' random, compute point R=[r',f(r')] from curve equation f(x), then calculate T=H(m)*G+rQ.  Choose random s, compute R=s^-1*T so that sR=T, then can write sR=H(m)*G+r'Q however now r=R.x and r != r' (because R is some random point) so the r value is inconsistent with point R, adjust for that by finding Q'=cQ such that sR=H(m)*G+rQ', so c=r'/r, ie Q'=r'/rQ (then rQ'=r'Q as required).Now we have a standard completely forged by Alice signature but not on Bobs public key but on a different public key Q' which is a known multiple c=r'/r of Q: Q'=cQ.  This key is mismatched with The ECDSA signature is (r,s), and the chameleon hash is (r,s,c) the secret value which allow Bob to modify the chameleon hash is c (the factor for modifying the public key Q'=cQ). To reveal the hash in event of dispute Alice shows c (Q is anyway computable from r,s; and Q'=cQ).  Then anyone can check r,s is a signature of m with public key Q'=cQ.  The signature is verifiable without revealing c, but meaningless as no one knows who's key Q' corresponds to, not even Bob.To forge different hashes Bob finds m' and Q" such that sR=?H(m')*G+rQ" so he has to find Q" such that H(m)*G+rQ'=H(m')*G+rQ" and as he knows d this can be written [H(m)+dr'/r]*G = [H(m')+dc"]*G where Q"=c"Q.  So solve to find c"=[H(m)-H(m')+dr'/r]/d and therefore Q"=c"Q.  Bob can show (r,s,c") and anyone can check r,s is a signature of m' with public key Q"=c"Q.One comment in the paper Greg referenced in OP is Bob forging reveals his private key in some protocols (which is obviously no good, its more than an inconvenience as it also destroys the non-transferability if his private key leaks people can check which hash the private key can be computed from to know which is the forgery).  In this case as c'=[H(m)-H(m')+dr'/r]/d = [H(m)-H(m')]/d+r'/r so d can be recovered d=[H(m)-H(m')]/(c"-r'/r).However its rather easy to fix this, instead of revealing Bob revealing c" or Alice revealing c they can prove knowledge of a discrete log of Q" or Q' in base Q using... an ECDSA signature with base Q and public key Q" or Q' respectively.However even that does not quite work the same way as the other chameleon hash because Alice can reveal c also to create a strong proof (where a signature involving c but not disclosing c is a weak proof) and it can be seen that it does not solve to d.  While its different thats actually a feature, as if Alice reveals a strong proof, Bob's forgery is not plausible as he cant make strong proofs - if he does it reveals his private key which makes it obvious his messages are forgeries.  (In the paper and the above Schnorr related scheme, in fact even if Alice does reveal her proof, an arbitrator cant tell which message was Alice's and which was Bob's, so in theory Alice could falsely claim to have made one of Bob's forged messages, though it assumed this is not generally a threat). Conversely Bob could be coerced into proving that a forgery he makes is not authentic, by showing c" (instead of a DL proof of knowledge of c") which then allows his private key to be recovered.  However Alice doesnt give Bob c, so Bob cant prove that Alice's message was not his, he could be lieing and actually have c.So overall that seems like a slightly stronger chameleon hash property. So we get the new benefit of no forgery ability for Bob if Alice reveals a strong proof, and yet no ability for Bob in the normal case to transfer proof of what Alice said.  He could reveal weak forgeries, and Alice's message is indistinguishable from them.  He could make a strong forgery (reveal c") which reveals his private key, but that still doesnt prove that Alice's weak forgery was authentic - they could both be Bob's and he could be lieing about not knowing the secret value c (discrete log of Q' wrt to Q).Adam Yes this is very true and a big potential for smart-contracts.  It is possible smart-contracts maybe more important than bitcoin itself.  Its a pre-singularity AI that can automatically and perfectly fairly apriori avoid disputes resulting from reneging, aborting and extorting virtual good exchanges.  Surely its better to mathematically avoid the possibility of a dispute occurring than to pay a lawyer $500+/hr and court fees to try sort it out after the inevitable happens when you rely on reputation (like ebay) and trust etc.Smart-contracts also have huge potential in financial disintermediation, think about the trillions per year spent into the financial intermediaries for doing nothing but writing, and acting as middle man in contracts for financial products, and holding escrow funds, matching orders; with smart-contracts you could write your own structured product, and it does not need escrow and its self-enforcing and executing and survives the financial institution going bankrupt so less systemic risk also.Yes.  I would say abstractly that the more of law and contract law is implemented in mathematically enforced code with pre-emptive impossibility of crimes, the less reliance on courts which are unreliable, biased or subject to political interference, uneven enforcement etc its a huge financial and human capital cost saving and a reduction in the need for and influence of governments in human existence.  And that is good because governments have inherent systemic problems, so less government is better.  All roads lead to Rome Adam Another analogy, its rather similar to why Ian Brown & I wrote the non-transferable PGP signatures draft (1998) and why Ian Goldberg's OTR (off-the-record) encrypted messaging protocol involves non-transferable signatures: you want the protocol to have properties that are aligned with the users interests, and to not have unintended and negative to you side-effects.When you're chatting in IM or email, its probably not your intention to create a legally binding non-repudiable permanent quotable provable record.  Really its not, and there are many people who got burnt for saying off the cuff things, that even ended up in court to their pain, so anything that increases the unintended consequences of making that unintentionally non-repudiable is BAD for the user.Its in your interest to be sure that the party you are talking with is who you think it is, and not an impostor, and if you dont sign messages anyone can pretend to be anyone even with PGP encryption; but if you sign non-repudiable PGP signatures, the person you are talking with can renege on the implied confidentiality of a personal message and transfer that signature and show it to other people against your will, as the signature is verifiable by anyone.  A non-transferable signature evaporates when its shown.  In the non-transferable PGP sense its very simple you sign a random (session) symmetric encryption key, and MAC the message with it, and encrypt the key for the recipient.  Now he can write any message he wants with that MAC key, but he knows he didnt write it himself and so he knows its authentic as you signed it.  k=random, SIG(k), c=MAC(k,m), PKENC(B,k,c) something like that.  OTR is doing something similar but interactive.The Chameleon hash signature has the same kind of designed to be aligned with user's interests design objective.Adam I think you maybe dont understand the concept of smart contracts and anarcho-capltalism (as embodied by crypto-anarchy where crypto means cryptography, and I guess not anarchy also, just an egalitarian society without a force monopoly form of government).  Basically the idea is using new crypto concepts its possible to contract without threat of violence/imprisonment as a disincentive to cheating, because the contracts are atomically self-enforcing.You might find sci-fi "Snow Crash" by Neal Stephenson interesting, and "Cyphernomicon" by Tim May a kind of crypto-anarchist manifesto (online http://www.cypherpunks.to/faq/cyphernomicron/cyphernomicon.html) (not to be confused with "Cryptonomicon" another sci fi work by Neal Stephenson, also fun but long and somewhat related).To quote Wei Dai from his motivation section intro to B-money (one of the main bitcoin precursors):http://www.weidai.com/bmoney.txtI am not sure if Satoshi had crypto-anarchy in mind but folks like Tim May (cypherpunks co-founder/cyphernomicon), most of the cypherpunks, and people working on ecash like myself (Hashcash, distributed mining), Wei Dai (b-money) / Nick Szabo (bitgold), Hal Finney (RPOW), and most of the digicash tech guys (David Chaum long defunct payer anonymous ecash company), zero-knowledge systems guys (pre-Tor privacy networking) and others working on ecash 1995-2005 certainly did have that in mind as their burning motivation.  I am also guessing Chris Odom (open transactions) who seems to enjoy distributed Chaum servers, with voting pool backing, though I cant speak for him.Since that time finally I also see some hope of political progress in the form of the meteoric rise of Rick Falkvinge & the pirate party (and the Libertarian party eg folks like Ron Paul to the extent the LP was slowly rising towards having a chance of being elected), but previously (eg back in 1995 - 2005) it seemed almost the only hope for humanity was a new wave of technological progress led shifts.  In the same way that the internet tends to topple undemocratic states, non-state controlled free money tends weaken the grip of to varying degrees systemically corrupt and difficult to reform governments.[EDIT: btw other than the internet, another example of technological led power shift was the discovery of public key encryption and the ready availability of PGP, and later other communication security/privacy iike OTR, Tor etc.  The fact that many governments tried to control access to and restrict encryption, before giving up, should tell you that you need to be using it: they were worried they can less control a populace with cryptographic free speech and cryptographic freedom of association, even those are legal rights in most countries, cryptographic enforced rights are more strongly held than legal rights, because as we see from Snowden, legal rights arent worth the paper they are written on.  The reason they gave up is it became an untenable position for a notionally free democracy to enforce.  More restrictive regimes tend to have more restrictive crypto usage regulations.]Anyway you can use bitcoin without caring about libertarian politics or its technical adjunct crypto-anarchy eg because its technically cool, or because you dislike governments doing money printing/quantitative easing to the benefit of connected banks, and detriment of individuals, or bank deposit seizures (like in Cyprus) or as a speculative investment, or because its faster and cheaper, or available in all countries, even without banking infrastructure and onwards   And by doing so, in a neutral non-political way, you are also helping build the crypto-anarchic future, in the same way that promoting internet use indirectly helps topple dictators.But I do recommend anyone to read the Cyphernomicon and Snow Crash it might just open your mind to a new view point or even convert you.  [EDIT I guess Assange et al's book "Cypherpunks" is probably on the money though I havent read it myself.]Circling back to why forge a contract, thats not the point: the point is the contracting parties should be free to contract without interference from outside parties (criminal or government) and the point of a chameleon hash based signature (or nearly equivalent designated verifier signature) is that the evidence evaporates because its intentionally non-transferable - they cant renege even if they wanted to.  Designated verifier is a bit different as that means it convinces the recipient (Bob), but neither Alice nor Bob can prove/transfer the signature as either party could forge; with chameleon hash signatures only Bob can forge.  Also bear in mind that other than the fact of shaming a pseudonym (Bob) and tarnishing his reputation that's may not be much of a disincentive, and another model is for the parties to agree on an arbitrator who has 3rd vote in 2 of 3 multisig.  Probably you can use two designated verifier signatures so the the arbitrator could also have forged the contract.Adam Occurs to me it can be even simpler and use EC discrete log for more compact keys (RSA keys are 3072-bit for security equal to 256-bit EC): relabelling t to be k to be more Schnorr like:A=kG+mQ where recipient knows d from dG=Q.now recipient can compute A=k'G+m'Q as he knows k and m, and x: r=k+md mod n (r is same as from Schnorr signature in fact) and then k' = r - m'd = k+(m-m')d mod n.  m would probably be H(msg).(A real schnorr signature is A=kG, r=k+cd, c=H(a,m); verify: rG=?A+cQ).Adam That is what this thread is all about.https://bitcointalk.org/index.php?topic=311000.msg3341985#msg3341985there are three specific proposals in there and it coincidentally references BIP 38 The first and simplest is you dont need to outsource - just create a random 32-bit salt and use scrypt(iter=1), then delete the salt, your smart phone can easily create problems it cant solve then.There is also a different way to outsource the work of redeeming a coin (so you could use a 46-bit salt and outsource to untrusted miners) something useful for litecoin miners to do.Adam Try this explanation: accumulators and ref to outline: https://bitcointalk.org/index.php?topic=175156.45 (sounds like you got this one)the ZKP that a=c^w without revealing c & w: https://bitcointalk.org/index.php?topic=175156.msg2378622#msg2378622 and more detail https://bitcointalk.org/index.php?topic=175156.msg2381470#msg2381470Adam btw a simpler chameleon hash involving conventional crypto can be seen as part of this indistinguishable shortcut hashcash variant based on RSA.  https://bitcointalk.org/index.php?topic=308009.msg3307636#msg3307636Just replace the search for t =? h( s, i, a, m ) mod 2^k (where i is an iterator, s salt, a initial witness, m message to sign) with t=h(m).  Then make random c, chameleon hash a=c^t mod n. Chameleon hash is (c,t=H(m)a).  Bob has p & q so he can compute different t'-th root, for (c',t'=H(m'),a) from c'=a^(1/t') mod n where t'=H(m'), where as Alice can only go in the forward direction choose c, hash mesage to make t, raise c to power of t.  I use it to create a hashcash variant with an indistinguishable short-cut which you could think of as a chamleon proof of work (a chameleon much repeated hash, or a single exercise of the trap door holders private key).I am guessing no one has thought of that particular chameleon hash construct for some reason because people do not usually reach for the esoterics gap DH or bi-linear DH unless they run out of flexibility with conventional hardness assumptions and need the extra degree of freedom.  I could be off base, but this also does not leak the private key, and that seems to be the implication of the paper you referenced with the improved Chameleon hash.Adam
fantastic  Finally someone figured it out for linux.  17.4 Mkey/s on 7870.I was thinking there ought to be a code patch to make it work other than copying the old version amdocl .so (or the windows analog) because surely that library is not that bugged - people are playing games on it etc.  Must be some thing that goes wrong (results inconsistent gpu/cpu) that could be debugged and fixed.  But this is close enough for now.Adam My claim is that brain-wallets are dangerous (private key which is the password) as your virtual "encrypted wallet" is effectively stored on the block chain so anyone can have a go at grinding your password.  GPUs are frighteningly fast at grinding passwords.  Even a 46-bit password can be ground for 50c of compute at bitcoin prices or analogous with litecoin/scrypt.Its not that much better with an encrypted randomly generated private key (BIP 38), if you are worried that its realistic other people will get hold of your encrypted private key.  Once that happens you're in the same boat as brain-wallets against the people who have your encrypted key file/wallet.Of course its better to encrypt than not.But about increasing the security of your private key, choose a parallelizable key derivation and buy yourself a machine with a lot of GPU cores.  (eg Scrypt(iter=1,deleted salt,...) with a deleted 30-bit or 40-bit salt; it will be GPU expensive to decrypt.  This delete salt bits (not a new idea its due to Merkle 1976 and mentioned in Rivest et al's time-lock puzzle paper) its described here:https://bitcointalk.org/index.php?topic=311000.msg3342217#msg3342217Also see the top part of the thread, I proposed a couple of ways to securely outsource computing your KDF so that you can pay 50c and get 100 GPU miners to stretch your key for you, this one is interactive:https://bitcointalk.org/index.php?topic=311000.msg3341985#msg3341985or lots of ASIC miners in the second version which is non-interactive, its a stretched signature verification, and after its spent you need to delete the private key component c to prevent somone who later gets a copy of your private key grinding your password against the now public stretched signature:https://bitcointalk.org/index.php?topic=311000.msg3402287#msg3402287Adam As stated that is a single use password because once a miner has published y=H(salt), Q is revealed and someone in possession of the encrypted private key X=AES(K,x) where K=Scrypt(password) can grind by trying x' values to check if x'G =? Q.To have a multiple address, reusable password the user needs to use BIP 32 private address derivation and store encrypted random chain codes so that Qi=(x+ci)*G is used in place of Q in the above protocol.  ie Q'i=H2(y=H(salt),Qi) and to delete ci after it is spent.Adam OK that makes better sense!  (I thought I must be missing something).So with that clarification I wonder what the benefits if any are of public unlinkable derivation (public key and random encrypted chain code).  - I think one thing is it could provide an infinite look-ahead - ie you dont need to look for keys of iteration i for some number of steps ahead, you could probably search all of them for the parent hierarchical base key, ie just decrypt E( Q, c' ) to find c' and verify to see if its one of yours vs random garbage.- Another property is the sender after the fact doesnt know who he sent to if he doesnt log random c' values.  - Also there's no stored chain code on the sender to be compromised (he can start from scratch fetching the base address from the shop site online and delete it with cookies, web logs etc at end of session)Adamps It wasnt obvious reading BIP 32 and even looking now I dont see mention of the security requirements for handling chain codes.  If thats not frozen it might make sense to put a note saying that somewhere.  I could even take a stab at the edit - looks like its an editable page. except you probably want c' to be random but derived as in BIP 32 like c"=random, ci=MAC(c",Q,i) to avoid maliciously chosen ci values as the recipient is eventually going to sign a tx using x+ci as a private key; seemingly ECDSA is relatively immune to that (from looking at the question briefly) but in the general case for other signature schemes that is a potential opening.Adam So in BIP 32 https://en.bitcoin.it/wiki/BIP_0032 (simplifying) the base private key is x, base public key Q=xG, then public derivation (BIP calls this function CKD) is Qi = m*G+Q where m = MAC(c,Q,i) and c is the public "chain code" (they use MAC HMAC-SHA512).  The recipient can derive key x_i corresponding to Qi as x_i = m+x mod n (because m*G+x*G = (m+x)*G).Now this is good for security but not so good for privacy as any public derived address is linkable as an analyst can just repeat the derivation function and check which key Q it is for.  In theory part of the reason to even use multiple receiving keys at all is to reduce linkability (unless there is an account benefit - one for each sender?)(With private derivation (also specified in BIP 32) conversely here x_i = m'+x where m'=MAC(C,x,i), and Qi=x_i*G so there is no linking but that can only be computed knowing the private key x, so it is not publicly computable, and does not interoperate ie for using public derivation both sender and recipient have to use the public derivation method; and for private derivation the recipient has to generate and send the address to the sender, you cant mix public & private derivation as they are incompatible).It seems to me you could make public derivation unlinkable eg by creating a random secret "chain code" and encrypting it for the recipient.  So c' = random, Qi = c'G+Q, E( Q, c' ).  Where E is public key encryption with Q public key, such as EC elgamal E(Q,c') = (A,B) where k=random, point C=[c',f(c')] where EC is defined by function f, A=C+kQ, B=kG.  Decryption is c'=[A-xB].x.  Now to receive transactions you need a full client and attempt to decrypt c" values and check if c"*Q=?Qi.With out of band coordination the sender and recipient could reduce the amount of full decryption the recipient needs to do.  (Eg he can replace public key encryption function E by AES and a shared key)Adam With Benaloh it true that B can be smaller (than the order of the group of a secure EC DL instance) and actually it has to be smaller if you use decryption, because decryption takes time sqrt(B).  But I dont think mod B solves the inherent problem with less than, because as a generic thought experiment consider B=251 (or n=251 in an EC group of order n using EC discrete log instead of Benaloh), now you have an input 4, you can make the homorphic addition still work while defrauding the network:E(4) = E(127)+E(127)+1 where 1 is the clear text fee (ie the recipent encrypts 1 and checks E(4) =? E(127)+E(127)+E(1)) which is true mod 251 because 127+127+1=255-251=4, and now you have created forged value of n=B=251 coins.Did you see the range proof on this thread?  https://bitcointalk.org/index.php?topic=305791.msg3294618#msg3294618I optimized the application of the Schoenmakers range proof and comes to 1kB-2kB per value (proof size depends on the precision of the coin value, not on the size of n).I avoided Benaloh because its less well used, not EC; and you still need the range proof I argue above, and being mod B anyway restricts your coin value precision to B, and the range proof will be no smaller in Benaloh than normal EC discrete log as a result.Using the Pederson commitment as shown on the other thread allows validation of adding up without revealing the transaction details because there is also an undisclosed x (value private key), ie c1=g^v1*h^x1 and x1 is never disclosed, and yet addition can be checked.Also about your idea there is a way to prove two discrete logs are equal that may allow what you want (havent checked how that works out with Benaloh).Adam I think it maybe simpler (and perhaps equivalent I didnt digest Sergio's post yet maybe we thought of the same thing) to say you only load the hotwallet with timelocked funds, so that they can be spent after the timelock, or undone with a cold wallet key before the timelock.Now unfortunately bitcoin timelock is not a function but a property of a script, so you cant write "sig cold OR ( timelock > +6 AND sig hot ), but never the less you can do things like that indirectly.  (Also locktime doesnt even work properly in that at some point its implementation was changed so that is the users responsibility to send it after the locktime has passed, otherwise nodes discard it.)It seems that the simplest way to implement the OR you can do is load the hot wallet with cold key signe, timelock > +6 AND sig hot (where hot is the hot wallets address).  Then the hot wallet private key can spend the timelocked coins to users addresses.The exchange can post the tx after timelock, but the exchange can also give it to the user now to repost himself, and to show to other users, and create follow-on dependent transactions, eg to spend it before the time lock has passed (the user accepting before locktime has passed is in an analogous situation to 0-confirms - if the coin turns out to be as a result of  a hot-wallet hack, the coin will be undone).How the coin is undone is the exchange monitors transactions, and if it sees something anomalous it releases a set of transactions sweeping all contested hot wallet spends to a cold address.  It can have the cold-signed sweep-to-cold transaction set pre-prepared even so there is no need to access the cold wallet under pressure.Doing that does remove the immediate irredeemability from bitcoins though.  eg if the cold transaction is every hour, then the merchants selling online irredeemable virtual goods may lose their goods if an exchange theft results in their payment being undone.  Ie in the event of theft, the person who most likely loses is the merchant that was abused to cash out.  Sounds a bit like credit card situation.Adam Well firstly the number of combinations of 2 transposed hex chars from a 256-bit (64 hex nibbles) is c(64,2) = 2016.  Secondly you need to swap about half the digits c(64,32)>2^64 for reasonable security and that will be really hard to remember, or not randomly chosen enough.And thirdly for paranoia you probably dont want to do that directly   Because there are algorithms for finding discrete log knowing some of the digits, at least for non-EC discrete log.  So I think it would be safer to make x' the private key x'=H(shuffle(x)) and you publish shuffle(x).In Shrem's case omitting one digit thats even worse - I presume they were in base58, so 44 chars, but actually you can use 128-bit private keys if you use them as a seed, then only 22 base-58 chars.Then if Shrem missed one char there are 22 chars to choose from and each can hold 58 values 22*58=1276 which is laughably grindable.I do like the private key on a physical object though.  Good unless you check out in a plane crash where the ring may get lost.  You want durable material, but I guess the jewelers know about that.If you swap chars in 22 base-58 (128-bit private key) representation its weaker still 231 combinations.Adam One downside of this pattern of not knowing if your password is correct at the high-level is that if you misttype your password, you lose 20c each time.  If you are using the process to offload a 32-bit KDF from your cheap/slow offline wallet computer to your own fast online computer its not a huge deal, just try again as there would be no fees.But if you are offloading a 46-bit key stretch online you could do with either a check character on disk (which makes 57/58 passwords offline grindable, so removes 6-bits from the password strength, or only a 40-bit key stretch for the CPU cost of a 46-bit one).  Or better augment the users password with a check character so that the user is expected to remember.  Remembering a check char doesnt seem so unreasonable if you are trying to remember a 50+ bit password you can probably remember a single char that was machine generated appended to the end.  Computed in such a way as to catch transposed characters, missed chars as well as typos with probability 57/58. Then for 60c per transaction in additional fees you can bump the security of a 50-bit password to 96-bits, with the knowledge that grinding is uneconomical even though your password unstretched is within grinding range.  I bet most people's wallets (whether offline or online), once an attacker has their disk so they become brain-wallet like, could be economically ground currently for amounts of $10k and above say.  Basically I claim, everyone effectively has the brain-wallet "you're either kidding yourself how good your password is, or your password is so good you'll forget it", once you factor in an attacker getting a copy of the (random private key) encrypted deterministic wallet.Adam Yes I'll edit it in place.  (Dangers of late relabeling!)Adam Here's a way to repair the security of the process of the miner claiming the fee for doing the KDF work.Q=xG (x is ECDSA private key, Q is ECDSA public key)A=H2(Q) address is hash of public keyExtended public key (R,S) as R = H2( (y=H(salt)), Q ),  S=salt*GExtended address E=H2(R,S).K=Scrypt(password), encrypted private key X=AESEnc(K,x).User deletes y, Q and A and k-bits of salt.User publishes extended address E and receives funds on it.   When user wants to spend funds (or an attacker who has the users hard drive), he types his password and computes K'=Scrypt(password), and computes a candidate private key x'=AES-Dec(K',X).  The candidate (non-extended) public key is Q'=x'*G.  The user cant tell if this is the right password (right private key x' nor right public key Q') the work to brute force k-bits of salt is much more CPU power than he has.User publishes (R, S, ECDSA(x',tx)); anyone can compute Q' from the signature, and see that the signature is valid, but it takes work to discover if R is derivable from Q'.  Thats the work the miner does as follows: the miner tries to find salt in the defined (advertised) search space such that either H2(H(salt'),Q') == R (because the password is correct) or if the password is wrong the miner finds salt'*Q' == R mod 2^k (ie last k bits match).  If the password is right the miner does not publish salt, only publishes H(salt') and signs with salt as private key to R in order to claim the full reward (40c+20c).  If the password is wrong (miner did not find full match within search space) miner signs with salt' but as H2(H(salt'),Q') != R he can only claim 20c.Unlike before it is not possible for other miners to take the solution and assign the fee to themselves so the KDF miner does not need to be a bitcoin miner (to include his own fee collection into a block), nor does he have to use committed transactions for security.Adam Here's another related idea, not for brain-wallets but for password encrypted random key wallets.  So above I described the symmetric time-lock approach (by deleting some of the salt to instantly create a brute force target).  As a requirement what you would actually like is to be able to type your password, stretch it a little bit (to be not too slow on your not-that-fast single CPU system which could be an offline netbook wallet), send it to miners, have them do the bulk of the KDF work, and then either end up with an invalid transaction signature (if your password was mistyped) or a valid signature which they publish.You would have to pay the miner something for this work eg 60c for 2^46 SHA256 iterations at whatever the bitcoin mining difficulty/reward cost is.  (Its perhaps better with GPU friendly Scrypt to not compete for bitcoin security as GPU capacity is mostly unrelated to bitcoin (ASIC) capacity.)At first I was thinking this would be very hard to arrange, but if you make the address of form H2( H( salt, public-key ) ) and then delete the salt, then the miner can try to find the salt without having to trust the miner.  Until the salt is found the signature is of unkown validity because it is unclear whether or not it matches the public key or is a random forgery.  Once salt is known the signature is cheaply validatable by anyone.The user tries to type their password (or an attacker with a copy of their disk tries to grind their password).  So they convert the password into a key and decrypt the encrypted wallet private key.  However we remove any checksums so all private keys are equally plausible.  The only way to verify the private key is to compute the public key and see if it is correct, however now this is an expensive operation to offload to an untrusted fast machine, or miners generally for a fee.If the user guesses their password wrongly the miner will still collect a smaller fee (20c) for presenting a 45-bit collision with the address, whereas the full fee (40c) is available for a full match with the address.  (This is necessary because there may exist 45-bit collisions on the real address and the others cant tell without redoing the full 46-bit address search).  Note the work is at most 2^46 for the full match because it is a known solution, but could take longer for the 45-bit collision if there is no full match because the password is wrong.The miner may have to do a committed transaction (if he is not mining his own blocks to put the transaction into) with the salt because otherwise the reward could be stolen.  Collecting the KDF fee is a bit insecure otherwise.https://bitcointalk.org/index.php?topic=206303.15In this way you get a stronger KDF than you have hardware for by paying a small KDF fee, with the benefit your password encrypted wallet becomes very expensive to grind.  (Bearing in mind that if someone has your hard drive, all keys are "brain-wallets").Or you could offload the KDF work from an offline wallet (which maybe a cheap slow old netbook) to a beefy less well secured network connected GPU desktop.Bitcoin script doesnt have scrypt as a primitive (could be a useful function to add), so the proof has to involve hashes.You could probably do all of this with existing P2SH without any new features (except for the committed transaction).Not completely elegant but somewhat interesting and maybe leads to some other ideas.(To pay the KDF fees the user needs an unprotected or simple (different) password protected wallet with a smaller balance).  Does not seem to be compatible with deterministic wallets at least as stated above.Adam Thats true as they are independent progress free works then.  But they do need to be time-stamped, which means some coordination (broadcast?) and incentive structure to ensure later miners do not disregard or throw away earlier wins.Were you thinking that the block needs to include the reward proofs as a means to time-stamp?Adam I agree these objectives are important.  I explored this a bit in the past and it seemed to me it could work to have multiple smaller rewards, and multiple parallel winners, where the coinbase for each new block mined referred to the set of previous parallel blocks that are non-conflicting with it.  (There's not actually any need to orphan something just because its different so long as you dont disagree with it and bitcoin doesnt do that, just adopting new mined blocks as the new starting point unless there is conflict).  Then some heuristics for how reward is paid out, how fees are shared out.  I was kind of gratified that it seemed plausible that it should work, as it appears difficult to change anything much about bitcoin without making it worse in some way.  However its clearly less bandwidth efficient and more complicated rules have to be used for reward and fees.Also its relatively easy to reduce variance of hashcash (or other proof of work functions), by the generic approach of using multiple sub-puzzles, however the problem is bitcoin is structured as a first-past-the-post race to find a solution (or first-n past the post with the multiple parallel chain) for the block reward, and if you reduce the variance the faster miner will win disproportionately to its power (eg win 75% of time with 50% of power or that kind of effect) which is bad. (You can see it more clearly with the thought experiment what if the variance is 0, ie the proof of work is deterministic, then clearly the fastest node will win every time.Adam Do you know is there some convenient package, or existing cracking tool that works in reverse - you give it your password, and it tells you how long it would've take it to find it using its heuristics, common words, l33tification, number and symbol combination rules?That might be a good demonstration for would be brain-walleters.  The other problem is even thats misleading because its not specific to them if you took someones online posts, handles, street address, publicly listed stats from social media sites a lot of the apparent entropy is going to evaporate also.  Need to augment the cracker with that info first.Adam Maybe you could do it (inflated variance) but generally I think it doesnt help because the attacker can just grind them all in parallel (multi tasking if necessary) so the uneven work factor will be removed.  You could think of knowledge of which bucket the real key is in as the salt, ie if you make a random salt in PBKDF2 or Scrypt and delete it as I suggested somewhere in the above thread (not a new idea, Rivest et al proposed it in their time-lock puzzle paper) then you can have instant setup, but a lot of work to decrypt.  If you keep the salt then it can be very secure.eg if you have a server with a password hash (or public key/address created with it), but the user has the salt stored and the salt is 128-bits, the server can verify when you get the password right, but the server (nor any hackers who break in and take the password hash db) have no hope what-so-ever to grind the password.  Actually I used that design in oneid.com end-2-end secure auth model in several places.  (I am a crypto consultant to them and a few other companies).The limitation for general use is you can think well the salt is on your disk, what if you have a disk crash.  In which case the salt is so large you'd just as well call it a key and be done.Adam I dont think it matters so much the actual scenario the point is to find ways to improve bitcoin security (and security of data & auth keys generally).  As Ed Felten observed recently, no its not a good idea for judges to start thinking because they can issue subpoenas that internet physics and software architects somehow owes them data in a subpoenable form.  The reason is the design is the same whether you are protecting against theft, blackmail, extortion, corrupt insider, or subpoena - its all the same thing from a technology perspective.https://freedom-to-tinker.com/blog/felten/silk-road-lavabit-and-the-limits-of-crypto/Clearly whatever you think of the war on drugs, and personally I am against drug taking but also against governments in a free country removing individuals freedom to choose, DPR if the charges arent made up apparently tried to have someone assassinated which obviously is very uncool.Anyway sometimes its fun to think about and articulate security problems in a james-bond-esque setting, over the equivalent but boring dining-cryptographers setting etc, but the techniques are the same if its a wealthy individual safe-guarding their money from extortion, or a normal level wealth protecting their bitcoin from theft physical or virtual.Adam Well if they fail to recover the private key eg because i) its 128-bit random, weakly protected with 40-bit password but stashed physically somewhere they dont know about, or ii) its 128-bit random encrypted with > 80-bit password and they have the encrypted key on the disk, or iii) its a brain wallet encrypted with > 80-bit password theyre going to fail via forensics and grinding.That forces them to negotiate with him which wont make them happy, but the US (in)justice system is all about negotiation and little about fair-trial justice, so they should be used to that.  (>95% of cases never get to court, but settled via plea.)  Of course they'll be pissed that they cant get around a technical barrier sitting under their noses, but mathematics dont bend to will.The other very interesting question is whether they know the address.  Is the address obvious?  Does it literally have $80m on one address?  Or is it more like split up into 1000 sized deterministic wallet addresses (addresses indistinguishable from random without the password).Maybe they have evidence from the addresses they do have of transfers to or from other addresses...  That seems rather likely unless some clever and meticulously error free wallet-control was used.If the address where the $80m is stashed, or some of them are identifiable, they are effectively tainted as belonging to DPR / Ulbricht.When he's finally free in 15yrs or whatever DPR maybe richer than Bill Gates, but with a lot of tainted coins.  Satoshi's coins are also tainted (not in a negative way but due to the linking bug).If there are some associates of DPR with control of some of the coins and they start to move, the taint problem could start to lead to some awkward fall out, and reinforce the need for committed-transactions, and change some opinions about taint not being a problem.The public support on the war on some drugs is mixed at best, and there could be a streisand effect and silk road tainted coins might be collectors items selling above par.  ps about taint I think its a bitcoin defect: what you really want is to identify the wallet, but not the coins.  In this way you can demand the wallet holder hand over the keys, but not screw up the 1000s of downstream holders of bits of long-circulated 10th hand change tainted by it.And finally back to the OP topic: blind KDF (which I think is a fantastic new idea:) whether you believe in brain wallets or not (and trust me I do not, I am paranoid and I dont want to forget a password, or I may get hit by a truck) everyone effectively actually HAS a brain wallet whether they realize it or not.  Once some seizes your computer (legally or via physical theft), your 128-bit random coin encrypted with 40-bit entropy password IS a brain-wallet in the hands of the government or other criminal group that has it.  Or if you store it on an online computer that gets malware that steals wallets.So even if your password is self-chosen (bad idea, as Greg says) or computer generated encoded in some mnemonic form, if its got a 40-bit offloadable stretch on it, you could more likely robustly remember the mnemonic form if its only 40-bits or 50-bits (its just as bad from your perspective to lose money from forgetting as from theft!)  Or 88-bit vs 128-bit mnemonic perhaps though the difference is lower.  If its a lot of money maybe you could use 50-bit stretch and pay $5k in offloaded grind to redeem it.One thing you could do is create a paper wallet in a safe or bank vault and a pre-created paper bitcon cheque to your paper wallet address.  This way as soon as you realize your laptop is stolen in a burglary, travel theft, hold-up etc you click the panic button and broadcast the paper-cheque, sending your assets over an air-gap into a bank vault.  Of course the law enforcement/criminals are going to realize this and try to stop you getting near to a keyboard.  You could even have a dead man switch or friend that does this for you.  You are not trusting them much as they cant take your assets, only transfer them with your bitcoin-cheque to your better physically secured air-gapped paper wallet.  Even the encrypted cheque could be published an encrypted form to the block chain, so that the panic word can release the cheque and the cheque cant be seized.  Say one word publicly or that gets out, and the assets are moved.  You could even have multiple encrypted cheques paying to different addresses or chain the process.Adam Is there a BIP or standard for brain-wallets?  Would be interested to read...Adam
Aside from the asymmetric blind proof of work, BIP 38 could be tweaked to avoid this issue.  (Though this approach is not securely sever offloadable).http://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg02948.htmlAdam The risk with brain-wallets (eg BIP 038 with no EC multiply, or even with EC multiply if the manufacturer is not that trustworthy) where the ECSA private key is computed from password is that the passwords can be ground and if successful the funds can be stolen.  So clearly its desirable to use key-stretching for brain-wallets and  this is already done with Scrypt or PBKDF2.  However a limitation with key stretching is it incurs computational load on the client, which maybe a smart-phone or single desktop class machine.  eg 16384 scrypt iterations are suggested in BIP 038, chosen to be fast enough to tolerate in javascript.So it would be desirable to have a secure server offloadable KDF, which means a kind of blindable deterministic proof-of-work.  I described one such proof-of-work in this post (relating to blind-hashcash a different but in hind-sight related topic, where you in addition need a transferable publicly auditable proof of work):An RSA based blindable (secure) work offload function:So if we call that can be use as a blind deterministic password-based proof of work: we could set message = password, or H(password), blind by random factor g^b, and have the server compute blind-pbkdf( password ) for us with some large w that we cant afford to do on our smart-phone or laptop because itd be too slow.The above work function is basically a blinded version of Rivest et al's time-lock puzzle (the time-lock puzzle desires non-parallelizabiiity as the idea is to intentionally encrypt something for the future, where you cant speed it up by using multiple cores.)  The fact that it is non-parallelizable is actually a disadvantage for a blind KDF, it means the speed up is limited to the fastest single-core offload server.   Another simple parallelizable time-lock is proposed in the time-lock paper which is simply to symmetrically encrypt and discard say 40 of the key-bits (this is also the model used by Juels & Brainard for their client-puzzles proof of work which is somewhat hashcash-like but has no public auditability).  However that is not blindable as its not an algebraic form.But it is easy to make an intentionally parallelizable instance by say 128 server cores (16x 8 core servers, or an even more impressive core count GPU server farm), use a smaller e value to take eg 10 minutes on a 1Ghz GPU core (whatever your transaction delay tolerance is), then stretch the password using eg PBKDF2 and 1 iterations, null salt, into 128-values worth of pseudo-random output call those m1..m128.  ie (m1||..||m128)=PBDF2(1,"",password).  Now create 128 cryptographically random (non-deterministic RNG) challenges b1...b128, the ECDSA key is x=m1^e+...+m128^e mod n, which is fast to compute when you know d (before deleting p, q, and d).  Each offload message is r_i = g^b_i*m1 mod n, and the respective unblind u_i=y^b_i mod n.  and the key is k = s1/u1+...+s128/u128 mod n.Unfortunately the user does need to retain g, y & n (or publish them in a hard to censor location, and keep the hash c=H(g,y,n) as a public fingerprint, or embed that in their coin on the block chain, because if the user relied on the offload server to provide g,y,n the server could provide a g,n where g has a small sub-group, allowing the search-space of blinding factor to be greatly reduced.  The few remaining candidate password hashes could then be run through the KDF with the real n.The user can even create a pre-signed message transferring ownership from key Q1=x1*G to new key Q2=x2*G, with bigger work parameters on x2, that it requests the server operator, or trusted party to release when the available compute farm sizes increase and compute becomes cheaper.  If locktime worked properly, you could even broadcast that transaction with a locktime 1 year into the future, and rely on the bitcoin network to automatically update your security margin over time.So a user protecting a $10,000 brain-wallet bitcoin investment might say use $10 worth of GPU time (at amazon prices of $2.10 per 400core tesla GPU hour thats 100,000 fermi core seconds or 714 fermi card seconds.  According to the bitcoin wiki mining comparison an S2070 is 4 tesla cores, and does 750MH so say 187.5MH/tesla second is about 37-bits in entropy compared to PBKDF2 rounds.  If you have a 40-bit entropy password that takes you from at risk of being GPU brain-wallet mined ($80 worth of grinding) to implausibly uneconomical  border line not feasible with any resources for the mid-term.  Of course there are faster (AMD not Nvidia) and cheaper ways to grind than amazon.  Eg bitcoin mining pool payout probably charges a lot less.  Maybe it would be something for CPU & GPU miners to do as an alternative to vanity address mining or  primecoin/litecoin mining.So in summary you in a javascript client, or puny cell processor can create an arbitrarily hard to undo KDF with no practical CPU cost at setup time.  You can offload it securely later to a server, and you are not relying on the server to be around - the information is public (on the blockchain) the "server" is replaceable and stateless, and could even be a bitcoin core feature (pay CPU/GPU miners and other users small fees to help you decrypt your brainwallet).  This is parallelizable so it should be easy to add 40-bits of key-stretching or more that would be really expensive even on a high end PC with top of the line graphics card, to do that from a smart phone.Probably some more things that could be done eg combine with secret sharing so you can detect and eliminate defective work answers, or perhaps find a way to also have signed proof of work that somehow is easily verifiable without introducing a password verification crib.Adam Not that simple to make a signature from that blind offload function, but I think I have a variant that does it, a working blind proof-of-work signature (blind implies privacy preserving offloadable).  (Though its still broken for mining uses for reasons explained below.)n=RSA modulus (prime factors deleted at setup)g=shared generatore=2^2^w-1 a very big odd number y=g^e mod n (generated cheaply at setup, or computable one-off cost afterwards)blind:m=messageb=random odd blinding factorr=g^b*g^h(m)  (broadcast r to miners)work:s=r^((e-1)/2) mod n (expensive because e is big and carm(n) is unknown)unblind:u=(y/g)^(b/2) (unblinding factor)c = s/u = g^{(e-1)/2*h(m)} (as u=g^{b*(e-1)/2})verify:c^2*g^h(m) =? y^h(m)however this still fails multiple criteria for mining:so this blind proof-of-work signature is still broken for proof-of-work uses because there is a precomputation that can be used by user (or equivalently a user in cooperation with a miner if he forgoes the privacy from blinding)).  The miner cant use the short-cut when the user blinds the work.precompute:p=g^{(e-1)}/2short-cut using precompute:c = p^h(m)(also it has progress in its computation).Adam OK so here's the evolution, from the other thread on homomorphic encrypted valueshttps://bitcointalk.org/index.php?topic=305791.msg3277431#msg3277431which seem to work and be a more space efficient than I was expecting (1-2KB per value depending on value precision), with that you could take an input with homomorphic encrypted value, spend it to three outputs two of which also have encrypted values (and one clear text fee for the miner) and prove to the miner in zero-knowledge that the transfer is authorized by the holder of the input value 's private key, and that the inputs add up to the outputs.  So the miner has validated the spend but doesnt know the values.  So thats value privacy.But there is still normal linking of which inputs are linked with which outputs.For comparison if we could use a signature by a trusted party for validation (as say in a central server ecash system), people use blind signatures to break the link.  So Chaum coins work that way, you probably know but for others Chaum blind signature is very simple:RSA key: e, d, n=PQx=randoms=x||h(x)  (coin serial number with some verifiable structure)user blind:b=randomp=b^e*s mod n (send proto-coin to bank)bank signs (normal RSA sig):r=p^d mod n (return to user)user unblind and get (blind signed coin):c = r/b = s^d  (as r/b=p^d/b=(b^e*s)^d/b=b^{ed}*s^d/b=b*s^d/b=s^d)so then a user deposit a coin and get a new coin out which is unlinkable, the bank keeps a double spend db of coin serial numbers s and refuses to accept them twice.so bitcoin distributes the double spend database and uses a proof-of-work with certain required properties instead of a signature.  But if we had a blind proof-of-work, which would be the distributed analog of a blind-signature, we could add the blind-signature style unlinkability to a distributed ecash system like bitcoin.The important property would be that the proof survived the unblinding step.   It would be immediately apparent to the recipient of c=s^d that someone put a lot of work into this, however they nor the miner who did it would be able to tell which mining event it was, because its blind.(Earlier in thread I posted a few proof-of-work signatures, that are signatures that support blinding, but the user has to do the work which is backwards and seemingly fairly useless).Even if we had a Chaum style signature (blind RSA signature) with a proof of work we could make an efficient zerocoin like system (where there is only one coin denomination).  Chaum cant handle multiple denominations because the server doesnt know what it signed.But there are several more advanced forms of blind signatures which allow the user to prove attributes of the protocoin (coin before signing) in zeroknowledge to the server, eg the value of the coin.  Brands can do that with an extended and blind Schnorr signature like mechanism called a restrictive blind signature or private key certificate.  Brands credentials are pretty counter-intuitive but basically say we have a coin that has an attribute being its value v and this attribute is encoded in some way into a coin public key h.  Now Brands you can do:h=encode(attribs,x)  (public key with attributes encoded & private key x)b=random blinding factorh'=blind(h,b)p=zkprove(attribs,h')s=sign(h')c=unblind(s,b)sig-verify(c,h,attribs) =? validso h is a public key that has some private attributes and a private key x.you blind h to form h' (eg multiply it or raise it to a random power by blinding factor b you keep)you create a proof p that still proves the attributes that are in the now blind form of the public key to the server.The server verifies the proof that the coin contains value v eg deducts that from the users account balance (the user is not anonymous at this point).  The server does an unblindable signature, and sends it to the user.User unblinds the signature to get a signed but unlinkable coin c which is a signature of h the public key which encodes the attributes.  Because the signature c of the public key h is not blind anymore no one can tell who's coin it was, even the recipient if you spend the coin, nor the recipient and the bank server in collusion.Brands calls this a restrictive blind signature because the server can see the attributes throgh the blinding (via the zero-knowledge proof) and choose whether it likes the attributes and if the user has enough balance etc before signing, compared to a simple blind signature like chaum where the server does not have any information about the signed value.There are a few papers that describe the Brands protocols I have links to here:http://cypherspace.org/credlib/So anyway any form of blind proof-of-work could be quite interesting as even the simplest form (Chaum, RSA) would be enough to match zerocoin.  Unfortunately the proof-of-work to be amenable for distributed mining has to have a number of specific properties that of the proofs of work only hashcash has (I consider litecoins mining also as hashcash its just using scrypt(1) as the hash function instead of sha256^2).  It has to have no progress, so that its like a random event like a coin toss, no large precomputation optimization and it has to be non-interactive as there is no server to interact with.  So even that seems challenging.To do attributes proven in zero-knowledge to the miners with restrictive blinding likely a lot harder.Adam Here's a pair of offloadable blindable functions:First RSA basedpublic params:[EDITED to relabel x as e, as its more like a large RSA public e exponent]n=pq (primes p & q deleted at setup)g=shared generatore=2^(2^w)-1 ie a big, big numbery=g^e mod n (generated cheaply at setup, or computable one-off cost afterwards)blind:m=messageb=random blinding factorr=g^b*m (broacast r to miners)work:s=r^e mod n (expensive because e is big and carm(n)=(p-1)(q-1)/2 is unknown)unblind:u=y^b (unblinding factor)m^e = s/u (as s/y^b=r^e/g^{be}=g^{be}*m^e/g^{be})Not bad other than the trap-door of n that you cant disprove knowledge of without a trusted person at setup.  Its also non parallelizable, and deterministic cost, so its not a good distributed mining function.  But the cost factor w can be increased fairly arbitrarily without n being bigger than 3072 bits.  Presumably can construct a signature out of this somehow.square root (4.1 from Dwork & Naor) is also blindable:public:prime p (of size relating to w)blind:m=messageb=random blinding factorr=b^2*m (broacast r to miners)work:s=sqrt(r)unblind:m=s/b (as sqrt(r)=sqrt(b^2*m)=b*sqrt(m))There are signature schemes based on square root (assuming RSA groups) but that could work over prime field, if the scheme doesnt need a trap-door, just use a very large prime so that its a big amount of work to compute the square root.  Unfortunately that makes big prime fields as you cant increase the work factor without increasing p.  (And using repeated square root wont work much because there are also n-th root algorithms).Square root doesnt have to be determinstic and the tonelli-shanks square root algorithm even has some randomness (better for distributed mining) however there are there are slower algorithms which do not and there is a precomputation on Tonelli shanks if you have to find multiple square roots.  To make the precomputation too large you have to increase s where p=2^s*q+1 but before it gets to be a useful size another algorithm becomes better Cipolla which has some small randomness but more of the work is deterministic.  The verification cost and RAM usage also increases as the prime size increases, and the difference between cost and verification is not as stark, ie it starts to get quite expensive to verify even for interesting work factors.Adam This is another unpublished signed-hashcash variant with an indistinguishable short-cut I came up with recently based on RSA (n here is the RSA modulus):setup: c=random, s=salt, i=counter, t=random mod 2^k, a=c^t mod n, m=messagerepeat find i such that t =? h( s, i, a, m ) mod 2^kverify: a == c^t mod n and t = h( s, i, a, m ) mod 2^kshortcut: s=salt, v=random, i=plausible random, t = h( s, i, a, m ) mod 2^k, c=v^(1/t) mod nworks because knowing p, q you can efficiently compute arbitrary t-th roots.It has feature parity with Dwork & Naor's (section 4.2 of paper) Fiat-Shamir signature forgery based proof of work (if you want RSA trapdoor for some reason).  But its faster, smaller, and simpler, also supports trap door based on RSA.They could have supported delegation because Fiat-Shamir is an identity based signature scheme, which they dont seem to mention in their use cases, that this approach doesnt.  However then you cant revoke so thats probably why they avoided it.  Also users who do the work can forge identities anyway in their scheme, though they cannot if they have delegated authority.[EDIT: also not blindable/offloadable because the work is in the exposed hash, but RSA has a simpler form of blinding so its a start.]Adam The other important thing I forgot to say is because the issuer doesnt see the hash its more that user can prove they have a forged issuer signature that the user spent a lot of work creating (its the user that does the work not the issuer).  And the user no longer needs to do the blinding and unblinding steps from 1. blinding the message, 2. having the server signing, and then 3. unblinding, he can just forge a weak signature himself at 2, an then there is no need to blind because you never showed it to anyway before.  This rather analogous to the way bitcoin freshly mined coins are fully anonymous, as you dont really need to bind a proof of work to a forged signature to prove work.So I think I am demoting/renaming the above scheme to be called signed-hashcash as while its true that you could blind, then do the forged signature, and then unblind (so it is a blindable signature) thats a waste of time as you're doing the blinding and unblinding all yourself the context of the user forging the signature!We may need a different form of proof of work where the work is blindable / offloadable.  Ie the user can blind a message, publish it so that miners can work on forging a blind-signature on it, and then have the users unblind it in such a way that the proof-of-work survives but in an unlinkable form.Adam There is a slip in that writeup, it is missing one parameter, the public key h0 (with unknown discrete log) that must go in the hash, it should be: H(s,i,a,h0,m).It should be noted that the hashcash backwards compatible version (unlike the non-backwards compatible version) is clearly distinguishable as a forgery, because in a real signature (with knowledge of the discrete log x of h0 where h0=h^x mod n) using the short-cut of knowledge of the discrete log the hash output mod 2^w would be unlikely to be 0, as c=s+H(s,i,a,h0,m) would be computed in a forward direction using knowledge of the discrete log x (of h0 wrt base h) with no iteration, and a and s computed as k=random, a=h^k, r=k+cx.Its easy to avoid forgery distinguisability, just use the not hashcash mining format compatible first form where c=random, r=random, a=h^r*h0^-c, and c=H(s,i,a,h0,m) mod 2^w (ie where the hash output is random but chosen first, and the only way to avoid work is to know the discrete log of h0.  But the fact that the backwards compatible form is distinguishable as a forgery, when h0 is chosen to prove no one knows the discrete log, doesnt matter, because any signatures are forgeries by definition!While true, this does not directly work out so well, as probably intuition should show anyway - how can miners create a forged signature based on a shortened hash with a target output (0 or committed random in the two alternative forms), and then have someone unblind that work and still verify the proof of work.  Hash outputs are non algebraic operations, not amenable to blinding/unblinding.  Here's why:A blind-schnorr signature actually hides the hash and message from the issuer, more details eg in Brands http://cypherspace.org/credlib/brands-technical.pdf (middle page 17), the certificate signature after unblinding looks like (using convention as Brands that variable with ' like c' are unblinded versions and c are the corresponding blinded version of the same variable)c' = H(h0, g^c'*h0^r') So Brands actually takes it one step further and the value that is (blindly) signed is users public key h0.  The issuer never sees h0 during issuing protocol.But what the issuer sees (if this were not forged) figure 7, page 18 of above Brands paper is obsecured c=c'-a2 for random blinding factor a2, and the issuer sends a blind signature r computed using its private key and c, and the user can unblind that as:r'=(r+a3)/a1 mod n using two more random blinding factors a1 and a3.  Now anyone can verify that the certificate signature is valid, it requires knowledge of the discrete log x1 of h1=g1^x1 to compute, which only the issuer knows (h1 is the issuer private key), and yet the neither verifier nor even the verifier and issuer in collusion can link the blind issue value c and blind response r to the unblinded values c' and r'.h0 is the users public key and the user can then demonstrate certified attributes.  (As part of the issuing protocol the user can also optionally disclose some attributes).(Much detail elided thats the bit that matters for this argument).  Now what about blind-hashcash - well if you forge the signature you dont need to talk to the issuer, and in fact the issuer doesnt exist.  So you dont need to blind nor unblind.  Consequently you are left with a moderately hard to forge signature only, which seems more like a curiosity than a useful addition to basic hashcash, because while it successfully binds a hashcash proof-of-work to a blindable-signature there is no need to blind or unblind as the user creates his own (forged) certificate.There does remain some interesting new flexibility in the signature, but it does not seem to admit any new features - eg homomorphic value was already possible with hashcash without binding it to a blindable-signature.ps dont mind me, it helps to clarify thinking to explain things as if to others  I am doing the open source analog of crypto, most people who publish papers do this on a white board and keep it closed until they reach publishable conclusions.  So you are seeing the steps, and failed or interesting but not-useful intermediate steps.  Adam (edited slightly)Its an interesting side effect that the ASIC hashcash backwards compatible variant is actually more convenient because you can test the work separately from the signature.Just check H(s,i,a,m) mod 2^w == 0 as now.  Then optionally you can check the signature could be useful its much simpler to check the hash, and for some aspects of validation the hash alone would be enough.(Step c=s+H(s,i,a,m) mod 2^w is equivalent to check 0=?H(s,i,a,m) then c=s).So far this is a blindable signature, I need to write up (and check) how the Brands blind schnorr signature fits together with blindable-hashcash.Adam That idea was blind-hashcash https://bitcointalk.org/index.php?topic=308009.new#newwhich I found a nice simple and efficient design for, that is backwards compatible even with the exiting hashcash with SHA256 or hashcash wth scrypt(1) CPU/GPU software and FPGA/ASIC hardware.The zerocoin killer status has some questions yet, but its interesting that you can make a distributed signature with no private key via the miners, and that you could blind something to be signed, and have the user unblind it.  Signatures are more malleable because they are based on algebra where as hash functions and symmetric ciphers are bit-level operations in their own right.Adam I had been musing on and off for a while now there ought to be a way to create and use to some useful effect in the bitcoin context a blind proof-of-work.  And that homomorphic value might open the way to some interesting not-forseen features.  This might be it.  With reference to this other thread on homomorphic values:https://bitcointalk.org/index.php?topic=305791.msg3277431#msg3277431at the end I quote an email to Chris Odom where I observe that the pederson commitments that are used for homomorphic values are actually the same encoding as the representation problem of an unblinded brands credential ecash.  So that leads to the question well can we use a blind form of hashcash instead of hashcash mining in bitcoin so that we use can somehow validate coin without seeing its spend history.The morphcoin proofs are using Schnorr /EC Schnorr (ECS) also, so the proof of value & range proofs etc are all compatible with Brands blinding.selective disclosure and other proofs.  (Only his coins are signed).However you might think, but how can you unblind a hash.  You could maybe include a random value in an additional hidden field like g^v*f^r*h^x and the miners challenge is to find a collision involving f, and then you could blind, still prove the coin contains v and adds up, and the right f value, have the miner do its work, the unblind.  That could work however then your coin is associated with a specific mined block reducing the anonymity set.So ideally you need to have the work itself be unblindable hence blind-hashcash.  Turns out you can do that: it has to be signed, and there is no signing entity.  However the trick is as with the outline idea of one of Dwork & Naor's 1992 proof-of-work (4.2)  (see http://hashcash.org/papers/ ) model of constructing a signature forgery as the work.  In our case because we want no central trapdoor (unlike the RSA modulus in zerocoin and Dwork's use of Fiat-Fiege identity scheme).  So we just create a public key that we can prove no one knows.  eg hash2curve digits of pi (or in non EC public key is hash of seed of digits of pi or such things).  Now we cant compute the EC discrete log (prime field discrete log) and everyone can be convinced that no one knows it.  RSA based is bad for trap doors, discrete log-based good.Recall a normal Schnorr signature is x is private key, signature is pair (a,r):k=random, a=h^k, h0=h^x, r=k+cxand the verification relation is to check: h^r=?a*h0^cor equivalently a=?h^r*h0^-c.Now for a forgery we dont know x but never the less we want those verification relations to work.Here's how blind-hashcash works:s=random salt, r=random, c=random mod 2^wcompute a=h^r*h0^-cfind i such that c=?H(s,i,a,m) mod 2^nw is the work factor in bits, i is iterator a string to randomly increase, s is a salt so miner's dont accidentally or intentionally (as DoS) do the same work, a is the initial witness a, h0 is the public key.  m is the message that is signed, in bitcoin thats the coinbase.The explanation is that we normally need to compute c=H(a,m) so we fix that up after the fact by doing the now shortened hash and using finding s,i such that c is still the same as the random value we guessed up front.You can use this blind-hashcash protocol with your choice of hash: double SHA256 as H for bitcoin, or similarly with scrypt with iterator 1.  (Litecoin itself is using hashcash also, its just the hash function is replaced with scrypt(1)).This is nicer than Dwork & Naor's weakened signature forgery based proof of work because the work core does not use big number operations.  (Well you could try to frustrate ASICs with such operations but thats what ppcoin is about, as a basic function you want simplicity).  Also unlike Dwork & Naor function has a trap-door that cant be removed.  Its also faster to verify, more compact, supports blind signatures.  We could allow a trap-door if desired by publishing a public key with an actual private key, or a threshold-held private key so k of n authorities need to collaborate to produce a proof-of-work with a short-cut.  However a short-cut in bitcoin means undo transactions, mint coins, killing the network (difficulty rockets to infinity unless real signatures and doesnt come down) etc.  Also its safer to use a separate signature for short-cuts so that it can be revoked, and detected, and ignored by users who dont trust the authority.  We wont be doing any of that for bitcoin, only mentioned for feature improvement of Dwork & Naor who focused on a central authority model, I tend to focus on eliminating such things!You notice the core work function is slightly incompatible maybe enough to break existing double SHA256 hashcash ASICs.  We can fix that if desired by doing:r=random, s=randomcompute a=h^r*h0^-sfind i such that 0=?H(s,i,a,m) mod 2^non verification compute c=s+H(s,i,a,m)Now the core work function of blind-hashcash is standard hashcash work function and so can reuse existing asm, C, GPU, FPGA and ASICs for normal hashcash with double SHA-256 or scrypt(1) as hash function.Then back to bitcoin applications now we can do blind-hashcash (a blind forged signature for an unknown discrete log public key that incorporates a proof-of-work), we can maybe find a way to use that in place of the certificate authority/ecash bank in brands.  If we can do that we can get the advantage of blind ecash privacy with the lack of central authority and distributed mining that bitcoin has.So if it can be made to work (some questions to check) we would optionally use a homomorphic value input (or a clear input though amounts tend to link if uncommon), blind it, the miners can validate the encrypted amounts add up, even though the coin is blinded (have to check that range-proofs work on blind representation).   Then the miners can make a forged blind signature that looks like they know the discrete log but in reality the forgery is created because we are using a malleable short hash (where you get to try lots of times).We need to encode in an extra attribute of the coin a block counter j.  So then we'd have a blind-coin with and blinding factor b:h0 = (g1^j*g^v*h^x)^bthat then can be blinded and disclose to the miners j, v still prove to the verifier you know x (and b).The main tricky things to work out are the interactiveness as we can have no issuer interaction as there is no issuer, just a distributed forged signature.  Some of the brands mechanisms are resonsive to a server chosen initial witness.  There are some lower round variants but as I recall they were RSA.  Unless the forgery aspect can take care of it - ie e dont need an initial witness, only a self-chosen forged one.  Not sure about that.  And also server knowledge of discrete log of bases g1,g wrt g0 that cant work at least directly in a distributed environmnt.Adam For off-chain purposes it is interesting to note that the morphcoins (hidden homomorphic value coins) have a representation problem format and so are compatible with brands credentials.Brands credentials http://www.cypherspace.org/credlib/ has the links to the Brands book, some technical papers, an implementation in C/openSSL.For an off-chain issuing server like open transactions (paste from email to Chris Odom):In the context of an issuing server, you could use Brands credentials whichare related to what I did (homomorphic value is using some techniques fromSchoenmakers, Pederson, Brands).But if you use Brands credentials as a blind ecash system you can put acleartext or hidden value in an attribute and prove things add up too, butwith the more complex added feature of server blind signatures from theissuer.  As there is a reissue sub-protocol where you can exchange a hiddenvalue coin for a fresh unlinkable (freshly blinded) hidden value coin withthe bank, you dont even need to do homomorphic values.Maybe there are some other things you would like to prove at the transactionserver level without reference to the issuer.  (Eg if there is a motivationfor the issuer to be relatively offline).  A Brands ecash coin once it isunblinded is the same format as the homomorphic value, so I think you coulddo homomorphic tallies on the transaction servers, and the users could auditthe information and validate it against transaction logs and other serversto make sure the balance matches the issued amount at all stages yet withoutbeing able to observe commercially sensitive smart contract amounts.I think I have a bit of implementation work ahead, convert credlib to useEC, add homomorphic value range-proof etc. And that led to a new idea... the topic of a new thread, which might offer finally an outright zerocoin killer.  Feature parity and more CPU & space efficient and no trapdoor.Adam Lets call the homomorphic coin for short morphcoin (and not homocoin;)  Or ringcoin from the additional implication of the below extended protocol.One more proof which allows a ringcoin (ring signature analog of Greg Maxwell's coinjoin) is to create a ring input R=g^v'*h^x' and change C' and then prove that with respect to someone else's coin where it can be publicly audited that C=R*C' (ie the coin adds up) and C' is the change left for the original owner.  The proof you need to make that an acceptable proposition for the original owner (subtracting random amounts from his coin!) is that either R=g^(v'=0)*h^x' OR  RP(C') and RP(R) such that C=R*C') where RP is the range proof construction from parent post.  That proves either you have a coin with 0 value (so its safe to subtract it without someone else's permission or cooperation from their coin) OR that you know the coin private key, so you can subtract whatever you want because you're its owner.  The way the subtraction is proven not to underflow, is you split the coin into two or more outputs range proofs that add up to the original coin, proving you are the owner.  The coin private keys for C is x, for R is x' and C' is x" and x' is random and x"=x-x' mod n, so final validation is simply EC addition of the split proceeds (which could be spent to other person and change address eg.)The OR construction is standard and the same technique as in parent post to allow to prove v_i=0 or v_i=1 (namely you intentionally allow a maximum of one forgery, by adding one degree of freedom to the choice of the challenge).Now a ringcoin is like coinjoin, but more powerful because you dont need the cooperation of the other coins!  That makes sense because you are provably not removing any value from them (as you dont know their private keys).   The additional cost for the "v'=0 OR "clause should be small, about 3 or 4 values (96-128bytes) on top of the two range-proof encrypted values.[EDIT: sorry about that its more like 2x ie 2*(2+3+2m) 5.6kB approximately for the ring coin because you need enough degrees of freedom to forge any 2 of the 3 statements v'=0 or v_i=0 or v_i=1, so you need m independent proofs of knowledge involving R=g^v'*h^x'.]You could in theory mix coinjoin multiple cooperative inputs with ringcoin appropriated inputs in one combined spend however it is only plausible to the extent that an adversary would find it plausible that one person controlled both private keys.Or I suppose you could state that differently that you could combine coinjoin and ringcoin to mix real inputs, real outputs, and additional ring-inputs (0-value inputs for people not in the coinjoin set) all for the same cost of <1+r+o range proofs.  Where i is the number of real inputs, r the number of ring inputs and o is the number of outputs (including change and fees).  Its a bit artificial as it will be thereby obvious the ring inputs are fake (as they are combined into a single multi-ownership proof unless they are used in limited numbers so that its plausible there is one owner for the multiple ring inputs) and the coinjoin inputs are real.  So to do it properly you would need to prove separately < i+r+o range proofs.You can also do coinjoin more efficiently on morphcoin (homomorphic values), which is not so much to do with the homomorphic encrypted values as that multi-sig is compact on schnorr signtures because it supports after-the fact multisig on the addition of the coin private keys.  So coinjoin only (no ringcoin) would cost 1+o range proofs in space, though each input i would have a private message as they built up the single combined rangeproof for their i respective inputs being a combined proof of C1+...+Ci.Generically n of n multisig (with one owner or a single owner with pre-split private key) is compact with schnorr.  Shnorr is a better sig than DSA, NSA reduced its flexibility when they tweaked it to avoid Prof Schnorr's patent.Schnorr also supports efficient threshold signatures (k of n multisig) so you can also do k of n multisig in the space of one signature on the validation side.Again to summarize:Ringcoin is like coinjoin except you the spender choose who to mix your inputs with, and you take 0 from each input, but because the value is homorphically encrypted no one but you can tell that, and you dont need to mix other people's outputs.Ringcoin seems likely to outperform zerocoin in anonymity, certainly in performance (coins can have flexible value unlike zerocoin which is one denomination, or dilutes the anonymity set if you have multiple denominations and 2 output coins are 10x smaller and much CPU cheaper to create and verify).  You can mix with 10 ringcoin inputs per 40kB zerocoin proof, and you dont have the competing anonymity-set issues from having to balance number of denominations (for efficiency of payments eg $1000 coins = 1000x $1 coin payment) against anonymity set (introduce $1, $10, $100, $1000 coins and now you can infer possible sources from handling of coins of required value and so reduces the anonymity-set).  Unlike zerocoin there is no unwanted trapdoor (the n=p*q issue where p, q is a global trap door allowing coin forgery that you cant prove you destroyed).It seems plausible that you might be able to combine ringcoin with zerocoin because coincidentally they also use pederson commitments though in a different group (subgroup prime field orer q, not EC prime-field order n.)  I haven't tried to look at that but if turns out to be possible it might solve their anonymity set/denomination number trade-off issue.Taken together the two factors (single ZC denomination and CPU/storage cost) it seems likely ringcoin could provide better anonymity set size, CPU performance, storage and bandwidth and solid security margin (256-bit EC throughout) in most if not all plausible use-cases.[EDIT: I should clarify that this ringcoin/zerocoin claim is efficiency/practical biased not theory based: with the argument that inefficiency reduces the anonymity set as people wont use it as heavily in its proposed plugin to bitcoin model where zerecoin mixing is optional and explicit on the part of users.  Your anonymity set in that zerocoin deployment is only as large as the number of ZC users between when you put your coins in and when you took them out.  So really it serves as a distributed intentional mix in that deployment model.A hypothetical all zerocoin alt-coin could have full system anonymity set which is appealing an categorically stronger claim,  however the single denomination or anonymity set reductions for multi denomination still impair the theoretical anonymity in practice.  And the zerocoins are CPU an bandwidth expensive.]Adam OK I guess I was thinking about it wrong last night, dependencies dont matter as a' is public so its simple: compute a' from the second verification relation (analogous to computing public key, but this time we know the public key h_i from computing the first verification relation).  Second verification relation a'=?h^r*(h_i/g)^-c".  Now send a new value t=H(a_0',...,a_50').  So thats 3+2m which is 1+(3+20*2+3+3*2)*32=1665 bytes for the m=20,e=3,and a one byte signed offset.  Or 3+2m is 3+51*2=3360byte for full precision e=0, or perhaps 3+(3+30*2)*32 = 2016 byte with a clear text 21-bit exponent, or even (3+27*2)*32=1824byte.  Coins with different public exponents can still be publicly audited (just raise the smaller coin to power 2^abs(e1-e2) which is multiply by 2^abs(e1-e2) in EC form). The exponent wont really need to move except over the multi-year time-frame as bitcoins get smaller.  27 bits is lots of precision giving a decimal precision of 8 digits eg 1c on $1mil or $1 on $100mil etc.  Just about plausible though maybe forcing mix of different precision coins reducing privacy could be 20bits and cleartext exponent at (4+20*2)*32 = 1408bytes.I think 27-bits is a nice precision balance without using the complexity of the encrypted exponent so I'll focus on clear text exponent and 27-bit precision, though the encrypted exponent is a valid optimization at implementation level.Encrypted value coins (of both mantissa only or mantissa and encrypted exponent form) are encrypted UTXO compactable after spends which is bitcoins UTXO compaction model.Clear text fees are still validatable: just publish f=fee and then include g^f*h^0=g^f with the other validation.  Clear text value payments are similarly validatable: just publish v and compute g^v*h^x.  They take the space of one ECS (EC-Schnorr) signature, same as DSA, no range proof required.  What you sign is proof of knowledge of discrete log of h^x.Adam An update on this, actual numbers for the size and its a bit better than thought.  This is from the above Brands reference, algorithm due to Schoenmakers.  Lets call bitcoins precision m=51.  x is a secret value and p commitment to the coins value (like pederson commitment) p = g^v*h^x.  g and h are bases such that the discrete log of h wrt g is unknown (log_g( h ) = y aka g^y = h , y is unknown).  I use exponentiation notation because I prefer it but the same works in EC.v=bitcoin value, bits of v are v0 ... v50 (ie so that v=sum 0..50(2^i*v_i) with v0 is the LSB.Choose m=51 random values in Zn (where n is the order of the group) call x0, ..., x50, and set x=sum 0..50(2^i*x_i) mod n.  Primary commitment is y=g^v*h^x.Now do m=51 auxiliary commitments i=0..50 calculate h_i = g^v_i*h^x_i.Prove for each auxiliary commitment that v_i = 0 or 1 as follows.  If v_i = 0 compute v_i=0 proof and forge v_i=1 proof, in such a way that you can only forge sub-proof, if v_i = 1 compute v_i=1 proof and forge v_i=0 proof.If v_i=0: prove v_i=0: k=random, a=h^k,c=H(a,h_i), c'=random,r=k+c'*x_i mod n.forge v_i=1: r'=random, c"=c-c',a'=h^r'*(h_i/g)^-c",else if v_i=1:forge v_i=0: c'=random,r=random,a=h^r*h_i^-c',c=H(a,h_i)prove v_i=1: k=random,a'=h^k,c"=c-c',r'=k'+c"x_isub-proof message is: (h_i,a,c',r,a',r") 6x 32 byte values.sub-proof verification is the same for v_i = 0 or v_i = 1 (as the verifier must not be able to tell the value of v_i). check a=?h^r*h_i^-c' and a'=?h^r'*(h_i/g)^-c"Finally the verifier also checks y =? prod 0..50 h_i^(2^i) mod n.This works because x=sum 2^i*x_i and v=sum 2^i*v_i.So adding up!  Each value is 32 bytes (for 256-bit values/compressed points and 128-bits of security margin) where m is the mantissa in bits we have presuming for now g, and h are shared parameters.  We have h, plus m times (h_i,a,c',r,a',r") so that is 1+6m=307*32=9824 bytes.  The other values c=H(a,h_i), c"=c-c are computed.However I spent the weekend on size optimization:1. note either r'=random (v_i = 0 case) or r=random (v_i = 1 case) and both are public values, so instead of choosing them randomly we can reuse r'=r (v_i=0 case) or r'=r (v_i=1 case). We cant use a seed and KDF to create r' or r respectively because that would reveal whether v_i = 0 or 1.  So then we get 1+5m=8192 bytes.  2. same argument for c' being random and public, in this case we can use a public seed of all non-dependent values, so then we have 1+4m=6560bytes.3. we can send H(a) and H(a') instead (H truncated to 128-bits according to Schnorr though Brands cautions that one must be careful with this depending on the complexity of the formula proven, so some more things have to be checked) and modify the sub-proof verification step to check H(a)=?H(h^r*h_i^-c') and H(a')=?H(h^r*(h_i/g)^-c").  So then 1+3m=4928bytes4. instead of H(a) from 3 send a (cant do both H(a) and H(a') as we need a) we can compute the public key h_i from the extended schnorr signature/representation proof (analogous to the way you can compute the public key from a DSA signature).  As we're verifying h^r=?a*h_i^-c', we can rearrange and compute h_i=(a*h^-r)^{c'^-1}.  We need to verify h_i values but we can do that with one hash h'=H(p,h_0,...,h_50).  So then we have 1.5+2.5m=4128bytes (or 2+3m=4960 bytes with out optimization 3).Recap at this point the proof message is { a,H(a'),r } or {a,a',r} the other 3 values are r' (copied from r or vice-versa), h is computed from sub proof (v_i=0 proof/forgery) verification relation, and cross checked with sub proof 2 (v_i=1 proof/forgery) verification relation.  c is computed as H(a,h_i) and c' is from the KDF seeded with the non dependent values.There is one more promising optimization which might take it to 3+2m, I need to verify for feasibility of dependencies.Also note one could reduce m eg to 24 bits, and include an exponent e also so that bitcoin value is m^(2^e).  24 bits is enough precision for 1c precision for up to $1.6m.  The exponent can be public (and signed as an auxiliary message to the proof).  Some ambiguity about the range of the value can be achieved by using a unencrypted mantissa offset o=random(-4,4) and from the original mantissa instead encoding: m'=m*2, e'=e+o so the coin value is the same m'^(2^e')==m^(2^e).The exponent itself could even be homomorphically encrypted and proven in a range and compared for equality using an equality proof proving the e1 and e2 values are the same, or differ by the unencrypted offset q1=g^e1*h^z1 and q2=g^e2*h^z2.  To compare offset do a range proof on e1 and e2 as above, and the encrypted range could be eg o/3 (in multiples of 8 bits) and the remaining bits from the public offset.  To verify the offset you'd prove q1 has same e value as q2/g^o.  As we only need to cover 25 bits, a 3-bit range proof for the exponent is enough which is quite small.  recalling (2+3m)*32=352bytes.You could probably set m=20 and e=31/8=4 for 2+3m+2+3e=2432 bytes.Finally some interesting implications arising: you can add coins without owning them (owning them is knowing the private keys xi.)  You can pay someone by adding your coin to their coin and broadcasting (or sending privately) the private key encrypted with their public key.  Anyone can verify publicly that the coin adds up.  You cant oveflow mod n to attacks because there are by definition less than 21mil BTC.  You can randomize a coin by adding a 0-value like g^0*h^x.  How you add is multiply the coins together (or point addition in EC terminology).  The new private key is the addition of the old private key and the new one.  No one not involved can tell if that was a 0-valued red-herring or 1c payment or $100.  The network itself could pre-emptively add the coin without the recipient doing anything and compact them if the encryption is also a proof.  (ie I try to add a new value v to your coin g^v*h^x, which comes with a range proof proving v is positive  and doesnt wrap  mod n and to do that I encrypt with your public encryption key pk (which was signed by the person who sent you the input) the key x and I also prove that the person with the private key corresponding to pk can decrypt to the same value as x (that anyone can verify) proving equality of discrete log.  If you had to you could probably reuse the coin public key for encryption (like sharing a schnorr signature public key and an elgamal public key, need to be careful but there is some analysis).For inputs, you only need to refer to the outputs (and prove knowledge of the private key) without having to do a new range proof, because by definition all bitcoins in existence cant wrap if added up.  You do need fresh range-proofs when you split a coin (to spend part of it).  You can split the private key too (x = x1+x2).To create a coin receiving address you just produce a zero-valued coin and prove knowledge of discrete log wrt h (because g^0*h^x = h^x).  Then people can send you coins without being able to spend them.For mining you prove knowledge of representation g^25*h^x which is efficient (no range proof because 25 is public).  Then you split the coin with range proofs when you spend (or when the mining pool divides up the reward to the pool workers).You maybe no longer need an address (hash of public key) that signs, because the coin private key is a signature key, but you do need an encryption public key.A type of taint mitigation is  spending to some statistical number of addresses a 0 or low value spend together with your real spend.I really need to implement the crypto as a library or stand-alone demo program and double check somethings are not confused but this appears quite practical.The bloat caused may not be so much because there is some privacy gain that may reduce incentive to have multiple addresses or use mixes.Adam Well technically it was achieved by Gentry and a few related improvements on that, however those schemes are extremely far from practical.  Ie megabyte keys, bajillion machine cycles per encrypted operation etc.  Still it was a nice result that proves it is actually possible which was uncertain in the 30+ years since it was posed as a question by Rivest et al.  They even somewhat recently have a library so one could download it and try out how expensive it is.Anyway for homomorphically encrypted coin values you dont need fully homomorphic (ie you dont need both additively homomorphic & multiplicatively homomorphic, additive only is enough).  In fact thats even easy and there are several additively homomorphic encryption systems like elgamal and paillier.  The hard part is efficiently preventing the user adding n the order of the group to their balance for massive scale fraud.Adam A third order thing that could be constructed if the second order boot strap of a synthetic USD traded with BTC worked, and a liquid market in auditable block-chain settled BTC <->synthetic USD could emerge to have auditable decentralized price-discovery of the exchange rate would be to create an alt-coin or coloured coin on the same chain, call that mined virtual USD that references the p2p validatable synthetic USD BTC exchange rate to dynamically control a mining function with the exchange rate as input with the objective of mathematically pegging the alt difficulty to keep the price stable. Of course people would be interested for mining to manipulate the price but arbitrage should ensure that would be a losing proposition.Adam For straight odds bet there's a more efficient protocol with no disconnect nor extortion attacks here:https://bitcointalk.org/index.php?topic=277048.msg3220019#msg3220019maybe the same trick can be applied to the binary option with reference to an external price feed.I think partly its that not many people tried to figure out how to write smart-contracts with bitcoin script, though I would think these are exactly the kinds of things Satoshi designed it for (as a smart-contract implementation with knowledge of what smart-contracts are).  So if you buy into the argument that we can with a bit of work find reasonably efficient contracts for the necessary options - I am still more interested in critique of the financial option/market assumptions.Adam Uh oh I think I made a mistake in reference to the t parameter - its the precision of the range, not the number of most significant bits.  Thats not as nice, but still perhaps just about practical.  (I was incorrectly thinking by changing the value range to 0..2^254-1 and using the step-wise addition cant wraparound argument made in this thread, I had it cracked and I would make the proof smaller, but its actually worse and the wrong direction).I was thinking of the algorithm due to Berry Schoenmakers (reference is unpublished) but Brands describes on p129 of chapter 3.To adapt for that it's back to what I had in mind previously that I was not that happy about the efficiency of.   Crap.  Now that I explained the thing prematurely (before its actually nicely efficient it turns out) here's the explanation of where it got to in the previous version.Choose value x with encrypted value X=xG+yH (or X=g^x*h^y in non EC syntax) and then proof as described in Brands p129 writeup of Schoenmakers with reference to OR proof more easily comprehensible from .   However I temporarily thought t was 2, which would've been sweet.  So the only remaining flexibility with that algorithm is to minimize bitcoin precision its still currently say 40 bits with bitcoin price up to $500 and precision down to 1c US.  A bit close to the limit if the price rises.  Bitcoin actually uses 51 bits (1c precision up to $1m per coin).  Anyway you need to run that proof which involves 40 or 51 subproofs each including one schnorr proof (2x ECDSA sized at least because of the need to prove x_i = 0 or x_i = 1 by the generic OR construct of creating one real ZKP with fairly chose challenge c (eg c=H(params)) and then two forged/simulated ZKP with forged c1 and c2 transcripts where c = c_1+c_2 mod n).  I cant see that working out at under 14kB to 18kB, probably a lot worse.[EDIT the general OR simulation argument should be one forged (c_1 calculated backwards from the simulated protocol run), then c = H(params) and finally c_2 chosen so that c = c_1+c_2 mod n and a real ZKP using c_2).]There was also another unpublished idea by Schoenmaker I mentioned that is more direct but doesnt work in EC and with non-standard p, q choice.  There's also an idea to use number other than 2 in the \alpha = \sum \alpha_i 2^i mod q line by someone.  Lipmaa also has a clever idea involving a generic argument about subset sum "additive combinatorics and discrete logarithm base range protocols" but the advantage over Camenisch previous result is not game changing for our purposes.  There were dozens more; maybe I'll post a fuller list of papers later on.Adam ie once you had a bootstrapped exchange market in BTC with synthetic USD (itself constructed from  BTC denominated synthetic USD futures) the only thing you lose if someone shuts off the conventional exchange is the possibility to do arbitrage between the BTC<->synthetic USD market and the BTC<->USD market?ie the external cash in and cash out would be missing other than bitcoin OTC, but people with synthetic USD positions (still fairly closely tracking USD modulo missed arbitrage price synchronization) would be able to create new positions and liquidate existing positions and spend BTC and synthetic USD.Adam
No I am interested more in whether you can do it without a banking interface, but fully backed in bitcoins with full public auditability..  It seemed to me that this could work with the sequence of bootstrap via existing exchange for price feed, and then p2p self-contained market trading synthetic USD backed and hedged by BTC and BTC denominated options, the trade itself setting its own price.Adam I believe there is a description/footnote/reference from chapter 3 of Brands PhD thesis/MIT press book "rethinking public key infrastructures", which is available for free download.  Its a component of ZK range proofs or ZK less than.http://www.credentica.com/the_mit_pressbook.htmlI'll write it up presently otherwise.  (Going to be AFK for a bit).Adam Aye, aye I'm getting there give me a chance The existing ZKP of less than use proof of a bit being 0 or 1 as a building block (thats why they are inefficient, they do that dozens of times depending on the ranges).  ie to prove x <= 5 = 101b modulo for illustration n=257 (9bit prime) they prove x=000000101b the prove first that x<100b by proving the top 6 bits are 0, and then the prove that xG-4G=01b <= 1 by proving the top 8 bits of xG-4G are 0.Adam Unlike currently you would have to communicate fee explicitly and have it validate as the inputs summing to the output.  (It is shown in my second post where f is communicated while inputs a,b and outputs x (spend) and c (change) are in encrypted form and yet it can be audited that A+B=X+C+fG.Adam So if you assume the existence of a ZK proof of knowledge of x (with syntax x_i is the i'th bit of x starting from 0 for the LSB) then ZKPoK{(x):x_i=0} then we can check two most significant bits are 0 with ZKPoK{(x):x_255=0 and x_254=0} by using it twice.This proof will work on values in some group, we use EC instance of schnorr group (like DSA, same keys, parameters, but simpler signature; DSA is a Schnorr signature variant that offers no advantages over the original AFAIK and many disadvantages that I mentioned in OP).  So we will call the value x where the top two bits must be 0 x_255 = x_254 = 0, and x_{253...x202} are the value in satoshis (same as existing precision) and the remaining values of x_{201..x0} are the private key.xG will be public and is also the coin public key (slightly different from an existing bitcoin address public key).  Now people can verify that encrypted input values (A,B) add up to encrypted output values (X,C) and fee f, where X is encrypted spend, C is encrypted change and f is fee because A=aG, and A+B=X+C+fG because aG+bG=xG+cG+fG.  This enforces that a+b mod n = x+c+f mod n.  The sender must include ZKPoK{(a,b):a_255 = a_254 = 0}.  The sender must also encrypt x and send it to the recipient so that he can prove information about it when he in turn spends it.  f is public because anyone must be able to collect it and attach it to their address via a mining event.When the recipient spends xG he will have to similarly prove that x_255 = x_254 = 0.The reason we need two bits is because n is not a power of two.  Say for simplicity we say n = 250.  Now imagine a=3, b=1, but we have to watch out for fraud by adding n because a+b+n = 254, a+b+n mod n = 4, and x=127,c=126,f=1 so checking only the top bit one could forge value by n as a+b+n = x+c+f mod n   3+1 = 127+126+1 mod 250.  The attacker has increased his value by 250 (minus 1 fee) without using any values with msb != 0.  If we prove top two bits are 0 then we can prevent this attack for up to 3 inputs.  (Because 3*64<250; but not 4 input because 4*64>250).  So for greater than 3 inputs we also prove each intermediate calculation in a 3-ary expression tree also has two msbits=0.  eg where Z(x) is short hand for ZKPoK{(x):x_255=0 and x_254=0}, Z(a),Z(b),Z(c),Z(a+b+c),Z(d),Z(e),Z(f),Z(d+e+f),Z(g),Z(h),Z(i),Z(g+h+i),Z((a+b+c)+(d+e+f)+(g+h+i)) so as mentioned i OP there must be k+log3(k) pair of proofs for k inputs (pair because there is one for x_255=0 and one for x_254).Finally notice that proving knowledge is a kind of signature so in principle you could pay to another persons existing balance, with their approval, rather than transfer control of a value to a new address.  ie say that your recipient already has a balance y and you want to add x to it for them, you disclose x to them (by encrypting it for their public key say) and then they can add it and therefore you can replace coin addresses by existing balances to save on signatures and keys.eg ZKPoK[Y]{(a,b,x,y,c),f:a+b=x+c+f and Z(a) and Z(b) and Z(y)}, E(x)where [Y] indicates an auxiliary signature of some information combined with the PoK.  So the sender is binding his spend of X to say it can be added to existing balance Y (where the sender does not know y).  Now the block validation will allow the recipient to replace his balance with Y'=Y+X=(x+y)G.  As the sender encrypts the value x for the recipient he can now make onwards transfers.Taint mixing is also possible (though not that cheaply at scale) by spending dust to some number of other users as a kind of ring-transfer.  (A ring-signature is a scheme where you can implicate without their permission other signers as possible originators of a signature where the originator wants to hide their identity among possible authors).  So thats a bit like coinjoin but you dont need the active collaboration of the other users.  If the E(values) are offchain (eg direct to the recipient) the recipient may or may not even be able to use the extra value, if he doesnt know the dust value (he can reject it by referring only to his previous balance, but that does not disprove that he could still have it in reserve - its hard to prove a negative.)  We could alternatively attach it to the chain (at some size cost) maybe even encrypted with proof that the recipient could decrypt it.  (It is easy to prove xG=xH where H=yG, y unknown to the prover, so EC Egamal could do a provably decryptable value, in which case the software can incorporate the coin and block the owner from using earlier versions).(dust is a value as now that is considered small, but because x_{202..0} is random by the sender and not computable without DL ability it has to be communicated to the recipient in order to be of value to them).With mining the original coin is of known value 25 bitcoins (and no dust), however the recipient can still spend it securely without people working out his current balance by elimination by keeping dust as change (which he may never spend as it is has truly negligible fractional nano satoshi values.)Adam I have been researching this for a few months on and off, because it seems like an interesting construct in its own right, a different aspect of payment privacy (eg from a user perspective or for auditable but commercially sensitive information if we expect commercial entities to use smart-contracts) but also that other than its obvious direct use it may enable the realization of some features that we have not thought of yet, or perhaps improve the efficiency of zerocoin like ideas (I dont see how yet, but it seems related).The starting point is it is known in the literature that you can do additively homomorphic encryption, and there are also zero-knowldge proofs of less than.  (Proving E(a)+E(b)=E(a+b) is not enough you also have to prove that the attacker did not add n to his balance during the process as the addition is modulo n, the order of the group, not normal arithmetic.)  Its more efficient to do less than a power of 2, but arbitrary values are possible by composition (all values are buildable from power of 2 ranges after all).Both of these (homomorphic add and ZK less than proofs) are based on established conservative crypto assumptions, however the generic ZKP of less than is big (number of digital signature sized proofs proportional to log(v) where v=log2(n/vmax)+1 = log2(n)-log2(vmax)+1, so in bitcoin log2(n) = 256, and vmax depends on the encoding, but there are 21million BTC < 2^51 satoshis.  And potentially also slow as it involves verifying v signatures.Originally I was thinking that will work out to be embarrasingly slow and big (something like zerocoin) so I held of discussing if and until i could find a practical efficient method.  There is also an efficient approximate less than ZKP by Berry Schoenmakers (that he never bothered to write in a paper, natch).  However that seemed to me to be more non-standard assumption based on choosing non standard p & q for the Schnorr group and to also not work over elliptic curves and so not ECDSA (only Schnorr, of which DSA is a variant).However finally I think I saw the missing step that the way bitcoin uses and validates coin values you only need to prove the two most significant bits of each coin is 0, and use an encoding which sets vmax<2^254 (ie increase bitcoin precision from 51 to 254 bits, less significant extra bits beyond the < 2^51 satoshis are the private key.  That gives encoding for 203 bits of security which is greater than the security of ECDSA over P256 which offers security of 128 bits.And so there is then finally a non-embarrassing efficiency way to do it with EC-Schnorr signatures at the cost of only 2 ECS sigs (same cost and size as ECDSA) per input and output where #input < 4 and #output <4.  For #input>3 you nee to also show eg ZKPoK{(a+b+c,d):a+b+c<2^254,d<2^254} and same if #output>3.  So 2k+2log3(k) signatures for k inputs or outputs.  (3 because 2^254*3<n but 2^254*4>n.)Btw there are good reasons to use ECS over ECDSA IMO its still conservative and simpler and anyway DSA is based on it.  Because its simpler (no *k^-1 step) its more flexible and easily supports multiparty (n of n) and even threshold signatures (k of n) which allows multisig in the space of one ECS signature (and without even disclosing the existance of k of n nor how big k or n is even), there are some arguments that ECS is more secure than ECDSA in its assumptions about hash properties.  To do multiparty with ECDSA is a research topic, even multiparty DSA is ridiculously complex and depends on the security of a homomorphic encryption instance big enough to hold temporary results involving powers of q eg the paillier cryptosystem with big keys, and threshold DSA on the even more complex Damgard-Jurik extended Paillier scheme.  The flexibility of ECS makes it more flexible for many things, eg the zero knowledge selective disclosure and blinding certification features of Brands certificates based on the representation problem (which is a kind of generalization of Pederson commitments, which is itself a generalization of schnorr).  There are a huge number of things you can do with Brands certificates towards smart contracts that preserve the privacy of the attributes of a person relying on smart contract by using ZK proofs of boolean formulae etc.  Also for the cost of an extra signature per value you can even have unconditional value privacy.  (Ie a hypothetical all powerful entity able to perform discrete log with minimal effort still cannot tell how much money  you paid).  This is because like OTP all possible values are equally possible, eg with a pederson commitment two base points G, H then xG+yH there are n possible solutions for all possible values of x and y (where x is a secret key and y is a value you prove things about).  The powerful adversary can just solve and find all the possibilities but your public  recorded ZKPs do not show which x value you knew, nor which y was the value you transferred.Will post more crypto level details and perhaps an openSSL based implementation presently.Adam HiIt occurred to me that one should be able to bootstrap a synthetic USD (or EUR etc) based only on an authenticated feed for the BTCUSD exchange rate (maybe validated against public order book, ideally with p2p blockchain settlement so you know MtGox et al aren't hacked or manipulating the rate) using conventional synthetic commodity financial mechanisms.How synthetic commodities work is that it is possible to create eg synthetic gold or synthetic stock index without buying the underlying asset, with a matched option pair with exercise price at the current asset price: sell a call option to give away the rights to any upside, and use the proceeds to buy a put option for downside insurance (plus some commission/spread cost).  There are two types of options: american options (which can be exercised at anytime before expiry) and european options (which can only be exercised on the maturity date).  Other potential building blocks include CFDs (contract for difference).  Synthetic commodities work and are used in the financial world, the cost of creating them over buying the underlying asset is small provided there is a deep, liquid market in the options, and similarly they can track the underlying price closely with the same assumptions.  Now options have expiry dates, however the synthetic can be made ongoing by replacing expired, or exercised (in your disfavor) call options.  You do not actually lose in these events.  Similarly you can sell your synthetic back to bitcoin early at a small cost by reselling the put you bought (if not execised in as part of the sale) and buying back the call you sold.Anyway read about how synthetic assets are created it in a financial reference tutorial or whatever.The point for bitcoin is a liquid market in BTC denominated BTCUSD options you can hold BTC, and spend a few basis points/year to convert that into a synthetic USD holding (with enough option liquidity).Such a liquid options market would have a second beneficial value for BTC in that people argue it would stabilize the BTCUSD exchange rate.I cant imagine I'm the first to think of this, and I suspect bitshare and maybe mastercoin may be saying the same thing, however their financial terminology was non-standard to the point I couldnt understand if this is what they were saying for sure or not.I would think smart-contracts can be written for the necessary options, so that the whole affair is digital and block chain settled and hence publicly auditable.  We do need more auditable block chain settled exchanges so that we can audit the BTCUSD order book directly, but that is something that needs to happen anyway.Once you have a BTC backed synthetic USD with smart-contract options, you can do atomic trades for BTC.  Perhaps once it boot straps a bit you dont even need BTCUSD exchanges, you can p2p atomically and publicly auditably swap BTC for synthetic USD which trade itself can auditably define the exchange rate.Of course I welcome any real financial wizards (or other) comments.Adam Got it.  So we have a slightly improved solution, except that its vulnerable to mutable signatures until those are fixed.Adam And now I understand iddo's previous comment on this type of attack earlier in this thread:But that sounds fragile per my comment above: what if the user is using deterministic wallet, and/or does reuse keys.  Many users do reuse keys as a matter of practice - eg tipjar addresses, static published addresses, vanity addresses etc.  Does that mean that step 8 allows an hostile gambler to use Bob as a blind signature oracle, where he'll sign anything at all?Adam OK with my now more up to date understanding of locktime (thanks gmaxwell) I agree with your summary.  Its a pity that locktime doesnt work as originally defined as I think it slightly simpler, and also it would've been nice if lock time was a boolean function (so one could directly write things like X OP_OR lock(time) ) but it seems you can fix it (in this case at least) with an additional round of signatures. However I have a bit of a concern about this step:If Bob is not paying attention cant Alice trick him into signing over his life savings there?  Signing a blank cheque to someone else's address without knowing whats in it.  How does Bob know its not spending one of his own bitcoins (eg managed by a different client, but with the same private key imported)?  Does the serialization make that obvious or partly disclosable?  Otherwise that seems quite unsafe.Adam I was presuming locktime means just what you said: you broadcast the time-locked transaction and the message order is determined then in terms of double spends, but it is not placed in blocks for mining, but rather held until locktime criteria are met.  (And it may or may not be updatable depending on the value of the latest sequence number).I'm taking it that was changed, temporarily.  Is there a description of what actually is currently working?  I looked around in the wiki and forum posts referred by iddo, but I do not see it.Adam I think iddo made a mistake in his his write up in presuming the TxA is privately communicated to Bob.  That is not the case: Bob must wait until he sees TxA arrive the broadcast channel before revealing B (simultaneously with cashing Alices $1 bet) to start the game.Correct, and thats what the protocol requires (though I think iddo's variant does not).No the protocol is that it happens in this sequence: 0. player A gives player B A2=H(A1), 1. $2 TxB bet broadcast, 2. $1 TxA play broadcast, 3. player B cashes TxA simultaneously revealing B1, 4. player A if she won (a+b<=2 && a xor b) can now cash TxB which relies on revealing A1, 5. player A if she lost should still reveal A1 to Bob so he can cancel early without waiting for the time lock.Refer to https://bitcointalk.org/index.php?topic=277048.20There is no extortion attack.  Mutating TxA or TxB also does not allow any reneging, nor extortion beyond the normal race or 51% attacks that apply to all bitcoin transactions.  I know this fair bet is a long running problem which have not quite worked because in most variants the loser has to do some thing active to admit he lost, and so he can hostile abort.  But I think I have all eventualities covered via the pay conditional 2x first trick as it reverses the burden so only the winner has to do something active.  Take a look tell me if you see a flaw.Alice and Bob need to connect to the network using ToR if they are doing 0-commitment games or using some other mechanism to be assured that the other player is not controlling their network or racing them to gain an edge.  (eg maintain connections to a sufficiently large number of large miners to see if they received the transaction).Note with the introduction of LOCK(txid) I described earlier in this thread I believe you could make this game such that even a successful race/network attack can not take your bet without starting the game, because it would make the bet transactions atomic with each other.  But they could still play normally, but try to abort if they lost by network attack (as described above - try to ensure only you get the payment).quibble you mean n-s; s-n would be negative, and ECDSA signature verification is defined to verify r and s are in [1,n-1].  (And n-s works because r=[-kG]x = [kG]x ie the x coordinate is the same for k and -k because of the x-axis symmetry of elliptic curves, and s = k^-1(H(m)+rd) where d is the private scalar from Q=dG, and (-k)^-1 = -k^-1, so hence swapping s for -s, -s = n-s.Adam [EDIT: ignore this message it is assuming the old locktime semantics and so is incorrect] There are mistakes in this version, with reference to my original ref https://bitcointalk.org/index.php?topic=277048.20 specificallyStep 3 is redundant Bob reveals it in step 4 so there is no need to privately send B2 to Alice.Bob must broadcast this bet already at this stage.Agreed except neither OP_XOR nor OP_MOD are enabled.  Can be done probably most simply with (C syntax) !(a && b)||(a||b) (aka infix bitscript OP_NOT(a OP_BOOLAND b) OP_BOOLAND (a OP_BOOLOR b)) or alternatively if (a+b<=2 && a!=b) { ... } (aka a OP_ADD b OP_LESTHANOREQUAL(2) OP_BOOLAND a OP_NUMNOTEQUAL b). btw you see what I mean about using the script notation - even with infix it is terrible!Not necessary Bob signs his own bet transaction?No Bob should broadcast his bet transaction before asking alice to do anything (other than provide A2=SHA1(A1) without disclosing A1.)Correct but Alice must broadcast this transaction now without requiring anything further from Bob.I think you have put an extra redundant interlock in here which is not stated in 7.  Bob has to reveal B to Alice and the world, simply to start the game (cash the bet transaction from Alice).Unless you have OP_BOOLXOR (logical xor ^^ in C syntax, which C lacks) I dont think it helps as you can do i with != (aka OP_NUMNOTEQUAL) if you anyway have to check a+b<=2.Adam Not really ("annoy some government just because you can"), and in fact it could easily be counter-productive to pick a PR/media fight, so I am actually quite circumspect and deliberate, though I do find the stuff Jon Matonis writes pretty amusing.  You may remember Satoshi was annoyed that people were being encouraged to donate to wikileaks - he thought it was too early, though presumably he was not against the principle of political donation, just the premature risk.   Unlike some people I respect such logic , there is a time as well as a principle.My comment was that government policies are usually on the wrong side of  progress and history.  Falkvinge wrote some good articles about such things.  In hindsight society can see the wrongness of previous misconceptions, bigotries, injustices etc. but its interesting to understand that analogous things are happening now, which in the future will equally be seen as short-sighted, archaic and stupid thinking.   Sometimes such things are not obvious to see as our thinking is coloured by language, PR, conventions etc.  I think historically government has been on the wrong side of most such problems.  Falkvinge suggets we're currently in one such rut around copyright policy, the concept that society could or should regulate copying of bitstrings or which bit strings are allowed.  Or the compatibility of such regulation with free speech, censorship free communication, privacy of communication, freedom of association and right to use encryption in the pursuit of such rights.Adam Here's a better example, more directly related to the fair randomness aspect.  Fair lotteries for resources.  its relatively common for there to be economic situations where competing parties want a scarce resource, and other than an auction, sometimes lotteries are used (the bidding company pays some amount of money to get the frequency allocation, and the lottery winner gets the frequency).  Maybe there is a bid cost and a completion cost for the winning bidder various permutations possible.  Similarly lotteries have been used for domain management contract allocation.  These situations can be potentially high value so it can be important that the contract is demonstrably fair, which means without the need to trust any third parties, and that area is one of the main strengths of smart contracts is to reduce the reliance on trusted third parties.  It removes intermediary fees, bribery, fraud, hostile contract breaking and so forth.Adam Maybe there would be a structured (financial) product use case where different payouts are made depending on the outcome.  eg One I bought and both made and lost some money on: for a period of 3 years I am paid 9% interest on my capital, if 4 stock indexes remain above 50% of their opening value (nikkei, ftse etc).  If any index falls below 50% I end up owning that index.  As I recall it was also 50% capital guaranteed (I lose no more than 50% of my capital).These products are sometimes made by investing 95% of the capital that compounds back up to 100% over the term to provide the capital guarantee, and then using the 5% to buy some leveraged derivatives to construct the potential upside.  But I think the above one needs a matching insurance buyer (they are buying insurance that the indices they invested in do not fall by more than 50%).  So for that kind of thing you need a collection of conditional, dependent (cant renege on your part after the other party made their commitment) and time limited contracts.Smart contracts should allow such things without paying credit suisse et al 5% of capital upfront to write the contract.Hence the analogous need to interlock the contract clauses relating to different events where different party has to pay out at various times.There's no actual randomness in the above contract other than the markets.  Some of them might be really close to random events.  Maybe there is a case to make for products where you get to make a bet on some provably random element eg bet on 2 of 4 indices fairly chosen, just to spice up the financial product.Anyway it doesnt seem to me that you could likely create a language that allows the above to be built but prevents a game of dice.  Maybe countries that allow financial gambling with OPM (other people's money) but not fair dice games can content themselves by making those bitstrings illegal for users in their jurisdiction.  We know how well that works, but if they say so.(The general idea that iddo started with to require successive disclosures to proceed to the next protocol step is related to the interlock protocol).Adam Oops, fixed.Correct.  I dont think anything new needs to be enabled if this is up to date https://en.bitcoin.it/wiki/Script though it would be nicer to have OP_MOD enabled otherwise you have to implement OP_MOD using OP_LESSTHAN and OP_SUB and OP_IF / OP_ELSE (which is very easy but seems kind of stupid).  (if a > n or b > n then reject; endif; if a+b > n then if a+b-n > n/2 then true else if a+b >n1 then true; endif; endif VS if a+b mod n>n/2).I do think it would be simple and useful to be able to be able to enforce an ordering on related transactions.  eg say LOCK(txid) meaning this transaction is not to be considered valid until the transaction with that txid has been accepted by the node.  That would be enough to prevent one of the network attacks on 0-confirmation games (that an opponent B cannot hack the other parties network to delete unfavorable messages - eg the relay of B's losing transaction, or the collection of A's win message (causing A to lose by default)).Notation was troubling me.  You may notice even my notation changed between the two posts.One problem is the literal script notation is terrible: reverse polish, stack language; long strings for standard operations like +, <.  Is there any mathematical version of that notation eg using C operators.  I was thinking maybe we could define one by applying mathematical PoK notation.  PoK[m]{(x):y=H(x) ^ SIG(A)} meaning a signature on message m with secret x, such that y = H(x) and a signature from public key A.  Or simply an infix rendering of the stack language using C syntax operators and functional notation? Someone else posted some examples in the thread now I see.Not my area but I strongly think bitcoin foundation should obtain some international legal advice on the best jurisdiction for the legal entity to be domiciled in.Adam OK here's a better, and still round efficient, algorithm that doesnt require any new script features.  Same idea as before player B pays player A $2 with probability 0.5 and then player A pays player B $1 (with probability 1) in such a way that collecting the $1 requires player B to accept the game (reveal enough information to allow player A to claim the $2 with probability 0.5).But we can do it without requiring atomic simultaneous scripts: just broadcast the $2 first, I think no bitcoin changes required. 1: A->B private msg: h(a)2. B broadcast msg: $2,{(a'=h(a) ^ b'=h(b) ^ ((a+b>n/2 ^ SIG(A)) v (a+b<=n/2 ^ SIG(B)))) v LOCK(time) ^ SIG(B)}3. A broadcast msg: $1,{(b'=h(b)^SIG(B)) v (LOCK(time) ^ SIG(A))}4. B broadcast msg: b,SIG(B) 5. IF a+b>n/2 THEN       A broadcast msg: a,b,SIG(A)ELSE       A->B private msg: a       B broadcast msg: a,b,SIG(B)So in words: 1. A sends B h(a), 2. B broadcasts a $2 payment payable to A if A can also show a such that a'=h(a) and show b st b'=h(b) (and of course provide a signature).  3. A broadcasts a payment of $1 payable to B if B can also show b such that b'=h(b).4. B cashes A's $1 payment from step 3, and therefore has to broadcast b, SIG(B), so accepting the game. 5. Now A knows b so he can find out if he won.  IF A won (a+b>n) THEN he can broadcast a,b,SIG(A) claiming B's $2 payment ELSE if B won, A should send B privately the value a, then B can reclaim his bet without waiting for the lock time.There is no financial advantage for aborting as the game only starts proper after step 4 where B claims A's $1 conditional payment accepting the game.  A needs no further input from B to decide if he won or not, so if B aborts A can still claim his win.  If A aborts he loses by default (whether or not he actually would have won had a revealed a).A should reveal a whether or not he wins because it avoids stalling the game waiting for LOCK(time), presuming that B will want to know if he won or not before playing another round.Adam Well I mean just the value (not the specific coin or payment) and value 2v all supplied by B.  The observation is that a game with two inputs: 1.  v from A and 2. v from B where fairly either A or B claims 2v (double or quits) is the same financial and probability outcome as an alternative game where: 1 A conditionally pays B v, but 2. B can only claim the payment on condition (proven atomically to the block chain) that he fairly offered A a 50:50 chance at receiving 2v.  If A wins the bet, he gets 2v-v=v (B's 2v minus A's earlier paid v); if B wins the bet he keeps the v A offered upfront, as A lost (the preimage didnt meet the requirements).  Its a convenient alternative game structure because then there is no extortion attack as the loser doesnt need to send a message to reveal the fact that he lost.Thats unfortunate.  I suppose generally its the output to a chosen address that matters.  (Inputs being subject to change, unless there is an extra transaction specially to make a 0 change payment).  I guess its still interesting in the sense that it would be good to look at the alternative candidate mechanisms that can most simply, immediately and fairly construct games for addition to the script language.The atomicity is probably not present either, ie you want the transaction "signature" claiming A's payment to itself atomically with that create a new transaction from B.  (Then I dont think there is any timing attack, I didnt fully think this atomicity requirement through in the original post).(If the two transactions are atomic, in fact B could safely use the proceeds of claiming A's payment as one of the inputs to his own 2v payment, meaning that he is not fronting an extra v.)Well it is true that with 0-confirmations bitcoin in general degrade to a network race rather than a mining race.  (Each party has an interest to double-spend his losing bets by having more and lower latency connections to hosts with high mining power; and simultaneously frustrating (eg DoS) his gambling opponent).I think a delay of more than a few seconds would kill the application.  People would sooner pay small house odds than wait minutes, which even litecoin parameters require.Adam Alright how about this for another tack.1. A broadcast msg: INPUT(v),h(a), require-script(INPUT(2v),b,SIG(b),TEST(a+b mod n>n/2))2. B->A private broadcast msg: INPUT(2v),b,SIG(B,b),TEST(a+b mod n>n/2)3. [optional B broadcast msg: INPUT(2v),b,SIG(B,b)]basically A broadcasts value v BTC, claimable by anyone who can satisfy the acceptance script.  The acceptance script has to provide a bitcoin transaction with input of 2v BTC, a challenge random value b, and a nested script that this payment must be made if a+b mod n>n/2.So its like A offers the game round by broadcasting the payment to game script.  B claims the game payment but only by himself committing to 2x the value and a game with a matching script game.Now there is definitionally no abort possibility because the loser has paid his losing fees up front, and the winner has the proof and aligned incentive to broadcast the claiming transaction.[EDIT: actually I guess message 2 also has to be public, or input 2v is at risk of being double-spent.  So then message 2 needs a moderate lock-time so that if A loses, B can reclaim.]The value 2v is not actually broadcast unless A wins it, and so does not tie up the input 2v unless accompanied by preimage b.  So a hostile A cannot achieve a DoS by broadcasting B's private message 2 if A lost.There would not actually have to be a locktime on message 1 as the user can play himself and always win knowing a, and there being no house fee.Can bitcoin scripts do the above protocol?Adam
The clunkier method would only be used in the hostile "loser aborted" dispute connect scenario.  Normally as I mentioned you can expect message 3 to always be sent.  These messages can be sent offline privately between the two players.  In normal play (non-hacked client) a single message can be broadcast to the network containing (a,b,c), and this is the normal bitcoin model of a first payment wins.What the BUT clause allows is to claim the win if the loser intentionally disconnects.  To avoid problems that you mention, as you also suggest, probably you would want to place a lock-time on the "loser aborted" win proceeds transaction.  The point is I have the proof he aborted in the form of his commitment and the absence of his reveal.  Now if the messages are offline there is one further permutation which is a false "loser aborted" (where party A did receive message 3 but falsely claims not to have) however that is easily remedied by the loser broadcasting message 3.So I suppose one way of looking at this is it would be simpler if there were a built in mechanism to handle or encode an ABORT outcome to scripts.I think the point is if there is no method to game the system the user other than DoS, time-wasting etc has no reason to attempt it, and the more efficient protocol can be used.Adam Too slow, dice users dont want to wait 10minutes to find out if they won.That is the desirable function (fair script RNG function), but its hard to get.  I think my proposal works and is faster, but yes it does fail the no bitcoin changes preferability you mention.  I think its central enough a use-case that maybe there is an argument for adding it anyway.In terms of how close you can get with existing bitcoin scripts you can play around with lock-time but I dont see how you can solve both the loser aborts problem AND the extortion problem without entangling with a higher valued good behavior incentive as you proposed.Adam So setup as before using your example, first both parties create a multi-input coin with a game script plus a lock-time refund in case of failure (1 btc each in and 1btc each change and payment after lock-time).Then normal interactive proof is A->B: witness (w), B->A: challenge (c), A->B response (r)1. A->B: w=H(a), SIG(A,w) for random a2. B->A: c=H(b,w,SIG(A,w)),SIG(B,c) for random b[optional 3. A->B: r=a TEST(a+b mod n > n/2)]If we say that the signature 2. is valid already and B can claim the winnings just by providing c of the given form and his signature (which verification goes in the original script).  This default win script clause is chosen so it proves who went first because the challenge includes the witness (which includes a signature from A), and the challenge is itself signed by B.Then we allow an override (higher priority OR or a separable BUT clause) which says A can claim he won instead if he can show that is the case (eg a+b mod n > n/2).This overcomes the problem that A coming last has an incentive to abort if he loses and wait for the lock-time to return his funds.  If he aborts he already lost.  As he lost his incentive to cheat, he may instead (non-hacked game clients) could actually reveal preimage a even if he lost.  If A does not reveal losing preimages B may elect to not play further games.  The motivation to want preimage a to be revealed normally anyway is that it starts the confirmation clock rolling earlier if users want confirmations, and even with 0-confirmation users probably want to have assurance they won before betting more.Adam The basic problem of a fair coin toss seems relatively straight-forward.  The hard part is to stop the loser reneging by aborting.  Iddo may or may not have a solution by locking up a multiple of the bet, and making the coin unspendable by forcing the spend to reveal something useful to the other party unlocking.But I have a simpler more generic new idea - let the committing party win by default, the loser if he loses has nothing to do, and if he wins he overrides the committing party.  It would require the introduction of the concept of an override (like this signature wins, but this signature can override it).Advantages: less rounds, no extra funds, and script simplicity/clarity.  I would say bitcoin (or perhaps a cryptographically exchange rate locked altcoin) should implement the override concept as it then allows fair games to be defined easily.Adam Anyway other than the question of whether soft forks make sense or not: what about making an all zerocoin based alt-coin (no bitcoins, nothing but zerocoins), that is either-or mined with bitcoin.  Then people can trade in and out of zerocoins by buying or selling them for bitcoin with an atomic transaction, probably p2p without some trusted exchange like mtgox.Either-or mined (as distinct from merge-mined) I mean that each mined coin set is either a set of 25 bitcoins or a set of 25 zerocoins.  If its a zerocoin set its not a valid bitcoin set, and if its a bitcoin its not a valid zerocoin.  I'm not sure the zerocoins or bitcoins have to do much with mining events for the other network other than check they have the expected number of bits as they wont automatically know how to validate the other network.  Some miners may choose to validate both networks, but thats a choice for them.In that way people can experiment with zerocoin, without bloating the block chain, complicating bitcoin, and without slowing validation on the bitcoin network.  And the two coins should have approximately the same cost (and maybe therefore value, though the price would be subject to demand/supply and any taint discount for bitcoins; zerocoins are taint free, or perfectly blended taint at least).Adam -S on the GPU gives a segfault during kernel compile.  -S or just normal on the CPU with oclvanity produces valid normal results (though of course its slower than vanitygen when run on the CPU).Adam Playing with this some more I think it is the case that 1 is special (it is the encoding for digit 0), and then values after first digit P (in the base58 alphabet) are possible; values after that are not directly possible however become possible when you get a short key (leading 0) as leading 0s are suppressed.  So all lowercase values and values starting Q only are at least one character short.That means you're going to have a lot more fun if you start with upper case first char, below Q.Adam Thats what I figured and already tried: doesnt work (on amd 7870, catalyst 13.4, fedora 18.)I tried that one and it has the same CPU hash GPU hash not matching issue (with or without BFI_INT disabled).This kind of sucks.  Must be some more bugs lurking or catalyst driver bugs?btw I am finding vanity addresses aiming for with lower case are much harder to compute seemingly, 1 out of 58 I generated so far with vanitygen -i are lower first char.  I think there maybe a target range miscalculation in vanitygen that is discarding valid finds?  Clearly all start strings are possible because 1zzz finds lots and so does 1111.  The alphabet is [1-0][A-Z][a-z] and strings before 1QQQ are easier.  Except 1111 is harder.  I am not really understanding why this is.  OpenSSL doco says it uses big endian encoding.  And the base58 encoder seems to use the same convention, so you would expect restrictions on the most significant digit.  However that doesnt seem to be the case empirically.The address is encoded as 0x1 || hash(160-bits) || checksum(32-bits) which is 193-bits.  Now log(58,2^193) = 32.9465 and 2^193/58^32 = 46.676 however the bignum is encoded big endian Adam Also seeing the CPU hash / GPU hash error message on AMD 7870.Running with -V has the same problem but slower.  -S crashes.  This on fedora.I notice there was news of a recent open source update from AMD, not sure if that made it to the package managers yet, but maybe someone wants to try see if that fixes.Its unclear to me if its an oclvanity bug or an AMD driver bug.  However people in the thread seem to be experiencing the same problem on windows.Has anyone had any success contacting samr7?  I tried to contact him with a bug report for something else related to vanitygen, and I have to say it strikes me a bit suspicious that a bitcoin related tool that is generating private keys has an uncontactable author and maintainer.  Even email to samr7@cs.washington.edu bounces with no such user, again suspicious.  (Maybe he finished his course, but he has a bitcointalk account also that he doesnt answer).  My bug so far was just about the probably incorrectness of timing estimates based on time to compute strings with and without capitalization.  eg 7 chars projects 3888 times longer case sensitive vs case insensitive.  Thats seems likely incorrect as the work to find a string that is case insensitive is 2x less for each alphabetic character.  So a 7 char target should be 2^7 = 128x faster not 3888x faster.  Thats out by a factor of 30.  Am I missing anything?(I mean excluding the leading 1 ie 1abcdefg: vanitygen 1abcdefg vs vanitygen -i 1abcdefg.)Adam Why do you involve a firmcoin server?  Does that mean a firmcoin server retains the technical authority to falsely trigger a firmcoin to think its loaded?Why not just pay to the address of the coin (which it knows), and then present it with a merkle tree containing the coin and a block with reasonable difficulty containing it.  As the coin knows it has sole control of the private key, it knows that the coin can not have been re-spent.A verifier can then check the information against its view of the block-chain and validate for itself the merkle tree?edit: I guess you're concerned that proper validation is too expensive for the coin, and you want some transferable representation of the fact a full node server (or even an SPV client) has validated the load transaction.   May also want to ideally avoid the need for the continued availability of the firmcoin server.  What happens if firmcoin goes out of business?  No more ability to re-load firmcoins?  Not obvious how to retain the loaded/empty distinction without a more powerful coin, or some entity to semi-trust.  You probably want to have the coin still check the block collision and merkle tree even with a firmcoin server signature.  (Firmcoin server could get hacked itself, and abused to load non-existing balance onto coins for offline spending).Adam But arent there possibility to accumulate small amounts of power continuously from stray / background EM emission?  Perhaps not for $3?Maybe I can shake the coin a bit and a led glows red or green   Not sure what linear micro generators cost.No what I was meaning is I am not worried about the manufacturer stealing coins (as the user controls the public address, and the coin not computing signatures has no subliminal channel other than NFC).More worried that the coin dies when I drop it with 10BTC on it.  I do prefer the QR code to be embedded in the coin as you have it, stickers can rub off etc.So eg say the coin encrypts x' with the manufacturers public key, preferably in a way verifiable to the user (user can verify if coin encrypted x' not x), sends E(x') to user.  User retains E(x') and y.  If the coin dies, the user sends the physical coin back to the manufacturer who computes x' and sends it to the user.  The manufacturer still doesnt know y so cant spend the coin.  The manufacturer only accepts physical coins so no one can easily trick the manfacturer into helping them recover coins from other users that they dont have physical possession of.  Manufacturer also cant remote invalidate coins.Adam Alright - sounds like you know what you're doing - you went for the plan A.That aspect was unclear from your description before, but that is a consistent and reasonable design.Your use of x=yx' (y chosen by user) makes more sense in that context also, as then attacker cant mark coin public keys for transfers to coins (which will appear on the block chain).btw As you have a funded state on the coin, and passive accumulated stray RF power possibility you could flash a light on button push to indicate green or red status even.Any thoughts about suggestion to make the private key recoverable by combination of users retained (but not block chain published) y values (or other new value) and manufacturer on receipt of broken hardware?  May make it more attractive for bigger balances - otherwise I can see people being scared to put bigger amounts on it in case of hardware failure.  As is I could take the value off the card (empty state) for safe storage/backup/paper-wallet, but as soon as I reload the coin it chooses a new private key that I dont know, and cant easily know without resetting it back to empty state.Adam I think there are people who like to work with the limited trust you can place in a piece of hardware made by a third party and given to you by a person hostile to your interests (or to just pretend thats secure, or secure enough for the low value transfer and social face loss of cheating).Under this argument they want to make the coin somewhat safe to transfer offline, eg to the extent that the coin makes it hard to take the private key out of it.  However it seems that the same people want the coin to be online spendable (emptyable) and reloadable.  Those objectives seem in conflict as any non-technical guy can follow the online spendable procedure, and end up with a coin that within protocol has no bitcoins in it!  So then you see the defense that the coin is somewhat offline verifiable in that it reports itself over local hardware link (eg NFC in case of firmcoin) as empty.  (eg it deletes its private key when spent).Maybe to the limited extent of the tamper resistance, tamper evidence, an holograms etc that some people may want to trust that, we could have both objectives in one coin (moderately safe for offline transfer AND new owner chooses part of the key).  And Sergio Lerner said something like this:So that means device computes P1=x'G, then user chooses y such that P=x'P1=x'yG so the final key is x=x'y mod n.  So while its true that the device didnt chose all of the private key bits, it still knows the full private key, could leak it over NFC, or more subtly send it in k when making the ECDSA signature via the big fat 256-bit DSA subliminal channel, so the user or manufacturer or criminal buyer of hostile hardware can later harvest coins from the signatures published to the network by examining the signatures.Concretely lets say you have some hostile hardware, here's how you leak x=x'y mod n.  key is some key buried in the hardware, loaded into its firmware etc and know to the attacker.  Compute k=H(key||H(m)||P) Now the normal DSA signture:(r=[kG]x, s=k-1(H(m)+rx)syntax [G]x indicates the x coordinate of point g.in this case x=x'y because of the way firmcoin generates x' on the coin and allows the user to generate y and pass it in.Now the attacker can recover the coin private key seeing only the signture (r,s) on message m (the transaction details) published on the bitcoin block chain, and then pre-spend your coin.that is because:s=k-1(H(m)+rx) => sk^-1=H(m)+rx=> sk^-1-H(m)=rx=> x=r^-1(sk^-1-H(m))and notice that the user generate x where x=x'y didnt help a bit.You either need to not trust the hardware to make the signature, or you need the DSA subliminal channel to be plugged.So you might imagine doing the same trick again, hardware chooses R=k'G and sends the user R, users chooses z so that r=[yR]x=[yk'G]x.  ie k=yk', and verifies that r=[yR]x.  Now the attacker cant set k arbitrarily.  You have to do the current x=x'y defense as well otherwise the hardware can set x to H(key||counter).Now there is no subliminal channel so you can safely have the coin make a signature (modulo NFC leaking).You better check R is on the curve, and that it generates the same subgroup (or that the card knows the discrete log of R in base G, eg with a schnorr proof in such a way that protects the card from private key extraction).You might want to arrange things so the hardware manufacturer can help the user recover x when mailed back the coin, and with y and z.  (eg from serial number on outside of coin package plus a secret key known to manufacturer).  Otherwise people are going to pretty annoyed if the hardware fails).  You can probably do that such that the manufacturer still cant do anything useful by itself with out the users knowledge of y and z.Adam Perhaps my objectives are different to other people but I am assuming a relatively online world where you check your coins with a smart phone, so the coin is more of a convenient physical representation and nice physical container for one bitcoin denomination.The problem with a coin is its a piece of hardware made by your enemy.  So you cant trust it with generating secrets, nor signatures.   (DSA signatures have a subliminal channel in the choice of k and hostile hardware can intentionally and undetectably leak the private key in the signature).I just mean you cant trust hardware given to you (the coin) to have interests aligned with yourself.  Its less dangerous to have it passively store a secret.  But you do generally want to be able to just hand it to someone, have them easily able to double-check what the block chain thinks about its balance, and to have them without trusting the hardware much take control of the coin (ie not have to trust you the previous owner to have retained a private key).My idea of coin security is that you want security against the coin - the coin is some hostile, third party hardware.  You cant check coin hardware authenticity, and if it gets interesting, counterfeit, hostile, secret leaking coins will come flooding onto the market.I avoid the new holder needing to worry about there being a second copy of the previous private key, by the act of transferring the coin enabling the recipient to set a new private key, and verify eg with 1 confirmation or some independent confirmation from a miner or tracking site that his spend to his own chosen key has gone through ahead of a potential double-spend by the previous owner.Adam Maybe there's another way to get a similar effect without having the same public key be reused with different bases.Lets say we create an initial bitcoin address for each physical coin, and engrave the initial address on the outside of the coin.  We'll also refer to this initial address as the coin serial number.  We want bitcoin to prevent reuse of the serial number, as it does for double-spent payments.  (Maybe we can trick bitcoin into doing that for us with appropriate formatting).The current coin private key is stored on the flash storage in the coin.  (And the public key can be computed from it).Lets say each bitcoin transaction optionally includes a serial number (eg via some auxilliary signed data).  Now when taking ownership of a physical coin the recipient would expect (demand) the serial number to be present on the current ownership transaction, and would include the serial number in the signature transferring ownership to a new key.  The new key would be stored on the coin flash storage.The main point of the serial number would be to correspond with the coin markings, and to allow convenient static locator to look up the state of the coin.  Tools like block chain would be needed to index by serial number.  (Alternatively if the serial number were implemented as a demonstrably invalid optional second signing address added to a multisig, on each physical coin, probably tools could already index it; though invalid addresses are frowned on for frustrating compaction.)Adam Very cool.  Like the 2-way NFC and button combination as an interface.  Coincidentally your first post on firmcoin just a few hours ago too!Yes but you cant prove the key was generated in a way not computable by the hardware manufacturer.  I was thinking it would be safer to have the key chosen by the software system under the currrent owners control (the person loading the coins).  (Or maybe verifiably half the private key bits by the owner and half by hardware).   In that way the hardware does not actually have to be trusted.  Also if the hardware fails you dont lose the coins (you could back them up).Its probably fine for modest value but in principle it seems that the manufacturer you use could make another coin with a different bigger firmware that contains both a standard firmware for responses and a hostile firmware for generating trap-door predictable private keys (eg)Adam So far physical bitcoins sell for a big margin above BTC value, and they are things of beauty is part of the fun, so throwing them away would be undesirable.  However they are currently security/trust risk because of their design.  Apparently some of them put the private key on the underside of a tamper evident sticker printed with inkjet.You want the info on the outside of the coin to be unchanging and yet easily verifiable as to its spent state, and you want to fix the trust issues with transferring them in physical form, so the thing that has to change instead is the private key and base.Now all we need is a kick starter for someone with a bit of hardware expertise to put an unpowered 1kB contact readable serial readable flash drive inside a coin   Maybe you could have a coin hold a standard usb drive, just pull it in half and plug it in even easier to read.  Unfortunately smart phones dont have usb readers.  btw it also occurs to me you could safely sell unloaded coins also, just engrave an address on the coin and include the public key on the embedded flash card.  User loads by spending to that public key and some chosen base they chose themselves.Also another weird thing you can do (unrelated to physical coins) if you allow user computed bases via y-th root, is have a public key which is human readable, without address mining.  (Note address remains unreadable as its a hash of public key).  eg your public key could be your email address.  Possibly a bit dangerous because there is no registration to prove its your address, though I suppose they could email you to check... however you probably wouldnt want to transfer a coin with your address as its public key via a base change.  (Just spend it normally to recipient).Unfortunately you cant chose both base and public key arbitrarily - you cant do it with out breaking discrete log - you can chose either the base or the public key arbitrarily.  To chose a point arbitrarily you have to use something called hash2curve - strings are not always valid points on the curve, so a simple deterministic algorithm is used to chose closest change from the string to make it into a point on the curve.  eg see 4.1.1 of http://tools.ietf.org/html/draft-harkins-tls-pwd-03.Adam I have been musing about how to improve physical coin security, because well physical coins are just so cool Its obvious that the https://www.casascius.com/ reliance on a hologram covering a microSD card held in a recess in the coin has several problems: how do you know there is a private key on a SD card inside it (trust manufacturer).  Also how can you spend it convincingly without wrecking the hologram.  And anyone can get some holograms printed up, remove key.  Now apparently some of the coins have the coin address engraved on the coin rim which is quite cool as you can check if its currently spent.  However it could be spent at anytime if the former owner or manufacturer cheated.So my variation on this is that you can actually generate a new private key for an existing coin address / coin public key (relative to a new discrete log base).  The effect is that I think you could hold a coin public key constant while convincing someone in zero-trust that you did not retain the effective private key, by changing the base.Normally P = xG (elliptic curve discrete log notation)Now you can use different G values and still make a signature.  eg if you could compute P = x'G' (same public key P, different private key x', different base G') you can make an ECDSA signature wrt P, x' and G'.  It will validate against P and G'.But you have to be careful as anyone can cheaply compute the y-th root of P: if you can choose G' randomly, you can cheat.  ie compute y-1 mod n and multiply: G' = y-1P.  Thats because that is an elliptic curve y-th root which is trivial to calculate because G' is arbitrary result (the y-th root) not a pre-chosen discrete log base, even though it looks like a base when you've finished.  (n is the order of the group).So how could you fairly chose a new base?  One way is to demonstrate you know ECDL of G', ie you know w such that G' = wG.  We can probably do that safely:recipient gets private key easily from coin, if it has an electrical interface to reveal it on contact.  Computes new random z, and G' = zG and x'=xz-1 mod n.  x' is the new private key because P=x'G' and P=x'G'=xz-1zG=xG so P is unchanged.Recipient publishes multi-signature of P' with old private key x, and second signature of P' with new private key x' relative to new base G' to the bitcoin network.  Once that is hashed after a few blocks they can be sure the previous owner can no longer claim the coin, even though the previous owner has the previous private key.Its analogous to the current coin transfer (signature from old key to new key as transfer), except the discrete log base is changing, not the public key.  (Currently G is held fixed as a fairly chosen EC parameter which is a constant point on the curve).This obviously can be repeated: keep original x for calculation purposes and store on the coin the current x.  So long as the new holder of the physical coin can choose their own x' and controls the IO interface to the coin, they can be confident the coin cant be stolen.  They can network verify the coin, which retains its public key (though changing base).Or maybe you write the first coin private key (and immediately change coin private key) around the rim of the coin, and just dont let people play with your coins up close, then you dont even need an electrical interface, nor any electronics on the coin.  (Or maybe simpler electronics that can just read out a fixed original private key x).  The transfer to new private key has to come via the smart phones on input of the private key manually, or just use the private key or part of it as a checksum to the actual private key sent to the user to check its the right physical coin.  It would be nice to store the current private key into the coin.In fact simplying slightly you could even allow transfer to a y-th root chosen base, so long as the holder knows the private key from the current base, and they sign the new base, why not.  Then you only need a single signature not a multisig from old and new private key with respective bases.You can think of this changing private key as a kind of one-use forward secure signature (foward secure signatures are where you can disavow old signatures because the old private keys are published after expiry).  Original signatures are still convincing in this context because of the time-stamping from the period before private key disclosure.The main advantage of keeping the public key fixed is you can engrave it on a coin (as now) and the main advantage of allowing a DL base to change to represent ownership change is you can safely transfer control of a physical coin without trusting anyone, the coin only needs to store the current private key for convenience.Maybe there is some advantage to be had for other bitcoin uses of keeping the public key constant.  eg maybe the UTXO set can be smaller (unclear how)?  You could actually do change with a fixed public key, but then you end up with a below par coin.  It could be two coins with the same fixed public key (but different bases and private keys and amounts adding up to the original coin denomination) or two coins one with a fixed public key and one not, or two not breaking the link with the physical coin public key.  An emptied or disassociated coin could still be reloaded by spending to its address/public key with a new chosen base.Coin addresses are currently somewhat opaque because its a hash of a public key.  The new base on each spend could also be opaque if desired (eg publish hash of public key and base in the transfer message.)Even if you wanted to go crazy for some esoteric reason (eg maybe someway to leverage for privacy somehow?) all coins could have the same public key (but different bases and private keys).It strangely also allows you to spend to "current bearer" with a fixed coin address, to add value to a coin, because the coin address doesnt have to change, the network tells you via the UTXO query which is the current base allowed to claim ownership and spend the coin!Adam I wonder if there is a way to use zerocoin off-chain to implement the auditable chaum-like thing, presumably zerocoin is the closest protocol.  Zerocoins are so far not transferable - you buy them with bitcoins and sell them for bitcoins.  But you could transfer a zerocoin - just sign the new accumulation with the old coin and put the old coins serial number in the double spent list.Recalling when you accumulate you have to spend a bitcoin (sign the accumulated coin c), and that authorizes you (in the view of all full bitcoin clients) to add c to the accumulator:sig(b,c) and A' = Acsignature using the bitcoin key b from bitcoin b.when you convert it back to bitcoin:ZKSoK[R]{(w,c,r): A==wc mod N and c==gshr mod p}w is witness (accumulator excluding c), c is the coin, s is serial number, r is random never disclose, R is the data the signature is over.  R in the case of conversion to bitcoin is a bitcoin b, and the new owners bitcoin address.If we want to transfer zerocoin to zerocoin without going via bitcoins we could do that too.Just set R to c the new accumulated value of the new owner, and update the set of spent serial numbers with s which is disclosed as part of the ZKP.  Now you have a replacement freshly unlinkable zerocoin.Now why would you want to convert a zerocoin to a bitcoin?  Its purely an efficiency argument - zerocoins are more work to validate and bigger.You could directly mine zerocoins also.  Just allow mining to a zerocoin accumulation directly.  Ie the winning miner in each block is allowed to include 25 coins in the accumulator.  So we could build a zerocoin alt-coin that doesnt directly use bitcoins at all with zc mining, and zc-zc transfer, and its own zc serial number double-spend validation in place of bitcoins linkable double-spend validation.  Maybe its merge-mined  (though that creates a strange conflict where miners get both 25 zercoins and 25 bitcoins for the mining price of 25 coins) or just track bitcoins difficulty, and bitcoin mine with intentionally unspendable mine-to addresses, that are valid  zerocoin addresses.  I think a "fair" merged mining aiming for price parity would be done by the miner having to choose zc or btc at mine time, and zc chain considering btc unspendable and bitcoin considering zc unspendable. Maybe one could trade zerocoins for bitcoins.  Probably zerocoins would sell above par because they are taint free, in the same way that fresh mined coins reportedly have sold above par.If bitcoin main choses not to integrate zerocoin - and indications so far is it wont for compute and storage efficiency reasons, and perhaps other reasons, then maybe this would be something interesting for a new altcoin.I think people have proposed methods to trade altcoins for bitcoins without an exchange through some kind of simultaneous trade protocol?edit: seems to be something wrong with this - dont miners on bitcoin networks have to be aware of validation logic of zerocoin alt-coin network, otherwise they will accept merge-mine of invalid eg forged zerocoinsedit2: maybe we can say that a mergemine does not count as a validation of the network for the respective network unless there is serialization in the coinbase indicating that the network is validated.  In that way you could have zerocoin mined and zerocoin validated, zero mined and bitcoin validated (strange but possible), zerocoin mined and both zero and bit coin validated, and also the same for bitcoin mined and zerocoin validated (strange but possible), bitcoin mined and bitcoin validated (normal bitcoin ignoring zerocoin) and bitcoin mined and bitcoin and zerocoin validated.  Then the validation events on zerocoin network might not be as frequent.  Maybe miners will tend to validate both networks as then they can claim fees on both networks, even if the protocol prevents direct merged mining on both networks (one or the other mined, and whatever chains validated as indicated by coinbase serialization).Adam Its a desirable audit requirement but I think the blinding may prevent it.  Lets call the blind chaum coins c' and the normal (unblinded) chaum coins c. (And it works because blind proto-coin p is sent to the bank p=res mod N, bank signs to create blind coin c'=pd=rsd, and user unblinds by dividing by blinding factor r: c=c'/r=rsd/r=sd.  So the bank sees c'=rsd on withdrawal and c=sd on deposit.  s is the serial number.)The bank on withdrawal exchanging bitcoins (call those coins b) for blind coins can log (c'1,b1).On deposit exchanging chaum coins for bitcoins the bank sees c and b, so it can log (c1,bR) for some random bitcoin bR.Finally on chaum->chaum off-chain transaction the bank swaps a non blind coin for a fresh blind coin, so logs (c1,c'2).The problem is if the bank logs two withdrawals (c'1,b1),(c'2,b2) and then logs deposit (cfake,bR) the auditor cant correlate cfake with either c'1 nor c'2 because of the blinding, even user 1 and user 2 who know their respective blind factors can't tell that it isnt the other user doing the deposit without breaking their privacy.  Unless they somehow all club together to do a ZKP to prove that a withdrawl is none of their coins which might be possible, somehow prove they know the blinding factors in one of the withdrawals that matches the deposit.  However that sounds a lot like zerocoin set membership level of efficiency proofs.  Maybe could still be interesting if it is off-chain.Is that described on the bitcoin wiki under fidelity bonds?Adam
It was described how that works somewhere in this thread.  The short version is that the commitment contains SHA1(SHA256(public-key)) and a normal address is a different hash addr=RIPEMD160(SHA256(public-key)) and any public (non-committed) transaction reveals the public key (because that is necessary to validate signatures, and transactions contain a signature from the address public key), then if a public spend is done anyone can calculate the commitment based on the public key.If another committed transaction is made RIPEMD160(SHA256(public-key)) is reused.The actual details are a bit more complicated to prevent various attacks and corner cases but the above explains why you could prevent double spending of something you cant even correlate unless it is double-spent.Adam The limitation I see with Chaum credentials, for off-chain transactions backed by bitcoin is that the transaction server could issue more chaum-coins than there are bitcoins, and you will never know until you find your chaum-coin is irredeemable because the bank is out of bitcoins, having redeemed them itself under a pseudonym with extra unadvertised chaum-coins it minted for the purpose.  Because they are not linkable you cant make a chaum-coin lock an on-chain bitcoin nor collectively all issued chaum-coins also cant lock a claim to the pool of on-chain backing bitcoins.  (Or more likely the bank gets away with it for a while, like an over-leveraged fiat bank with off-book liabilities until there is a run on the bank).(And I guess its been tried, monetas OpenTransactions system implements David Wagner's blind MAC (in the form of Ben Laurie's lucre library) something similar to Chaum and I think is flexible enough to issue Chaum-alike credentials for bitcoin).Thats because while the Chaum bank can demonstrate it is holding some bitcoins, the coins are blind and not linkable.  So you cant tell when an extra coin is used (that was not backed by bitcoin) to claim a not yet spent bitcoin, rightly belonging collectively to the set of bitcoin backed chaum-coins.That could be interesting, but the chaum-blinding doesnt directly work as the way bitcoin consensus is to put it inside a merkle hash inside a massive hashcash stamp.  Maybe you could put it inside an RSA accumulator instead, which is a more blinding friendly algebraic construct.  However that is basically what ZeroCoin is trying to optimize.Adam So apart from the political blather this bit seems to be like a potentially interesting idea, perhaps other people had the same idea beforeie why not as a design objective try to separate identity from coins.  So you make the coins payee and payer anonymous, and then each user has a wallet identity/pseudonym that maybe optionally disclosed to the other party, or revealed to other party or to the auditor in event of dispute.  In that way we avoid taint, and yet the privacy and anonymity of the payment system becomes more arbitrarily tunable and even negotiable between parties, or set by system default.  Taint and tracability of taint is bad because it affects fungibility (in a p2p respendable ecash system like bitcoin, random users end up holding retroactively tainted and reduced value or unspendable coins through no fault of their own, and this erodes confidence).  But a system may like to offer or aim for a specific privacy level or traceability of amounts and identities.  Those things thereby become separable.  Nice Now all we have to do is find a way to make zerocoin efficient.  (And that seems to be the question of the hour - its not at all obvious how to do that).Actually its an open question how far bitcoin direct chain transactions scale, so maybe there is some hierarchy of off-chain (or sub-chain) that evolves eg around miners, exchanges, or p2p sub-chains that offer lower value coins, that backed by the main chain but not detail validated by it.  The supposition being that if bitcoin does hit a scalability limit (fails to scale as fast as its adoption), the minimum effective transaction value amount that is economical to send due to fees will go up, a lot.  Maybe the main chain is used for inter-chain clearing and investment level bitcoin holdings.So maybe the privacy policy types of things get decided by competing sub-chains and off-chain transactions in such a bitcoin world.  And seemingly its not obvious how to do sub-chains and off-chain transactions without trust for double-spend protection.  (Which is why things like fidelity bonds come up in this scenario).Adam You can get privacy without anonymity, eg as with the committed coins idea https://bitcointalk.org/index.php?topic=206303.0, only the sender and the recipient get to see the coins and who is spending to who.  (Unfortunately the committed coin privacy is not ideal because later people in the transaction chain of committed-form respends necessarily have to learn all previous details for validation reasons).Some of the privacy focused ecash systems distinguished between payer anonymity and payee anonymity.  As a buyer you dont necessarily want all your payments to allow the public, the (ecash) bank nor the merchant to track which say ebooks you are reading.  It none of their business.However the usual argument to blackmail crime scenario is that the criminal cant do that if there is only conditional payee anonymity (ie the spender colluding with the ecash bank can identify who the receiver is).  In bitcoin there is no bank to collude with, but you could imagine arbitrators in that role, or that the payee is identified to the payer (but no one else).  And of course the identify the recipient ignores identity theft, and assumes criminals are mindless non-adaptive automatons so its a fairly weak argument IMO.  In any system that strips privacy, the people who suffer loss of dignity and privacy invasion are the normal users, the criminals can still get privacy via identity theft, fake identities, buying fake identities from corrupt employees of government id issuers etc.  And criminals still launder money en-masse even with regular banks.   HSBC which reportedly laundered $880m of significantly dirty mexican drug cartel and even terrorist money and faces a $1.9b fine.  http://www.guardian.co.uk/business/2013/may/23/hsbc-court-threat-money-laundering-charges  Probably HSBC are going to walk away with the fine only (too big to jail despite the posturing).Another possibility is it would be technically possible for the spender to be convinced who the recipient is without being able to prove it to other people eg with a ring signature, non-transferable signature, or designated verifier signature (the spender being the designated verifier).Being able to sell things anonymously is a different and actually separable feature.  But people have also made pretty convincing arguments about why individuals should have the right to retain privacy while selling physical or virtual goods in a free society.But I do think bitcoin ideally needs to find an efficient way to fix the fungibility problems with taint.  Payer privacy without payee privacy might not fully fix that as a payer who claims he didnt make the payment (claims the thief made the payment using the victims wallet to the thief) the victim would then identify the recipient.  If there were identities separate from coin addresses, you could imagine payee/recipient losing privacy on payer complaint, without the payee losing ability to make further payments with payment privacy.  ie the payee is expected to repay the value, not that the coins themselves become traceable.  However even then when identity is some random public key with no certification, its really not much of a threat to burn an identity.  Fidelity bonds perhaps are closer to network identities with some cost to losing.Even in the physical world with conventional banks, once non-petty criminals are involved "identifying the perpetrator" becomes a fuzzy and useless fig-leaf fast as they identify a victim, or a fake identity bought from a corrupt government employee, or dupe the issuer - the RA stage is usually inherently pretty weak.  Criminals rent identities (money mule), buy or create fake identities, shell companies etc.Finally to note a payment system could obviously have emergency tracability added to it as noted in the zerocoin paper.  Its typically easy technically to selectively weaken a protocol.  The problem is if you want it at all, you want emergency tracabiliy to be restricted to genuine emergencies, not drag-net fishing, not tracing of petty crimes.  Law enforcement are not always so clever about drawing lines there so you get mission creep until jay walking is an emergency.  eg in the UK I read a local council abused crime surveillance cameras to trace people who were bending the rules about which area they lived in to get their kids into a better school!  Next up people not pooper scooping their dog.  You know those things were weakly approved by society for terrorism clean up and maybe, arguably, serious organized crime.Some ecash crypto papers have talked about system limits like payments are fully untraceable if they are under some amount (eg $10k like paper cash reporting limits) or under some amount per day per user.  Another limit can be the "emergency" access is limited to 1% of traffic period, more is not cryptographically possible.  Or I think alternatively and more simply access requires cooperation from involved users would be a nice balance.  Everyone has to transact with someone, and most transacting parties have no particular interest to protect some organized crime activity that rented a server or car from them.Anyway the whole thing is a big mess.  And it's hard to maintain binary fungibility in the face of grey fuzzy privacy/traceability, and court ordered mission creep.  Computers do binary well so to me that is the natural physics of crypto and p2p virtual payments: irreverasable is cheaper than charge-backs (cash over credit cards), and there is no partially irrevocable.Probably in an actual free society, people would understand that more people being killed by furniture falling on them than by terrorists should be sort of factored in in terms of spending and focus, and societal balance.  Obviously the people charged with cleaning up and infiltrating these things are too involved for perspective, but they work for society not the other way around.The UK had its share of history with IRA blowing various stuff up, the US news typically in that era referred to the IRA as freedom fighters, some US factions even funded them, and yet the sky did not fall, eventually the UK lost their face of "we do not talk with terrorists", the IRA became involved  in the political process, some political prisoners were freed, and now things are not blowing up.  The UK government got up to some pretty shady things in the history of the troubles also.  Its just possible that the current problems have an element of blow-back and two sides to any argument also.  Its kind of interesting from inability to learn from history that the UK government finally admitted and will compensate victims of its past torture of kenyan resistance fighters and civilians including Obama's grandfather in kenya troubles, and here is Obama presiding over the next generation of the same picture (the powerful torturing the weak for attempting asymmetric and reactive warfare).  That still seems to me like a retrograde step, trials were heard at nuremberg about such activities in the past for good reason.Adam So what did the tweet say if you still have it.. enciphering minds need to know!  (and undetweetable.com says they've been asked to shutdown).Adam [edit used sup and sub for exponent and subscripts]^ is power modulo some prime or RSA modulus depending on the situation and * is modular multiplication.So the A=uc1c2...cn is modulo N an RSA modulus N=P*Q two primes P & Q.  A is the accumulator.   Note c1c2..ck gets pretty big as users cant reduce it as they dont know phi(N) = (P-1)(Q-1) - no one does as its deleted after parameter generation.  u is some fairly chosen quadratic residue (square numbers mod N) ie there exists u' st u=u'2 mod N.This is the P & Q where you unfortunately get to trust someone to delete them.Next for each coin c=gshr mod p, where p is a fixed prime (not the same prime as P) actually a strong prime (where p = 2q+1, or even p=2wq+1 for some integer w, to get a smaller q).  Because c=gshr mod p c can be prime ie gshr is clearly not prime by definition (it divides by g, h, g2 etc) but gshr mod p can be prime.  It quite a bit of work of trying random commitments to find a prime c though.  I tried coding it in openSSL and it wasnt that fast eg c=gshr check if its prime, if not c'=c h mod p (so that c'=gshr+1 mod p) and repeat.  Prime density is not so great at those sizes.g and h are two generators in the shnorr group of size q.So its curiously using two completely different groups - an RSA group for the accumulator and a Schnorr group for the pedersen commitment sounds odd but it doesnt really matter they are independent.Now you can easily choose a c with two commitments in it (trying to get two zerocoins for the price of one bitcoin): prime c=gs1hr1 gs2hr2 mod p=gs1+s2hr1+r2 mod p.  However to cheat and prove/spend two separate witnesses and zerocoins paid for with one bitcoin you need to prove you know A=w1c1 mod N and also A=w2c2 mod N with w1=uc2c3...cn mod N and w2=uc1c3...cn mod N.  However A=uc c2c3...cn) mod N because we paid for zerocoin c with our bitcoin.So the only way to cheat is find c1,c2 such that c=c1 c2 or c=c1c2 mod phi(N).  You cant find c=c1 c2 because c is prime.  And you cant find c=c1 c2 mod phi(N) because you dont know phi(N) = (P-1)(Q-1) because P & Q are deleted during zercoin genesis.If you could find such a c1 and c2 you would have found phi(N) by definition, and using that you can factor N trivially - ie thats impossible unless you can break RSA.  (You need phi(N) because you have to reduce the exponent by phi(N) with RSA ie A = uc1c2 mod N = uc1c2 mod N = uc1c2 mod phi(N)) mod N.Now if you did know phi(N) = (P-1)(Q-1) you could clearly create multiple zerocoins for the price of one bitcoin.  So thats the trust in the person who sets up the value of N during zerocoin genesis.Adam The ZKP in zerocoin is able to prove you know a w and c such that A=w^c (where w=witness, c=commitment/coin and A is the global accumulator value at a given point in time) without revealing w and c.  c has the form c=g^s*h^r where s is the coin serial number (revealed) and r is a random number never revealed.  c=g^s*h^r is a pedersen commitment, you can think of it like a hash function c=H(s,r) in that its hard to find either s or r (because it one way).  Also its collision resistant so its hard to find another s,r value eg to find g^s*h^r==g^s'*h^r' even if you know what s and r are.  That like symmetric hash function also hard to find H(s,r)==H(s',r').  The difference is pedersen commitments involve algebraic operations on big numbers and the hardness of discrete logs and so are easier to prove things about (ie because you can usefully multiply them etc - hash functions like SHA256 just make a big mess of their inputs to achieve collision resistance.)So putting that together zerocoin have a ZK signature of knowledge ZKSoK[tx]{(c,w,r):A==w^c and c==g^s*h^r} ie c,w,r are not revealed, tx is the transaction that is revealed and signed by the zerocoin spend/signature (eg tx = spend this zerocoin to this bitcoin address), s is revealed and stored and is the serial number that is recorded to avoid double-spending.  ie combining it shows that A==w^(g^s*h^r) and they were able to find a somewhat large way to prove that without revealing c,w,r.  Its large because it involves multiple cut-and-choose rounds as each round is only 50:50 convincing that what the prover claims is true.  After 80 rounds its security is 1/2^80 which is quite good.  (Though bitcoin aims for 2^128 which is more, they only used 80 to save space - 40kB was already unfortunately large for the zerocoin spend ZK "signature".s is revealed and is the coin serial number, so its important that r is not revealed otherwise anyone could calculate c=g^s*h^r and just scan for that in the list of zerocoins de-anonymize the coin spends .  Fortunately because of the collision resistance of the pedersen commitment (hash function) not even the owner of the coin can create different s, r equal to the same c so he cant get two coins from one that way.  But to prevent the owner of the coin creating c=g^s'*h^r' * g^s * h^r and then proving two separate coins (and that would work because A = u^(c1*c2 *... cn) for all zerocoins ci) they further require that c be a prime number.  So you're not proving its prime via the ZKP when spending, but you are proving it when you create the zerocoin - all the miners check if c is prime (as c is revealed at that point).  So thats why c is prime.  (I had to ask Matthew Green that it was puzzling me as making c prime is moderately expensive, and why it takes 0.5 - 2 seconds to just create a zerocoin, and the Camenisch and Lysyanskaya paper the zerocoin accumulator comes from uses c prime only for  different reason that zero coin doesnt need - membership deletion).It seems counter-intuitive that you can prove things without revealing them but thats what ECDSA does too - it proves that the signer knows the EC discrete log.  Its basically because you can see that only someone who knew the discrete log could have computed the signature, and yet anyone can see that the signature is valid.  The ZKP is the same just more complicated.Adam miners validate 3 things about other miners work:a) that previous coins have the correct difficulty at the time of miningb) that none of the transactions are double spends of previous transactionsc) that the input values are >= the output values (input > output means balance is fees)with committed coins the last validation c) is delayed until the coin is decommitted (which could be 6 blocks later, or years later, after 0-follow-on transactions or 100s of follow-on transactions).  However the recipients receive the decommitment for all committed coins and so can validate it immediately for themselves in order to know whether they should accept.  Thats a bit more complicated for SPV clients, as they also need to see the committed coin decommitments which requires a bit more network activity and computation.The other two validations a) and b) are still validatable by miners even though the coins are committed.Adam Its strange because as far as I can tell Ashish did not contribute to the hashcash library (and there were a few dozen people did).  Actually I had no idea who Ashish was other than the owner of hashcash.org (.com, .net) until reading this thread to realize he sounds like a pretty interesting open source crypto hacker and even involved with ecash related things at DMT which I was barely aware of though I had read some of the late J Orlin Grabbe's libertarian articles in the distant past.  I didnt realize he was an economist (see his wikipedia).edit: Actually its not ambiguous the heading of the section on the above link is "As Seen On..." and includes sections for TV, news, magazines, and... code that mentions his name.  And hashcash certainly did that in the context of his giving the domain name, gratis.Ashish did give me the domain - I think I offered $100 to have a better .org domain for the opensource project.  His counter-offer to give it to me free was a pleasant surprise.  He got me to make a PGP signed statement saying I wouldnt try to obtain hashcash.com nor hashcash.net.  I notice now hashcash.net is for sale by one of those resellers so maybe he accidentally didnt renew it.The speculations about Ashish personality to be eschewing financial reward are interesting (re $100m of unclaimed BTC on the block chain).  I dont know Ashish so I cant help there.  But it is interesting that there are some cultures and religions that do intentionally forgo financial reward, and shy away from shows of wealth etc.  I noticed some indian sub-cultures have that, but they are certainly not alone.  Ashish apparently was/is involved in open source, and interesting projects like DMT where presumably most of the interest is the technology purist, or political freedom potential.Adam Taking a leaf from Meni Rosenfeld  https://bitcointalk.org/index.php?topic=121314 I figured I'd create a thread for people such as Serith (and he seems not alone) to dis me in.  https://bitcointalk.org/index.php?topic=225463.msg2371674#msg2371674Go for it And now back to the ring signature sub-thread.  Ring signatures and accumulators are closely related with the convenient exception that ring signatures are directly anonymous (not requiring a ZKP of set membership like zerocoin and Sander & Ta-Shma's auditable electronic cash that predates zerocoin in its auditability.)Most of the ring signatures are however also not compact (with signature size linear in the number of members of the ring).  With bitcoin thats the anonymity set size, analogous to the total number of zerocoins so in any real use thats probably worse than zerocoin.This Shoup ring signature however has a small constant size:http://www.shoup.net/papers/subring.pdf(trying to decipher now) however it is based on an accumulator and sigma-proof (ZKP) not figured out how efficient that proof is yet to understand if its better or worse than zerocoins set membership proof, nor even if it could be directly used (membership proofs dont have to prevent multiple-uses, zerocoin does).Adam Taking a leaf from Meni Rosenfeld  https://bitcointalk.org/index.php?topic=121314 I figured I'd create a thread for people to dis me in.  Go for it People seem to think I am trying to claim bitcoin is mostly hashcash with a small change (or it seems that that is what they assume I am saying, its hard to tell other than they find me annoying for some reason).  I'm not saying that.A number of crypto people have asked me seriously over time if I was Satoshi, and I am not, and dont want to be mistaken to be because he has $100mil bitcoin shaped reasons to guard the physical security of his coins.  (And I dont even have coins which could be mistaken for really well hidden coins).People also tell me I probably know Satoshi (ie that I know many of the applied & theoretical crypto privacy tech people and cypherpunks who worked on ecash technologies like digicash, brands ecash/credentials, lucre, wagner mac-based coins, b-money, rpow) though I am not so sure myself if Satoshi came from that background; my guesses are evolving based on the types of bitcoin crypto mistakes (the very few that there were).So my tag line is actually serious.Also while it is true that I invented hashcash (1997 hashcash.org), I am not claiming bitcoin is some simple extension, bitcoin has actually several key innovations that no one succeeded with before.  And not for lack of trying: there were a number of people on the cypherpunks list who were exceedingly interested in ecash, viewed it as the holy grail, and tried hard for many years (say 1995-2005 range) to figure out how to deploy ecash.  (All the central server ones failed, out of business, failed to reach critical mass).  And so there was interest in distributed ecash.  For example the 1999 Sander & Ta-Shma paper generated a lot of interest (pretty close to zerocoin - the zerocoin references that paper).  As far as that goes the bitcoin paper cites the hashcash paper for the proof-of-work, and uses it with small changes (not all of them positive).Anyway before you say cypherpunks are grey beards trying to muscle into the bitcoin party, you might want to read some of these 1999 threads on the cypherpunks list.  The thread actually started herehttp://marc.info/?l=cypherpunks&m=95280154629912&w=2 and then continues herehttp://marc.info/?l=cypherpunks&m=95280154629900&w=2 because of a subjectline change and then http://marc.info/?l=cypherpunks&m=95280154629916&w=2and http://marc.info/?l=cypherpunks&m=95280154629948&w=2more subject line change confusion.A related thread a few days later also covers Sander & Ta-Shma (whichzerocoin is based on):http://marc.info/?l=cypherpunks&m=95280154630167&w=2Eg Wei Dai's B-money and this thread talking about distributed mining.  There was an anonymous poster on there who seemed more convinced the B-money related very bitcoin like idea could work - that could have been a 1999 Satoshi:The rest of us got stuck on inflation (moore's law) or deflation (fixed up-front supply of coins) and couldnt see a way to control it, other than human intervention.  You can see in hindsight that proposal in that thread is rather close to bitcoin and yet we stupidly abandoned the concept and spent years more trying to find other ways to get there.Hashcash did have some concepts of inflation control but they were not implemented the proposal was to have some group of people estimate moore's law against a reference $1000 machine, and set hashcash difficulty so that the $ cost per hashcash stamp was constant.I also propose an auditable namespace, I forget when probably around 1999 or so, and bitcoin is related to auditable namespaces.  https://bitcointalk.org/index.php?topic=220138.msg2317418#msg2317418Another who is this annoying guy first post:https://bitcointalk.org/index.php?topic=15672.msg1873483#msg1873483Adam Greg also said something like that:https://bitcointalk.org/index.php?topic=139581.0but as a multi-user/multi-input transaction to complicate simplistic tracing taint back to a the owner on the assumption that all inputs from spends are from the different addresses of the same sender.  So in that case there is no unsigned input statement, just a multisig with multiple inputs (from a variety of people) and multiple outputs, so there's not really any doubt about who put money into the mix or who took money out (presuming each person takes out what they put in), just that any tracing identities has to account for this existing mixed owner inputs possibility.You could view the version when all the transactions in a block are mixed as something like zerocoin except with a fresh anonymity-set for every block.  And the output goes directly to the recipient which I guess could be done with zerocoin also (put recipients address rather than your own on cashing out of the pool).Interesting but limitations with DoS vulnerability & also multi-round.  Also presumably if the amounts are uneven you can pair spends and change amounts that match to inputs, and conclude one is the recipient of that sender and on the change to self.  However I see that's what the ref to a post by Mike Hearn was about, splitting the payments to lot of keys in small enough payments to create ambiguity. https://bitcointalk.org/index.php?topic=93390.msg1036406#msg1036406Towards a more efficient solution, maybe we could use a ring signature scheme so that groups of users can spontaneously form groups, and sign on behalf of the group without revealing which user they are.  (Ring signatures are like 1 of n multisig but do not reveal which user signed).When all the outputs are group signed, the users sign their respective inputs to fund the transaction and publish it.http://people.csail.mit.edu/rivest/RivestShamirTauman-HowToLeakASecret.pdfThat same set of users can then sign (with normal ECDSA) the inputs to fund the transaction.  Doesnt completely solve the DoS problems, but you cant just spam you have to join or be elected as a group member by the initiator (just one user).  The process of choosing which users will be in the group is flexible from the ring signature perspective - the other users dont even have to cooperate.  The ring signature concept was extended by others to cover DL based signatures (and EC) so I think you could simply enough add ECDSA ring signatures.The point is you dont want to know who proposed each output, but the inputs have to be signed to release the funds.  And yet you dont want a spam free-for-all of proposed inputs, the ring signature keeps the proposed outputs unidentified as to which user proposed them.  The sender retains control however as he wont sign the input unless the outputs match the requirements of his payment and change.  The group setup doesnt need to involve the miner in this way either so everything can be done in one round.[edit] btw the ring signatures are exceedingly computationally efficient, barely any more than the underlying signature in the case of Rivest's and its actually a simple concept here's a simplified example RSA ring signature: something like if an RSA signature is presentation of a s=H(m)^d then a simplified 2 user ring signature could be eg s1,s2 where s2=r and s1=(H(m) xor r')^d, r = random, r' = r^e then to verify the verifier calculates s1^e=H(m) xor r' and s2^e = r' and test with (s1^e xor s2^e =? H(m)).  Now you cant tell if s1 or s2 is random, and so it could have been signed by either person.  The other person you implicate in this "could have signed" game doesnt even have to participate, but the verifier and anyone can be convinced that the message must have been signed by one of them.  (Technically r is an existential signature forgery of "message" r'.)Adam Yes the miners need to validate for double-spends and collect the anti-spam related fees that are not hashed/not encrypted (in the clear on the outside).Adam I am saying it is possible to leave the validation to the transacting parties.  The spender just reveals the input transactions to the recipient, the recipient checks the validation and that the transactions are on the block chain (in hashed form) accepts or not accordingly as usual.You shouldnt ideally be relying on a few powerful miners to do validation anyway if the miner is dishonest or more likely hacked you can accept fictitious bitcoins that weren't mined.  SPV clients do rely on this because they dont have enough bandwidth.You can decommit the hashed coins to help SPV clients as then most transactions can be validate by the miners (all the old decommitted ones).  The only coins that cannot be miner validated are the ones that have not yet been decommitted.  (How many times user respend in committed form without decommitting is up to them, though such coins are a bit less SPV friendly.)Adam Yes I had the same thought - seems awfully expensive for a mix.  You can view zerocoin as a private keyless p2p mix.  Several people have proposed non-p2p mixing protocols where the mix cant steal your coins.  Whats wrong with that?  I guess the main limit is the mix disappears and your coins get locked.  Probably that could be fixed with smart contracts/multisig.Greg Maxwell also and others proposed taint mixing using multiple coin inputs.(Other than mixing you may also aim to taint all, equally as a protocol).I agree that is likely the end game for mixes.The committed coins idea that temporarily keeps the taint decision private allows people to at least retain p2p decisions about taint without any a priori restrictions.  However the privacy is either short-lived (fairly immediately decommit the coin) or the privacy shrinks over time (if you keep spending the coin in committed form) as more people get to see the transaction history, as each recipient must see all details prior for validation.  A posteriori sanctions after decommit may come into play to if the user is identifiable - if your IP address is logged as posting the reveal of a tainted coin, maybe that matters also.Fairly efficient/low overhead but still some limitations there.It seems like users who are doing high value bitcoin things should be using ToR to hide their IP address which geolocates them.  And servers also should to add resistance to network split types of attacks.  Maybe in a 2.0 bitcoin it might include the minimal defenses of encryption, tunneled relaying and hard to influence remote connections for double-checking local claims.Adam Another time-related concept is a beacon - that is a broadcast, unpredictable and fairly chosen random value.  Eg like this weeks national lottery numbers, someone has gone to lengths to ensure they are chosen fairly, and they are published widely on TV, internet, newspapers etc.  You could view the latest bitcoin block hash as a bit like a beacon.  Even the miner cant control all the bits - it costs him enormous computation just to control the first 55 bits (current log2 target).  There are another 101 bits he cant control; he could control 1 bit by doubling his effort and reducing his mining reward by 1/2 etc.  To control them all is considered impossible.Say each user, or users collaboratively store the sequence of beacons and vouch for the correctness.  (In the case of the a time-stamp merkle hash chain, used as a beacon it helps you verify that because each block hash includes the previous hash in its preimage.)You might wander if one could use an abstract beacon for timestamping (beacon without preimage chain).  Could use a beacon to prove that you made a transaction, or mined a pool-sized mining share at a given point in time?  Not fully: if you include a hash of a beacon in your mined pool share, or transaction signature, then you do prove that you did that after the beacon.  However you can also back-date your operation.  Eg you could intentionally include an old beacon value.  Because bitcoin is more concerned about back-dating than forward dating, it doesnt help much.  (Bitcoin concerns itself with first to do something, not last).To prevent backdating, bitcoin (and time-stamp servers, and auditable name-spaces) put the hash that you are dating into the "beacon".  That proves it was published then.  It may also have been published earlier (ignoring validation), but at least you cant create something and then try to change its date of publication.Unfortunately to prevent backdating seems to require transmitting all values to the timestamper/namespace manager.  And in a distributed timestamper/namespace manager broadcasting to all full nodes.A namespace manager also wants to enforce first come first served (no name reuse) so it enforces that it wont stamp names (or name hashes) that it has seen before.  (If the names are random looking like public keys, hashing names is secure against brute-force, unlike hashing domain names or email addresses, so with bitcoin, like with document time-stamping you are not revealing the document/public key at the time of publication).Adam I've been trying to understand the relationship between timestamping, namespaces and validation in bitcoin.Bitcoin is described as relying on a timestamping service.  Now in existing (non-bitcoin) time-stamping service, merkle trees are used to hash a set of documents users want to time stamp during a period into a merkle tree.  The merkle tree root is published (assumed unchangeable)  The previous periods merkle root is also hashed into the current merkle tree, to prevent historic modification.  (Just like bitcoin in fact so far).  The time-stamp server may sign the merkle root; bitcoin substitutes a distributed attempt to create a proof-of-work for a signature that the current majority by CPU power agree is correct.But bitcoin is more than a timestamping of transactions.  Timestamping does not guarantee uniqueness.  Users are allowed to stamp the same document more than once.So lets consider a less distributed bitcoin where peers rely on a time stamping service.  Consider it has only full nodes for now.  To know transactions are not double spent they have to track all documents (transactions) hashed by the timestamp server each time period.  If the timestamp server signs its hash every period, if it ever cheated and issued a second merkle root for the same period, all peers would have a proof (and could migrate the timestamping over to a competing time-stamp service).However that is not convenient for SPV nodes, the only way to know a transaction was not already spent is to look at all time-stamped documents (transactions) ever.Namespaces have the missing property.  A namespace manages and allocates names on a first come first served basis.  The same name is not allowed to be issued twice.  For bitcoin purposes we'll consider names do not expire and so do not become available for recycling.We could use a namespace to implement bitcoin.  Eg consider DNS name .bitcoin operated by a somehow trustworthy registrar with the first come first served, never expire policy.  Now we could mine by being the first to claim the name being a hashcash stamp (mined as bitcoin on the hash of a public key).  Stamps which dont match difficulty are ignored or rejected.  When we spend we claim the name being the public key and output.  As owner of the name we can attach txt records to it (eg the signed transaction including the public key hash of the new owner).  For bitcoin purposes transactions which are not signed are ignored or rejected and with names (public key+outputs) that dont correspond to previous txt records (public key hashes of coin owners) are ignored or rejected.Namespaces can be some-what distributed but publicly auditable to reduce or even avoid any trust in the registrar.  eg http://cypherspace.org/p2p/auditable-namespace.htmlIf no trustworthy registrar could be established, the protocol could fall back to current the full p2p bitcoin namespace of the list of transactions.Bitcoin does one more thing beyond namespace management which is to expect the miner (distributed transaction namespace node) to validate transactions.  Meaning that the inputs have sufficient value to cover the outputs.  That implements coin splitting and combining.  SPV nodes even rely on that, full nodes check it themselves.Note that with the exception of validation, a namespace manager (auditable and being distributed, somewhat-distributed, or even central) does not need to know the names nor documents.  ie It is normally the case that a time-stamping service does not know the contents of the documents it is stamping.  Eg because they are published in hash form, or hash of non-malleable encrypted form.  The same can be true for namespaces.  It reduces the need to trust a time-stamp server or name-space server if it doesnt know what it is timestamping/allocating names of.  That is because it cant apply apriori policies about whose documents it will process, nor what the documents can contain, nor who they can be addressed to if it doesnt see the document.  And it can not undetectably revise history because of the published chain of merkle hash roots.  And if it does detectably revise history, other servers or peers in a p2p protocol can reconstruct the true history.  Consequently a mostly trustworthy server (say 99% of transactions have no attempt to modify history by the server) we can still leverage service from such a server.  Its easier to scale such a server and users can then concentrate on validation and reconstruction and repair of history revisions which is a 1% problem vs a 100% problem.Adam So one thing you could think of and I think it has been mentioned a few times is that you could replace the merkle tree in bitcoin with an accumulator based tree.  Now a problem with accumulators is someone or some set of n people only 1 of whom has to be trusted, have to create n = p*q two primes p, q and then delete p, q; which is not great but could be entertained perhaps if accumulators made some big saving.Consider accumulator hashes: then an SPV client can be convinced a coin is in a block by receiving Bi and xi.  Each Bi is 384 bytes (3072bit RSA n is about the same security margin as the rest of bitcoin, considered about as secure as 128-bit symmetric keys and 256-bit EC keys).  Then a proof of membership within a block is 384 bytes + the hash say 20 bytes + the transaction detail whatever that is a hundred bytes say 512bytes.  The merkle tree approach requires log2(k) hashes each 32 bytes, k the number of transactions in a block.  I guess a block could hold ~10,000 transactions best case with 1MB blocks.  However this page https://en.bitcoin.it/wiki/Scalability says transactions per second is currently limited to 7 = 4200/block.  log2(4200) ~12 and 12*32=384 bytes.  No saving for accumulators!However another trick could be to not start a new accumulator with each block, just keep going, then you only need the last block in the chain.  (SPV clients download all blocks, or some set of recent blocks for confidence?)   So with accumulators to catch up an SPV client just download the latest block, cross-check a few peers agree its the latest block.  However someone (each full node?) would have to update Bi for all unspent coins.  Updating Bi is a 3072-bit to a 256-bit modexp operation which has some cost.   That might start to get unreasonably CPU expensive, unless the network shares out the work.  The benefit would be faster catchup for SPV clients.I suppose alternatively blocks themselvs could be placed into a sorted merkle tree, and then SPV clients could download blocks as needed (log2(b) blocks where b is 23866 blocks so far http://blockexplorer.com/q/getblockcount) ~15 blocks to test a given block.  But its probably not a big saving because transactions are made from multiple outputs and an SPV client if it does a few transactions per day will soon have to download all blocks anyway. Or you could have an accumulator tree of blocks, with the accumulator hashed in the latest block.  Then you can download any historic block and instantly check it belongs in the history of the current block without downloading the rest of the block chain, nor 15 blocks for log2(b) verification if the block were organized as a merkle tree.  Cost is each full node needs to update (or fullnodes cooperatively update) the Bi values for all 23866 blocks every block (10mins).Some possibilities in there but nothing very impressive, plus the problem of there temporarily existing an accumulator private key that must be deleted (spread across the RAM of n users during accumulator genesis/generation, only one of which needs to be trustworthy).Adam Another thing CPU cores have going for them over GPU is they are independent.  AMD GPU cores are in SIMD groups, eg 7970 has 2048 cores, but groups of 16 of them have to execute the same instruction each clock on different data, that means if you force them to do dynamic work, there are only really 128 cores that can do independent dynamic work.  And the cores are about 32x slower than a CPU core.  So then a four core CPU matches a GPU for dynamic workloads.However again that is not a good ASIC-hard direction because the SIMD nature of AMD GPUs is overcomeable eg http://www.adapteva.com with a MIMD (ie no SIMD restrictions) 28nm 64 core risc CPU and plans for 1024 even 4096 risc cores per chip.  And they are low energy too.Adam I can see the attraction of CPUs however if you optimized for the CPU to the detriment of the GPU, that leaks possible advantages to ASICs over GPUs.  I think about all you can say that a CPU has is faster single core performance (irrelevant for mining: more compute bandwidth is more important than per core speed).  And main memory readable over a narrow bus (DDR3 64-bit vs DDR5 over 384-bit).  GDDR5 in an AMD 7970 is quad-pumped at 1500MT with 384-bit data bus where as DDR3 is dual-pumped a 1333MT or 1600MT etc similar speed.  So if you are reading random chunks in CPU friendly 64-bit chunks the GPU ram is still 2x speed (quad vs dual pump) even though its 6x bus-width advantage is wasted for random access.  However i7s have two memory channels so they match the GPU for 64-bit reads.  Some CPUs eg 3930k have quad channels so they can do 2x that and beat a GPU.  i7 3930k rated at 51.2GB/sec memory, regular i7 at 25.6GB/sec bandwidth, amd 7970 rated at 288GB/sec but in terms of ability to read 64-bit chunks the 7970 would do 6x less = 48GB/sec.However the peak figures are in sequential read, DDR3 and GDDR5 are both slower with random reads.  And thrashing RAM with reads for data intentionally too big to fit in L3 is going to bog your computer down for normal use.Adam
I am not sure the ASICs actually have any protocol choice power.  If bitcoin main developer branch for some reason decided to phase in a new mining algorithm, the choice is actually the users.  If the users agree, they will keep on the main branch and accept the algorithm phase in.  If they dont someone forks the code, and the users migrate over to a new fork.If there was a code fork like that where both forks accepted the existing coins created up to the fork date as valid, that might be kind of strange sort of like an alt-coin that accepts bticoins up to a hard-fork point in time.Adam Btw I made a summary of the zerocoin paper here.  http://www.mail-archive.com/cryptography@randombit.net/msg04117.htmlNot sure it helps understand it or not, but there you go.About ZKP of set-membership the first thing to understand is the RSA accumulator of Benaloh.  http://www.cs.stevens.edu/~mdemare/pubs/owa.pdfIts like a commutative hash function but using RSA.  With discrete log (or EC discrete log) if i give you A = xG (G is base point x some random number) I can prove I know the discrete log by showing you x and G is fixed.  But if you are allowed to use any generator H then you can start with A divide it by some random number x and call the result H.  Now you can prove xH = A but that doesnt prove anything as anyone can do that if they can prove the discrete log to some random base its an x-th root not a discrete log, which is easy .  How you "divide" A by x is multiply by x^-1 mod n (n is the order of the curve a public known value for a EC parameter set).  And you can compute x^-1 mod n easily with euclidean algorithm (normal modular math, no EC).However the analogous division is not possible with RSA, in RSA computing x-th roots is also hard (as well as discrete log).  eg If I give you A you cant compute A^(x^-1) because x^-1 has to be mod phi(n) = (p-1)*(q-1), and in the case of RSA phi(n) is secret and in the case of an accumulator p, q, phi(n) are supposed to be deleted after setup so no-one knows them.  So if I can show you H and x and H^x = A that proves you I had an influence in producing A.  each step is done by the user after receiving the previous accum set.  Users can go in any order as exponentiation is commutative.G and n is published, p, q deletedstep0: accum set = {G}user1: private x1, accum set = {G,A"=G^x1}user2: private x2, accum set = {G^x2,G^x1,A'=G^x1^x2}user3: private x3, accum set = {G^x2^x3,G^x1^x3,G^x1^x2,A=G^x1^x1^x3}The accum set is broadcast by each user and each user raises every element except the last to his private exponent xi, and appends the last element raised to his private exponent xi.You notice that the base of each user is missing the exponent of his respective xi, user1 base is missing x1 (first item in set), user 2 is missing x2 (second item in set), user 3 is missing x3 (third item in set).  Consequently a user can raise his private base call it Bi for user i, to power xi and get A the global accumulator Bi^xi = A.  Because discrete log and x-th roots are hard in RSA he cant do that unless he was involved in this process.That involves a lot of sending of sets.  If alternatively each user broadcasts his xi, everyone can compute his own Bi and the final A, however now anyone can compute any Bi and all xi are public.  Its a lot more communication efficient however.  To combat the fact that xi are public, xi has to be chosen eg as xi = H( yi ) where yi is secret.  Then a user can prove that by revealing yi and having the verifier check xi = H( yi ) and Bi^xi = A.Or as its hard to efficiently make ZKP about (symmetric) one way hash functions a discrete log "hash" function could be used eg xi = H^yi.  Now the user could prove knowledge of yi without revealing yi (via a Schnorr signature see below).So lots of people compute and pass those messages around then they can prove simply that their zerocoin is in the set until there is a final A that includes contributions from all users who produced zerocoins in this time period.  And each user knows a Bi such that Bi^xi = A for the single A value so they can prove membership.  The order is commutative so it doesnt matter which comes first.  A is small - just 2048 bits = 256bytes no matter how any serial numbers are provable against it.  Bi is also small 256bytes as well as is xi.  And the user need only store Bi and xi because he can compute A from it.So that provides a proof that you had an influence on an accumulator (some non-secret value of yours was included "hashed" into an accumulator).  Its rather like a merkle tree except that you dont need to provide log n path in the three to prove, just prove you know Bi^xi = A.So far thats not private as all Bi values are recognizable to anyone who saw them.  However using an extended blind schnorr signature like proof where you can prove you must know such an xi and Bi without actually revealing them.  Its ZKP because the verifier could even create a fake if he choose the challenge himself so therefore you can argue he couldnt learn anything about Bi nor xi from something he could've created yourself.  A schnorr proof of knowledge to get an idea how you could prove something similar is related to a DSA signature and relatively simple eg here.  http://en.wikipedia.org/wiki/Schnorr_signature and its the same concept as DSA, ECDSA etc - ie you can prove you know the discrete log of something, without actually revealing the discrete log!A schnorr proof only hides xi, the zerocoin enhanced proof also hides Bi but the basic idea is the same.The efficiency problem in zerocoin is that each run of the ZKP has a 1/2 chance of being unconvincing.  So you have to run it like 128-times to get probability 1/2^128 kinds of cryptographic assurance.  This repetition is called cut-and-choose.  Fortunately it can be made non interactive (by fixing the challenges based on a one-way hash of the parameters), but thats still 128 x 2048-bit RSA things which is like 10s of kB.  Probably they are doing a bit less than 128 cut-and-choose rounds because they say that proof size is 45kB for 2048-bit and I presume a proof includes at least 2x 2048-bit values.  Actually I see they say 80x, so that comes out to 2.2 so maybe there is some auxilliary info, eg the serial number?To prevent double spending they just keep a public list of spent zerocoin serial numbers, and you cant influence the serial number after the fact.So I guess the other thing you can do if that is unnecessarily complicated is just say ok there's a ZKP of set membership which proves your coin is one of that set, but not which one and trust that people have figured out how to make that work.btw Benaloh's accumulator paper is quite readable [edit: fix error about xi vs Bi and give a small example][edit2: more communication efficient public xi = H^yi, secret yi or xi = H( yi ) version]Adam One issue I was noticing with committed coins is you cant send to someone who is offline as you need to direct-send them the decommittment.Here's  a way to fix that while retaining compact addresses.  The address public key becomes no longer secret and not used for direct receiving, rather for self-signing further sub-keys only.  Then an encryption (public) sub-key can be signed with the address public key.  And a separate receive sub-address = H( receive-pub-key ) relating to corresponding (unpublished) receiv sub-pub-key.  The self-signed set of sub-keys is broadcast and available for download from all peers, keyed by address (hash of public key).  (This is quite analogous to looking up someone's PGP/GPG key based on fingerprint, where a PGP key includes a top-level DSA key and then one or more sub-keys for Elgamal etc.)So in that way you still keep the compact address, and the sender can lookup:pub-key, sig( enc-pub-key, receive-addr ) keyed by addr = H( pub-key )Then blind committed transactions become:receive-addr, PKE( enc-pub-key, sender-receive-pub-key ), H( sender-receive-pub-key), E( sender-receive-pub-key, transaction )PKE is public key encrypt, E is authenticated symmetric cipher mode.probably could be optimized in some ways, but a proof of concept.  Therecipient is identified, which is a loss, but optionally can be fixed withstego, at some cost; and recipient can and is encouraged to create newrecipient addresses is another defense.Probably you could reuse the sig pub key as an encryption pub key, but as adesign principle that adds risk.Both committed and non-committed transactions would have to use the receive-addr.The mechanism of self-signed sub-keys could allow self-certified identity (eg put your email address as one of the attributes), and could allow you to change your receive-address, or update a set of receive addresses gradually without changing your identity and base address.Adam It seems at that point that all the block chain and miners are doing is helping users order transactions that it doesnt know much about.Well thats true, however anyone can be a miner, so all full clients need the fee information, and the fee is used in the broadcast to prevent flooding/spamming, so probably the information that is broadcast needs to carry its own fee information.  It would not however have to go into the block, that is just to prevent spamming.It does seem to be true that not much needs to go into the block (eg just the blind commitment in a merkle tree) and when you're validating information about a specific payment it is just a few small pieces of info that you need, not a whole block worth of validatable information.  For commitments it seems that its better not to require reveals go in the block as then there is no conflict with miners trying to exclude them.Adam Yes, I think censoring transaction reveals matters less because the transaction has actually already completed in blind form, and can continue to be spent in blind form.If the dishonest miners have a lot more power than honest miners so that they could forcibly make any acceptance of honest reveals into orphans yes.  Though payments can continue.Also I notice that there is no actual need for mining of reveals, they were already mined in blind form.  They can simply be made available p2p for download by user clients.  They can easily be verified as correct with out need for high hashing power confirmations, the only validation needed is that they hash to a previous blind commit in the block chain.I think the wallet storage for a blind transaction even after a long chain is simply the set of public keys for the addresses in the last hop unspent output set.  That is because you can validate a blind coin by iterating backwards if you have the last hop public keys, you can decrypt the commitment.  Then you see the public key of the previous hop, so you fetch the previous committed transaction, decrypt it and get keys for next hop etc until you reach a mined coin or a non-blind transaction.  So the wallet itself doesnt really grow.  The validation procedure becomes longer and eventually the privacy eroded if many users are party to it (each user only has visibility of the transactions before, not after; but a user being the last hop in a long chain sees a lot of history).  No worse than now, just not helping privacy that much long term.I think the answer maybe above, to not require reveals to be hashed a second time into the block.  Just have peers make them available for download, there is no DoS as they can be validated back to their hash which is already cemented into the block chain in blind form.  If no mining is required on reveals, then there is no need to trust miners to process them.  And users can reveal at their convenience without the need for cooperation from miners.Its hard to allocate blame.  The dishonest miner may say it is the revealer that dropped the connection part way through and so falsely claim he never received it.Adam I tried to retain the existing bitcoin semantic that first spend is valid, later double-spends are invalid and rejected (whether the spend is blind or non-blind).I think what you said was that it could be possible to have unblind transactions take priority over blind transactions.  You could define it that way but it might create problems I think.  Eg say you accept  a blind transaction after one confirmation then you pay it to someone else.  But the second block has a double-spend with a non-blind transaction in it.  Now according to the one block confirmation view the blind transaction is valid, but according to the two block confirmation view the non-blind transaction is valid (and the blind one invalid).  What if you try to spend it with someone who expects two block confirmations, and goes and looks and sees that according to that definition the blind coin should be rejected?Its somewhat but not quite analogous with the confirmations required in bitcoin now, because those can only be undone by orphans which are expected to be increasingly rare (longer orphan chain is increasingly less likely) or require a lot of resources by a dishonest entity to create.Conversely revealing a non-blind transaction has no cost and can be done at any time for no cost by the original owner.  Maybe it has no effect if it happens after a given number of confirmations.  eg if everyone agreed that six confirmations were always required, then it could work, as the recipient can just check that there are no overriding non-blind transactions during the six blocks that came after the blind transaction.  So I think the problem is if people have differing preferences for how many blocks of confirmation they require (of no double-spend event happening) then one type of transaction (non-blind) overriding another type of transaction (blind) becomes a problem.Adam Well I am saying the dishonest miners must not be able to guess with good confidence that the transaction involves tainted coins or other information like who is paying or receiving, or they can reject them even though they are blinded, ie if that happens the blinding was ineffective.About necessity of using addresses & public keys: one clear requirement is that double spending must be prevented, and the way that works is that if you double spend a non-blind version of an unspent output then a signature is provided to prove ownership of the output.  And a signature always includes the public key to allow the signature to be verified.  The public key was previously unknown (before spending) and so could serve as a blinding factorSo the main trick is that if the public key is used as the only non-public blinding factor, then double spending in non-blind form will unblind and expose double spend attempts.We cant use eg the recipients address in as the blinding-factor because we want one recipient to be able to tell that the sender tried to double spend an output with another recipient.  If the recipient doesnt know the other recipients address, he would be unable to detect double-spending.So the commitment looks like(com1,com2) = SHA1( SHA256( pub ) ), AES-CCM( key, transaction )where key = SHA256( pub ).There has to be separate blinding per unspent output used because the UTXOs could be double-spent separately.  So a blind transaction could include a list of blind commitments and a plaintext fee to pay for the processing of the blind transaction.  The fee should be extremely taint free.  The fee may optionally be paid by the recipient.Adam If the destination address is re-used that might be guessable, but people are discouraged from re-using addresses.  I am not sure about scripts - I suppose scripts contain addresses or they become insecure also so the same applies?Adam Well they could iterate over UTXOs and amounts looking for a permutation and amount that results in that hash.  It might take a bit of computation but if you're talking about attacks you have to consider eg 2^50 operations and such things  the miner has a lot of CPU power as it is.If there are one-use addresses in the commitment that becomes basically impossible.Adam If there are legitimate situations where scripts do not contain an address (that is disclosed by the corresponding signature during a spend) it maybe difficult to blind those scenarios.Well if there is no non-public info (like the public key is not public even though the address which is the hash of it is public) then people can guess which transaction is hashed to form the commitment, and then they will not be effectively blind.  We want the transactions to be blind so that dishonest miners can not make taint or sender/recipient based policy decisions.  The other key part is that the public key becomes public unavoidably as part of a non-blind spend.  Those two features are necessary seemingly to make blind commitments work and yet prevent double spending.Adam I think it maybe that it should more accurately commit an unspent transaction output and the address in control of it.  How would you identify or serialize that?(I am taking it that balance is not on the address as such, but that each not yet spent transaction output is owned by an address, and can be spent in its entirety in a transaction?)I think for privacy bitcoin discourages address reuse so it maybe that the difference is not much.  eg hash of transaction identifier, output number and public key (that is the basis for the address).  It is only the public key that is not already public, and something non-public has to go into the commitment.Adam I think one could make a mining function which was fairly hard to gain an advantage with using ASICs.  But I do think you have to target GPUs because a GPU is basically a better CPU.  The CPU has a lot of resources dedicated to optimizing the single thread execution speed (eg super scalarity, out-of-order execution etc).  Alternatively GPUs dont have that.  A 7970 has basically a 2048 RISC cores.  So I think you want to optimize for the characteristics of the GPU.  Memory line size, cache architecture, instruction set.  Make all of those things work hard, and dynamically, but in proportion to the resources the GPU has.  eg some integer instructions, some FP instructions, some memory.Then a would be ASIC miner has to make a better GPU.  AMD is putting quite a lot of resources into that.Also I think we could have automatically balanced algorithm mining, including mining parameters.  So the idea is anyone can introduce a new algorithm or new set of algorithm parameters.  Presumably with some public review process so that there is no trapdoor known only to the introducer.  Then each algorithm has a floating separate difficulty set by the network.  The difficulty inflation is set so that the algorithm which appears last susceptible empirically to inflation is he inflation target.  Other algorithms have their difficulty adjusted so that their inflation matches the minimum inflation algorithm.  So eg if SHA256 hashcash mining has a big batch of new fast ASICs come online, to the extent that difficulty gets much harder quickly, the difficulty is increased faster yet so that the proportion of coins producible with SHA256 mining falls and the other mining functions rise.Adam It was made by Dan Kaminsky in the comments section of his wired article.  See this thread:https://bitcointalk.org/index.php?topic=194554.msg2078882#msg2078882My view they cant do that.  If the client accepts only blind coins, or has a switch in it that can be toggled to only do so, then the dishonest miner either has to follow the protocol and mine blind coins, or leave and form their own alt-coin without blind coins (or join an existing alt-coin without blind coins).  It might be lonely and unprofitable on that network however if there are no users who want their coins subjected to dishonest miner policy Lots of hash power doesnt mean an alt-coin becomes popular nor profitable to mine after all.  Popularity comes from the users, and profitability from the interest of users to buy the coins.You can consider a network with miners that reject coins based on centrally applied policy as like a file sharing network that wont let you share files that have given hashes as enforced by a few big players for whatever reason.  Presumably people wont like that and will stick to the less restricted network.Adam I dont know the bitcoin script language well enough to have a good answer for that.  Someone on the dev list did comment on that aspect:also:I guess the next step unless iddo finds a flaw is to write up a BIP and get help with the simplest way to integrate from people who understand the script language well.  (And learn the script language myself!)  Well maybe a short white paper describing the detail wouldnt hurt before that even as so far the detail is spread out over a few posts on this thread.Adam Going back to the commit definition (symmetric version, with defense against insider commit to junk):The point of the use of K = SHA-256( pub ) is that anyone in possession of the public key can decrypt, and verify the mac.  That means direct spend-to-junk is not possible by someone without knowledge of pub.  Now of course anyone with knowledge of pub could superficially spend to junk, however as pub allows decrypt and mac check, superficial junk is fast to detect and remove, just by validating the mac.  And a more subtle spend to junk (by someone knowing pub) cant work as the coin is ignored as junk unless the MAC passes, and unless the decrypted tx contains a valid signature from pub.yes Bob accepts the blind commitment payment after waiting however many confirmations he requires.   He does have the decommitted value Alice sent him directly (without broadcasting) so he can validate.if Alice double spends non-blind she definitionally reveals her public key, and so allows anyone to correlate with any blind commitments with the same key, and validate them, and so presuming the blind commitments are not all fakes, the secondary txn is rejected unless there are remaining sufficient funds on the address to fulfill it also.Alternatively if Alice tried to double spend in blind committed form, the committed sender address would be the same and the recipient who needs to validate would receive the decomitted value over a private channel, and be able to validate the committed transactions.  (Validation includes discarding junk commitments).No reversing.  See above the secondary (double-spent non-blind) txn is rejected.  So decommiting the first (committed) transaction just optionally exposes more details about the committed transaction.Overall the picture with blind and non-blind transactions however you mix them and whichever comes first and how much money is left on the input address after processing, is just like standard transactions.  First is accepted, later are rejected as double spends.  Despite the blinding you can still tell because two blind committed transactions with the same input address are hashed deterministically so SHA1( SHA256( pub ) ) is the same in both cases.  If you send a non-blind transaction that is also correlatable to blind addresses because the public key is revealed as part of the signature.OK this is a second issue - an insider who knows pub, was an issue with the straight hash-based commitment of the transaction.  This is why I said in a later mail (as quoted at the top of this message) encrypting and use of a MAC is more robust, and safely allows multiple use addresses, because it defends against that issue.As you indicate preventing other users sending multiple times to the same address is problematic.so lets say Alice is malicious, Eve is malicious but doesnt know pub, Mallory is malicious and does know pub (eg because she gave the committed coin to Alice) but Bob wants to send Alice her goods after 1 confirmation anyway provided there is no double spending within that time-period.Com( pub, tx-commit ) = (blind-sender, auth, encrypted-tx-commit)        blind-sender = SHA1( SHA256( pub ) )        auth = HMAC-SHA256-128( K, encrypted-tx-commit )        encrypted-tx-commit = AES( K, tx-commit )        K = SHA-256( pub )(A: indicates A broadcasts, A->B: indicates A sends to B private channel)Alice: Com( A, "A spends 1BTC to B" )Alice -> Bob: pubAlice: Com( A, "A spends 1BTC to A" )Eve: blind-sender, auth, junk    [blind-sender & auth copied from Alice commit]Mallory: Com( A, "A spends 1BTC to M" )Eve -> Bob     [cant send pub as doesnt know it]Mallory -> Bob: pubBob can validate Alice's first spend as he has the pub.Bob can also validate Alice's attempted double spend to herself.  However so long as the confirmation rejects the second one, it doesnt matter.  Normal bitcoin double spend semantics: first spend to reach the winning miner is valid.now Bob can see that Eve's message is junk because the junk doesnt match the auth tag.Bob cant tell as easily with Mallory's message as she has pub and so K; but still the tx-commitdecrypted from Mallory's message has no valid signature, as Mallory can not forge signature with Alice's key.Bob waits 1 confirmation, and as the double spend from Alice to herself was not hashed by the winning miner, and the two fake commits from Eve and Mallory are the only other transactions relating to Alice's input, he accepts and sends the goods.Bob nor Alice have to reveal.  They may opt to decommit after the transaction is long confirmed.Bob can pay Carol who can pay Dave etc all without necessarily decommitting.Each person in the chain of committed spends must see all transaction details earlier in the chain to verify its validity.  They learn this conveniently because they see the public key of the tx-commit, and from that can see the public key of the sender.  That in turn allows them to lookup the SHA1( SHA256( pub ) ) of the sender, and from that transaction learn the pub key of the previous sender and so on until they see a non-committed transaction, or a mined coin.Adam I dont think you need to prevent reuse.  It just means you have to allow duplicates (same committed send address).  And the recipient has to get reveals for all of the associated spends to validate.If you wanted to it should be enough to have clients reject any other than the first on validation, and senders randomize it for you.The recipient of the de-committed tx will have to go look at all of the matching inputs.  I think the recipients client needs to store and index by committed pub key all of the payments to him.  He can do that as they arrive (doesnt need to do it afterwards) looking backwards.  So he has like a pool of not yet decomitted received transactions.  Ones that he has processed he can probably combine into his UTXO if I get that concept.Adam That does make sense I see.  I get that you understand this but to note the committed value is the senders public key not the recipients.  [ Com( sender-pub ), Com( transaction ) ].  So the sender necessarily has to have access to his private key, and anyway at that point the sender-pub is fixed because it was a former recipient address.The issue between committed coins and type-2 address generation you mention is with the recipient address generation.  Arent there already a pool of pre-generated addresses in the client design?  Or maybe the point is you dont need that with type-2.  You do need to store the random value r from P' = rP = rxG.  However so far with normal coins it is not security sensitive.  With committed coins it becomes semi-important (leak pub key, someone can link your committed coins).  However you can solve that with public key encryption of the r values.  ie generate random r, compute addr = RIPEMD160( SHA256( P' = rP ) ); store PKENC( pub, r ), delete r, P'.  PKENC some public key encryption.  You need to be be able to efficiently associate it with the address.  If there is an aspect of deterministically derive rather than encrypt (eg so no wallet backups need to be made or for brain wallets) then just generate r using that scheme and do not store it.  (You will need your seed then, or maybe you can store the head of a hash chain, and replace seed_{i+1} = H( seed_i ) and use r = seed_i.)No because Bob can distinguish fake from real as for Bob to accept the transaction he will expect to receive the decommitted transaction.  Note to protect against fake commits needs the variant with a MAC of something eg the tx commit (so you can prove the fake is a fake, and not a double spend you refuse to disclose the pre-image of - you cant prove a negative ie that you dont know a pre-image).Adam Yes I said that myself also in the post you're referring to:(It was an aside more about the size of committed payments).I dont think it creates  backwards compatibility issue.  If the client is changed to store the public key in the encrypted section as if it were part of the private key, but  the coin address would be stored still in the public section, that would fix the problem in a backwards compatible way, because receiving coins only uses the coin address, not the public key.  Old keys (prior to a client upgrade) that had already had their public keys somewhat exposed by storage on the un-encrypted part of the wallet would need to be marked as not suitable for committed transactions (unless the user is convinced he never spent with the public keys, which the network or his tx log can tell him, and that his backups and machine are secure enough for his purposes without the encryption.)  The only threat from the old keys not being secret is unavailability of the policy defense of committed transactions for the affected coins, and that is the status quo without the fix dishonest miner power centralization fix provided by committed transactions.  If the user is unsure he can try a committed spend.  If it doesnt work as the miner is blocking it, he already had a problem because the miner would've blocked his uncommitted transaction.  He can still try again uncommitted but clearly that is also likely to be blocked.  His only remaining bet is to wait until another miner wins the lottery, includes his payment, and hope the dishonest but >50% miner isnt motivated enough to try to orphan the transaction; he might like to spend the coins in many small parts just to make life difficult for the dishonest miner (so he has to waste power creating many orphans).  I think that might be fixable, but I am not sure it is worth the effort because the verify is slightly slower and if people dont like the problem, they should implement and deploy the solution, not focus on the boundary condition for legacy coins.   It might be possible to create a second different type of commitment that anyone who has seen both the public key and at least one a signature from the public key can verify, but someone who has seen only the public key can not.  That would still be safe because the coin can not be spent without revealing a signature.  That would be a secret key commitment (after secret key certificates that Stefan Brands credentials are based on).  Let me have a play with that it sounds interesting.  I am not sure yet if you can do it deterministically (ie so the recipient doesnt have to scan all secret key commitments is the issue.)  One problem is DSA sigs needlessly complicated Schnorr's base protocol, NIST/NSA did it to avoid paying Schnorr for his patent.  In most ways Schnorr signatures are superior and more flexible than DSA, eg it is easy to make threshold and split key where that gets quite complicated with DSA.  (The Schnorr patent expired in 2008.)Anyway thats the problem committed transactions are trying to fix, that it doesnt work with as much assurance before people upgraded cant really be blamed on the protocol.Also the committed coin cant be locked by someone malicious who knows the public key, because the fake committer doesnt know the private key so the transaction will be bogus.  The real owner of the private key can unlock the fake committed transactions to a committed payment receiver or to the list via decomitting, by posting his public key in a normal signature, which will immediately show there is no committed double spend as the only committed transactions are unsigned fakes.See above, I think all attackers are powerless.  If you see a flaw I'll be interested to discuss it.Adam correct.The attacker doesnt know Alice's pubkey - Alice and Bob keep it secret until the transaction is committed.  Alice & Bob should store it securely (eg encrypt it in their wallets).The point is the coins are already spent by the time of the decommit, because Bob can opt to spend them in committed form, and they are confirmed (eg left for 6-blocks of confirmation before decommitting).Note the coin address of the recipient is all that is seen before the commit by the network.  The coin address is addr = RIPEMD-160( SHA-256( pub key )that does not allow the network to calculate the committed value which is commit = SHA1( SHA-256( pub key ) ) because you cant do that without inverting the hash, which is hard to do.Therefore the network (and anyone) can not correlate txout coin addresses with committed spends until the reveal (or a double spend).However on a normal transaction spending from the address, the spenders actual pub key is revealed in order for the ECDSA signature to be verified as part of the existing bitcoin transaction format.  Because of that at that point, the committment (of txin pub key) can be reproduced by the network, and validated against both double spending, and committed double spending.So as I said Bob could spend in committed form and so could Carol, Dave etc indefinitely.  However if Bob decommits and a dishonest miner does not include the decommit, by doing that he has still not revealed his public key (only his coin address).  Consequently he can react to the dishonest miner and still spend his coin in committed form.  However he should probably wait until the decommit is accepted and confirmed in the block chain by some number of blocks (eg 6) until spending because by spending he reveals his public key, and loses the ability to spend in committed form because as soon as his public key is known to the dishonest miner, the miner can recognize the committed form payment.Part of Bobs reason to commit is to compact his coin.  I suggested another variant on the bitcoin dev list in response to other comments which keeps the committed coin at 64 bytes, however many times it is respent in committed form.  In this way it is simpler for Bob and everyone else to just keep respending the coin in committed form indefinitely.  There maybe SPV costs associated with that however .Adam Actually (public) commit to junk was an attack that I fixed with this modification:however that doesnt change the picture that you need to keep your public key secure for committed transactions, and use it once only also.  So either the client needs to encrypt them, or you could consider the public key alternative I mentioned:and there x is already protected in the wallet.  However gmaxwell has a valid point that one cannot assume ECDSA because the CHECKSIG script action is generalized, pluggable and upgradeable.  And analogs of that particular trick may not be available for other signature schemes.  I guess that rather means that this blind coin has to involve a new script operation that provides the semantics which can then be implemented in a given way, and potentially themselves be upgraded.Adam
The thing is you cant use blinded transactions for fees, because you dont know who the miner will be and the recipient needs to see the revealed transaction.  That could be fixable, but also you cant tell the value of a blinded transaction (nor validate the value even if it were public in the format) unless you're a party to the transaction.  Otherwise I would have liked to say you can use blinded fees also.I think the solution is to change the protocol pre-emptively so only blind coins are valid, other than for reward.  Then if dishonest miners block all transactions, they are not participating in the network, they are just DoSing it for no reward, expending massive amounts of compute and forgone profit, just to jam all transactions by releasing a chain of no-transaction blocks (or dummy transactions to self).  If that were their aim they might just more cheaply and effectively DDoS nodes.  Non-blind for reward only should be client enforceable eg require pay from address to same address with balance to fee. If clients reject and dont forward non-blind transactions which try to abuse fee for payment, the miner cant do anything other than DoS the network.  Note the miner can already do that to the current network (someone with money to burn, >50% of network and no concern for profit or loss relating to his hardware can do a lot of damage).I just meant that a hypothetical direct-mined share (if we could somehow figure out how to make them scale) is a low value reward coin so it has no input and no taint by definition as it has no input and no history.  Its completely anonymous and so not subjectable to policy.  Also as fees are low in relation to payments, it should be cheap enough that you could mine it yourself on demand on GPU or maybe even CPU.Adam It was too abbreviated there.  The more accurate version was in a later post in this thread:The idea is to use a different, but also one-way hash. Which can be the same hash function with a fixed prefix concatenated to make it different eg string "1" ( eg 1||public key ).  Then even though you see H( pub-key ) you cant compute H( 1||pub-key ) without computing the hash preimage which is hard.  And the coin address is just H( pub )  (actually RIPEMD160( SHA256( pub ) )) so you dont know pub until someone spends the coin either conventional transaction or committed transaction.  In both cases you can then verify double spend against normal transactions and committed transactions.Also on the dev list I thought of and fixed a minor insider attack so it really needs to include also a MAC of the tx-commit value or someone can create fake committed transactions that look like you made, but you cant disprove (because you cant compute the hash preimage on junk).  The MAC allows you to believably disavow them because their MAC will be wrong.And it looks like I forgot to define K = SHA-256( pub ).Also I suggested a public key variant, however the above is faster to verify for validators.Adam The committed transactions have to include fees (in the clear outside of he commitment), like normal transactions, then if you do that the miners get rich and you get poor.Clearly the spender needs to use coins that he thinks the miners are not going to have a policy against for his fees.(Ideally we would have direct mineable shares, so that fees could be low enough you can mine them on your GPU without linking, and have them earn direct reward.  However that is a different topic.)Adam No because an attempt to pre-spend a committed transaction, via a normal transaction, can be validated against committed transactions.  That is because a normal transaction necessarily includes the address public key, for validation of the ECDSA signature on the transaction.  Then the network can see that the hash of the public key has already been spent via an earlier commitment and so the pre-spend attempt is rejected.As soon as the commit has reached 6-blocks the coin is spent, whether or not its revealed publicly.  That is because a recipient can spend it in committed form via a second commitment (with the address he received it with).  If Bob uses the same commit protocol with Carol, he can send her both the committed tx he received from Alice, and his own new committed tx.Revealing the commitment to the network at all, ever is just to compact the committed coin size which grows with each committed spend.  So even if or when the transaction is revealed to the network, the dishonest mining cartel has a choice: either ignore the compaction request (which doesnt stop it, just delays the owners attempt to compact his coin... eventually another mine will accept it),  or he can include it (desired outcome), or finally and very difficult the dishonest miner has to recompute the chain and create a fork back to the initial commitment which is at this point likely some weeks under.  That seems quite impractical and people can play games with the dishonest miner to waste all his compute fighting his own power by revealing fresh policy bait coins frequently enough that the dishonest miner never completes a fork.  He has to restart the fork attempt from the oldest coin depth each time!You might think the coin growing each time is bad, but actually its saving the network bandwidth.  Consider if you are able to compact your coin, by having he miners accept it, all full  nodes in the network must receive it and process it.  If you spend it in committed fashion only the new commitment goes to the network, the payment happens direct between nodes.  Note the commitment is 2-3x smaller than an actual transaction.Adam The commitment is blind - the miner, nor anyone else other than the spender can tell which input the committed (blind) transaction relates to, nor who the sender is, nor who the recipient is, nor the amount.  When there is no information miners cant apply a selective policy - all they can do is random DoS which loses them fees.  If this is part of the protocol, which I argue it should be, and all payments happen this way they have no choice - they either have to play honestly or fork the protocol.  (Go form an alt-coin with a revised protocol, otherwise network continues without them.)So the blind commitment goes into the block chain.  It sits there until the recipient discloses it, which will be after 6-blocks, or longer if they wait until they come to re-spend it, or maybe never even, because they can re-spend coins in committed form equally well.  If the recipient chooses to reveal the commitment (send the committed transaction) to the network, the network can either include it in later blocks or not.  If they do not, it does not alter the validity and irrevocability of the transaction, as the recipient can still re-spend committed transactions in the same way.  The only motive to even reveal commitments to the block chain is to compact your wallet (otherwise you have to keep the committed transaction chain as coins grow on each committed coin spend, you have to reveal the whole transaction history to the next recipient so they can check it relative to the commitments on the block chain for double spending).Note committed transactions are more compact than regular transactions - they are just two hashes, so they reduce network bandwidth and make bitcoin more scalable to the extent that transaction reveals stay off network.  (As well as more secure against centralization policy risks).The commitments do reside on the block chain, but they are blind.  So no selective policy can be applied to them.The point is the transaction once revealed is already done in the eyes of the recipient, and everyone else, including the miner cartel.  You dont even need to reveal it to the network, thats just optional committed coin transaction chain compaction.The only way for the cartel to undo a subsequently revealed committed transaction it is to redo all the work that piled on top of the commitment (which the cartel did the bulk of themselves!).  That might be 6-blocks or 100-blocks or 1000-blocks (a week).  Even if a cartel with 75% of the network power tried to do that its difficult.  In the time they compute a fresh 6-blocks, the rest of the network has 2-more blocks.  Also each time a new committed transaction is revealed that they wish to remove, they have to redo the work from scratch starting another chain fork.  I think it becomes hopeless for them fast, someone can commit a few hundred part payments, and reveal one every time the mining pool gets near 6-block chain fork.  The miners earn no new fees for this work.  I think its game over - they can be trivially made to fight their own compute power perpetually and unprofitably.  Users would become suspicious if a 6-block or 8-block fork formed, they may just reject it outright, or investigate manually to observe that whats going on is some revealed coins are deleted, and whats common about the coins.A user who was concerned could wait thousands of blocks before revealing, or simply live perpetually with a bigger coin (eg a year, you can still re-spend it in its committed form).  Having to frequently fork a year of block work is untenable as a way to impose a policy.  The threat is minimal at this point, and the effort to revoke transactions herculean and un-winnable at volume.Adam Paying to a new address doesnt protect you from arbitrary policies being imposed by fiat by big miners based on the coin source or taint.  I described the example policies which users may find unsatisfactory but be powerless to robustly detect nor prevent with current protocols.  This is a solution to that "(cpu) might makes right" current problem.The inputs are blinded (revealing SHA1( SHA256( public key ) ) and that does not associate with the public key hashed in the input transaction, until the commit is revealed.  There are no attacks because miners can check the validity because when a normal transaction is made the public key is revealed and can be verified against the committed key.  If multiple committed spends are made, the network just serves to order them.  How many of them are needed to add up to the input amount is verified by the recipient.  It is the spenders job to provide the revealed commitment (the committed transaction) to allow them to verify.  When the commitment is revealed back to the network, eg after 6-blocks, or when the recipient spends, or after a few commitment based spends, the network itself can do the value based validation also.  I dont see any attacks.Adam Here's two of my replies to comments on the above on on the dev mailing list.Protocol voting is a vote per user policy preference, not a CPU vote, whichis the point.  Current bitcoin protocol is vulnerable to hard to provearbitrary policies being imposable by a quorum of > 50% miners.  The blindcommitment proposal fixes that, so even an 99% quorum cant easily imposepolicies, which leaves the weaker protocol vote attack as the remainingavenue of attack.  That is a significant qualitative improvement.The feasibility of protocol voting attacks is an open question, but youmight want to consider the seeming unstoppability of p2p protocols for ahint.Bit-commitments are based on deterministic one-way functions eg like SHA1(SHA256( public key ) ) Obviously it has to be a different one-way functionto the coin address calculation which is RIPEMD( SHA256( public key ) ) asthat is already public.  Alternatively it can be a different serializationusing the same hash eg RIPEMD( SHA256( 1 || public key ) ).There is only one commitment possible per public key - so you can onlycreate one commitment that would validate to a receiver, or to thenetwork. The network checks that there are no non-blind double spendsof committedcoins which it can do as spends require disclosure of the public key, whichallows existing commitments to be verified, and it similarly qchecks thatthere are no blind double-commitments.Each committed coin would be:commit = Com( spender pub ), Com( transaction )where Com is implemented as the above hash.  The network just places thecommitments in order as with conventional transactions.The committed coins are not linkable to your non-blind coin because you didnot reveal your public key in the (largely passive) act of receiving to acoin address.The temporary unlinkability (until commitment reveal) is a necessary sideeffect, not a cryptographic anonymity feature like zerocoin.  Thetransactions are identical to bitcoins once revealed.  How long thecommitted transaction chains can be between reveals is an implementationchoice could be 1 hop, or as long as you like.  (Actually it appears to beup to the individual users how long the maximum chain they accept is - thenetwork itself, though ordering the committed spends (if there are multiplespends on the same key) cant even tell how long the commitment paymentchains are).Obviously the first coins in the network ordered committed coins on the samekey up to the coin value are spends as verified by the recipient, the restare double-spend and ignored.  If someone wants to waste fees by sendingmore spends than there inputs thats up to them.Probably the typical user doesnt care about long committed chains  otherthan their wallet will bloat if the chains are too long, so probably theywould periodically compact it by revealing the long chains.  Committed coinsare probably a bit less SPV client friendly, though with correct formattingin the merkle trees between blocks, probably a committed coin holder canprovide enough proof to an SPV client to verify even multi-spend committedcoins directly (without a network feed).About privacy, up to the entire commitment chain can be opened at any time(to other people or to the bitcoin network in general) with the cooperationof any user on the chain (up to the point they saw it), so while the blindcommitment protocol is not vulnerable to a > 50% power quorum unilaterallyimposed policy (without even needing client updates), it is fully dependenton the good will of the recipients for its temporary unlinkability.  Thatsthe point: it puts policy control in the users hands not in the > 50% powerquorum.If you want cryptographic anonymity its better to look to zerocoin.  You mayhave noticed zero coin talked about optional fraud tracing.  Its usuallytrivial to add tracing to an otherwise privay preserving protocol.The blind commitment if implemented as described (and its not obvious how toget more privacy from it) offers somewhat like community policing.  Users onthe chain can still themselves do fraud tracing, or any policy they choose,on any blind committed coins that they receive.  If they dont like thecolour of them they can refund them.  The point is to enforce that this is afree uncoerced community choice, by individual end users, not a > 50% cpupower quorum choice surreptitiously imposed.Adam So in a previous mailhttps://bitcointalk.org/index.php?topic=205533.msg2149057#msg2149057I described a simple, extremely efficient and easy to implement symmetric key commitment that is unlinkable until reveal time (at bottom).  I thinkthis can help improve the byzantine generals problem, that bitcoin only defends to simple majority (with one vote per CPU power), and so assumesmost nodes by cpu power are honest.  With this simple protocol change youdont need any honest nodes, just some honest clients to spend to, to haveyour transaction accepted.You can think of this in terms of a (somewhat distributed) server performingvalidations, but in a way that it sufficiently blind to the details of thevalidations that it can not selectively enforce a policy, it power islimited to random DoS.There are other situations where you can rely on a server for one propertybut not another - eg a somewhat distributed encrypted backup (like TahoeLAFS) you rely on for availability, but not integrity nor confidentiality(because you encrypt those, and some sharing scenarios still work.) So thisis in that class of protocols - zero-trust in server, but can extractservice and some guarantees from the (optionally distributed) server anyway.(Bitcoin does not use known better than majority results for byzantinegenerals based on fair coin toss, relying instead on simple majority and anassumed largely unjammable network.  I notice Nick Szabo was complainingabout this on his blog and saying bitcoins majority is not even a standardor proven byzantine voting protocol - something adhoc.  I think the bitcoinunjammable network assumption is a false at the limit so that someone withstrong network hacking capabilities can create network splits long enough toeven overcome the network majority vote without having any compute power oftheir own.  All they need is to have a split with enough power to plausiblyquickly get the victims their desired number of (split) confirmations.)Anyway this should be a clear voting improvement, that is efficient.Imagine a couple of big pools or ASIC miners started enforcing somearbitrary coin policy, eg say coins must not have some taint according toits list of black coins, or coins must be certified by some entity, betraceable to some type of event etc.  Well call these miners/voters"dishonest", in that they are not following the intended zero-policyprotocol.If the coins dont match their chosen policy, the dishonest miners willrefuse to include transactions in blocks they issue.  If they see atransaction which does not match their policy in a block by someone elsethey will ignore it and try to make it into an orphan.  As they have say 75%of the network power they can do that successfully.  Even with currentvalidation protocols in the clients, so the "but clients wont accept thechange" argument does not apply - the existing clients will accept thepolicy change, because they cant detect it, nor prove it, and dont have thevoting power to impose honest policies.(For realism of this risk, note that according to Kaminsky there alreadyexist multiple entities with reserve ASIC power each exceeding currentnetwork difficulty who are holding part of their power in reserve for profitmaximisation reasons.  This is a coming to fruition of the concentration ofpower issue I was talking about in my first bitcoin forum post.  People whohave that kind of power in reserve have clearly invested millions ofdollars, which probably makes them more vulnerable to political influence.)Alright so the solution.  Use the commitment protocol (below) which eventhough it is symmetric key strongly hides the committed transaction publickey.  (Symmetric in the sense that the validation steps are all highlyefficient symmetric key based).  Now send the transaction (which includesthe public key) direct to the receiver, over a secure channel, or an assumednon-eavesdropped direct channel, with no p2p flood of the transaction.  Thereceiver can check the hash to the commitment, and decide how manyconfirmtions he needs.  Once he has eg 6 confirmations he reveals thecommitment to the transaction (by publishing it).  The sender may also sendthe reveal/transaction to the network directly himself, if the recipient isoffline.  However there is no advantage to publishing early so it seemsbetter to let the recipient do it when he is ready to incorporate thepayment into his wallet.Now the powerful dishonest voters if they try to apply their policy whenthey see the reveal triggers it, must redo the work of the 6-commitmentsthat they computed themselves.  This is like starting 6-steps behind in thestatstical gamblers ruin game that Nakamoto describes in the bitcoinpaper. Consequently even with 75%, they will find it very hard to outcompetetheir own prior work, to create a 6 chain long orphan while the 25% is movingforward on the honest chain.  Each time they see transactions which violatetheir policy, they have to restart their chain recalculation again fromscratch.  Often if simple lower powered intermittent recipient sends thecoin will be burried hundreds of blocks back.  In addition 6 chain longbranches are extremely unlikely with honest payers, so clients can (andmaybe already do?) act with suspicion of they see one.Going further, I said for best security, the recipient should never evenreveal (to the network) until he is actually about to spend, but futher hedoes not even have to reveal publicly ever, he can choose to reveal only tothe recipient with a direct connection (no p2p flood fill of transaction.)And the direct spend argument composes, ie the 2nd recipient can not do thesame thing again.  (public key A sends to public key B sends to public keyC: B publishes COM( transaction B->C ), sends the reveal of COM( transactionA->B ), and COM transaction B->C ) to C.  C waits 6 confirmations and isconvinced.  So its the approach is composable, and in fact the networkdoesnt learn the size of the transaction even, though the spend grows eachtime.  Eventually presumably someone will publish will the confirmations tothe network to trim the tansaction size, though it is not strictlynecessary, and the transaction flow is small and direct (no network scalingissues), so that it wouldnt be a huge problem to have a 1MB paymentrepresenting 1000s of hops of network blind transactions.  (For thecomposable network blind respending the commitment has to commit publicly toboth the sender and next hop recipient keys, so the network can see how longthe chain is).Probably you can cope with multiple inputs and outputs, and maybe given evenyou can work with a 100% dishonest network mining network (all the dishonestminer can do is selectively DoS transactions if they are all network blindexcept the mining), maybe the mining can even be decoupled from the voting,as you no longer demand much from the voting process.  That admits moreinteresting things like pool free direct mining, low variance hashcashcoins, probably.  Many things to think through.I suppose the commitment could be described as a blind symmetric commitment.Adam So I still think that is an important point.  "Ecash should not berevocable".  I think bitcoin currently has a partial problem because oftaint.Now blinding based unlinkability, in a distributed cryptographic payer/payeeanonymous system like Sander & Ta Shma [1] and zerocoin has so far beenbased on ZKP of set membership.  Of course that is somewhat expensive,though zerocoin improved the ZKP with an relatively efficient (but stillcut-and-choose) proof.Bitcoins relative lack of privacy creates a problem with tainted coinsrisking becoming unspendable, or spendable only with some users, or at adiscount.  So while the policy coded says all coins are equally acceptable,the information exists so people can unilaterally reject them, depending onwhat the taint is.  So far revocability hasnt reared it's head that I heard,nor taint inspection too much?  However people have the choice and technicalmeans to check the taint and send the bitcoins back.Another aspect is that bitcoin, like systemics sox/digigold, makes adifferent privacy tradeoff.  Somewhat private, but not very much.But it creates the question: could the taint issue be fixed efficiently (egeven without blinding or ZKP of set membership?)One related concept is commitments.  I think its relatively easy to committo a payment and lock a coin without identifying yourself, until thecommitment is released.  You might do the commitment, wait 6-blocks forconfirmation, then reveal the commitment.  Then that is like a self-issuedgreen coin with no need for trust, that can be immediately cleared.  Therecipient has to be committed to at the same time to prevent doublespending.So just commit = H( input-pub ) H( transaction ) and put it in the blockchain.  Where transaction the is usual ( input signature, output-pub,script).  (Fee for the commit would have to come from an unlinked coin orthe input-pub reveals the coin).  Wait 6 blocks, send/reveal the transaction(free because fee was already paid).  Validators check input-pub hashagainst committed coins by hash, check the transaction hash, and the usualransaction validations = sum inputs, otherwise reject.  The user better paychange if any to a different public key, as the inputs public keys are oneuse - are after the reveal they are DoS lockable by other people repostingH( input-pub ).The input-pub coin is locked as normal transactions have their public key hashvalidate as not being locked.Adam[1] Sander & Ta Shma "Auditable, Anonymous Electronic Cash"    http://www.cs.tau.ac.il/~amnon/Papers/ST.crypto99.pdf So back in 1999, in an ecash thread on cypherpunks I claimed:http://marc.info/?l=cypherpunks&m=95280154629900&w=2> I wouldn't say ecash has to use blinding, but I would argue it would be a> misuse of the word "ecash", if something which was revocable were dubbed> ecash.This was in the context of a discussion of digigold (e-gold stored thephysical gold, digigold offered "ecash" backed in that physical gold).Digigold ran on Systemics payment server/sox protocol.  Because ofinferred regulatory concerns and patent licensing issues digigold & systemics werenot using blind signatures.  However with systemics sox server, likebitcoin, you could create multiple accounts on demand and shuffle paymentsaround for a degree of privacy.  The bitcoin analogy would be thetransaction log lived in the systemics server, so it had a central failurepoint, but arguably more privacy as the log was not public.  Also systemicsSOX protocol (Ian Grigg & Gary Howland) had some aspect of bitcoins smartcontract concepts - ricardian contracts.http://iang.org/papers/ricardian_contract.html(Btw the anonymous reply itself was interesting -http://marc.info/?l=cypherpunks&m=95280154629912&w=2 that could have beenNakamoto, the only missing thing from the parts on the discussion room floorto bitcoin is mathematical inflation control.)The thread actually started herehttp://marc.info/?l=cypherpunks&m=95280154629912&w=2 and then continues herehttp://marc.info/?l=cypherpunks&m=95280154629900&w=2 because of a subjectline change and then http://marc.info/?l=cypherpunks&m=95280154629916&w=2and http://marc.info/?l=cypherpunks&m=95280154629948&w=2more subject line change confusion.A related thread a few days later also covers Sander & Ta-Shma (whichzerocoin is based on):http://marc.info/?l=cypherpunks&m=95280154630167&w=2there were many more threads about various ecash technologies.Adam Well its not really a separate pseudo-currency, because it not spendable, nor respendable by the recipient - its basically emailing failed direct mined shares with the extraNonce containing the recipients email address as an offline verifiable proof to convince the email recipient that you tried for 10 seconds (or whatever) to mine a coin for them.Very infrequently someone will actually win $3000 (25*$120) as a result of this - when the lottery ticket wins.Adam I didnt quite follow the write up either, but it revolves around bitcoin/hashcash merged mining.  Here's my reply from bitcoin-dev: Kaminsky replied on the wired thread:I would think the reason to hold back is economic - if you had 100TH and you mine too hard at 50% spread across a few pools, you reduce your own profit as difficulty adjusts to you.(Deleted my other post here - since Kaminsky posted his comments on the wired article)Adam I thought it was a rather good article.Did everyone notice this later comment by Kaminsky in the comments section:He seems to be claiming that there are multiple dark-miners with ASICs who have enough power to exceed the network, but are holding back for fear of damaging their mining profit.  He's usually quite careful to not make claims he cant back up.You would think someone in that position given the level of investment would not be likely to try double spending, but rather would be out for mining profit.  Its an interesting dynamic though eh - restraint - maybe via explicit or implicit cartel if there are multiple.  Probably some physical oligopoly mining analogy eg diamonds with reduced supply pacts to hold the price and profit up.Adam Bitcoin direct mining is cleverly zero-sum if you shake network difficulty (by pulling out for 2 weeks, then piling in 2 weeks and repeating) due to geometric difficulty adjustment.I think the short intuition for why (pool based) under-contributing difficulty shaking gains an advantage where direct mining can not, is in this case the under-contributor leeches off the pool during his period of under-contributing to make his profit.  With the parameters in my previous post the under-contributor (with his 2 pseudonyms) gains 1/48 and the other pool members lose 1/48.  The gain from network shaking inflation acceleration of 1/24 goes to the other non-pool members.  So a summary under-contributor steals from the pool, and other non-pool miners (or other different pool miners) gain the entire inflation acceleration of 1/24 a unwitting benefactors of the pool shaking.Note there is an electricity cost to under-contributing, while the reward is reduced; however that does not change the viability of the under-contributing attack.  And there is a net win of 1/48 with the parameters, and the electricity cost is the same as playing fair.Two other factors which would need to be taken in to account: 1. network difficulty is growing with moore's law inflation (and right now it is growing above moore's law inflation rate as hardware efficiency is getting closer to current moore's limit with ASICs and more users are joining.)  Consequently if the attacker is not increasing his hardware quantity and efficiency at the same rate  as the network, the first 2 weeks loss may outweigh the pool leeching gain.Factoring in electricity cost, even shaking network difficulty by pulling out can profit because while it is zero-sum, and the hardware amortization is already there, the saves 50% of his electricity cost for the first 2 weeks and his reward is the same.If multiple people are trying to shake difficulty they may cancel each other out if they do not under-contribute or switch off during the same 2 week period.  Therefore they need to collude or observe and implicitly synchronize their attacks to mutually gain.Adam Schadenfreude (doing DoS that costs you but creates costs for others) as you allude probably shouldnt be excluded.  There are people who will do uselessly destructive things because they can even for no gain.I guess you would call that under-contributing ie getting reward share, but not helping win.  I got exited about network shaking about month ago, and investigated it a bit and concluded it was zero sum (other than schadenfreude).  That was because I was thinking in terms of switching off a big miner, rather than in under-contributing to a pool.  Now that I did that different calculation it seems there is actually a way to win by under-contributing!Lets consider why would someone do that?  It'll be easier to see if we start with a high powered pool participant (50% of pool).  Say this is a big pool (50% of network).  We have to consider both cases: immediate effect, and after difficulty adjusts.Immediate: the pool useful power drops to 25%, rest of the network continues at 50%, so block interval increases to 13.3mins average (network reward drops by 25% as it goes uncollected for longer).  The pool claims only 1/3 (25%:50%) of the remaining 3/4 network reward = 1/4.  The under contributor claims half the pool = 1/8 of full speed reward.  Playing fairly would have seen him collect 1/4 of full speed reward.  Under contributor loses.Difficulty adjusts: difficulty becomes 25% easier, block interval reverts to 10mins, network reward is fully collected.  Under-contributor continues under-contributing, pool still collects 1/3 but of the full reward, under contributor claims half of pool reward = 1/6 of reward.  Attacker continues to lose, just less badly.  Alternatively attacker switches playing fairly & contributing (now difficulty has adjusted), so network power jumps up by 1/3 (25%:75%) so block interval falls to 7.5mins, so network reward increases to by 1/3 to 4/3 of full speed.  Pool claims 1/2 of 4/3 oversped reward = 2/3 of full speed, attacker claims 1/2 of reward = 1/3.  Attacker wins by 1/3-1/4 = 1/12.  However looked at over the 4 week period his average reward was 1/2(1/8+1/3) = 11/48 of a normal full speed reward.  If he played fair the entire time, he makes 1/4 and 11/48 < 1/4.  Attacker loses overall, its in his own interests to play fair.After that the difficulty adjusts back to normal speed and the cycle starts over.But continuing, I suppose you could wonder where does the 1/48 loss go.  One thing I notice is 1/2(4/3+3/4) = 25/24 so average network reward increased over the 4 week period by 1/24.  To see why that is, an analogy if you drive at 75mph for an hour then 133mph for an hour, your average speed is over 108mph (75mph+133mph = 108mph) even though the geometric average is 100mph (0.75*1.33=1).  Difficulty adjusts according to geometric average, but reward is payed out with simple average.The attacker lost 1/48 relative to playing fair, but other people benefited from that 1/24 reward boost.  If the attacker could gain over half the reward boost for himself he could make a net gain.  Thats a new one to me, lets explore.If the attacker actually has two pseudonyms A (25% on the pool) & B (another 25% power, direct mining, not on the pool) which seems the most promising direction intuitively.Psuedonym A we calculated above, it loses 1/48 of its winnings relative to playing fair.Immediate (for psuedonym B): (copying from above) The pool claims only 1/3 (25%:50%) of the remaining 3/4 network reward = 1/4.  The direct miners collect 1/2 of normal speed (unaffected), so B collects 1/2 of direct miners = 1/4.Difficulty adjusts (for pseudonym B): (copying from above) Alternatively attacker (A) switches playing fairly & contributing (now difficulty has adjusted), so network power jumps up by 1/3 (25%:75%) so block interval falls to 7.5mins, so network reward increases to by 1/3 to 4/3 of full speed.  Pool claims 1/2 of 4/3 oversped reward = 2/3 of full speed, attacker (A) claims 1/2 of reward = 1/3.  Also B claims half of unpooled reward = 1/4*4/3 = 1/3.Psueudonym A's lowest loss strategy (other than playing fair) was 11/48; B by playing fair averages 1/2(1/4+1/3)= 7/24.  Combined win for B = 7/24+11/48 =25/48 a net gain of 1/48.The other players must win the other 1/2 (1/48 average reward) of the 1/24 overall predicted as the attacker only gets half of it.Wow I did not see that coming.  It seems to actually work to shake the network if you can do it by under-contributing with part of your power!  There will be some net losers as well because the pool participants are leached on by Psuedonym A.  Lets check how bad that is: from above immediate: rest of pool gets 1/8, direct miners unaffected (1/2 splt across 1/4 for B, 1/4 for other direct), difficulty adjusts: pseudonym A lowest loss strategy, pool gets 1/2 of 4/3 = 2/3, the other pool players get 1/3.  Average other pool players get 1/2(1/8+1/3) = 11/48 < 1/4 they lose 1/48.  The other direct miners get 1/2(1/4+1/3)=7/24>1/4 they win 1/24!  Check it adds up: A+B win 1/48, other pool lose 1/48, other direct win 1/24: 1/48-1/48+1/24 = 1/24, which matches total network gain from shaking.It also seems like the attack scales down, eg with 10% of power split between two pools, or pool and direct, you can do the same thing and gain a small %, though I havent checked with < 50% power examples - any takers?.Seems like the network is using the wrong type of averaging to adjust difficulty eg simple averaging might solve it.  Drive 75mph then 125mph and your average is 100mph.Or there is an under-contribution algorithm in the amortizable hashcash paper that is still fairly auditable (only example I know of in the literature of symmetric key blinding:) See http://hashcash.org/papers/amortizable.pdf page 5, second algorithm on page "Interactive Fair Amortizable Hashcash".  The idea is basically the amount over the share work is measured separately against a secret known to the server, that it will disclose to publicly when it finds the full block.  That is a single hash of extra work for the server.  The server also gains no computational advantage in over-contributing himself relative to the miners from knowledge of the secret.  Knowledge of the secret gives no advantage in over-contributing but allows under-contributing.  Oops!  In amortizable metering & document popularity applications for fair amortizable hashcash that is enough as server under-contribution is not meaningful there.  For under-contribution in bitcoin that means the server itself could perform the network shaking attack (even if the rest of the server skimming issues were fixed).It might be that other allocations of power to pseudonym A & B might get higher reward.So I think that brings it back to the wrong averaging algorithm.  Have to explore problem more thoroughly and measure different algorithms immunity to it.This may also explain the interest in DDoSing big pools - a way to shake the network without the cost of under-contributing.  When there's money at stake most people dont mind if someone else wins more than they do, even if unwitting co-benefactors dont know it, so long as they selfishly win (and some others lose, and the planned inflation curve is accelerated a little).I thought eligius CPPSRB seemed like a nice way to allocate funds fairly.  Speaking of DDoS to look at CPPSRB I went to eligius.st and it seems to be having problems: nginx bad gateway 502.Adam Yes I was thinking since posting the above, it could be more efficient to pay the miners directly,  if there is support for multiple reward addresses per block (or that could be added).   (The pool is going to soon enough pay out anyway which will create the more network traffic).  Additionally by paying out to multiple reward addresses, there does not need to be a transaction fee, which is the basis of the pools policy of non-immediate payout.  Immediate proportional reward is attractive to miners, I know my son was waiting anxiously to get his payout minimum for a few weeks!I hope it achievable with minor changes.  But its a little more than just putting multiple reward addresses in the block, because you have to protect against a few attacks:- the amount of share work done must be auditable by the pool participants, so they can know their payout share is fair- the pool may have a fake miner in his own pool, that is tallied as if it did significant work, but in reality did none, if it is not auditable that the share work was actually done- ideally this should be done in a network efficient way for the pool- and even more importantly in a network efficient way for the main network.I dont think thats possible other than as a self-harming DoS, because the reward goes to the pool's address.  If the miner mines for his own address, the pool will not accept it as a work share proof, so the only possibilities for the miner are to either solo mine, or play fair via the pool, so no attack is possible. The same would be true of mining against a direct payout list of reward addresses, the pool server would check they are correct, and not count reward if they were not correct.  Or at least the pool has an incentive to do so if there are consequences if a miner can prove any of the accepted mining contributions omitted his past contribution (mainly being he block is invalidated), or include claimed work that didnt happen.I guess that might work at present if the client is not checking for nor really aware of the pools reward address.  Even if the pool advertises its address, on the pool web site that also can be hacked.  You might even see DNS poisoning, and MITM theft of work.Probably the trick is to do it partially so the miner doesnt notice how unlucky he is.  Calculating your expected reward proportion is a bit tricky, due work stalls, moving network and actual instantaneous difficulty.  A malicious pool or a MITM could hide a big skim in that.  Maybe many of these things are happening right now, the profitability didnt seem very good over electricity with a mid-high AMD GPU (especially if you factor in buying the card and machine to put it in).  Hard to say if that is due to large scale skimming via pools, hacked pools and MITMs or the FPGA & ASICs are sucking the profitability out of GPU to that extent already.btw someone said about slush being DDoSed when the bitcoin price was high - that makes sense because it holds the network hash rate down (bigger % at current difficulty for attacker) and after a while affecting difficulty after averaging takes effect (even bigger % than due for attacker, and all non-DDoSed users); particularly that could work for some miners with no backup pool config and are not monitoring their mining rig very closely.Adam Do you know where I would look to see the source code to check how the pool server verifies the user before storing (or paying out.)GBT (GetBlockTemplate https://en.bitcoin.it/wiki/Getblocktemplate) appears to allow (but not require) client challenge randomness:Do you know if the GBT pool attempts to make the block template challenge unpredictable for the cases where the coinbase/append feature is not offered by the pool or offered but not used by the miner?  (I think the share work issued should be both non-reassignable and unpredictable for defense in depth, if miner chosen extranonce is to remain optional).There seem to be a number of exploitable avenues for hacking pools, even if they are honest, and even when the GBT user-chosen extranonce is used, and as pools are a concentration of risk with current $500k/day network reward, and near perfect crime status, the attacks are going to be increasingly sophisticated their payout may exceed an exchanges coin float depending on cold-keys etc strategy used by the exchange.I outlined a scheme to achieve a zero-trust, unskimmable and non-server-hackable pool protocol in this other thread: https://bitcointalk.org/index.php?topic=1976.msg2035637#msg2035637Adam Towards reducing extra network packets, maybe the block-detached mining contributions could be piggy backed on transaction relay messages.Then you could imagine the block grows in weight but only in size relative to the number of new transactions they contain as the  references to contributing blocks they build on top of can still have a limited fan out on as people contribute to them, each block gathering only current orphan blocks it has seen by reference (in its list of predecessor blocks, which would be implemented as a merkle tree).  The number of current orphan blocks should be constrained as every miner is trying to merge orphans, and soon as a block with an orphan merged reaches your node, it is no longer an orphan from your perspective.If the reward can be correctly slanted, there is maybe no need for all peers to independently add transactions, which would be the most network costly aspect.Maybe it can be a continuous process even - no 10 minute cut-off, as there is no longer a post to race.  The networks consensus of the biggest block just keeps growing in weight (the weight or value of all blocks seen so far).  Mining value is assigned to coins in proportion only to the amount they contributed to the ever and continuously growing distributed network mining activity.I'll re-read SPV method to think about efficiency.  And p2pool.Adam Actually I think something a bit more is needed or a dishonest pool could still skim by handing out different merkle trees to different miners.  (Miner A would see his past contributions in the merkle tree path he receives, Miner B similarly, but A's contributions could be missing from B's tree path and vice-versa.  The dishonest pool could then plausibly deny the tree path as a fabrication.  Probably an ECDSA signature from the pool could fix that (from the reward private key, or separate "fairness" key pair).  Miners can audit the blocks, and in the unlikely event of a pool skimming can prove it, which could create reputation problems for the pool.  Or as before more directly publish the proof of skimming to be validated by the network with some outcome - eg block declared invalid, or pool fees reassigned to first skim prover (a kind of multisig).  I think a signature is not quite as desirable as the verification is higher than for hashes, but I dont so far see a network efficient way to avoid it.  Anyway the signature does not have to be published nor verified unless the pool cheats so that is probably acceptable.  If the punishment for cheating is that the block gets invalidated, there is no reward possible from any form of hacking of the pool server including obtaining its fairness private key.It would be possible to have a fair exchange protocol as part of the mining share submission (as the signed proof of past work is delayed until after the work is submitted, a dishonest pool could accept a mining share work proof, and then not respond, claiming network error).  However fair exchange is a tricky somewhat computationally inefficient area of cryptography involving an arbitrator in event of dispute, and fair exchange doesnt seem that necessary - the pool doesnt want to lose miners, is probably deterrence enough.Adam
Dont you keep the slush reward address private key offline, & airgapped?Then payouts can be batch calculated from a USB key transfer of a share work tally db report, and usb key transfer of the payout transactions to the pool miner addresses say once per week or whatever.Then the worst that the attacker can do is delete some of the share work tally db records, or change the reward addresses in the db to themselves.  And if you notice an attack, even the miners could resubmit the shares.And in fact the pooled miner reward addresses should be included in an additional merkle tree in the coinbase itself, and the pooled miners should be presented a verifiable log2 path showing their presence and number of contributions within the coinbase, so that if they can see their contribution is missing, either due to pool skimming, or pool share work db compromise they can switch to another pool.  In this way reward can not be reassigned, without redoing the work, and other than the pre-mining attack, you could basically operate with zero-trust (give out the ssh root private key to the serer without loss of security.)The proof of contribution merkle tree could even be published to the full network, and included as part of the reward verification, then the pool wouldnt need to be trusted at all in terms of provable no skimming.  Of course the pool is still trusted with validation (by those pool miners who dont build their own blocks nor independently validate the pool constructuced blocks).Adam Someone with better knowledge of the pooled mining code could check my potential attack idea.The way bitcoin tweaks hashcash (I guess bitcoin-hashcash?) the challenges are potentially not random enough any more, because the reward collecting public key is overloaded to serve the function of the hashcash self-chosen challenge.  And up to this point I presume this is considered not an attack because all you do by mining on someone else's address is mine coins for them.You see artefacts of this in the way that some of the pools protocols share out work, as the reward public key is not self-chosen (being chosen by the pool not the miner), then there becomes non-negligible risk otherwise that pool miners would statistically redo work, or be starved of work.  The pooled miners seem to be short of search space, because lengths are gone to stretch what work space there is within 32-bits counter, for example increasing the 32-bit time field somewhat (and it cant be increased too far or the network rejects the block), and concerns about flooding the pool with too many small requests.  Obviously the pool needs to send the client updated work string, as it will include new transaction fees, but the mining client should be able to choose its own challenge.I am not sure to what extent the respective mining protocols are in relative use currently, but DoS pre-mining could actually be a mining security problem in the case of bitcoin pooled mining, depending on some details.  It seems that in some cases a bigger extranonce is used to increase search space, eg as noted here https://en.bitcoin.it/wiki/Transactions    And I saw the Stratum mining proposal http://mining.bitcoin.cz/stratum-mining proposal does use a second variable sized extraNonce2. But if the challenges hands out that are unencrypted (and sniffed), too small, or predictable an attack could arise based on the attacker pre-mining other pool miners pool shares, and assigning the work to himself (which is a separate question). Say an attacker has a large amount of mining power, eg enough to slightly exceed a small pool that hands out challenges that are unencrypted, too small, or predictable.  Now as the work done is known to the attacker, he can increase his pooled reward, because the work of the other miners on the pool could be negated if done first by the attacker.  (Whether that would work depends on whether the pool checks if a challenge was submitted by the person it was issued to; as some pools are account-less it seems plausible that this may not always be the case). Presumably a pool wont accept the same pool share solution twice.  Beyond making the other pool miners unexpectedly unlucky this helps the attacker (and other direct miners and pooled miners using different pools) because if he adds say 10% to the network, he simultaneously removes 10% from the network, so over time the difficulty will decrease by 10% from what it would have been had the 10% attacker played fair.If there are pools that are giving out predictable work, and allowing miners to claim reward for solving other users work shares, the same attack can scale up all the way to the entire proportion of pools that are vulnerable provided the attacker has the CPU power to match.  The attacker could not actually tamper with transactions because the pool is validating them.Hashcash was designed to defensively avoid this risk by the user including including of a big enough self-chosen challenge to avoid accidental mining collision.  The hashcash paper recommends 128-bits for general use.  The hashcash library implementation use 96-bits for email (16 base64 chars).  In bitcoin it probably should be defensively changed also even if the mining pools do enough checks to avoid the attack above, if nothing else it would be more network efficient for pooled miners to choose their own challenges, and leave the less open to work starvation.  There should be a 128-bit length challenge field (possibly 256-bits even to be defensively conservative given the scale and to balancing other defensive features like double SHA-256 ).  In bitcoin I suppose this could me done by increasing the size of extraNonce to 256-bits and having the miner self-chose a random extraNonce.  (Hashcash defines challenge and counter separately which is slightly preferable  I consider otherwise your challenge security margin is eroded as CPUs get faster the number of possible non-overlapping search spaces is reduced - that is basically what happened to bitcoin in the wiki pages about pooled miners scavenging extra search space by changing time.)Adam While the effect is the same, I disagree: the race to claim transaction fees and reward is a first past the post race, because orphan blocks do not get to keep any of the fees nor reward (in the single winning chain approach).  The fact that miners will start a new race as soon as they learn that a past race is won, doesnt mean they are not engaging in a first past the post race (it just means they enjoy racing and immediately try the next race;)The reason bitcoin mining is fair, despite the first past the post race, is that hashcash based proof-of-work is power-fair.Hashcash proof of work is power-fair because as you alluded it has no memory (its like a coin toss, with no progress within the work, and all sequences of choices of nonces taking the same amount of work).  Most of the other proof of work functions do not have this power-fairness property (eg client-puzzles, amortizable hashcash, time-lock, Dwork-Naor pricing functions (maybe)). Scrypt is power-fair I think.  If scrypt turned out not to have the power-fair property its a security bug and people with fast processors will be able to get a disproportionate advantage.However the need for power-fairness in the proof-of-work function is just because of the first past the post race choice.  For other cooperative race types it is not needed.A way to see why power-fairness is needed in first past the post (and that bitcoin is a first past the post) is imagine the bitcoin proof of work was tweaked to use a simple non-power fair proof like amortizable hashcash with eg 256 smaller proof of works with same expected 10mins time total... 2.34 seconds per challenge.  (Amortizable here just means the challenge is to collect 256 sub-challenges.)  This achieves 16x lower standard deviation which is potentially desirable because it is achieved without incurring network traffic, neither on the main chain, nor on a p2pool chain.   With this approach you can see there is work-progress so it is no longer power-fair.  Ie a fast node is going to win races disproportionately even accounting for its power.I made a racing car analogy for reduced variance in https://bitcointalk.org/index.php?topic=182252.msg1911750#msg1911750You make some more points:Your points about increasing number of packets and slight bandwidth increase are valid downsides.(I think the bandwidth increase would not have to be too large as nodes could refer to other variable cost blocks by block hash, they only need to add any additional transactions they have seen that are missing.)I think I need to re-read p2pool a 2nd time to comment on the other bit.Btw that sounds like a separate argument against alt-coins that shorten the block time interval.Adam I'm sure someone's going to find some issue with the above.  But anyway some more thoughts: because its no longer a first past the post race (anyone can post  mined block of any difficulty any time), the elusive variance reducing techniques become safely possible (I think).  ie you can amortize your mining offline, and post it when you're ready to cash it in.  Subject to sensible messages sizes (you just need multiple nonces, one per challenge) you could reduce variance until its quite smooth.  Its clearly safe because whether you post them immediately, or post them in a batch later for a combined reward, its the same thing - just batching network packets.  Your only risk is to post them when the reward is all used up.Maybe there's some way to adapt reward to be more continuous and adapted to on going unpooled mining.Also in the interests of network traffic (re parent post) you probably dont want to retransmit the transactions you've seen already published in other blocks, so you could refer to them by block hash, and add more transactions.  In that way a block could even be quite small (adding no transactions) and yet claim high or even most of the reward.Adam It seems to me that discarding orphan blocks outright loses their potential utility in hardening the byzantine voting on the transaction log.  ie work went into them, but currently they are given no weighting in the chain length (AFAIK).  Therefore to the extent they happen they weaken security because a 50% attacker wont accidentally create self-orphans on his hostile private chain.  Also maybe a 50% attacker will try to disrupt the network to induce network splits that increase chances of orphans (ie not slowing the network down, nor over-powering it, just fragmenting its power so that he ends up with as much power as the largest fragment to foist a 6-length chain and a sudden flurry of fragmented 5-length chains from a significantly net split network as he drops the net split attack).Therefore for both reasons, how about this as an enhancement to make 50% attacks harder, and to make the network less vulnerable to net splits: blocks have a list of predecessor block hashes, rather than the current single predecessor.  A slow network slow node may reveal its block late (or equivalently may have just recovered from a net split attack), but can be included in the next round.  To validate a block for inclusion into a the predecessor list of a block, all that is required is the node agrees that all included blocks pass validation (no double spending etc) and dont contain mutually conflicting transactions.  Usual arbitration for two conflicting blocks as now (though potentially augmented with higher difficulty block wins - see variable difficulty below).With this approach also faster, smaller transaction blocks could perhaps be used, even blocks with variable difficulty, opening possibility for direct pool free mining, and combating mining variance.Reward is claimed incrementally in proportion to the difficulty of the block relative to the network difficulty.  When a block is used up no more reward can be claimed.  A small proportion of reward may need to be carried forward to incentivize later blocks to include the block in their predecessor block list.(This idea for discussion is vaguely related to my post about 2002 amortizable hashcash paper - you could view the list of blocks as the same as the amortization list).Some general concerns: more block packets, creates network scale limiting traffic increase?  (Are blocks getting too big anyway?)  Is the modified incremental block reward too complicated?  Is there a way to simplify it?  eg place limits on block sizes, and/or transaction fee maximum per block?  Maybe there is an alt-coin that already experimented in this direction?  Slightly related to p2pool (p2p pool implementation) but I think different in objective.Adam I am not sure, but if you look at the complaint on one of the websites, it says that the contract itself included a $50M penalty clause for breach that MtGox had there lawyers review and elected to sign.  If they willfully breached the contract in those circumstances the damage seems more than a bit self-inflicted no?  (I see someone posted a link to the now public contract so presumably that $50M and the terms around it can be verified.)And its not like MtGox have seemingly demonstrated a lot of competence in the internet facing aspects that we can see (various HTTP response codes indicating overloaded systems from web server, massive lag in processing AML, bewildering array of odd-ball indirect payment methods).When they finally processed my AML after serveral weeks, they declared it to be "temporarily rejected" claiming it was scanned below 300dpi.  Not sure about that - it looked ok to me in the previewer, and was the default scanner setting, but worse now I have to rescan (paying careful attention to dpi advanced options!) and send it back, and that'll probably take another few weeks.Oh yeah and my fiat might just be jammed up now.  Maybe that fact is propping up the price even as someone else commented  - people taking out via BTC as better than having fiat jammed in mtgox for who knows how long.  Or people potentially trading jammed fiat for potentially less tradeable BTC (in both directions).  Thats not exactly a great market environment.I wonder actually if the fiat deposits (and even bitcoins) are firewalled from mtgox liability if they dont settle or lose, in terms of like banking separation of client money.  What I put in there to buy my first BTC* is not going to bankrupt me but its still a nuisance.  (*  Except for $6 a redditor tipped me a few days back)Adam No no thats no how it works.  A smart contract is written who's execution is evaluated by all bitcoin miners, and an arbitrator adjudicates and signs the coin multisig releasing assets to the wronged party.  Smart-contracts all the way Adam btw what I was thinking there is the difficulty precision ideally needs to be a few bits more than log2( interval = 2016 ).  So 8-bits might be a bit low.  16-bits (+8-bit mantissa) would be ample.If that was not the case (eg 8-bits precision) consider a pool holding 50%, now it can see that difficulty is getting close to rolling over another lsb digit of difficulty, it may back off (stop mining) to prolong the time to the block being found, preventing the roll-over.  That makes difficulty fraction f easier 1/128 < f < 1/256 for the next two weeks, or specifically f=1/m for difficulty mantissa m, 128 < m < 256.  By holding off it loses 1-block, and it stands to make r= 2016/m*50% reward r for that action.  (Or r = 1008/(m*b) < for holding off for b-blocks, which makes sense so long as r > b.  With 50% that remains the case for between 1 and 3 < b < 7 depending on the mantissa.  Now of course as the 50% pool mines faster than difficulty predicted, the 2 week period goes past in under 2 weeks slighty, but it still it is 2016 coins by definition, and actually the pool actually gets slightly more than 50% of the coins in addition because now it is working at full power, while it slacked off briefly before.So minimally 8+log2(7) bits = 11-bits kills the weak attack.  And bitcoin minimum is 16-bits.  Coincidence?  Probably not.Perhaps something for a slow altcoin to think about (everyone seems to go for faster pools for some reason).  Though the unfair advantage gain is slim even then.Adam OK yes thats what I was referring to with "human huffman encoder" comment.  Therefore I see what you mean about also, I just meant that there would be (my guess) no floating point in the sense of call of CPU floating point instructions, and that seems to be the case Its simple as such things go (I've seen worse) and just a way of encoding between 23 and 16 bits of precision plus 8 bits of mantissa.  (Kind of odd that the precision depends on how close the difficulty is to an 8bit boundary, but there you go.)  It could have made better use of the 8-bit exponent eg by treating it as bits instead of bytes as the number is anyway definitionally a 256-bit number. If optimized it could probably have been a 16-bit (8-bit exponent + 8-bit mantissa) encoding if the bits in the exponent were used as bits rather than bytes.  Or certainly a 24-bit.   But maybe thats my turn to over-optimize - the difficulty precision is not that critical anyway. It depends how you treat it - you could consider it a 256-bit big int also.  However I was thinking of it as fixed point because I found the fractional comparison easier to think about.  (Fixed point means only mantissa is used, exponent fixed to 0, or at least a fixed value.  People used to abuse integer CPU instructions to do fixed point arithmetic in the days before floating point processors were included in CPUs or at least integer arithmetic was much faster than FP coprocessor).I dont know, but let me guess based on the difficulty algorithm: my guess it uses integer math only.Adam Isnt it interesting that the hextarget isnt the same as what I calculated, maybe not so simple as deepceleron declares   Starting from difficulty 10,076,293 http://bitcoindifficulty.com/ I get .00000000000001AA3EA9EBE... so there is a .0015% discrepancy.  Clearly the target is the correct value as its the used value.  Looking around it seems that difficulty is actually the multiple of hardness relative to the minimum difficulty which is actually not 32 0s (expected 2^32 tries) but rather 0.FFFFh/2^32 (ie x < .00000000FFFF0000h) expected tries 2^32/0.FFFFh = 4295032833 (100010001h instead of 1000000h).So convert from target to difficulty and difficulty to bits is even messier:scale=80 define pow(x,p) { return e(p*l(x)); }define log(b,x) { return l(x)/l(b); }define log2(x) { return log(2,x); }  # http://blockexplorer.com/q/hextargetibase=16target=1AA3D0000000000000000000000000000000000000000000000/2^100mindiff=FFFF/2^10 # the source of the .0015% discrepancyibase=Atries=2^32/mindiffdiff=1/target/triesbits=log2(diff*tries)   cbits=-log2(target)    gdiff=diff*4*mindiff # difficulty in gigahashesnhash=70.48*1024time=gdiff/nhash I think my unnecessary complexity issue with this page https://en.bitcoin.it/wiki/Difficulty (and the measure chosen for difficulty) is not so much that it is log2 scale or not.  I can handle that.  But that it is not even expected number of hashes (or Gigahashes etc).  At an approximation it is number of hashes / 2^32.  Now 2^32 is not a nice number in both bases (log2 scale and log10 scale); 2^30 is a nice number.  That would be a nicer way to report difficulty IMO as thats a GH, and you'll notice ALL of the miners are reporting power in GH or MH; and the network hash rate is in TH.  (Not difficulty chunks which are the former divided by 2^32).  But on top of that for proper accuracy it is not even hashes/ 2^32 but difficulty = hashes /2^32*0.FFFFh.  And that is harder to test at discrete difficulties (whole number).  Which is why pool shares are not an exact multiple of difficulty but rather trailing FFF difficulty to counter act this issue.You know I once knew a crypto math/hacker guy who used to think human huffman encoding was fun.  Satoshi?  Hmmm Well that wasnt exactly my point (my point was that you can get a ball park approximate order of magnitude with your eyes and mental arithmetic with bits).  But about your question log2(1.1) = .1375 (call it .14, remember that) so 55.26+10% = 55.40?I dont find 2^32/.FFFFh a particularly meaningful number.  I know the discrepancy is small, but why even bother .. just simplify and use trailing FFF difficulty.Sorry but simplicity does matter.Anyway untangling and ignoring the .0015% discrepancy, you could convert difficulty into approx gigahash by multiplying by 4: difficulty *4 = 40305172 GH.  And network hash rate = 70.48TH, so expected time = 40305172/(70.48*1024) = 558s.   Close enough - network hash rate has grown since that difficulty was calculated.  (Or in log2 scale difficulty is 55.26 and network hash rate is 46.14 so > 2^9 tries > 500 seconds. ) Adam OK here's another version for you.  What does difficulty even mean specifically?  Read this and tell me if you can figure it out: https://en.bitcoin.it/wiki/DifficultyI tried and it was pretty confusing.  Snippets of C code, definitions in terms of other undefined things.  Mixing in 600 seconds in places not in others.  Does difficulty include 2^32 or not?  Adjusted for 600 seconds or not?  That whole page is extra confusing.Whereas I know what 55 bits mean, as with hashes and ciphers: it means you had to try 2^55 times to get this (on average).  And I can convert bits=log2(diff)+32 not so hard on any scientific calculator.And therefore if I can search 1GH/sec then I know that is 30bits/sec so I'm going to need to try 2^25 times.I think part of the problem is difficulty is actually divided by 2^32.  So its not really the number of expected tries.  And 2^32 isnt 1G its 4G.Adam No I mean fractional bits.  Hashcash worked on whole bit only, and there it was possible only to double or halve bits, like you said.  Bitcoin needed more fine-grained control, and so extended hashcash with fractional bits and there the challenge is not technically to find a hash with 55 leading bits, but to find a hash that is less than 1/2^55.26 bits where bits is fractional and the hash is viewed as a 256-bit precision fixed point decimal. (Those are the same thing if the bits are whole).So 55.26 bits is numbers < 1/2^55.26 viewed in hex that is any hash < .00000000000001FFE(I use bc -l: bits=l(10076293)/l(2)+32; obase=16; 1/2^55.26).Anyway my point is for human understanding you can mostly ignore or estimate the fractional bits and be within 10% of right.  And its easy and meaningful (in terms of cipher & hash security which are measured in bits) and visually checkable to see that its around 55 bits = 13 or 14 leading 0s.  You can even approximate the fractional bits as I was saying.For comparison EFFs 1998 $250,000 DES crack machine broke a 56-bit DES in 112 hours expected.  Bitcoin network does something approximately analogous every 20mins Now if we could persuade EFF to make another miner but for bitcoin, they could fund their own donations.   I did suggest it to the people on the DES crack team...Adam http://www.platformonomics.com/2013/05/press-releases-wed-like-to-see-iceland-embraces-the-bitcoin-economy/"While some may put their confidence in the resolve of policymakers, we put our confidence in the cryptographic assurance arising from the second preimage resistance of the SHA-256 hashing algorithm." Adam Why is bitcoin difficulty not expressed in bits?With hashcash I always used bits eg 20bits.  I think bitcoin is currently at 55.26, as bitcoin mining is extended to allow fractional bits (rather than to find k 0 bits, to find a number < 2^k where can be fractional - that is the same thing when k is a whole number).You can convert difficulty into bits with log2(difficulty)+32.  (log(difficulty)/log(2)+32).(+32 because 2^32 is the original or minimal difficulty in bitcoin and is excluded from the difficulty number).I find this page is unnecessarily complex for a very simple actual problem: https://en.bitcoin.it/wiki/Difficulty(Current difficulty 10,076,293 from http://bitcoindifficulty.com/).By comparison bits are very easy to read, even by hand.  If one looks at the hash output in hex just multiply the leading 0s by 4 (and the next nibble figure out if it is >7 = +0 bits, > 3 = +1 bits, > 1 = +2 bits and 1 = +3 bits (and obviously 0 would be another leading 0).  QED trivial, human comprehensible difficulty that can be hand-checked.  That was part of the design aim for hashcash to simplify the computation, programming and human verification.And when you see a bitcoin in hex you can visually see those 55 bits.  This is the latest hash from the block explorer:http://blockexplorer.com/block/00000000000000e3d3268e05a9901759c1452590d0838a80aeb8abaea59f1e9fand bingo I can count 0s (14 of them) multiply by 4 (bits per hex nibble) and I know that is a 56bit hash collision.  (You get lucky and an extra 1 bit half the time, 2 bits 1/4 time etc).Adam So reading the bitcoin paper it is claimed that the recipient generating hisaddress at the last minute before accepting the payment makes him lessvulnerable to a 50% double spend attack.  This argument doesnt seem correctto me, though creating new addresses serves as secondary purpose a mildprivacy feature.Lets consider two attack approaches, a) where all users generate freshaddresses to receive each payment and b) using prior knowledge of victimsaddress,a) is the attack described in the paper: attacker tries to create a blockchain fork of longer length than the rest of the network by working on achain that he does not publish yet, spending a coin to himself on this fornow private chain.  Now and then with probability determined by his ratio ofnetwork power he gets ahead of the network by 2 chain links, so he startsthe double spend attempt, paying it to the fresh address of a victim.  Oncethe rest of the miners publish a block containing the victims confirmation,and once victim to sees the confirmation, the attacker publishes his up tonow private chain which contains a different spend.  Now there is a networkfork, and the network will believe the 2 chain links branch over the 1 linkbranch, for any coins that are spent in both.  The network has no way todistinguish which spend to reject other than the CPU voting, and that isindicated by the chain length.  The network abandons the short fork of thechain, and the victim's received payment is considered a double spend by allnodes.  If the victim accepts with 0 or 1 confirmations, he loses; if thewould be victim waits for 2 confirmations the attack fails as he would notyet consider it valid.  (Analogous for n confirmations with correspondingylonger private chain).b) the attacker tries to gain some additional advantage from prior knowledgeof the victims address.  If the attacker accelerates the confirmation byalso computing the confirmation rather than letting the network do it, hedoes work the network would do for him reducing his power to amass asufficient length private block chain that he must do privately, and soreduces his chance of success to construct a n confirmation defeatingprivate chain.  And yet he gains no success advantage.  What he does do isavoid make speculative payments to the victim.  However there will existpayments that result in resellable virtual goods.  Or online gambling thatis approximately zero sum so those payments do not have to be considered aloss or penalty, only the transaction fee & resale (virtual goods) or housecut (online gambling).  eg Satoshi dice apparently is popular.Maybe I am misunderstanding what Nakamoto meant in the paper, but I dont see any 50% attack extra defense coming from choosing address justbefore receiving payment.Adam Ha coincidentally found this thread when I was googling my name (not something I am normally in a habit of doing) because I talked to a journalist a few weeks ago and I wanted to check if he mangled my technical explanation or worse; btw he didnt mention my name, even better, win!)My exchange with Satoshi was early but very brief.  I understand the tech ok and much of the precursor tech with various ecash technology.  Theres a lot that happened since Satoshis paper in altcoin so I am in catch mode for a bit.But I am not a good public speaker - I am allowed that luxury because I'm a crypto geek not an ex-CEO.  There are people who are masters at sounding cool, moderate, responsive and informative when faced with Bill O'reilly type verbal rough ups, and while covering controversial topics.  ie Politicians and professional PR & and spokespeople.  Rick Falkvinge is very impressive.  Or for example watch Kim DotKom in this interview http://www.youtube.com/watch?v=pF48PjCtW4k  Awesome "Well you have to understand blah blah.."  sounds so reasonable.  (Yeah ok it a friendly interview, but there are a few talented people who are amazing at sounding more reasonable than the presenter under fire).  Kristinn Hrafnsson holds his cool really well - and given the wikileaks controversies he gets to face up to the worst of it.I always find Matonis fun, and his mix of ex-hushmail CEO and ex-VISA exec background seems hard to match in terms of bridging credentials.  He does like to push the libertarian angle which is amusing to crypto-libertarian types but might not always look so amusing or bitcoin credibility inspiring to the business people and regulators, but he's still really good.The main media do seem to more enjoy sensationalizing about the fringe users doing naughty and titilating things with bitcoin that they could just as well use paper notes in the snail for.  Bitcoin isnt even anonymous for example as Shamir et al showed with their statistical analysis paper on the bitcoin public ledger - its less anonymous than paper cash - you dont get that kind of transparency and flow analysis with paper cash or physical banks handling of paper cash.  And as far as that goes HSBC were found guilty of laundering getting on for a trillion dollars ($880 bil) and accepted paying $1.2 billion fine.  Thats probably a slap on the wrist at their scale.  No one went to jail, no one had banking licences revoked etc.  Barclays did something similar.  Maybe the regulators should start with real problems, they say HSBC laundering covered mexican drug cartels and even terror funding.I always thought Ian Brown does pretty well for a tech guy - you see him on Al Jazeera sometimes for tech commentary.Also I gotta write code, man, and stop getting sucked into blathering about politics fun though it is.Adam Sorry that part was unclear, what I had in mind was the pool would send a header with a random number embedded, the miner himself would append his bitcoin address to it, and then mine that.  There would be a new (alt) bitcoin coin format which would include multiple hashcash outputs, eg say 100 outputs.  That means that the first 100 or so (not an exact number mind as bitcoins have different values) first 100 or so miners of the pool to hit the minimum share difficulty get their part bitcoins added up by the pool, and the pool publishes the bitcoin.I think my idea was a bit half-baked.   Apart from that lack of clarity, there are two aspects of the amortizable hashcash concept - being able to add them (very approximately) and a metering function.  Its probably the case that the metering function which requires under/over contribution prevention is irrelevant for pool related use, everyone wants to over-contribute, and thats encouraged.  So lets say we remove the contribution protection (ie blinding value and u part).  Then whats left?  Just an alt bitcoin formed of a list of part-bitcoins, which has lower variance, and the owners of the parts can be different owners.  The pool cant benefit from its miners work without revealing their coin addresses, so the pool cant skim.  The downside is the coin gets bigger.  However I do not think that initial mining events form a big part of the network traffic - isnt the transaction log the big deal, with all the fractional bitcoin change and combining?Correct the pool would set some minimum work factor to limit the network traffic from miners sending it part-bitcoins.  I work in log2 of difficulty because thats the way hashcash was expressed, I think it clearer to think about really.  The log difficulty right now is 55.1 bits (logdiff = log2( difficulty ) + 32 is the bitcoin formula its easy to see the difficulty visually in the hashes eg http://blockexplorer.com/block/00000000000000bf11ad375a87a5670571ee432fbf629ba0e69e33860461bf84 then by counting leading 0s and multiplying by 4 bits per nibble - yes its 56 bit - you get lucky with an extra bit 1/2 time and two extra 1/4 time etc.)In this idea the pool is mainly saving the miners the network overhead of keeping up with the transaction log traffic, otherwise they could just post their part-coins to the p2p network directly.  Alternatively miners could broadcast their coins if they preferred.  eg the whole network in a p2p sense could grab the first set of broadcast part-coins that added up to the current difficulty and hash them into the transaction log.  In that way your part-bitcoins could go straight to the network bypassing the pool.  Because the part-bitcoins are smaller and released faster that may create some micro forks, but perhaps the p2p voting can handle that.You got it -  could have the part-bitcoins themselves be composed of even smaller subpart-bitcoins (eg 32 of them) and then the miner has lower variance, and actually can measure progress, even print a progress bar that means something.  (With single hash bitcoin mining there is no progress as they are like trying to toss 55 tails in a row with a coin - the coin has no memory).Then while eg 1/128 of the difficulty is massive for most miners, the variance for mining is reduced, which is part of the miners problem.  eg Say 128-part coins = 7 bits, which would make a mining share 48 bits (thats huge even for a 1500MH gpu even it would only have a 1/436 chance of creating a valid share in 10 mins - thats not good because no share = no direct payout).Correct.  However you could use it recursively to have the miner create subpart-coins but each time you increase the number of parts the coins grow.But I think there maybe a potential problem with multi-part coin low variance concept, imagine the extreme case where there are 1million part-coins, now there is practically NO variance; its almost completely deterministic and 100% related to your CPU power.  Now the guy with the biggest GPU/ASIC farm is going to get the coin 100% of the time - for hashcash stamp anti-DoS that determinism is good, but for bitcoin however with its 10min lottery thats very bad - winner takes all with almost complete certainty.  Even with modest numbers of part-coins the effect exists and stacks the reward in favor of the biggest CPU players, arguably the opposite of what you need if anything (in terms of centralization resistance).  If its recursive with first 100 part-bitcoins past the post sharing the 25 bitcoins, with low variance part-bitcoins in the race (themselves made of subpart-bitcoins) you still have the same issue, fastest CPUs win.A loose analogy imagine currently bitcoin miners are race cars.  Some are fast (ferrari) and some are slow (citroen 2cv) but they are all very very unreliable.  So who wins the race?  The ferrari mostly, but the 2cv still has a fair chance relative to its speed because the ferrari is really likely to break down.  With low variance coins, you have well maintained cars, and they very rarely break down.  So the ferrari wins almost always.  Now if you have a line of 20 cars of varying speeds, well maintained (low variance) the first 5 that are going to get past the post are almost certainly going to be the 5 fastest.  No one else stands a chance hardly.So I think the take away is you cant use low variance techniques for the underlying coins in any first (or top 10 etc) past the post race, which is what bitcoin 10min CPU lottery is in effect, because it is inherently unfairly stacked in favor of the fastest CPUs.Thats kind of inconvenient and as you noted the only other variance reduction method discussed (that I saw) has been to reduce the difficulty (unpooled) or the share size (pooled).  But that can increase bandwith requirements because there are lots of small coins flow up to the pool, or if direct to the whole network.I think I have to read about p2pool before I can understand what you wrote on that thread.  It sounds like you plan a bit commitment to be later revealed.This might be the same as what you meant but I was thinking about coin compactness and maybe it works for pools too that you could demand from the pool a hash including the main bitcoin transaction log hash plus the merkle hash tree of miner coin addresses using the pool, plus a log( #shares ) hash chain proof to the miner that his address is in the tree.  That would seem to allow proof of contribution, however the generated bitcoin would be quite big as it would need to include ALL of the shares, but spends of the bitcoin would be compact just referencing the offset of their address in the generation coin.  Alternatively the generated bitcoin could be compact, and the miner could be responsible to disclose the claim to the bitcoin at time of first use, which would bloat spends, and I believe thats worse because coins get created once but spent many times.(And now I need to go read p2pool and then your other post.  So much to catchup on!)Adam "amortizable hashcash" is the title of the 2002 paper I wrote so some of the terminology comes from that.  If you read what I just wrote (and I just re-read it to be sure) I did not mix the terminology - except in one place as a slip.   I called hypothetically directly claimable micro (low denominatoin) bitcoins microcoins.  The rest of the terminology is specific to the paper.I know someone prattling about historic stuff can be irritating, there is one such fellow on the crypto list and it irritates the heck out of me; I am not trying to be obnoxious, really.  My main interest is to help improve bitcoin itself (eg scalability, security, pool security etc) or to have altcoins test or innovate if any of the old things I point out they might have not been aware of.  Sometimes a new person can see a new innovation, that everyone else missed.  (eg an altcoin might see some trick with amortizing coins to achieve a scalability jump that no one including me has thought of - thats how innovations happen).But yes I know bitcoin isnt hashcash anymore than SHA256 isnt bitcoin.You also have to understand there is some history to ecash and cryptocurrencies stretching back to David Chaums 1982 paper on blind signatures for untraceable payments.  Some of us got pretty excited about this stuff on the cypherpunks list for a period of years on and off - maybe 1992 - 2005 or something of that range.   Of the aspirations or dreams for what privacy technology could do to improve society ecash was pretty much the holy grail one that was tantalizingly out of reach.  There were even books written about this hunt eg Neal Stephenson's cryptonomicon.  People were talking about ecash for a few decades and excited about the social implications, so that is not new to bitcoin.  So I am not trying to falsely claim any satoshi glory, nor rename anything, but you cant stop me joining the party   Alright.  Otherwise flame on.Believe me, the fact that Satoshi invented the key missing parts that tantalizingly eluded everyone else for about 20 years is pretty damn cool to me.  It wasnt that we werent trying to figure out how to do this, some of the smartest applied and theoretical crypto people tried their damnest and failed.  So yes bitcoin is the biggest news for a couple of decades in my technical favorite area of interest.There were prior attempts to control inflation in hashcash.  Otherwise it inflates away at the rate of Moore's law (once it caught up to GPUs then ASICs).  One was to use to broadcast an increased difficulty periodically resetting the number of bits back in line with moore's law (plus a beacon to prevent anticipatory epoch skipping).  The hashcash of this type would have included the epoch beacon and the difficulty in the hashcash service string.  But it would have had no re-spendability, so of use only for anti-DoS and metering applications.  I never implemented it, but the above was discussed on mailing lists as I recall.  Also it would have no supply limitations other than computational resources, but as it was not respendable it was intended as a cost-break on DoS so that didnt matter.However there was no mathematical enforcement some "trusted" authority would have to estimate and increase the difficulty (eg rate achievable on  equipment costing $1000 every few months).  Wei Dai's B-money and Nick Szabo's bit-gold extended those ideas with respendability and distributed but still based on human markets.  Maybe Szabo envisaged computer mediated markets it was unclear to me.  They all failed to find the elusive deployable pure mathematics/crypto solution without human intervention.  Hal Finney actually built his idea RPOW, and that provided re-spendability and proper blind cryptographic privacy (that bitcoin does not), but it was centralized, and relied on hardware security which has to trust the manufacturer as they are the CAs for the keys involved an could bypass the HW assurance).I tried to find ways to design an offline ecash system over quite a few years and I failed, most of the discussion is on old crypto lists.  The best I came up with was to find a way to create offline multiply transferable Brands cash.  But it turned out someone already invented it, there was a tiny obscure footnote in his book he pointed me to.An experiment with controlled scarcity was the digicash (chaum cash) betabucks server.  They issued some number of coins and I think you could just go claim them.  As they were in limited supply people started trading them.  I sold a few perl-rsa t-shirts for beta-bucks.  Blind ecash, fixed supply, but central; and it went under when digicash did!Adam Hi BitcoinersA few topics:1. amortizable hashcash and zero-trust bitcoin poolingIt occurs to me that my 2002 paper on "amortizable hashcash" could be used to make zero-trust bitcoin pooling possible.http://hashcash.org/papers/amortizable.pdfWhile pools are held honest  by reputation, always smart contracts and cryptography and end to end self-determinable security are preferable to gameable reputation, particularly where the cheating is only detectable in the long run, and the pool could skim based on non-transparent statistics.  How do you know what the real pool statistics are.  From their stats page?  Etc I'm sure others have worked through the possibilities.  Maybe some pools are skimming right now above their advertised commissions, and could perhaps get away with that for months.  Possibly even the largest pools.  Eventually the stats add up, but who is doing the manual statistical auditing back to the blockchain?  No one probably.Amortizable hashcash (my later 2002 variation following on from hashcash) means that you could mine two hashcash microcoins (corresponding approximately to the pool "share" microcoin but directly ownable by the individual miner without possibility for cheating, skimming etc by the pool), and the amortization function is that you yourself can add them together offline by yourself, with the resulting coin having a fixed modest size regardless of how many coins you added together and have anyone publicly audit and accept that resulting coin.  The pool has no trap door, no computational advantage arising, so you dont have to trust the pool at all.No change to the core mining function is necessary, as amortizable hashcash is still based on the same mining function (which I used to call a hashcash cost function - others later called them proof-of-work functions) so it works on ASICs and GPUs etc though some minor changes would be needed in the serialization of what gets hashed and the definition of the value of coins.  Well thats the idea, the crypto is sitting there and a good hacker could put that together in a few days IMO.  (To elaborate for clarity, the serialization and definition changes I mean each microcoin would hash its owners coin address as part its self-chosen challenge.  If the pool uses the clients hash - and it has an incentive to if it wants to win the pending 10 minute full-sized coin strip, and collect the bounty - then the pool contributor unavoidably gets the microcoin.  The pools reward can be encoded also as a smart contract into the format so that if the pool is due the tx fees but not a coin share (like eligious fee structure) or a percent that can be in the smart contract.) So there's the brain dump, do with the suggestion as you wish.  Alt-coiners might like it.  Bitcoin itself maybe has more energy right now for scalability engineering.  But thats part of the value of alt-coiners -- innovation jumping ahead in different directions.2. pool auditing?Maybe an alt-coiner or a pool contributor with enough at stake might like to audit the main pools and publish their findings.  If pools have been skimming it could lend credibility to an alt-coin that uses amortizable hashcash and fair micro smart contracts based pooled mining.Its not an accusation btw from what I saw the pools seem to be friendly, and some of the published % fees are fairly steep so maybe they can be profitable enough without entertaining it.  More to lose than gain?  etc.3. reducing coin mining time varianceOh yes something else, though I am not sure it is necessary with microcoins as I commented in another thread they are inherently smoothed mining randomness due to their size, but it is also easy to make a much more deterministic mining definition with hashcash.  Just collect more smaller hashes in a list and define the value to be the logsum of the coin values in bits.  The expected work as the same but the variance falls fast.  Juels et al proposed that in their client puzzles paper.  Microsoft also did it in their hashcash mail stamp fork.  You can optimize the storage size, though obviously they will be bigger than single mining event coins.  In the case of bitcoin the size is mostly dominated by the transaction log so maybe that is a negligible effect.4. even flatter network (maybe.. proto-thought in progress)I havent thought about it enough yet, but there might be a way to use amortizable hashcash at the whole network level (I mean the amortizable hashcash protocol itself is 100% scalable)  but use it to somehow benefit the network scalability, and/or even need for pools to exist and yet without spamming the network with microcoin commits.  For example the pool (symmetric) blinding value (you'll have to read the paper to understand what that is) could alternatively be chosen after the fact via a fair beacon based on the network aggregate mining events.  Then the all the micro clients can have a look through candidate microcoins and see if they scored with any of them.  Kind of like lots of little lottery tickets rather than one big lottery ticket.  I do appreciate that all the miners need to either directly validate the anti-double spend properties of the block chain, either directly, or indirectly; and that the miner effectively acts as a super node doing that for users, and charging a fee.  (If the pool fails or cheats on the block chain validation and is well below 50% or exceptionally lucky, he will lose the bounty anyway as everyone else will declare his coin invalid).  Anyway I suppose the main point is the miner doesnt have to wait for a delayed payout nor trust the pool, he has his own coin and can validate it and claim it himself.  But at that stage pool would be doing so little - just sending you the current claimed hash, that perhaps there is a trick that could remove the need for them.  Thats where I havent thought enough yet Adam
Well thats an interesting and valid pro-ASIC friendly argument.  People with ASICs will try to secure them and notice if their coins are stolen.  But also there is an indirect human utility to having botnets being used for mining - it is a very benign payload compared to other things criminal hacking activities have historically used botnets for.  Maybe spam would even fall if hashcash CPU/GPU mining is a more profitable market than spamming.  It seems to me highly likely that it would be even.  Maybe hashcash beats spammers yet in an incredibly indirect and unexpected way   Thats amusing.Well I would be alarmed if anyone tried to impose that by fiat, as its payment system political interference EU-troika style, but what I meant for example the bitcoin foundation (and/or any other trustworthy organization with a public interest - eg EFF?) might collect donations from bitcoin users to be divided up between the most dangerous 0-day problems in bitcoin code.  And maybe the bitcoin code changes should not even be shipped until it has survived a months and a few $million of the best code analysis minds on the planets best efforts.  In that way it is actually in the bitcoin holder and users mutual and selfish interest to donate to that because if such an attack happens they maybe the losers.I mean think about it - bitcoin surreptitious hidden code check in attacks, or accidental code mistake attacks - they could be the perfect payout allowing a 0-dayer to retire on Satoshi like money.  Say bitcoin grows by another factor of 100x in transaction volume and market cap over the next few years.  This is a higher assurance code security scenario than society has ever seen, the security of the code and development and review model maybe its only technical security weakness.Another defensive thought: bitcoin may like to take a leaf from mondex, p2p respendable electronic currency cash card.  They had a hot spare crypto protocol ready and predeployed switched on via peer2peer transfer of signed upgrade notice cards in case of cryptographic or implementation problem.  In a bitcoin world that might more be a spare implementation in another language or something.  (Its a common concept in mission critical systems eg spacecraft navigation computer, to have two or three different implementations in different languages, by different programmers, but from the same spec, voting on what is the correct reaction and course adjustment).Adam I dont think you even need a lot of money for that, the grey/black hat hacker just does it as his own project...  There ought to be some really serious scrutiny of every byte every check-in.  Maybe bitcoin should think about paying a bounty for the bugs out of some slush even.Some of those guys ranging through black, grey to white hackers are very very smart.  If they can find new 0-days, in highly reviewed code, and sell it on the grey (legit actually) market - they are well qualified to know what a subtle mistake looks like, and how one would create one.Ok you called me on that.  Your points are valid also IMO.  I was mostly reacting to the 'one-two teak clones' as you put it that are basically 100% bitcoin with paramtweaks.  I should have qualified that with simple no difference forks.  Otherwise why would each person not start the same code or a paramtweak metoocoin etc in their own name and go for the first mover coins until there are 100k coins types and the concept of a cryptocurrency gets weakened by the noise!  Its confusing to the semi-technical viewer and erodes the meaning of a cryptocurrency.  But yes part of an experiment is potentially the economics which maybe you cant really tell without operating it.There are limitations with bitcoin, things that could be improved, maybe crytpographic and/or p2p optimizations perhaps that could jump scalability up, reduce network requirements of peers, etcDifferent mining and decentralization retaining features etc.The research and experimentation brings value.  Maybe in the longer term bitcoin would merge an innovation to improve.  And worse cast, yes a monoculture defense, if bitcoin lost its way.The first mover thing is odd though.  No one knows if an alt-coin will perhaps for some unforseen reason overtake, if bitcoin hits a big stumbling block people didnt see coming.Adam Thats because the minimum network accepted virtual "nugget gold weight" is too high for the end user miner.  If the rate of average production for a spec of virtual gold dust was 1 second on a GPU (for some picosatoshi) the rate of progress would be smooooth, so its not the randomness per se, its the size of the minimum mining target.  It'll be acceptably smooth even at 1 microcoin per hour for 500MH miner at a given difficulty.The problem and reason for big 25 coin blocks I think is p2p network scalability.You can therefore think of pools like supernodes in a p2p network.  They hand "shares" sized chunks of work, out effectively the microcoin challenge and smooth it out for you, and like supernodes in p2p networks in general, they help the network scalability.  There is healthy competition amongst pools, and the barrier to entry is low.In an idealized crypto currency you could argue it would be desirable to be able to mine picocoins directly with out pools.  poolproof as you called it.  But I think for now the people working on the code are having enough fun scaling for transaction volume etc with the current parameters absent some interesting new crypto to say allow secure offline combinable and splittable proofs of work.Adam I think that is something to think about in byzantine threat models.  Could a big and hostile player greatly out sizing bitcoin in terms of money to burn destabilize via financial exchange manipulation, or mining out the coins with vastly more CPU power, buying and deleting coins etc.  It seems often that some big players prefer covert plausibly deniable or hard to prove action than something overt.  Or alternatively they could find or make an legal excuse to cut exchanges off from the banking interface.Even competitors like banks themselves if the bitcoins started to eat into profit margins maybe they could drive out the currency by buying all the liquid parts.  (Bad currency drives out good?)Adam Well they might, but thats a fiat currency issue, thats why some people are buying bitcoin .  Also dont use exchanges in countries with high banking exposure to GDP.  (Like credit rating of country, you can look them up).Adam I am anti-fork as bad for mindshare, confidence and dilutive of bitcoin and crypto currency value aggregate.I was suggesting it maybe in the self-interests of bitcoin to think about that for the main branch.Obviously ASIC miners wont like it short term.  I ordered some ASIC miners off butterfly also.But my statement was bigger picture, longer term view: all bitcoiners, including ASIC miners, will like it even less in the longer term and bigger picture if the entire currency gets devolved into a non-p2p corporate controlled network.  That itself would either destroy bitcoin value via loss of interest and/or bitcoin's user-centric properties along the way.Anyway there was some interesting discussion in this thread, and there are uncertainties about what is the right answer.  So I guess by default we're going to wait and see.If there even exist lots of ASIC privately held at present, that in itself is an argument for p2p nature surviving ASIC with hashcash mining function.Adam (Here's a ppcoin like idea I wrote before reading about ppcoin.  I havent quite managed to decipher the ppcoin wiki page finding it hard to find isolate a concise definition of its mechanism and intended low level effects.  Maybe someone who has internalized ppcoin could skim this idea below and tell me if is the same as ppcoin (but simpler?) or not.)There might be other ways to tilt the field towards p2p control also without changing the mining function.One could give coins accompanied by first 4 year (50 coin block private keys) from the block chain some definitional hashcash mining boost.  This boost only has value for protocol voting, but NOT coin reward and could be an interesting drag on corporate control.  Would give Satoshi some anonymous power if he is still around and mining.  There'd have to be some coin reward to encourage the GPU miners with old private keys to play and keep the p2p aspect going, other than altruism, but it could be a different payout.  The generation 1 private keys boost level would frustrate subsequent control centraliztion.  Also the boost private keys are the first miner original keys only, the boost cant be transferred bitcoin purchase to the new address private key.Adam Agreed, good synopsis of the problem.Thats a rather good point, I like it.  That might even win the argument if we see ASICs of good quality and efficiency flood the market in the next few years, partly as a result of the simplicity of SHA/hashcash.It would do something about the people we want to exclude, that was my point/intention anyway: there are limits to custom hardware optimization where it becomes just too expensive and you're better off buying or making a faster CPU.  Intel is a target you're chasing at the speed of Moore's law.  Particularly if the algorithm is changing every 6 months in interesting and novel ways.  Imagine someone come to you with a mountain of money and says build me this custom CPU in 3 months (so there's three months left to start mining).  Maybe you cant do it in time to repay the investment.  Maybe you cant do it in the timeframe with any amount of money.  Even all of it - there are complexity and science limits for hw gurus and chip fab people etc.But maybe thats too simplistic a view of the hw response to the challenge, eg maybe they optimize in the direction of reconfigurable flexibility - eg ultra flexible, ultra fast, 22nm FPGAs with more pre-optimized lumpy parts (FP units, cache arrays, integer units, etc).  But then there is an argument that that might however be a rather nice general purpose re-programmable CPU so maybe everyone and his dog will be able to buy cards and racks with them on par with miners.  And if it becomes reusable enough, it becomes a product with general availability, and that becomes a win for dynamic epoch redefinition of mining function.If the target is too flexible, particularly dynamic over too short an interval, the hw guy either loses to intel, or he builds an intel competitor flexible hw reconfigurable CPU that everyone (supercomputer vendors, scientific computing, dyanmic function miners) will want to take off his hands.  Either way it a win for the dynamically changing mining function approach.It takes a lot to compete with Intel.  Even AMD cant seem to do it these days  - though AMD make real nice GPGPUs.But your main point simple hashing algorithm ..[as it] keeps the barrier to entry lowish for new ASIC producers stands maybe is more robust than the harder to quantify difficulty of super-optimizing hw for an inventively changing mining function - harder to project what could be done, and anyway if the sheer simplicity of the hashcash mining function is enough to ensure p2p availability of hw, its is a more elegant, simpler solution.  Simplicity I like.You know there maybe more than hw availability also to consider.  Many GPU miners are mining because they have a GPU.  If some of them had to pay for the miner they may drop off.  But bitcoin could probably live without that if it had to (sad though it would be to have them lose their fun without buying an ASIC.)Adam I did - quite significant typo/braino there    I also dont know who Satoshi is and the first I heard of bitcoin was a 2008 email from him as I mentioned.  (Or one of the crypto lists I cant remember which came first or which I saw first).Not clear.  Maybe failed to achieve enough momentum on the network effect.Its use is clearly small, but it maybe like SMIME, it may have many more clients deployed who would act on it if anyone would bother sending them some hashcash (mainly server located hashcash capable spamassassin) relative to the small the number of stamps.There was also a nay-sayer article about the economics of it all claiming it would be insufficient to deter spammers.  "Proof of Work proves not to work" (I put it on http://hashcash.org/papers/ also.)Also you may or may not know microsoft did their own hashcash fork (chosing it over their own R&D labs memory bound functions (first version of the concept scrypt is based on).  They deployed it I think into exchange, outlook maybe hotmail.  I didnt follow it too closely.  They released on an open spec, and one could even implement the changes into the open source hashcash.  Was on my to do list for a while, still languishing.  But who can work on spams when there are bitcoins for enciphering minds to think about Kind of lame that I didnt put that microsoft hashcash fork link on the hashcash site that I can see now.btw it also occurred to me recently that you could recycle low bitcount bitcoin failed hash attempts for hashcash, just stuff the email in a bitcoin ignored field.  Sure the format is binary and different, and big but maybe it could be tweaked somehow to include hash( bitcoin stuff ) to be ignored by hashcash email other than as a randomization or ignored field, in a way that still makes sense to bitcoin.  Combined anti-spam with bitcoin as a freebie   Or something the ASIC miners could do as a sideline is spam like crazy   Ok for the GPU users though.However I do worry about the privacy implications of that.  If you mined a 25 blocker and have to disclose a recipient thats not ideal.  You could probably fix that eg though a separate field that is encrypted, before hashing, and the encryption key sent with the hashcash for the recipient to verify, but kept private from the bitcoin network.  Maybe they'd even have an indirect satoshi level value for email postage uses.  Though they are not transferable as hashcash is fully decentralized and scalable.  ie the miner has to be the mail sender generally, because the stamp includes the email recipient in the hash.  (Though the encrypt the recipient address before hash trick, would allow moderately privately outsourcing the work.  I say moderately because the miner can still correlate the stamp issued to the email if it got logged.  Dont forget these things were also meant to cope with anonymous remailers.  even for regular email it just not smart to scatter around electronic breadcrumbs in the name of outsourcing a few seconds of CPU without some cryptographic unlinkable blinding, which seems doable but I didnt explore)Adam Well I dont think thats as dangerous a problem as corporate control by a long way.  A pool cant misbehave much.  If it does the users will realize and pull out and it'll go under.Surely thats just a question of mining in much smaller parts, so that rewards are meaured in the Satoshis range instead of 25 whole coins.  I think the harder but probably solveable problem if it was desired would be p2p traffic efficiency.  I do think poolproof would be useful.ppcoin seems interesting.  I think I reinvented it or something similar, had another post in draft form, though ppcoin seems complicated at least the way its explained on the wiki  (not sure I fully understood it from quick skim of wiki).  Will post my similar idea next.Adam Go the satoshi-quo  -- I am not displeased -- you're using my mining function (with pretty much no wikipedia attribution anywhere btw other than Satoshi's paper *), and I am also attached to it, and frankly I did guess that would be the likely, and with some justification, community response.  And indeed as I said in another post I appreciate the Satoshi-quo quite strongly for concept stability that may affect investors confidence.  And I'm game to see how that turns out.  It'll be an interesting ride.It remains to be seen whether ASICs become available to the user-level participants in enough volume to mean that the network remains > 50% controlled by users.  The economics dynamic is too hard to tell.  I do very much hope it works out that way to strongly enough to keep the network well in excess of 50% p2p controlled.What the community can do is try to bootstrap garage, kickstart, small co mining manufacturing enterprises to help retain the p2p power balance.  Unfortunately I dont have the direct skills to help with that much because I am not a hardware hacker.If the corporate controlled entities amassed enough of a majority of network hash power (eg > 90%) for a year or so period they may feel confident enough to fork the protocol.  Dont forget they may be forced to, as advised by conservative corp lawyers, even if it may likely destroy the p2p aspects of the bitcoin network, and indirectly perhaps their own profit.  (Which they may or may not see coming).  If that happens I would be worried for the longevity of bitcoins distinguishing features (other than virtual hashcash gold based paypal like concept with the usual seizure, blocking, payment roll back etc issues).And I suppose there is an implicit backup plan if bitcoin devolves into non-p2p, corporate controlled, stripped of most useful p2p era functions, but still working in a paypal like way (balance seizures, account blocks, transaction rollbacks included) system, then a replacement more agile mining process or other innovation crypto-currency may rise up from the ashes or be adapted by the p2p community as a continuation of the p2p bitcoin ethos.Well actually that would be of general utility as a (faster at all costs) next gen CPU, and so it would more tend to have universal availability - the market for CPUs is much larger than miners - and scientific computing would love to use it.  Its also an inherently useful innovation force (in a bread pudding protocol like way) whereas ASIC hashcash miners are laser focused and of little non-bitcoin use.There is an estimate that there is (massive) computing physical limit - that does involve very high temperatures.  I forgot the number of groups of 000s on the operations per second the physicist's paper i read had estimated, but it would make a unbelievably ferocious miner indeed if humanity could ever get that close to the physics computing limit.  (That physical limit model assumes no quantum computing).But I've said my piece, and maybe it'll inspire people to poke at various alternatives (though please no gratuitous no-innovation bitcoin forks!).  Got the bitcoin equivalent of my 1990s "CAs are going to be abused by governments to issue rogue certs" warning in. And I'm just warming up on the crypto suggestions...Adam(*) I added the hashcash ref on bitcoin wiki, or it also didnt reference as I recall, and I had a go at adding something on wikipedia but the editors/moderators didnt seem inclined and I didnt have the energy to argue with them. So about the mtgox DoS or inability so far to scale their servers in line with user demand ramp up:Gollum suggested I comment on this thread re a short side discussion we had of a subset of this topic.  About exchange security model I do have some ideas, that presumably others have already thought of (not read enough of the massive forum back log to know).  I tweeted about this a few times (@adam3us).  Basically it seems like an easily avoidable design flaw to me that the exchange is holding the bitcoins.  That is why exchanges keep getting hacked - they have a big coin float on them and coin transfers are by design irreversible.Maybe I should create myself a bitcoin address for free advice tips if anyone does a startup or exchange or anything with this stuff 1. My thought is why not handle the money and transfer proofs in two stages so the actual coin flows p2p and never sees the exchange.  I reckon you could do that without any bitcoin protocol changes.  (eg with the exchange just handling the escrow of the funds, and arbitrating on the basis of the clearance of those funds that the buyers address has been confirmed to have transferred to the buyer's address).  QED, simple no?  (aka Quite Easily Done:)2. You can do better than that with bitcoins multi signature option probably, then from the exchange point of view the transaction can complete instantly without waiting for the confirmation if it is one of the signatories on the pre-confirmed first stage.  The exchange cant spend the coin because it doesnt have the user private key, and can remove itself from the signature via a second spend and confirm back to the users exclusive control if they wish.As far as I could see no-one is doing this, nor attempting to do this.3. Also even within that the exchanges seem not leverage obvious crypto approaches - they dont even use public key crypto to bank coins they dont need immediately with an airgap to the big value stuff.  (They can bank over an airgap by paying to their airgapped address).4 The rest about the mtgox exchange overload is that they for some reason are struggling presumably due to inexperience or too fast a ramp for what they were expecting to keep up.  Buy more equipment, hire more really experienced data center engineers (who have handled equipment at real stock exchanges or bi g online trading platforms like etrade where a 5min down time costs millions.  These people get per minute mallus on their fat salary for downtime, but they know their shit!)  QED3.5. There were ideas to introduce dnyamic anti-DoS hashcash requirements into TCP cookies and SSL-handshakes. I wrote about it in one of my hashcash papers.  It would be easy to put bitcoin in there.  That way under attack the exchange just increases its connection fee, and if the attackers persist the exchange makes more money. http://hashcash.org/papers/6. about bitcoinxIts a quite interesting idea, and seems more p2p minded than opencoin.  But a limitation is a big part of the contribution of bitcoin is that transactions are final, irrevocable and not subject to seizure, recipient blocks etc. but not too politically controversial as they arent that anonymous.  Even more than with bitcoin (if bought via an exchange) getting money into a coloured coin actually has to happen via an exchange to represent offline ownership of a share certificate, a claim on a EUR deposit (who holds the actual while the coin is circulating? - what happens if its a Cypriot bank and the government an EU troika seizes 50% of it).   Its like a digital bearer bond (man Bob Hettinga would be drooling over coloured coins).  But I think those interesting bitcoin properties are lost because governments can easily require the exchange or bank / broker entity holding the actual stock certificate or bank deposit to revoke ownership etc.  However was left holding the coloured coin is holding a worthless clump of hashcash.(ps I presume though I didnt read far enough that the colouring process starts with a valid bitcoin, spends it down to 0, to buy the instrument, leaving a btc 0 coin with a coloured second use as a claim on the exchange held instrument.)Adam If it wasnt clear that wild 1997-era hashcash design alternative idea was I meant this design competition would be on ongoing and a candidate picked via fair crypto lottery at each 6month epoch.  ASIC miners have to get fast off the mark or they wont recoup their investment.A risk you run is its a bit like obfuscated malware C contest but in crypto - if someone manages to slip a backdoored design past the crypto reviewers (which could include the cryptographic community) maybe the designer of a picked design gets a small bitcoin bounty, and more importantly the breaker of a design after the submission cut off gets a bounty also to bring in the best cryptoanalytic minds from the community.You dont really want any human intervention allowed after the lottery or its arguably destabilizing.btw a way to think clearly about the economics of $100m+ ASIC investments - say it becomes possible to build economic machines to do alchemy (convert lead or other worthless stuff into gold).  It is actually possible presently and has been demonstrated in particle accelerators and what-not but the cost is phenomenal and they yield low.  Anyway say its possible to build one for $100m, with a yield 1000x what can be done for a $1m investment, and practical but almost zero yield machines are possible to build in your garage or buy - chance do you think you have buying one of those digital alchemy boards?  I didnt think so.btw2 I like the argument put forward by a presenter in a Matonis + some economist guy discussion that come some unspecified pre-singularity events eg like self-replicated nano-bot gold miners, or genetically engineered algae to filter sea water for gold and dump it in locateable clumps.  Again thats going to be  government research lab or monsanto event not a garage event, and you can bet they will try to hoard the mechanism if the barrier to entry is high and not easily garage reproducible.  And anyway if they're not careful either way the bottom is going to fall out of the physical gold market   At that point its all bits an bitcoin is better than physical gold.  Singularity timeline projections: this century.  Some pre-singluarity events clearly earlier this century than later.Adam[/quote] Well my (A-level economics grade;) economics argument is market price is set by supply and demand, the supply and competition is limited and the barrier to entry large, so its a sellers market and so the sellers will either not-sell and mine, or sell at a small margin below utility value so the buyer takes the market risk and the seller takes most of the projected profit.  Ie they'll charge a massive margin, which yes invites competition, but unlike a normal market there is a floor to how much they'll be undercut - the mining value.  The next manufacturer will do the same thing, as they also leverage their barrier overcoming investment, so I dont think the market can fix this.Maybe bitcoin price volatility helps somewhat while it lasts - big hardware manufacturers maybe dont want penny-stock odds - thats more VC profile - established owners of fabrication plants, chip design houses etc have a business to run, and want to reduce their projected sales volatility.  However I could see bitcoin price volatility reducing as the market matures and derivatives contracts availability appears - and that would elevate the above problem.So I am (and was from the beginning) concerned there was a risk hashcash could end up stacked in favor of big players because they can pay for the development and contracts etc and mine their own equipment.  And with hardware - hardware hackers can get somewhere, but no where near AMD gpus and Intel cpus - the analog of that level of manufacture and design.  And the AMD & Intels investment level is huge.  I think it comes down to what the price/performance/power graph looks like between generic hardware (GPU), close to current moores' hw limit big funding hardware (VC or existing big co), small biz hardware (butterfly), and hackerspace level hardware hackers can do.  If there is a big discontinuity between hackerspace or kickstarter, the p2p nature of bitcoin may erode in a few yearsMaybe bitcoin ought to community use some of that $1bil market cap to do something mega-kickstart.  Maybe there is even a self-interest in that.  If bitcoin loses its p2p nature I expect the currency value to drop.If I was a hardware guy with like ex-intel chip designer experience - I would go for this right now.  But I know close to zip about ASIC & CPU/GPU design at layout compiler etc level.  A detailed and airtight kickstarter contract could bootstrap availability of close enough to moore's law edge to defend the p2p nature for scalable investments and profitability down to $100 level.  But on the receiving end with those kickstarter projects they look like make-money-fast schemes for the operators of unknown technical skills and execution ability.  Like butterfly but much worse.  You need hardware design credibility, execution ability history, openness and a contract that on independent legal review guarantees community access without the kickstarted employees walking off with 99% of the profit or miners.(I figured this out the hashcash big player hw design issue in 1997 and had some other candidate cost function ideas re anti-spam - note bitcoin has pushed hashcash harder than spam might have because there is more money and motive involved so the answer may change - for hashcash anti-spam / anti-DoS for anonymous remailers and other anti-DoS applications I took the risk because my estimate was the extreme simplicity, ultra fast and simple and human readable mechanism and 100% distributed and 100% scalability prototcol was just too cool to pass up and the spamming profitability business model has ultra slim margins so even with near universal scale deployment it would be safe from mega investments .  Its not many things that can accurately claim to be 100% distributed and 100% scalable.  Not a coincidence I  was at the time a distributed systems PhD student and crypto fan - distributed systems field studies scalability limits and distributed algorithms.)Maybe thats what Satoshi's moving on plan is - protect the p2p nature with a hw manufacturing stealth project funded with discretely siphoned post anonymity bug genesis bitcoin hoard.If there was a way to bootstrap and keep p2p levels of market availability and profitability, you can see the advantages of keeping to the hashcash gold-standard.  It stood 16 years test of time so far cryptographically, and thats worth something, quite a lot of bitcoin's viability is based on that stability.  It also keeps the satoshi-quo, which I like.I agree.  Without being a concrete design, and very much wild-discussion material - maybe a fair cryptographic p2p lottery elected function each epoch chosen at random from a massive function family.  But its hard to design  a function family where all functions have enough variability to reduce the GPU/ASIC gap, and with hashcash-like properties (fast verification, compact storage, no shortcut).Btw it would also be desirable to have something generic enough that as the hardware that gets built would if configurable enough (if the function family heads towards general program) it has dual uses.  Ie it IS a next gen GPGPU and that in itself could help accessibility as there is lots of market demand for such things from the scientific community.Or a 6month design competition with review for security (no hidden trap-doors), fast verification, and then a replacement chosen via fair lottery.  I figure 6months ought to break the ASIC or higher end design cycle for a new function up a bit.Ps I presume everyone heard of Jakobsson & Juels "Bread Pudding" protocol http://www.rsa.com/rsalabs/node.asp?id=2049Trying to get the miners to do useful work.However absent an efficiently publicly auditable proof-of-work that is fairly tied to the computations of a homomorphic encryption scheme, their proposal as far as I can see not possible to scale with decentralized trust.  (Email me if you understood the import of that last sentence   And I dont like non-decentralized things.Juels was also the same author that reinvented something hashcash-like but online (Client Puzzles).  (Offline is better as its more private, and publicly auditable, client puzzles are not).  Juels was not aware of hashcash at the time.  I have a link to that one and others on:http://hashcash.org/papers/Adam Thats kind of an unfortunate privacy bug.  Coincidentally I thought about and fixed a few potential issues like this in hashcash (it was originally designed for anti-DoS for remailers as well as anti-spam for email so privacy and linkability mattered).  (hashcash is the bitcoin mining function).The way I did it is to have a separate field dedicated to adding the randomness to avoid start collisions (two miners choosing the same stamp/coin) and then I just used a never decreasing counter for the mining.  Simples QED.For Satoshi now - maybe he can find a private buyer via a lawyer and swiss banking services.Or perhaps we're forced to implement zerocoin to protect him Anyway dont sweat people - he can probably get by on a few $M play money from his post privacy bug fix mining hoard until there's a solution on his post.  (When was that bug fixed btw?  Cant tell from those low res graphs).  And hes' probably holding out for the $10k bitcoin era anyway.Adam I presume most share the view that "me too" forks of bitcoin thattweak parameters are a bad thing and should be ignored.  However Ithink litecoin is the exception, because even though I am the inventorof hashcash (the bitcoin mining function - yes I contributed to the40MW and growing environmental crime;) - even with that personalinterest/attachment I think the scrypto mining function used by litecoinhas advantages and should be partially merged, and I'll tell you howwhy I think this, and how I think it would best be done.The reason is litecoin is ASIC unfriendly, so that moore's law chasinggeneric CPUs and GPUs will track closer to what is achievable withcustom ASICs because of the intentional memory footprint.  Ok everyoneknow how litecoin works, my point is meta, coming next: when the ASICwall hits (if butterfly ever ships) its probably going to put the GPUminers out of business.I think that is a bad thing for a few reasons: GPU mining is fun, itadds the visceral gold-like aspect for users, and its inclusive, andp2p friendly.  ASIC mining is exclusive, not in principle - nice ASICPCI cards and USB boxes could be built in $100, $200, $500, $1000increments etc - but in practice because anyone with skills to makecards has an obvious incentive to mine them themselves rather thansell them.(I just placed my own butterfly order + a two 5GH baby ones for myteenage sons, one of who is enjoying GPU mining Now the concern is longer term.  Imagine its 3-5 years down the road.Rows of data center racks lined with blades chock full of 14nmhashcash mining cores.  A danger I see is that manufacturers have aninterest to hoard as long as bitcoin price supports a high profit withnext gen hardware compared to what is available to others.  So the bigboys (and I mean financial houses, venture capitalists, kind of level)will be best placed to be able to buy their way into the line at TMSC,front millions in design, pre-order fees, circuit board design.  Therisk is p2p miners arent going to be able to get access to equipmentthat can financially compete with this equipment.  Butterfly seems likea small player - maybe they'll ship.  But what can be done with theabove scale could eclipse their power and efficiency, probably in the same way ASIC outclasses GPUs and I can see market reasons whyyou or I wont be able to buy them.Now some people might think so what - all's fair in a moore's law armsrace - thats part of the design.  And to some extent thats right.Bitcoin could do fine like that, but it wont be a p2p currency anymore, not really.  That's because if all the peers are big stock marketlisted companies, with corporate lawyers, very statically and easilyidentifiable, they will do whatever governments tell them to do.  Andgovernments will tell them to convert the network into swift 2.0including government feeds for analysis (yes bitcoin is public anyway,but not to your legally required truename etc), and legal requests toblock this and that payment entity change the protocol by fiat etc. toroll back transactions because of some fraud or dispute unrelated tobitcoin, to freeze and confiscate bitcoins - we'll be back to square one.At that point also they'd just as soon stop mining and write contractsto each other and save the hashcash GWs.  Big companies are largelyscared enough of misbehaving or having their banking or wire transferrevoked that they're not going to hack a block chain fork or suchtricks.Now I think one reason you might want to listen to me, some randomcrypto-hacker, is I think I've been here before.  I predictedsomething similar about CAs a decade or more ago.  I said one shouldnot trust CAs (I can probably find the post), one should not buildecosystems that rely on them implicitly - governments will simply getthem to issue fake certs and intercept or manipulate user traffic.Roll forward 10 years and it eventually slips out that we have CAs onthe down-low selling rogue CA certs, and some pretty questionablegovernments operate some CAs.  Mozilla is debating removing anotherCA right now for some malfeasance.  (And Iranians and Syrians etc critical of their government etc are being identified, rounded up torturedand murdered with using the info).  Well and western companies with government blessing or turning a blind eye are making and selling them the equipment to do it with, and doing backroom deals with the same dictators in the name of strategic influenceAnyway hopefully you see my point - you do want bitcoin to remain p2por there is a risk if too large entities evolve, of that destroyingthe p2p nature, and essentially removing the need for or value ofdistributed time-stamping using hashcash.Secondly the p2p miners and users "own" and are the network.  Weshould protect their interests.  Keep them interested in bitcoin viathe fun of mining.  Maybe you could do that via easy access tocompetitive ASIC and above hardware built with kickstarter or opensource hardware or small companies like butterfly.  But I'm notconfident.  Or if I had influence I'd encourage implementing a backupplan ready to roll out.I suspect the network difficulty might even drop facing a wall ofASICs over the next year or so if GPU mining goes the way of CPUmining.  I say that because even though the ASICs might get 100x moreMH, they may drive out 1000 GPUs each, and then the ASICs get toprofit even more (they own a bigger than anticipated slice ifdifficulty falls).  Doesnt affect bitcoin price necessarily, butdifferent people will be getting the mining rewards.So if you buy any of the above here's how I think it should be donetechnically.  Clearly you dont want sudden changes, or it affectsconfidence in the definition of bitcoins.  Maybe there are counterarguments or other approaches.  I understand people are atttached tothe satoshi quo - as it should be sudden changes are bad.  You guysare now in a EU troika like position you have to be careful what youdo because it can have consequences in the confidence in the BTC.  Maybe soon even what you say!  So I do respect the no sudden orunconsidered moves concept.Well my idea is this aim to get to 50:50 hashcash scrypt (or perhaps even 66:33 so the hashcash which is potentially more vulnerable tocentralization cant control in the 50% sense of forks if the corporates decide to fork the chain following a government edict)hashcash and scrypt are accepted as both equally valid whoeverfinds the collision of the required difficulty wins the 10min block.Phase in, maybe be ready to phase in, but dont even do it untiltrouble looms.  Start with 2% scrypt and grow every 2 weeks (same cylceas difficulty adjustment).  But this is the trick: give hashcash and scryptindependently calculated difficulties, the market will figure out thefair value between them.  The custom ASIC filled rackmount corporteguys at the high end may focus on the ASICs they hve 50% to play with.Maybe they can help make things fast and reliable with nice serversand bandwidth.  And everyone else can compete on a level field withscrypt.  Now the corporate guys can get into scrypt also, but the harwarethey buy is the same basic class as you or I can buy - Intel CPUs,GPUs etc with the same power efficiency.(A more detailed comment one may want to allow the scrypt size parameter to be network dynamic like difficulty because if a CPU starts to be common (or is developed custom for mining) with L3cache larger than the avarage systems minimum assumable main memory you have a big problem as memory bound computational puzzles like Moderately Hard Memory Bound functions 2003 (of which scrypt is an improved derivative)http://research.microsoft.com/pubs/54395/memory-longer-acm.pdfare sensitive to too much ultra fast ram.  On the plus side the argumentis in general that variation in ram speed is less than variation in core speed between mid and top range.)You could consider it a BTC/LTC alloy so I guess I am arguing for agold-silver alloy coin.  (Or the BTC shiny coin logo always seem to be 2 tone anyway already?)  A negative version of that could be callof currency dilution, however I argue its not because it doesnt create any new coins, just levels the playing field to lower hardware while no one gets any particular advantage.(Midly disgruntled after just having escaped the ignominy of being inthe newbie trap:).  But dont be gentle - bring on he nay saying - Ivebeen through USENET flame wars of the early 90s - bring it on.(My ignominy post towards my 5 to get out of newbie trap!https://bitcointalk.org/index.php?topic=15672.msg1873483#msg1873483 )Adamps Its kind of ironic - I got emails from Satoshi in 2008/2009 abouthashcash & inviting comments on his paper, and to try the alphasoftware; the irony that I invented the hashcash function all theCPU/GPU and ASIC miners are burning 40MW on and yet I dont own (norever have) a single bitcoin.  What a foolish person  Surely Ishould've tried it out mining at the beginning like Hal Finney did.Well I'm going to fix that via mtgox & an asic miner but there's noway I'm going to get to Satoshi's $100m genesis hoard level as a latelate player  their market depth is 0.  There are two asks at $99/btc and nothing more.  Trade volume ~0!Adam Oh the ignominy of it - stuck in the newbie bin after 24 years of internet use, 18 years of linux, 30 years of programming from z80 assembler and up,  debating C++ template semantics with Stroustrupp while I was writing a parallelizing C++ source to source translator (before I evolved into a philosophically an anti-C++ person preferring C), enjoying USENET flame wars in the old days and tittering about newbies ineptitude So anyway hi I am Adam Back, inventor of hashcash (the bitcoin mining function... all those mining cores and ASICs are grinding away producing hashcash).  So yep I contributed to the environmental crime of so far 40MW continuous mining.  We installed a 3.5kW solar installation but it seems like a small offset :|  I also implemented the opensource library credlib which implements Chaum and Brands ecash.  And actually reinvented offline multiple transfer Brands ecash (turns out someone else already figured it out when I asked Stefan).  I consulted for Nokia on ecash crypto back in 2002.  I worked at Zero-Knowledge Systems from 2000-2003.  So anyway I know a few things about ecash, privacy tech, crypto, distributed systems (my comp sci PhD is in distributed systems) and I guess I was one of the moderately early people to read about and try to comprehend the p2p crypto cleverness that is bitcoin.  In fact I believe it was me who got Wei Dai's b-money reference added to Satoshi's bitcoin paper when he emailed me about hashcash back in 2008.  If like Hal Finney I'd actually tried to run the miner back then, I may too be sitting on some genesis/bootstrap era coins.  Alas I own not a single bitcoin which is kind of ironic as the actual bitcoin mining is basically my hashcash invention.  (The only difference being a double hash for a bit of added design paranoia, the switch from SHA1 to SHA256 and defining fractional bits - hashcash difficulty can only double or halve - just count leading bits - bitcoin variant of hashcash defines the challenge as to find hashes < 2^x where x is the log2(difficulty)+32 in bits which is the same when there is no fractional part).I am a strong believer in distributed trust models.  I was one of the early and vocal technical voices on the cypherpunks list.  Worked on distributed trust privacy tech and anonymity designs at ZKS (ToR is a newer re-implementation of their freedom network which includes my forward anonymity contribution), understand the risks of centralization, vocalized concerns about the risks of CA model, decade before we saw diginotar and others bring those predictions to fruition with Iranians and other CA operators issuing rogue sub-CA certificates for gmail.  I broke a number of crypto deployed systems most of which under NDA.  I have some concerns about centralization trends and how to avoid them on bitcoin.  Oh yeah I proposed something namecoin like also a decade or so back.But for now I, just gotta get out of the newbie trap.Ignominy, my word for the day Adam I think you're right and you could reasonably claim HFT is a stupid zero-sum game, leading to flash spikes when algorithms go wrong real-fast.  The defenders might claim it adds liquidity but traders were trading before HFT and liquidity was fine, and what human needs sub-microsecond liquidity.  People should be investing not speculating by the day, minute or now microsecond!  A bit of short-term speculation helps liquidity and remove exchange differentials via arbitrage and reduce spread via volume, but there need to be sanity limits.Adam Well its just a guestimate and there are factors pushing towards it being over estimate (FPGA, ASIC, and people having second uses as space heaters, people using mining on systems that were on anyway and not using much extra power or no extra because of it) or an underestimate more people than you'd think still playing with CPU miners, or CPU mining + GPU simultaneously etc.  Who knows!But another thing is the stat of 982/24 = 40 MWatts sounds less alarming than ~ 1 GWh per day.  You notice how they did that.  However thats still quite a few households eh has to be into the thousands of households range.  According to this stat http://www.eia.gov/tools/faqs/faq.cfm?id=97&t=3 that would be like 30,000 households ongoing energy budget.  And escalating probably as the difficulty ramps up if the price supports the demand.Adam
