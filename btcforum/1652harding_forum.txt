Is this some consequence of the structure of "defi" lending contracts?  I hadn't paid them much attention, but a quick search showed several where you use BTC or ETH as collateral for a loan denominated in some "stablecoin".  That leaves you exposed to the risk of (paper) losses if BTC or ETH declines, so it doesn't seem like a constructive sale to me, unless the IRS is treating all cryptocurrencies as substantially similar assets (which might be warranted given the amount of obfuscation alts try to pull off). For anyone curious about this idea, perhaps read: https://en.wikipedia.org/wiki/Leveraged_buyout .  I had learned about the wave of leveraged buyouts that occurred in the 1980s (taught in the context of how it may have made large organizations more fragile and short-term focused) but hadn't myself connected that with the idea of companies holding significant amounts of bitcoin. This statement runs counter to my intuition, so I made a quick comparison.  First, I assumed we were talking about the P2P network protocol ("the Bitcoin protocol" could also refer to the consensus protocol, but this conversion seemed to be about networking).  Second, I looked at all merges to Bitcoin Core during the six months up to today and the same period five years earlier.  Completely subjectively, I made a list of all the commits I thought affected how Bitcoin Core interacted with the protocol in a non-trivial way.  Here's the list for the the past six months (2020):Code:$ git log --since=2020-01-09 --until=2020-07-09 --merges --oneline | wc -l768abdfd2d0e Merge #19219: Replace automatic bans with discouragement filter8edfc1715 Merge #19204: p2p: Reduce inv traffic during IBD28ce05d06 Merge #19260: p2p: disconnect peers that send filterclear + update existing filter msg disconnect logic73407ff65 Merge #16939: p2p: Delay querying DNS seeds7d32cce3e Merge #19010: net processing: Add support for getcfheaders4479eb04d Merge #18960: indexes: Add compact block filter headers cachec73bd004a Merge #18861: Do not answer GETDATA for to-be-announced tx553bb3fc3 Merge #18962: net processing: Only send a getheaders for one block in an INVe45fb7e0d Merge #18877: Serve cfcheckpt requests7a5767423 Merge #18808: [net processing] Drop unknown types in getdata0ef0d33f7 Merge #18038: P2P: Mempool tracks locally submitted transactions to improve wallet privacy67dfd18f4 Merge #16902: O(1) OP_IF/NOTIF/ELSE/ENDIF script implementationd104aa0ac Merge #17951: Use rolling bloom filter of recent block txs for AlreadyHave() check01fc5891f Merge #16702: p2p: supplying and using asmap to improve IP bucketing in addrmanHere's the list for the same six-month period five years ago (2015).  Note, the merge messages back then didn't include a title, so I placed the subject from one of the commits in that merge in brackets:Code:$ git log --since=2015-01-09 --until=2015-07-09 --merges --oneline | wc -l32166e546577 Merge pull request #6310 [f581d3d banlist.dat: store banlist on disk]41076aad0 Merge pull request #6124 [ffd75ad Enable CHECKLOCKTIMEVERIFY as a standard script verify flag]e34a8acd9 Merge pull request #6233 [3e91433 Advance pindexLastCommonBlock for blocks in chainActive]c1fb0e107 Merge pull request #6274 [02a6702 Add option `-alerts` to opt out of alert system]3a1d3e8f5 Merge pull request #5985 [14d4eef Fix removing of orphan transactions]8d9f0a606 Merge pull request #5927 [dce8360 Reduce checkpoints' effect on consensus.]9d6060244 Merge pull request #5875 [9be0e68 Be stricter in processing unrequested blocks]88a7ead5d Merge pull request #6172 [a1ba077 Ignore getheaders requests when not synced.]9f7809f6c Merge pull request #5976 [8ba7f84 Reduce download timeouts as blocks arrive]e9af4e65b Merge pull request #5947 [36cba8f Alert if it is very likely we are getting a bad chain]7bf5d5efa Merge pull request #5918 [f7303f9 Use equivalent PoW for non-main-chain requests]5048465fc Merge pull request #5662 [00dcaf4 Change download logic to allow calling getheaders/getdata on inbound peers] 71900b442 Merge pull request #6029 [a784f90 Cap nAttempts penalty at 8 and switch to pow instead of a division loop.]27e8d224e Merge pull request #5945 [ad9e86d Keep mempool consistent during block-reorgs]f7dea1cba Merge pull request #5941 [1d21ba2 Scale up addrman]29fef0b90 Merge pull request #5360 [9c27379 Reduce fingerprinting through timestamps in 'addr' messages.]c1b723c30 Merge pull request #5442 [dca799e Ignore getaddr messages on Outbound connections.]51377c2db Merge pull request #5843 [ba04c4a Limit message sizes before transfer]fcf646c9b Merge pull request #5286 [a930658 Change the default maximum OP_RETURN size to 80 bytes]6ee87f9bc Merge pull request #5647 [3ff735c Increase block download timeout base from 10 to 20 minutes.]41e6e4cab Merge pull request #5713 [5a47811 BIP66 changeover logic (Pieter Wuille)]de8b9ab75 Merge pull request #5608 [9161303 Introduce 10 minute block download timeout]So there were 22 (subjectively) notable merges in 2015 and 14 notable merges in 2020, a 35% decrease in the number of merges. In both cases, an overwhelming majority of the changes are tweaks to the existing logic mean to improve security, privacy, or reliability rather than more significant extensions of the protocol.  Looking at the titles of the merges, and again very subjectively, I think I'd consider the aggregate of the changes made in 2015 to be even more than 35% useful than the 2020 changes, so the gap between the years is arguably larger than suggested by just the numbers.However, based on these data, I don't personally agree that "there isn't much activity in improving the Bitcoin protocol anymore."  The rate of change does seem slower, but I think it's far from stagnant. Please, please, please don't hesitate to compete with us!  Although Optech is technically a for-profit company, we operate like a non-profit, have only modest revenue, and almost all of us are contributing for free (or through salaries paid for by other organizations, like Chaincode or Square Crypto).  We occasionally write about fee management because we think it's important, but there's plenty of other important things we could be doing with our time (both as individuals and as a team).Early on, we made a decision to focus on producing educational material and holding workshops rather than offering direct consulting---so you (or anyone else) working directly with companies to optimize their spending would be a complimentary service, not a competitive one. That update was likely the result of my prompting.  On 23 November (my local time), I emailed several people I knew who owned .org domains encouraging them to renew as far in the future as possible because the .org registry was being sold.  Here's a copy of the email I sent Cøbra:Cøbra replied thanking me for the tip and saying that he'd update both domains, although he wasn't sure it was strictly necessary (indeed, so far, I don't think renewal fees have increased much). If you're referring to https://bitcoinops.org/workshops/#taproot-workshop, please note those were private training sessions for Optech member companies (who all pay an annual fee in part so that we can produce training material for them).  The workshops did not involve any of the primary contributors to taproot (edit: this is incorrect: Pieter Wuille attended the SF workshop and Andrew Poelstra attended the NYC workshop) and did not involve any protocol development.  Indeed, here are some quotes from Bryan Bishop's rough transcript of the New York session https://diyhpl.us/wiki/transcripts/bitcoinops/schnorr-taproot-workshop-2019/notes/ :I'm sorry if there was any confusion about these workshops somehow being official. Last I heard, Sjors Provoost works for Blockchain.info, Anthony (AJ) Towns works for Xapo, and Jim Posen works for Coinbase. Blockstream employees Pieter Wuille, Jorge Timon, Gregory Sanders, and several other contributors (plus two C-Lightning devs)  Several companies also help support the Media Lab's Digital Currency Initiative (DCI) that employees Wladimir van der Laan and Cory Fields (as well as several other open source Bitcoin contributors who don't normally focus on Bitcoin Core).The other major source of employment for Bitcoin Core work is ChainCode Labs.(I could be forgetting some companies; if so, sorry.) I'm disappointed that almost everyone posting in this thread is making suggestions about what other people should do rather than thinking of ways to contribute themselves.I plan to open at least one PR a month adding a useful new test to Bitcoin Core, or significantly improving an existing test, with the first PR to be opened by 31 October 2018.What do the rest of you plan to do? I added information about finding a safe server with Electrum here: https://en.bitcoin.it/wiki/July_2015_ForksIf you find any more servers whose banner lists a safe version, please add it to that list. At a guess, the payload would be something like this:Code:01 ......... Filter bytes: 10000 ....... Filter: 0000000000000000 ... nHashFuncs: 000000000 ... nTweak: 0/none00 ......... nFlags: BLOOM_UPDATE_NONEYou'd have to determine for yourself whether an empty filter or an nHashFuncs of zero is permitted.  It might even be possible to set nFilterBytes to 0 and omit the filter field entirely.Note that you don't need a filter to inhibit receiving transaction invs---that's the default connection mode if you set the relay flag to 0x00 in the version message.  (This would normally be done in conduction with setting the services bitfield to 0x0000000000000000 to indicate you're not running a full node.)  The quote is out of context, so it isn't clear that we're talking about a non-upgraded node after a hard fork.  In that case, the non-upgraded node does not think the stronger chain is valid (because it breaks some consensus rule), so it will not accept it as the local best block chain.  The error/alertnotify is to tell you something is wrong.  For reference, that section of the docs was written based on the code is this function.I'll push a minor revision to the quoted sentence so it's more clear and harder to take out of context.  Thanks! We recently added docs about bloom filters and merkleblocks to the Bitcoin.org developer documentation.  You probably want to read this first:https://bitcoin.org/en/developer-reference#filterloadAnd then look at the Python example here:https://bitcoin.org/en/developer-examples#creating-a-bloom-filterI also agree with Mike: I found reading the BitcoinJ sources very useful when writing the above linked documentation (and, of course, I depended on BIP37 for design details). It looks to me like CompactSize requires the smallest possible encoding.  See: https://github.com/bitcoin/bitcoin/blob/master/src/serialize.h#L218It also looks like there are some tests to ensure non-canonical compatSize uints are forbidden in the test cases.  See: https://github.com/bitcoin/bitcoin/blob/master/src/test/serialize_tests.cpp#L81 Incorrect.  The developers reference describes Remote Procedure Calls (RPCs) which have nothing to do with the configuration files.Incorrect. I opened the issue proposing that page based on a bitcoin-devel mailing list discussion and, as the issue says, I'm delaying writing that page until there's a setup-free package which allows Bitcoin Core to run as a background service---that means no config file editing will be required.Incorrect, as described above.Scurrilous.  Luke-Jr is the one who suggested you update the Wiki, so he's unlikely to reject a quality contribution.I disagree. The video promotes your website (Bitcoin.me) and so your behavior is highly relevant. Based on the calumnious statements you've made in the pull request, issues, email correspondence, and this thread, I would recommend people stay away from you and your website. super3:Greg Sanders and myself (Dave Harding) wrote almost all of the original text. The in-text illustrations were all done by me, I think. Saïvann Carignan (blockgenesis) was managing editor, integrated the text into the website (along with icon development), and generally did the many small necessary things to keep the project on track and productive. I'd call us three the current core docs team (but more people are welcome!).Mike Hearn brought most of us together, provided a large number of invaluable early reviews, and more ongoing feedback to the degree his busy schedule allowed.  Knowing we had the explicit support of at least one core dev was highly motivating, and I think we're all deeply appreciative that Mike was willing to lend his time to our endeavor.Tom Geller provided line-level editing of the first-written section of the guide, the Block Chain section, as well as creating the style guide we continue to follow.Chris Beams has been continually providing reviews, feedback, testing, and suggestions both on the text and the website presentation.Quite a few other people have contributed, although in ways that are harder to track. For example, Greg and myself used the Bitcoin Wiki extensively for research, and the authors of those articles deserve a huge thanks. We're also incredibly grateful to everyone who reviewed parts of our text for accuracy---even if they didn't find any mistakes.I hope I haven't forgotten anyone.As for Bitcoin addresses, Saïvann (blockgenesis) received some docs thank-you donations and has already made arrangements to split them between himself, Greg, and myself once they stop coming in. He's been receiving those donations to the address in his sig, 18XXXQs1vAQGBAZbXKA322r9Zy1nZac2H4.  If you send a tip because of the docs, you really should mention it to him that it was for the docs.However, speaking only for myself, I think the best contributions we can receive are additional reviews for accuracy and help spreading the word about these docs. There is no firm.  This is volunteer-written documentation for the entire Bitcoin community.  However, we do have to start somewhere---and I can't think of anywhere better to start than Bitcoin Core.I'm sorry if I confused you.  Thanks again for your comments! piotr_n:Our audience description says that we're focusing on application developers, which (in my mind) means that we prioritize writing documentation for developers who will use libraries or Bitcoin Core RPCs for the underlying network communication.Once we've covered the topics application developers need to know, I'm happy to move on to topics library developers or core re-implementors need to know.As for opcodes, we describe all the opcodes used in standard transactions here: https://bitcoin.org/en/developer-reference#op-codesAs for cross-reference linking, we use it extensively---there are over 2,000 links in the Guide and Reference.  Just hover your mouse over a paragraph to see all of the internal links appear in blue.  You can further hover your mouse over a term to get a brief description, and then click on it to go to the full description.We really did put a lot of work into trying to design the docs to be useful for developers at all stages, from Bitcoin neophyte to core dev.  Given more time (or more volunteers!) we'll be able to fulfill our core mission and expand the docs to cover more and more parts of Bitcoin.Thanks for your comments! Hi, piortr_n.Did you checkout both the guide and the reference pages?  The guide is aimed at new developers who need to learn how Bitcoin works.  The reference is aimed at the developers who know how the general system works but need, as you say, tables and short explanations (which we've put all on one page for easy in-browser Ctrl-f searching).Guide: https://bitcoin.org/en/developer-guideReference: https://bitcoin.org/en/developer-referenceBoth are linked to from the main page, which also links to other useful resources: https://bitcoin.org/en/developer-documentationWe'll be adding more content over the next few monhs, so check back often!  Thanks! Notes about where to contribute to the current effort from the bitcoin-development mailing list: Locktime was initially designed to be used with transaction replacement---the replacing of one version of a transaction with another.  This is a feature used today in "contracts" such as a micropayment channel.Obviously, if time locked transactions are added to the block chain, you can't do transaction replacement.Now my question: why would you want to irrevocably pay someone but not let them spend the money until a later point?  I kind of like the current method where I can give someone a time locked transaction but rescind (double-spend) it prior to the locktime maturing.   With this method, you can accomplish everything on your list except for #4:1. No need for a separate service: the time locked transaction can be stored in the same wallet as the receiver's private key.  If you lose your private key, then the transaction is worthless to you anyway.2. No risk of the spender double-spending if you use a two-hop transaction where the first transaction goes to a 2-of-2 multisig output that has one key each from the spender and the receiver.3. Only one private key needs to be kept secret if the spender deletes his private key.4. (You do not get protection against the transaction format changing.)5. Simple UIs have already been written for micropayment channels which use time locked transactions.  For example: http://www.youtube.com/watch?v=r0BXnWlnIi4
Hi,We could use a little advice about what's relevant to wallet authors when it comes to choosing which inputs to select for making a new payment.  We described three options:* A merge avoidance algorithm makes it harder for outsiders looking at block chain data to figure out how many satoshis the receiver has earned, spent, and saved.* A last-in-first-out (LIFO) algorithm spends newly acquired satoshis while there's still double spend risk, possibly pushing that risk on to others. This can be good for the receiver's balance sheet but possibly bad for their reputation.* A first-in-first-out (FIFO) algorithm spends the oldest satoshis first, which can help ensure that the receiver's payments always confirmWe were thinking about cutting out FIFO because it doesn't seem very useful (except for being reliable and easy to implement).  We were further discussing whether we should cut out LIFO---which might be useful for some applications---in order to emphesize the privacy benefits of merge avoidance.However, none of us writers/editors have any practical experience here, so we would appreciate some developer feedback about what you need to know.  Here's a direct link to the input-selection section and our GitHub discussion of the issue.A quick trace of Electrum's source code (which I happend to have handy) made it seem like it used FIFO.Thanks, -Dave Hi, Jan.We'd absolute love any help!  We're mostly guessing about what developers need to know, so feedback based on your experience with Mycelium would be hugely appreciated.  For example, what assumptions made by other documentation has tripped you up?[1]  Which BIPs have you found hard to understand?[2]  What important things just aren't documented elsewhere?[3]Thanks!,-Dave[1] As an example of assumptions, one developer told us that the standard format for describing scripts is confusing to new devs because it doesn't mention the op-push-data codes that must be used.  It just assumes you know about them. We revised the documentation based on his feedback.[2] As an example of finding documentation hard to understand, when I wrote a quick test implementation of BIP70, trying to figure out one particular sentence from BIP70 cost me three hours of time.[3] I'm sure there are plenty of examples of undocumented things. :-) Hi,We've been working on a developer guide for Bitcoin.org which might be what you're looking for.  We have a forum thread, GitHub repository, and a demo site.We're actively looking for writers and reviewers, so if you'd like to help, please see the forum thread above.Thanks!, -Dave Hi,The payment processing section (including BIP70 payment requests) has been added to the devguide.  Comments and suggestions are welcome on the pull request.(Please comment there even though the pull request is closed.  Every comment posted will be read and replied to.)Thanks to Saïvann's late-night efforts, you can read the new section in nicely-formatted HTML on the demo site.General questions or comments should be sent here, the mailing list, or submitted as an issue.Thanks!, -Dave Edit:  After reading through the Bitcoin Core source code for an embarrassingly long time, I figured out that this paragraph from BIP70,means to do this:Code:request.signature = ""before doing this:Code:request.signature = sign(priv_key, request.SerializeToString(), "sha256")Thanks to everyone who read my previous post. Thanks! Mike:Thank you for your answer.I think I confused the issue by trying to generalize it and tie it into bitcoinj. Looking at a particular transaction with the form:Code:Input0|Input1||Output0And...*   Input0 is signed SIGHASH_NONE|SIGHASH_ANYONECANPAY (prevout script was pay-to-pubkey-hash)*   Input1 is signed SIGHASH_ALL (prevout script was pay-to-pubkey-hash)And...*   The transaction is transmitted directly to a single miner who doesn't relay itQuestion: Is it true that the miner can remove Input1 and Output0, add a new Output0, and mine the modified transaction?---Your answer did point out something I haven't seen documented elsewhere, so I want to make sure I understand correctly before documenting it myself:Question: Is it true that each signature in a multisig scriptSig can use a different hash type?Thank you again for your help! -Dave Hi,I'm currently writing about OP_CHECKSIG for the dev guide and I could use a quick hint from someone more knowledgeable about the SIGHASH_NONE|SIGHASH_ANYONECANPAY hash type:What prevents peers (relayers) and miners from extracting all inputs signed with SIGHASH_NONE|SIGHASH_ANYONECANPAY from a transaction and using those inputs to create new transactions that pay themselves?I'm confused because, on one hand, bitcoinj's payment channels seem to use SH_N|SH_ACP, so I suspect Mike thinks it's secure, but on the other hand, I don't see how it could be based on the explanation of SH_N|SH_ACP on the wiki, which I understand to say:* SH_NONE prevents signing of any outputs by the current input.* SH_ANYONECANPAY prevents signing of any input except the current inputThe combined effect being a valid input which can extracted and spent to an arbitrary script.Any help will be appreciated,-Dave Right now there are two simple (but not necessarily easy!) ways to get started:1.  Dip your toes in the water: work with Blockgenesis to refine the text we already have about the block chain. Blockgenesis has proposed a number of improvements (some small, some larger) and we need a writer/editor to implement those improvements.2.  Jump into the deep end: agree to write a section of the outline Blockgenesis posted to above. The Block Chain section is written and I'm working on the Transaction section, but all the other sections are unclaimed. Just tell us what section you want and give us a rough idea about how long it will take you.You can, of course, think up an option #3 and do thatBlockgenesis is currently co-ordinating everything, so let him know what you want to do and he'll give you access to the resources we're currently using.-Dave (author of the block chain section in the OP link) Fair enough.  Although now if you get bored, you can be the person who codes up a simple web service that stores locktimed transactions and broadcasts them when appropriate.  :-) Not being able to broadcast it before the effective date may be less cool, but it's not any less functional.  I use locktime to send money to myself in the future---sort of like buying myself a savings bond.The sequence number lets you publish multiple versions of a transaction. The network is supposed to drop a pending transaction when another transaction appears spending the same input but with a higher sequence number.  Sequence number and locktime are both currently used for payment channels as implemented in bitcoinj.  See the following link for details:    https://en.bitcoin.it/wiki/Contracts#Example_7:_Rapidly-adjusted_.28micro.29payments_to_a_pre-determined_partyI'm curious: what cool thing did you want to do with locktime that you can't do now? I assure you, you can set sequence to non-max. Here's a locked transaction I sent myself last week:    https://blockexplorer.com/rawtx/5af2104b1d7f9524f9bb2d5b81e79e7d6e3b21cb5552e31a96a24a7adc3344c7Note that since early 2013, the memory pool will not accept non-finalized transactions in order to prevent DOS attacks. This may be the source of your error. Try sending the transaction when the locktime/lockblock is in the past. Automatic:I just saw your post. The reason your transaction went through immediately was that the sequence number of all inputs was set to the maximum value (4294967295), indicating the transaction was finalized and the locktime didn't apply.Changing any sequence field to any number less than the maximum will prevent the transaction from being entered into a block until the locktime (or, in your case, lockblock number) passes.I got tired of changing locktimes manually, so I wrote a quick shell script that changes the locktime to an arbitrary date and sets the sequence number to zero. The script then does some quick validation of the resulting transaction to help prevent me from doing anything simple.I added some comments to the script to help explain what's going on, but let me know if you have any questions.  Note: I haven't tested it on multiple-input transactions.Code:#!/bin/bash -euBITCOIND="bitcoind"#BITCOIND="bitcoind -testnet"if [ $# -ne 1 ]then    echo "Command to change the locktime of a bitcoin transaction provided on standard input"    echo "  Usage: ... | $0 '<date>'"    echo "  Example: btc-spend-all | $0 'tomorrow'"    exit 1fi## I usually use this script in a pipeline with btc-spend-all, i.e.:##    btc-spend-all | btc-change-locktime tomorrow | bitcoind signrawtransaction $(cat)## or##    echo '01000000017f286f35362457e961925835bff28351e0b679c7810827396c76967712a6714d0000000000ffffffff0100e1f505000000001976a9144c56a8926eeb911b06575be05bad06e66463fb1e88ac00000000' | btc-change-locktime## Load the raw transaction from standard inRAW_TRANSACTION=$(cat)## Get the desired locktime in human-readable format and convert it into## epoch time in both decimal format and little-endian hexadecimal formatLOCKTIME_DECIMAL=$( date +%s -ud "$1" ) || { echo 'Invalid date' ; exit 1 ; }LOCKTIME_HEX=$( echo $LOCKTIME_DECIMAL | awk '{ printf "%x", $1 }' | sed 's/^\(..\)\(..\)\(..\)\(..\)/\4\3\2\1/' )#### SAMPLE TRANSACTION# 01000000017f286f35362457e961925835bff28351e0b679c7810827396c76967712a6714d0000000000ffffffff0100e1f505000000001976a9144c56a8926eeb911b06575be05bad06e66463fb1e88ac00000000#### Every two characters (char) in hex equals one byte# 01000000 .............................Version (8 char)# 01 ...................................Vin count (2 char)# 7f286f35362457e961925835bff28351e0b679c7810827396c76967712a6714d ...Prevout hash (64 char)# 00000000 .............................Prevout index (8 char)# 00 ...................................Signature script length (2 char)# ffffffff .............................**Sequence number** (8 char)# ++++++++++++++++++++++++++++++++++++++[[[[ additional inputs can go here ]]]]# 01 ...................................vout count (2 char)# 00e1f50500000000 .....................satoshis to transfer to send in this output (16 char)# 19 ...................................public key length (2 char)# 76a9144c56a8926eeb911b06575be05bad06e66463fb1e88ac public key claim script (50 char)# ++++++++++++++++++++++++++++++++++++++[[[[ additional outputs can go here ]]]]# 00000000 .............................**locktime** (8 char)## Modify the transactionMODIFIED_TRANSACTION=$(     echo $RAW_TRANSACTION | sed '''        ## createrawtransaction by default creates transactions with        ## max-value sequence numbers, which prevents locktime from having        ## any effect. We need to change one of these sequence numbers to a        ## lower value. Since the first sequence number always appears in        ## the same byte location within the encoded transaction (after 84        ## hexits), we will reduce it down to zero.        s/\(.\{84\}\)ffffffff/\100000000/;        ## Now we need to set locktime to the earliest date when we want to        ## be able to spend the bitcoins. Locktime is always the last 8        ## hexits of the encode transaction, and by default it is set to zero.        s/00000000$/'$LOCKTIME_HEX'/;    ''')## Pre-build the decode command so we can reuse it several times_dc_cmd="$BITCOIND decoderawtransaction"## Now lets diff the original and modified transactions to test for changes.## The diff should always produce 11 lines of output: a two-line header## listing the file names, three one-line headers for each changed part,## and three two-line diffs_diff_line_count=$( eval diff -u0 <( $_dc_cmd $RAW_TRANSACTION ) <( $_dc_cmd $MODIFIED_TRANSACTION ) | wc -l )if [ $_diff_line_count -ne 11 ]then    echo Unexpected output from the diff command.  Dying...    exit 1fi## Now test that all of the expected changes were madeeval diff -u0 <( $_dc_cmd $RAW_TRANSACTION ) <( $_dc_cmd $MODIFIED_TRANSACTION ) \        | egrep -v  '^(---|\+\+\+|@@) '  \        | sed '''            ## Whitelist all of the expected changes in the diff by            ## deleting them so we can then test for unexpected changes            #            ## The new locktime should decode to the decimal locktime            /^+.*"locktime".*'$LOCKTIME_DECIMAL'/d;            ## The old locktime should have been zero            /^-.*"locktime".* 0,/d;            ## The new sequence should be zero            /^+.*"sequence".* 0$/d;            ## The old sequence should have been the maximum, 4294967295            /^-.*"sequence".* 4294967295/d;            ## The only thing left should be the automatically-computerd            ## txid hashes            /"txid" : /d            ## If anything remains, somenthing went wrong        ''' | grep . && { echo "Unexpected changes.  Dying..." ; exit 1 ; }## If we get here, all of the tests have been passed, so give the user## the modified transaction so they can sign itecho $MODIFIED_TRANSACTION Ah, I retract my suggestion.  A particularly crafty virus could infect the media device, install an autorun file, and get the device to switch from MTP mode to USB mass storage mode between the time it disconnects from the online (hot) computer and connects to the offline (cold) computer.  -Dave Hi, Alan, and thanks for the wonderful work you do on Armory.A portable media player which connects to the host computer in MTP mode might offer reasonable security and convenience:    + Files need to be downloaded from the device to the host computer's OS before processing, so files accessed through MTP cannot be automatically executed on Windows[1] or Linux[2], blocking most viruses.    + There are plenty of cheap MTP-enabled used MP3 players on eBay.    + Uses standard USB connections found on practically all computers.    + Runs at high speed for transferring media files, so small transaction info will transfer almost instantly.     + On Windows and novice-friendly Linux distros, unprivileged apps can by default write to MTP so Armory doesn't need root access.    + Open source MTP library and tools for Linux: http://libmtp.sourceforge.net/    + Possible sample code for MTP support on Windows: http://addons.songbirdnest.com/addon/172    - GNOME Virtual FS (GVFS) and probably Windows may autoload thumbnails and other metadata from MTP devices, creating possible attack vectors.  Removing the MTP GVFS module on an offline Linux machine would prevent autoloading there and not otherwise affect the user (unless he used MTP for other things on that machine).Also notable:    +/- Wikipedia seems to say that Windows can't do arbitrary autorun from non-volume devices such as MTP[3], but I recommend testing for verification.    +? There's MTP over Bluetooth[4], which may provide an enhancement at minimal extra development cost (your time) for those users willing to tolerate a network connection.I knew practically nothing about MTP an hour ago and the above points summarize everything I now know, so take it all with a grain of salt.Thanks again for your work,-Dave[1] http://portableapps.com/node/3292[2] http://intr.overt.org/blog/?p=153[3] https://en.wikipedia.org/wiki/AutoPlay#Non-volumes[4] https://en.wikipedia.org/wiki/Media_Transfer_Protocol#History I don't have time to start reading the week before Christmas, but I'm in for next week.Also, I think these chapters are too long for one chapter a week.  What do you think about reading a constant 20 or 30 pages a week?  (Or 21 and 28 pages a week for 3 or 4 pages a day.)-Dave While reading, if you have any questions or doubts, write them down.  Then continue reading to the end of the chapter and see if your questions are answered and your doubts eliminated.  If either remain, post them here.At the end of each chapter, each participant should post here at least one paragraph about what they thought was most important in that chapter.  (More than one paragraph is fine.)I suggest for convenience that we reference the in-text page numbers and paragraphs in the PDF edition at http://mises.org/books/mespm.pdf. We do not need to choose between Human Action and Man, Economy, and State--we can choose to read both in sequence. I do love Economics in One Lesson, but what bitcoin user needs help understanding books written for lay adults and children?  Those books stand on their own--that is their purpose.If the point of this group is to help us learn more together than we would learn by ourselves, then a challenging book must be selected.  Human Action is challenging; it is not light reading--but it is damn informative; it has changed the thinking of some of the best thinkers; it brought back to life a dead school of economics; and it is today the rock upon which the entire Austrian School stands.  I can think of no better book with which to begin this group's studying.-Dave BitCoinMail says the same thing about unredeemed bitcoins in its FAQ (and has for months):"What happens to BitMail that isn't redeemed?"Recipients have 14 days to redeem their BitMail. In the rare case that a BitMail is not redeemed after that time, the bitcoins will be used to support the site and help ensure that BitMail is always free."-Dave
